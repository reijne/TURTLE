c 
c  $Author: wab $
c  $Date: 2005-01-28 06:43:03 $
c  $Locker:  $
c  $Revision: 1.4 $
c  $Source: /c/qcg/cvs/psh/GAMESS-UK/mopac/mopac.m,v $
c  $State: Exp $
c  
      block data mopc0
      implicit REAL (a-h,o-z)
      common /cmporb/ natorb(107)
***********************************************************************
*
*     common blocks for am1
*
***********************************************************************
      common /elemts/ elemnt(107)
      common /corec/ core(107)
      common /multip/ dd(107),qq(107),am(107),ad(107),aq(107)
      common /expont/ zs(107),zp(107),zd(107)
      common /cmpone/ uss(107),upp(107),udd(107)
      common /betas/ betas(107),betap(107),betad(107)
      common /twoele/ gss(107),gsp(107),gpp(107),gp2(107),hsp(107),
     1                gsd(107),gpd(107),gdd(107)
      common /atomic/ eisol(107),eheat(107)
      common /vsips/ vs(107),vp(107),vd(107)
      common /istope/ ams(107)
      common /ideaa/ guesa1(107,10),guesa2(107,10),guesa3(107,10)
      common /ideap/ guesp1(107,10),guesp2(107,10),guesp3(107,10)
      common /cmpga/ fn1(107),fn2(107)
***********************************************************************
*
*     common blocks for mndo
*
***********************************************************************
      common /mndo/  ussm(107), uppm(107), uddm(107), zsm(107),
     1zpm(107), zdm(107), betasm(107), betapm(107), betadm(107),
     2alpm(107), eisolm(107), ddm(107), qqm(107), amm(107), adm(107),
     3aqm(107) ,gssm(107), gspm(107), gppm(107), gp2m(107), hspm(107),
     4polvom(107)
***********************************************************************
*
*     common blocks for pm3
*
***********************************************************************
      common /pm3/  usspm3(107), upppm3(107), uddpm3(107), zspm3(107),
     1zppm3(107), zdpm3(107), betasp(107), betapp(107), betadp(107),
     2alppm3(107), eisolp(107), ddpm3(107), qqpm3(107), ampm3(107),
     3adpm3(107), aqpm3(107) ,gsspm3(107), gsppm3(107), gpppm3(107),
     4gp2pm3(107), hsppm3(107),polvop(107)
***********************************************************************
*
*     common blocks for am1
*
***********************************************************************
      common /am1blo/ussam1(107), uppam1(107), uddam1(107), zsam1(107),
     1zpam1(107), zdam1(107), betasa(107), betapa(107), betada(107),
     2alpam1(107), eisola(107), ddam1(107), qqam1(107), amam1(107),
     3adam1(107), aqam1(107) ,gssam1(107), gspam1(107), gppam1(107),
     4gp2am1(107), hspam1(107),polvoa(107)
      common /refs/ refmn(107), refm3(107), refam(107), refpm3(107)
***********************************************************************
*
*  common blocks for mindo/3
*
***********************************************************************
      common /onele3/  uss3(18),upp3(18)
      common /twoel3/  f03(107)
      common /atomi3/  eisol3(18),eheat3(18)
      common /beta3/  beta3(153)
      common /alpha3/  alp3(153)
      common /expon3/  zs3(18),zp3(18)
*
*  end of mindo/3 common blocks
*
c
c electric field options for polarizability
c
      common /cmpfd/ efield(3)
      character elemnt*2, refmn*80, refm3*80, refam*80, refpm3*80
      data efield/0.0d00,0.0d00,0.0d00/
      data elemnt/' h','he',
     1 'li','be',' b',' c',' n',' o',' f','ne',
     2 'na','mg','al','si',' p',' s','cl','ar',
     3 ' k','ca','sc','ti',' v','cr','mn','fe','co','ni','cu',
     4 'zn','ga','ge','as','se','br','kr',
     5 'rb','sr',' y','zr','nb','mo','tc','ru','rh','pd','ag',
     6 'cd','in','sn','sb','te',' i','xe',
     7 'cs','ba','la','ce','pr','nd','pm','sm','eu','gd','tb','dy',
     8 'ho','er','tm','yb','lu','hf','ta',' w','re','os','ir','pt',
     9 'au','hg','tl','pb','bi','po','at','rn',
     1 'fr','ra','ac','th','pa',' u','np','pu','am','cm','bk','cf','xx',
     2 'fm','md','cb','++',' +','--',' -','tv'/
c
c   natorb is the number of atomic orbitals per atom.
c
      data natorb/2*1, 4, 7*4, 0, 7*4, 0, 4, 9*9, 7*4,
     12*4, 9*9, 7*4, 2*2, 14*8, 9*9, 7*4, 15*0,1,5*0/
***********************************************************************
*                      valence shells are defined as                  *
*  pqn   valence shells                                               *
*                 p-group              f-group    transition metals   *
*   1       1s                                                        *
*   2       2s 2p                                                     *
*   3       3s 3p  or  3s 3p 3d                                       *
*   4       4s 4p                                    4s 4p 3d         *
*   5       5s 5p                                    5s 5p 4d         *
*   6       6s 6p                       6s 4f        6s 6p 5d         *
*   7  not assigned yet  ****do  not  use****                         *
***********************************************************************
      data      polvom(1) /0.2287d0/
      data      polvom(6) /0.2647d0/
      data      polvom(7) /0.3584d0/
      data      polvom(8) /0.2324d0/
      data      polvom(9) /0.1982d0/
      data      polvom(17)/1.3236d0/
      data      polvom(35)/2.2583d0/
      data      polvom(53)/4.0930d0/
c
c                standard atomic masses
c
      data  ams /  1.00790d0,  4.00260d0,  6.94000d0,  9.01218d0,
     110.81000d0, 12.01100d0, 14.00670d0, 15.99940d0, 18.99840d0,
     220.17900d0, 22.98977d0, 24.30500d0, 26.98154d0, 28.08550d0,
     330.97376d0, 32.06000d0, 35.45300d0, 39.94800d0, 39.09830d0,
     440.08000d0, 44.95590d0, 47.90000d0, 50.94150d0, 51.99600d0,
     554.93800d0, 55.84700d0, 58.93320d0, 58.71000d0, 63.54600d0,
     665.38000d0, 69.73500d0, 72.59000d0, 74.92160d0, 78.96000d0,
     779.90400d0, 83.80000d0, 85.46780d0, 87.62000d0, 88.90590d0,
     891.22000d0, 92.90640d0, 95.94000d0, 98.90620d0, 101.0700d0,
     9102.9055d0, 106.4000d0, 107.8680d0, 112.4100d0, 114.8200d0,
     1118.6900d0, 121.7500d0, 127.6000d0, 126.9045d0, 131.3000d0,
     2132.9054d0, 137.3300d0, 15*0.000d0, 178.4900d0, 180.9479d0,
     3183.8500d0, 186.2070d0, 190.2000d0, 192.2200d0, 195.0900d0,
     4196.9665d0, 200.5900d0, 204.3700d0, 207.2000d0, 208.9804d0,
     518*0.000d0,   1.0079d0,  5*0.000d0/
c
c   core is the charge on the atom as seen by the electrons
c
      data core/1.d0,0.d0,
     1 1.d0,2.d0,3.d0,4.d0,5.d0,6.d0,7.d0,0.d0,
     2 1.d0,2.d0,3.d0,4.d0,5.d0,6.d0,7.d0,0.d0,
     3 1.d0,2.d0,3.d0,4.d0,5.d0,6.d0,7.d0,8.d0,9.d0,10.d0,11.d0,2.d0,
     4 3.d0,4.d0,5.d0,6.d0,7.d0,0.d0,
     5 1.d0,2.d0,3.d0,4.d0,5.d0,6.d0,7.d0,8.d0,9.d0,10.d0,11.d0,2.d0,
     6 3.d0,4.d0,5.d0,6.d0,7.d0,0.d0,
     7 1.d0,2.d0,3.d0,4.d0,5.d0,6.d0,7.d0,8.d0,9.d0,10.d0,
     8 11.d0,12.d0,13.d0,14.d0,15.d0,16.d0,
     9 3.d0,4.d0,5.d0,6.d0,7.d0,8.d0,9.d0,10.d0,11.d0,2.d0,
     1 3.d0,4.d0,5.d0,6.d0,7.d0,0.d0,
     2  15*0.d0,1.d0,2.d0,1.d0,-2.d0,-1.d0,0.d0/
c
c     enthalpies of formation of gaseous atoms are taken from \annual
c     reports,1974,71b,p 117\  there are some significant differences
c     between the values reported there and the values previously in
c     the block data of this program.  only the third  row elements
c     have been updated.
c
* all the other elements are taken from crc handbook 1981-1982
      data eheat(1)  / 52.102d0/
      data eheat(2)  /  0.000d0/
c
      data eheat(3)  / 38.410d0/
      data eheat(4)  / 76.960d0/
      data eheat(5)  /135.700d0/
      data eheat(6)  /170.890d0/
      data eheat(7)  /113.000d0/
      data eheat(8)  / 59.559d0/
      data eheat(9)  / 18.890d0/
      data eheat(10) /  0.000d0/
c
      data eheat(11) / 25.850d0/
      data eheat(12) / 35.000d0/
      data eheat(13) / 79.490d0/
      data eheat(14) /108.390d0/
      data eheat(15) / 75.570d0/
      data eheat(16) / 66.400d0/
      data eheat(17) / 28.990d0/
      data eheat(18) /  0.000d0/
c
      data eheat(19) / 21.420d0/
      data eheat(20) / 42.600d0/
      data eheat(21) / 90.300d0/
      data eheat(22) /112.300d0/
      data eheat(23) /122.900d0/
      data eheat(24) / 95.000d0/
      data eheat(25) / 67.700d0/
      data eheat(26) / 99.300d0/
      data eheat(27) /102.400d0/
      data eheat(28) /102.800d0/
      data eheat(29) / 80.700d0/
      data eheat(30) / 31.170d0/
      data eheat(31) / 65.400d0/
      data eheat(32) / 89.500d0/
      data eheat(33) / 72.300d0/
      data eheat(34) / 54.300d0/
      data eheat(35) / 26.740d0/
      data eheat(36) /  0.000d0/
c
      data eheat(37) / 19.600d0/
      data eheat(38) / 39.100d0/
      data eheat(39) /101.500d0/
      data eheat(40) /145.500d0/
      data eheat(41) /172.400d0/
      data eheat(42) /157.300d0/
      data eheat(44) /155.500d0/
      data eheat(45) /133.000d0/
      data eheat(46) / 90.000d0/
      data eheat(47) / 68.100d0/
      data eheat(48) / 26.720d0/
      data eheat(49) / 58.000d0/
      data eheat(50) / 72.200d0/
      data eheat(51) / 63.200d0/
      data eheat(52) / 47.000d0/
      data eheat(53) / 25.517d0/
      data eheat(54) /  0.000d0/
c
      data eheat(55) / 18.700d0/
      data eheat(56) / 42.500d0/
      data eheat(58) /101.300d0/
      data eheat(62) / 49.400d0/
      data eheat(68) / 75.800d0/
      data eheat(70) / 36.350d0/
      data eheat(72) /148.000d0/
      data eheat(73) /186.900d0/
      data eheat(74) /203.100d0/
      data eheat(75) /185.000d0/
      data eheat(76) /188.000d0/
      data eheat(77) /160.000d0/
      data eheat(78) /135.200d0/
      data eheat(79) / 88.000d0/
      data eheat(80) / 14.690d0/
      data eheat(81) / 43.550d0/
      data eheat(82) / 46.620d0/
      data eheat(83) / 50.100d0/
      data eheat(86) /  0.000d0/
      data eheat(102)  / 207.0d0/
c
      data vs(1) /  -13.605  /
      data vs(5)/-15.16d00/
      data vs(6)/-21.34d00/
      data vs(7)/-27.51d00/
      data vs(8)/-35.30d00/
      data vs(9)/-43.70d00/
      data vs(14)/-17.82d00/
      data vs(15)/-21.10d00/
      data vs(16)/-23.84d00/
      data vs(17)/-25.26d00/
      data vp(1)  /  0.0d00  /
      data vp(5)/-8.52d00/
      data vp(6)/-11.54d00/
      data vp(7)/-14.34d00/
      data vp(8)/-17.91d00/
      data vp(9)/-20.89d00/
      data vp(14)/-8.51d00/
      data vp(15)/-10.29d00/
      data vp(16)/-12.41d00/
      data vp(17)/-15.09d00/
c      data npq/1,1, 2,2,2,2,2,2,2,2, 3,3,3,3,3,3,3,3, 4,4,4,4,4,4,4,4,
c     +4,4,4,4,4,4,4,4,4,4, 5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5/
c
c *** one center repulsion integrals
c     gss ::= (ss,ss)
c     gpp ::= (pp,pp)
c     gsp ::= (ss,pp)
c     gp2 ::= (pp,p*p*)
c     hsp ::= (sp,sp)
************************************************************************
      data gssm(1) / 12.848d00 /
      data gssm(4)/9.00d00/
      data gssm(5)/10.59d00/
      data gssm(6) / 12.23d00 /
      data gssm(7)/13.59d00/
      data gssm(8)/15.42d00/
      data gssm(9)/16.92d00/
      data gssm(13)/8.09d00/
      data gssm(14)/9.82d00/
      data gssm(15)/11.56d00/
      data gssm(16)/12.88d00/
      data gssm(17)/15.03d00/
      data gssm(35)/15.03643948d0/
      data gssm(53)/15.04044855d0/
      data gppm(4)/6.97d00/
      data gppm(5)/8.86d00/
      data gppm(6) / 11.08d00 /
      data gppm(7)/12.98d00/
      data gppm(8)/14.52d00/
      data gppm(9)/16.71d00/
      data gppm(13)/5.98d00/
      data gppm(14)/7.31d00/
      data gppm(15)/8.64d00/
      data gppm(16)/9.90d00/
      data gppm(17)/11.30d00/
      data gppm(35)/11.27632539d0/
      data gppm(53)/11.14778369d0/
      data gspm(4)/7.43d00/
      data gspm(5)/9.56d00/
      data gspm(6) / 11.47d00 /
      data gspm(7)/12.66d00/
      data gspm(8)/14.48d00/
      data gspm(9)/17.25d00/
      data gspm(13)/6.63d00/
      data gspm(14)/8.36d00/
      data gspm(15)/10.08d00/
      data gspm(16)/11.26d00/
      data gspm(17)/13.16d00/
      data gspm(35)/13.03468242d0/
      data gspm(53)/13.05655798d0/
      data gp2m(4)/6.22d00/
      data gp2m(5)/7.86d00/
      data gp2m(6) / 9.84d00 /
      data gp2m(7)/11.59d00/
      data gp2m(8)/12.98d00/
      data gp2m(9)/14.91d00/
      data gp2m(13)/5.40d00/
      data gp2m(14)/6.54d00/
      data gp2m(15)/7.68d00/
      data gp2m(16)/8.83d00/
      data gp2m(17)/9.97d00/
      data gp2m(35)/9.85442552d0/
      data gp2m(53)/9.91409071d0/
      data hspm(4)/1.28d00/
      data hspm(5)/1.81d00/
      data hspm(6) / 2.43d00 /
      data hspm(7)/3.14d00/
      data hspm(8)/3.94d00/
      data hspm(9)/4.83d00/
      data hspm(13)/0.70d00/
      data hspm(14)/1.32d00/
      data hspm(15)/1.92d00/
      data hspm(16)/2.26d00/
      data hspm(17)/2.42d00/
      data hspm(35)/2.45586832d0/
      data hspm(53)/2.45638202d0/
c
c     the monocentric integrals hsp and gsp for aluminium are only
c     estimates. a value of g1 for al is needed to resolve olearis
c     integrals.
c
c     optimized mndo parameters for h, be, b, c, n, o, f
c                                                     cl
c     estimated mndo parameters for       al,si, p, s
c
c     elements h, c, n, o were parameterized by walter thiel
c     elements b,si,p,s   were      ..          michael mckee
c     elements be,f,al,cl were      ..          henry rzepa
c
***********************************************************************
*
*    start of mindo/3 parameters
*
***********************************************************************
c *** f03 is the one center averaged repulsion integral for use in the
c        two center electronic repulsion integral evaluation.
      data refm3  ( 1)/'  h: (mindo/3): r.c.bingham et.al., j.am.chem.so
     1c. 97,1285,1294,1302,1307 (1975)'/
      data refm3  ( 5)/'  b: (mindo/3): r.c.bingham et.al., j.am.chem.so
     1c. 97,1285,1294,1302,1307 (1975)'/
      data refm3  ( 6)/'  c: (mindo/3): r.c.bingham et.al., j.am.chem.so
     1c. 97,1285,1294,1302,1307 (1975)'/
      data refm3  ( 7)/'  n: (mindo/3): r.c.bingham et.al., j.am.chem.so
     1c. 97,1285,1294,1302,1307 (1975)'/
      data refm3  ( 8)/'  o: (mindo/3): r.c.bingham et.al., j.am.chem.so
     1c. 97,1285,1294,1302,1307 (1975)'/
      data refm3  ( 9)/'  f: (mindo/3): r.c.bingham et.al., j.am.chem.so
     1c. 97,1285,1294,1302,1307 (1975)'/
      data refm3  (14)/' si: (mindo/3): r.c.bingham et.al., j.am.chem.so
     1c. 97,1285,1294,1302,1307 (1975)'/
      data refm3  (15)/'  p: (mindo/3): r.c.bingham et.al., j.am.chem.so
     1c. 97,1285,1294,1302,1307 (1975)'/
      data refm3  (16)/'  s: (mindo/3): r.c.bingham et.al., j.am.chem.so
     1c. 97,1285,1294,1302,1307 (1975)'/
      data refm3  (17)/' cl: (mindo/3): r.c.bingham et.al., j.am.chem.so
     1c. 97,1285,1294,1302,1307 (1975)'/
      data f03              /  12.848d0, 10.0d0, 10.0d0, 0.0d0,
     1  8.958d0, 10.833d0, 12.377d0, 13.985d0, 16.250d0,
     2         10.000d0, 10.000d0, 0.000d0, 0.000d0,7.57d0 ,  9.00d0 ,
     3         10.20d0 , 11.73,10.0d0,35*0.d0,10.d0,53*10.d0/
c *** uss and upp are the one-center core electron attraction and kineti
c     energy integrals for s and p electrons respectively in e.v.
      data uss3             / -12.505d0, 0.000d0, 0.000d0, 0.000d0,
     1                       -33.61d0, -51.79d0, -66.06d0, -91.73d0 ,
     2                       -129.86d0,
     3                        0.0000d0 , 0.000 d0 ,0.000d0 , 0.000d0 ,
     4          -39.82d0 , -56.23d0 , -73.39d0 , -98.99d0 ,.0d0/
      data upp3             /   0.0d0, 0.0d0, 0.0d0, 0.0d0,
     1     -25.11d0 , -39.18d0 , -56.40d0 , -78.80d0 , -105.93d0 ,
     2                        0.000d0 , 0.000d0 , 0.000d0 , 0.000d0 ,
     3         -29.15d0 , -42.31d0 , -57.25d0 , -76.43d0 ,.0d0/
c *** eisol3 and eheat3 are the gs electronic energy of the neutral atom
c     (in e.v.) and the heat of formation if the free atom (in kcal/mol)
      data eisol3             /-12.505d0 , 0.0d0 , 0.0d0 ,0.0d0 ,
     1        -61.70d0 ,-119.47d0 , -187.51d0 , -307.07d0 , -475.00d0 ,
     2                         0.0d0 , 0.0d0 , 0.0d0 , 0.0d0 ,
     3          -90.98d0 , -150.81d0 , -229.15d0 , -345.93d0 , 0.0d0/
      data eheat3             / 52.102d0 , 0.0d0 , 0.0d0 , 0.0d0 ,
     1     135.7 d0 , 170.89d0 ,  113.0 d0 ,  59.559d0 ,  18.86d0 ,
     2                         0.0d0 , 0.0d0 , 0.0d0 , 0.0d0 ,
     3     106.0d0 ,   79.8d0 ,  65.65d0 ,  28.95d0 , 0.0d0 /
c *** beta3 and alp3 are the bond parameters used in the
c     resonance integral and the core core repulsion integral respective
c     that is according to the following convention
c
c     here is the
c     bond type designation
c
c
c         h   b   c   n   o   f  si   p   s  cl
c       -----------------------------------------
c      h  1  11  16  22  29  37  92 106 121 137
c      b     15  20  26  33  41
c      c         21  27  34  42  97 111 126 142
c      n             28  35  43         127 143
c      o                 36  44     113 128
c      f                     45     114
c     si                        105
c      p                            120     151
c      s                                136 152
c     cl                                    153
      data beta3(1),alp3(1)   /  0.244770d0 ,  1.489450d0 /
      data beta3(11),alp3(11)   /  0.185347d0 ,  2.090352d0 /
      data beta3(15),alp3(15)   /  0.151324d0 ,  2.280544d0 /
      data beta3(16),alp3(16)   /  0.315011d0 ,  1.475836d0 /
      data beta3(20),alp3(20)   /  0.250031d0 ,  2.138291d0 /
      data beta3(21),alp3(21)   /  0.419907d0 ,  1.371208d0 /
      data beta3(22),alp3(22)   /  0.360776d0 ,  0.589380d0 /
      data beta3(26),alp3(26)   /  0.310959d0 ,  1.909763d0 /
      data beta3(27),alp3(27)   /  0.410886d0 ,  1.635259d0 /
      data beta3(28),alp3(28) /  0.377342d0 ,  2.029618d0 /
      data beta3(29),alp3(29) /  0.417759d0 ,  0.478901d0 /
      data beta3(33),alp3(33) /  0.349745d0 ,  2.484827d0 /
      data beta3(34),alp3(34) /  0.464514d0 ,  1.820975d0 /
      data beta3(35),alp3(35) /  0.458110d0 ,  1.873859d0 /
      data beta3(36),alp3(36) /  0.659407d0 ,  1.537190d0 /
      data beta3(37),alp3(37) /  0.195242d0 ,  3.771362d0 /
      data beta3(41),alp3(41) /  0.219591d0 ,  2.862183d0 /
      data beta3(42),alp3(42) /  0.247494d0 ,  2.725913d0 /
      data beta3(43),alp3(43) /  0.205347d0 ,  2.861667d0 /
      data beta3(44),alp3(44) /  0.334044d0 ,  2.266949d0 /
      data beta3(45),alp3(45) /  0.197464d0 ,  3.864997d0 /
      data beta3(92),alp3(92) /  0.289647d0 ,  0.940789d0 /
      data beta3(97),alp3(97) /  0.411377d0 ,  1.101382d0 /
      data beta3(105),alp3(105) /  0.291703d0 ,  0.918432d0 /
      data beta3(106),alp3(106) /  0.320118d0 ,  0.923170d0 /
      data beta3(111),alp3(111) /  0.457816d0 ,  1.029693d0 /
      data beta3(113),alp3(113) /  0.470000d0 ,  1.662500d0 /
      data beta3(114),alp3(114) /  0.300000d0 ,  1.750000d0 /
      data beta3(120),alp3(120) /  0.311790d0 ,  1.186652d0 /
      data beta3(121),alp3(121) /  0.220654d0 ,  1.700698d0 /
      data beta3(126),alp3(126) /  0.284620d0 ,  1.761370d0 /
      data beta3(127),alp3(127) /  0.313170d0 ,  1.878176d0/
      data beta3(128),alp3(128) /  0.422890d0 ,  2.077240d0 /
      data beta3(136),alp3(136) /  0.202489d0 ,  1.751617d0 /
      data beta3(137),alp3(137) /  0.231653d0 ,  2.089404d0 /
      data beta3(142),alp3(142) /  0.315480d0 ,  1.676222d0 /
      data beta3(143),alp3(143) /  0.302298d0 ,  1.817064d0 /
      data beta3(151),alp3(151) /  0.277322d0 ,  1.543720d0 /
      data beta3(152),alp3(152) /  0.221764d0 ,  1.950318d0 /
      data beta3(153),alp3(153) /  0.258969d0 ,  1.792125d0 /
c *** here comes the optimized slater_s exponents for the evaluation
c     of the overlap integrals and molecular dipole moments.
      data zs3(1),zp3(1)      /  1.3d0       ,  0.0d0      /
      data zs3(5),zp3(5)      /  1.211156d0 ,  0.972826d0 /
      data zs3(6),zp3(6)      /  1.739391d0 ,  1.709645d0 /
      data zs3(7),zp3(7)      /  2.704546d0 ,  1.870839d0 /
      data zs3(8),zp3(8)      /  3.640575d0 ,  2.168448d0 /
      data zs3(9),zp3(9)      /  3.111270d0 ,  1.41986d0 /
      data zs3(14),zp3(14)    /  1.629173d0 ,  1.381721d0 /
      data zs3(15),zp3(15)    /  1.926108d0 ,  1.590665d0 /
      data zs3(16),zp3(16)    /  1.719480d0 ,  1.403205d0 /
      data zs3(17),zp3(17)    /  3.430887d0 ,  1.627017d0 /
*************************************************************
*                                                           *
*               data for the sparkles                       *
*                                                           *
*************************************************************
*                               data for the " ++ " sparkle
      data eheat(103)    / 0.0d0/
      data vs(103)       /10.0d0/
c
c  start of mndo
c
      data alpm(103)     / 1.5d0/
      data eisolm(103)   / 0.0d0/
      data amm(103)      / 0.5d0/
c
c  start of am1
c
      data alpam1(103)   / 1.5d0/
      data eisola(103)   / 0.0d0/
      data amam1(103)    / 0.5d0/
c
c  start of pm3
c
      data alppm3(103)   / 1.5d0/
      data eisolp(103)   / 0.0d0/
      data ampm3(103)    / 0.5d0/
*                               data for the " + " sparkle
      data eheat(104)    / 0.0d0/
      data vs(104)       /10.0d0/
      data alpam1(104)   / 1.5d0/
      data eisola(104)   / 0.0d0/
      data amam1(104)    / 0.5d0/
      data alpm(104)     / 1.5d0/
      data eisolm(104)   / 0.0d0/
      data amm(104)      / 0.5d0/
      data alppm3(104)   / 1.5d0/
      data eisolp(104)   / 0.0d0/
      data ampm3(104)    / 0.5d0/
*                               data for the " -- " sparkle
      data eheat(105)    / 0.0d0/
      data vs(105)       /10.0d0/
      data alpam1(105)   / 1.5d0/
      data eisola(105)   / 0.0d0/
      data amam1(105)    / 0.5d0/
      data alpm(105)     / 1.5d0/
      data eisolm(105)   / 0.0d0/
      data amm(105)      / 0.5d0/
      data alppm3(105)   / 1.5d0/
      data eisolp(105)   / 0.0d0/
      data ampm3(105)    / 0.5d0/
*                               data for the " - " sparkle
      data eheat(106)    / 0.0d0/
      data vs(106)       /10.0d0/
      data alpam1(106)   / 1.5d0/
      data eisola(106)   / 0.0d0/
      data amam1(106)    / 0.5d0/
      data alpm(106)     / 1.5d0/
      data eisolm(106)   / 0.0d0/
      data amm(106)      / 0.5d0/
      data alppm3(106)   / 1.5d0/
      data eisolp(106)   / 0.0d0/
      data ampm3(106)    / 0.5d0/
***********************************************************************
*
*    start of mndo parameters
*
***********************************************************************
c                    data for element  1        hydrogen
      data refmn  ( 1)/'  h: (mndo):  m.j.s. dewar, w. thiel, j. am. che
     1m. soc., 99, 4899, (1977)       '/
      data ussm   ( 1)/     -11.9062760d0/
      data betasm ( 1)/      -6.9890640d0/
      data zsm    ( 1)/       1.3319670d0/
      data alpm   ( 1)/       2.5441341d0/
      data eisolm ( 1)/     -11.9062760d0/
      data amm    ( 1)/       0.4721793d0/
      data adm    ( 1)/       0.4721793d0/
      data aqm    ( 1)/       0.4721793d0/
c                    data for element  3        lithium
      data refmn  ( 3)/' li: (mndo):  taken from mndoc by w.thiel,
     1qcpe no.438, v. 2, p.63, (1982).'/
      data ussm   (  3)/      -5.1280000d0/
      data uppm   (  3)/      -2.7212000d0/
      data betasm (  3)/      -1.3500400d0/
      data betapm (  3)/      -1.3500400d0/
      data zsm    (  3)/       0.7023800d0/
      data zpm    (  3)/       0.7023800d0/
      data alpm   (  3)/       1.2501400d0/
      data eisolm (  3)/      -5.1280000d0/
      data gssm   (  3)/       7.3000000d0/
      data gspm   (  3)/       5.4200000d0/
      data gppm   (  3)/       5.0000000d0/
      data gp2m   (  3)/       4.5200000d0/
      data hspm   (  3)/       0.8300000d0/
      data ddm    (  3)/       2.0549783d0/
      data qqm    (  3)/       1.7437069d0/
      data amm    (  3)/       0.2682837d0/
      data adm    (  3)/       0.2269793d0/
      data aqm    (  3)/       0.2614581d0/
c                    data for element  4        beryllium
      data refmn  ( 4)/' be: (mndo):  m.j.s. dewar, h.s. rzepa, j. am. c
     1hem. soc., 100, 777, (1978)     '/
      data ussm   ( 4)/     -16.6023780d0/
      data uppm   ( 4)/     -10.7037710d0/
      data betasm ( 4)/      -4.0170960d0/
      data betapm ( 4)/      -4.0170960d0/
      data zsm    ( 4)/       1.0042100d0/
      data zpm    ( 4)/       1.0042100d0/
      data alpm   ( 4)/       1.6694340d0/
      data eisolm ( 4)/     -24.2047560d0/
      data ddm    ( 4)/       1.4373245d0/
      data qqm    ( 4)/       1.2196103d0/
      data amm    ( 4)/       0.3307607d0/
      data adm    ( 4)/       0.3356142d0/
      data aqm    ( 4)/       0.3846373d0/
c                    data for element  5        boron
      data refmn  ( 5)/'  b: (mndo):  m.j.s. dewar, m.l. mckee, j. am. c
     1hem. soc., 99, 5231, (1977)     '/
      data ussm   ( 5)/     -34.5471300d0/
      data uppm   ( 5)/     -23.1216900d0/
      data betasm ( 5)/      -8.2520540d0/
      data betapm ( 5)/      -8.2520540d0/
      data zsm    ( 5)/       1.5068010d0/
      data zpm    ( 5)/       1.5068010d0/
      data alpm   ( 5)/       2.1349930d0/
      data eisolm ( 5)/     -64.3159500d0/
      data ddm    ( 5)/       0.9579073d0/
      data qqm    ( 5)/       0.8128113d0/
      data amm    ( 5)/       0.3891951d0/
      data adm    ( 5)/       0.4904730d0/
      data aqm    ( 5)/       0.5556979d0/
c                    data for element  6        carbon
      data refmn  ( 6)/'  c: (mndo):  m.j.s. dewar, w. thiel, j. am. che
     1m. soc., 99, 4899, (1977)       '/
      data ussm   ( 6)/     -52.2797450d0/
      data uppm   ( 6)/     -39.2055580d0/
      data betasm ( 6)/     -18.9850440d0/
      data betapm ( 6)/      -7.9341220d0/
      data zsm    ( 6)/       1.7875370d0/
      data zpm    ( 6)/       1.7875370d0/
      data alpm   ( 6)/       2.5463800d0/
      data eisolm ( 6)/    -120.5006060d0/
      data ddm    ( 6)/       0.8074662d0/
      data qqm    ( 6)/       0.6851578d0/
      data amm    ( 6)/       0.4494671d0/
      data adm    ( 6)/       0.6149474d0/
      data aqm    ( 6)/       0.6685897d0/
c                    data for element  7        nitrogen
      data refmn  ( 7)/'  n: (mndo):  m.j.s. dewar, w. thiel, j. am. che
     1m. soc., 99, 4899, (1977)       '/
      data ussm   ( 7)/     -71.9321220d0/
      data uppm   ( 7)/     -57.1723190d0/
      data betasm ( 7)/     -20.4957580d0/
      data betapm ( 7)/     -20.4957580d0/
      data zsm    ( 7)/       2.2556140d0/
      data zpm    ( 7)/       2.2556140d0/
      data alpm   ( 7)/       2.8613420d0/
      data eisolm ( 7)/    -202.5662010d0/
      data ddm    ( 7)/       0.6399037d0/
      data qqm    ( 7)/       0.5429763d0/
      data amm    ( 7)/       0.4994487d0/
      data adm    ( 7)/       0.7843643d0/
      data aqm    ( 7)/       0.81264450d0/
c                    data for element  8        oxygen
      data refmn  ( 8)/'  o: (mndo):  m.j.s. dewar, w. thiel, j. am. che
     1m. soc., 99, 4899, (1977)       '/
      data ussm   ( 8)/     -99.6443090d0/
      data uppm   ( 8)/     -77.7974720d0/
      data betasm ( 8)/     -32.6880820d0/
      data betapm ( 8)/     -32.6880820d0/
      data zsm    ( 8)/       2.6999050d0/
      data zpm    ( 8)/       2.6999050d0/
      data alpm   ( 8)/       3.1606040d0/
      data eisolm ( 8)/    -317.8685060d0/
      data ddm    ( 8)/       0.5346024d0/
      data qqm    ( 8)/       0.4536252d0/
      data amm    ( 8)/       0.5667034d0/
      data adm    ( 8)/       0.9592562d0/
      data aqm    ( 8)/       0.9495934d0/
c                    data for element  9        fluorine
      data refmn  ( 9)/'  f: (mndo):  m.j.s. dewar, h.s. rzepa, j. am. c
     1hem. soc., 100, 777, (1978)     '/
      data ussm   ( 9)/    -131.0715480d0/
      data uppm   ( 9)/    -105.7821370d0/
      data betasm ( 9)/     -48.2904660d0/
      data betapm ( 9)/     -36.5085400d0/
      data zsm    ( 9)/       2.8484870d0/
      data zpm    ( 9)/       2.8484870d0/
      data alpm   ( 9)/       3.4196606d0/
      data eisolm ( 9)/    -476.6837810d0/
      data ddm    ( 9)/       0.5067166d0/
      data qqm    ( 9)/       0.4299633d0/
      data amm    ( 9)/       0.6218302d0/
      data adm    ( 9)/       1.0850301d0/
      data aqm    ( 9)/       1.0343643d0/
*                               data for the sodium-like sparkle
      data refmn  (11)/' na: (mndo):  sodium-like sparkle.   use with ca
     1re.                             '/
      data refam  (11)/' na: (am1):   sodium-like sparkle.   use with ca
     1re.                             '/
      data refpm3 (11)/' na: (pm3):   sodium-like sparkle.   use with ca
     1re.                             '/
      data vs(11)       /10.0d0/
      data alpam1(11)      / 1.668d0/
      data alpm(11)        / 1.660d0/
      data alppm3(11)      / 1.681d0/
c
      data eisola(11)      / 0.0d0/
      data eisolm(11)      / 0.0d0/
      data eisolp(11)      / 0.0d0/
c
      data amam1(11)       / 0.5d0/
      data amm(11)         / 0.5d0/
      data ampm3(11)       / 0.5d0/
c                    data for element 13        aluminum
      data refmn  (13)/' al: (mndo):  l.p. davis, et.al.  j. comp. chem.
     1, 2, 433, (1981) see manual.    '/
      data ussm   (13)/     -23.8070970d0/
      data uppm   (13)/     -17.5198780d0/
      data betasm (13)/      -2.6702840d0/
      data betapm (13)/      -2.6702840d0/
      data zsm    (13)/       1.4441610d0/
      data zpm    (13)/       1.4441610d0/
      data zdm    (13)/       1.0000000d0/
      data alpm   (13)/       1.8688394d0/
      data eisolm (13)/     -44.4840720d0/
      data ddm    (13)/       1.3992387d0/
      data qqm    (13)/       1.1586797d0/
      data amm    (13)/       0.2973172d0/
      data adm    (13)/       0.2635574d0/
      data aqm    (13)/       0.3673560d0/
c                    data for element 14          silicon
      data refmn  (14)/' si: (mndo): m.j.s.dewar, et. al. organometallic
     1s  5, 375 (1986)                '/
      data ussm   (14)/     -37.0375330d0/
      data uppm   (14)/     -27.7696780d0/
      data betasm (14)/      -9.0868040d0/
      data betapm (14)/      -1.0758270d0/
      data zsm    (14)/       1.3159860d0/
      data zpm    (14)/       1.7099430d0/
      data zdm    (14)/       1.0000000d0/
      data alpm   (14)/       2.2053160d0/
      data eisolm (14)/     -82.8394220d0/
      data ddm    (14)/       1.2580349d0/
      data qqm    (14)/       0.9785824d0/
      data amm    (14)/       0.3608967d0/
      data adm    (14)/       0.3664244d0/
      data aqm    (14)/       0.4506740d0/
c                    data for element 15        phosphorus
      data refmn  (15)/'  p: (mndo): m.j.s.dewar, m.l.mckee, h.s.rzepa,
     1j. am. chem. soc., 100 3607 1978'/
      data ussm   (15)/     -56.1433600d0/
      data uppm   (15)/     -42.8510800d0/
      data betasm (15)/      -6.7916000d0/
      data betapm (15)/      -6.7916000d0/
      data zsm    (15)/       2.1087200d0/
      data zpm    (15)/       1.7858100d0/
      data zdm    (15)/       1.0000000d0/
      data alpm   (15)/       2.4152800d0/
      data eisolm (15)/    -152.9599600d0/
      data ddm    (15)/       1.0129699d0/
      data qqm    (15)/       0.9370090d0/
      data amm    (15)/       0.4248438d0/
      data adm    (15)/       0.4882420d0/
      data aqm    (15)/       0.4979406d0/
c                    data for element 16        sulfur
c
      data refmn  (16)/'  s: (mndo): m.j.s.dewar, c.h. reynolds, j. com
     1p. chem. 7, 140-143 (1986)      '/
      data ussm   (16)/     -72.2422810d0/
      data uppm   (16)/     -56.9732070d0/
      data betasm (16)/     -10.7616700d0/
      data betapm (16)/     -10.1084330d0/
      data zsm    (16)/       2.3129620d0/
      data zpm    (16)/       2.0091460d0/
      data zdm    (16)/       1.0000000d0/
      data alpm   (16)/       2.4780260d0/
      data eisolm (16)/    -226.0123900d0/
      data ddm    (16)/       0.9189935d0/
      data qqm    (16)/       0.8328514d0/
      data amm    (16)/       0.4733554d0/
      data adm    (16)/       0.5544502d0/
      data aqm    (16)/       0.5585244d0/
c                    data for element 17        chlorine
      data refmn  (17)/' cl: (mndo): m.j.s.dewar, h.s.rzepa, j. comp. ch
     1em., 4, 158, (1983)             '/
      data ussm   (17)/    -100.2271660d0/
      data uppm   (17)/     -77.3786670d0/
      data betasm (17)/     -14.2623200d0/
      data betapm (17)/     -14.2623200d0/
      data zsm    (17)/       3.7846450d0/
      data zpm    (17)/       2.0362630d0/
      data zdm    (17)/       1.0000000d0/
      data alpm   (17)/       2.5422010d0/
      data eisolm (17)/    -353.1176670d0/
      data ddm    (17)/       0.4986870d0/
      data qqm    (17)/       0.8217603d0/
      data amm    (17)/       0.5523705d0/
      data adm    (17)/       0.8061220d0/
      data aqm    (17)/       0.6053435d0/
*                               data for the potassium-like sparkle
      data refam   (19)/' k:  (am1):  potassium-like sparkle.   use with
     1 care.                          '/
      data refmn   (19)/' k:  (mndo): potassium-like sparkle.   use with
     1 care.                          '/
      data refpm3  (19)/' k:  (pm3):  potassium-like sparkle.   use with
     1 care.                          '/
      data vs(19)       /10.0d0/
      data alpam1(19)      / 1.405d0/
      data alpm(19)        / 1.396d0/
      data alppm3(19)      / 1.400d0/
c
      data eisola(19)      / 0.0d0/
      data eisolm(19)      / 0.0d0/
      data eisolp(19)      / 0.0d0/
c
      data amam1(19)       / 0.5d0/
      data amm(19)         / 0.5d0/
      data ampm3(19)       / 0.5d0/
c                    data for element 24  chromium
      data refmn  (24)/' cr: (mndo):  m.j.s. dewar, e.f. healy, j.j.p.
     1stewart (in preparation)        '/
      data ussm   (24)/     -17.5170270d0/
      data uppm  (24)/     -12.5337290d0/
      data uddm  (24)/     -44.1249280d0/
      data betasm (24)/      -0.1000000d0/
      data betapm (24)/      -0.1000000d0/
      data betadm (24)/      -8.7766360d0/
      data zsm    (24)/       1.5000000d0/
      data zpm    (24)/       1.5000000d0/
      data zdm    (24)/       2.8845490d0/
      data alpm   (24)/       3.0683070d0/
      data eisolm (24)/    -134.8187920d0/
      data gssm   (24)/       6.0000000d0/
      data gspm   (24)/       4.1500000d0/
      data gppm   (24)/       5.0000000d0/
      data gp2m   (24)/       3.5000000d0/
      data hspm   (24)/       1.0000000d0/
      data gsd    (24)/       2.8746410d0/
      data gpd    (24)/       3.0000000d0/
      data gdd    (24)/       8.8949670d0/
      data ddm    (24)/       1.7320508d0/
      data qqm    (24)/       1.4142136d0/
      data amm    (24)/       0.2205072d0/
      data adm    (24)/       0.2711332d0/
      data aqm    (24)/       0.4464656d0/
c                    data for element 30        zinc
      data refmn  (30)/' zn: (mndo):  m.j.s. dewar, k.m. merz, organomet
     1allics, 5, 1494-1496 (1986)     '/
c                    data for element 30
      data ussm  ( 30)/     -20.8397160d0/
      data uppm  ( 30)/     -19.6252240d0/
      data betasm( 30)/      -1.0000000d0/
      data betapm( 30)/      -2.0000000d0/
      data zsm   ( 30)/       2.0473590d0/
      data zpm   ( 30)/       1.4609460d0/
      data zdm   ( 30)/       1.0000000d0/
      data alpm  ( 30)/       1.5064570d0/
      data eisolm( 30)/     -29.8794320d0/
      data gssm  ( 30)/      11.8000000d0/
      data gspm  ( 30)/      11.1820180d0/
      data gppm  ( 30)/      13.3000000d0/
      data gp2m  ( 30)/      12.9305200d0/
      data hspm  ( 30)/       0.4846060d0/
      data ddm   ( 30)/       1.3037826d0/
      data qqm   ( 30)/       1.4520183d0/
      data amm   ( 30)/       0.4336641d0/
      data adm   ( 30)/       0.2375912d0/
      data aqm   ( 30)/       0.2738858d0/
c                    data for element 32        germanium
      data refmn  (32)/' ge: (mndo): m.j.s.dewar, g.l.grady, e.f.healy,o
     1rganometallics 6 186-189, (1987)'/
      data ussm  ( 32)/     -33.9493670d0/
      data uppm  ( 32)/     -27.4251050d0/
      data betasm( 32)/      -4.5164790d0/
      data betapm( 32)/      -1.7555170d0/
      data zsm   ( 32)/       1.2931800d0/
      data zpm   ( 32)/       2.0205640d0/
      data alpm  ( 32)/       1.9784980d0/
      data eisolm( 32)/     -76.2489440d0/
      data gssm  ( 32)/       9.8000000d0/
      data gspm  ( 32)/       8.3000000d0/
      data gppm  ( 32)/       7.3000000d0/
      data gp2m  ( 32)/       6.5000000d0/
      data hspm  ( 32)/       1.3000000d0/
      data ddm   ( 32)/       1.2556091d0/
      data qqm   ( 32)/       1.0498655d0/
      data amm   ( 32)/       0.3601617d0/
      data adm   ( 32)/       0.3643722d0/
      data aqm   ( 32)/       0.4347337d0/
c                    data for element 35        bromine
      data refmn  (35)/' br: (mndo): m.j.s.dewar, e.f. healy, j. comp. c
     1hem., 4, 542, (1983)            '/
      data ussm   (35)/     -99.9864405d0/
      data uppm   (35)/     -75.6713075d0/
      data betasm (35)/      -8.9171070d0/
      data betapm (35)/      -9.9437400d0/
      data zsm    (35)/       3.8543019d0/
      data zpm    (35)/       2.1992091d0/
      data zdm    (35)/       1.0000000d0/
      data alpm   (35)/       2.4457051d0/
      data eisolm (35)/    -346.6812500d0/
      data ddm    (35)/       0.6051074d0/
      data qqm    (35)/       0.9645873d0/
      data amm    (35)/       0.5526068d0/
      data adm    (35)/       0.7258330d0/
      data aqm    (35)/       0.5574589d0/
c                    data for element 50        tin
      data refmn  (50)/' sn: (mndo): m.j.s.dewar,g.l.grady,j.j.p.stewart
     1, j.am.chem.soc.,106 6771 (1984)'/
      data ussm  (50)/     -40.8518020d0/
      data uppm   (50)/     -28.5602490d0/
      data betasm (50)/      -3.2351470d0/
      data betapm (50)/      -4.2904160d0/
      data zsm    (50)/       2.0803800d0/
      data zpm   (50)/       1.9371060d0/
      data alpm   (50)/       1.8008140d0/
      data eisolm (50)/     -92.3241020d0/
      data gssm   (50)/       9.8000000d0/
      data gspm   (50)/       8.3000000d0/
      data gppm   (50)/       7.3000000d0/
      data gp2m   (50)/       6.5000000d0/
      data hspm   (50)/       1.3000000d0/
      data ddm    (50)/       1.5697766d0/
      data qqm    (50)/       1.3262292d0/
      data amm    (50)/       0.3601617d0/
      data adm    (50)/       0.3219998d0/
      data aqm    (50)/       0.3713827d0/
c                    data for element 53        iodine
      data refmn  (53)/'  i: (mndo): m.j.s.dewar, e.f. healy, j.j.p. ste
     1wart, j.comp.chem., 5,358,(1984)'/
      data ussm   (53)/    -100.0030538d0/
      data uppm   (53)/     -74.6114692d0/
      data betasm (53)/      -7.4144510d0/
      data betapm (53)/      -6.1967810d0/
      data zsm    (53)/       2.2729610d0/
      data zpm    (53)/       2.1694980d0/
      data zdm    (53)/       1.0000000d0/
      data alpm   (53)/       2.2073200d0/
      data eisolm (53)/    -340.5983600d0/
      data ddm    (53)/       1.4253233d0/
      data qqm    (53)/       1.1841707d0/
      data amm    (53)/       0.5527541d0/
      data adm    (53)/       0.4593451d0/
      data aqm    (53)/       0.4585376d0/
c                    data for element 80        mercury
      data refmn  (80)/' hg: (mndo): m.j.s.dewar,  et. al. organometalli
     1cs 4, 1964, (1985) see manual   '/
      data ussm   ( 80)/     -19.8095740d0/
      data uppm   ( 80)/     -13.1025300d0/
      data betasm ( 80)/      -0.4045250d0/
      data betapm ( 80)/      -6.2066830d0/
      data zsm    ( 80)/       2.2181840d0/
      data zpm    ( 80)/       2.0650380d0/
      data alpm   ( 80)/       1.3356410d0/
      data eisolm ( 80)/     -28.8191480d0/
      data gssm   ( 80)/      10.8000000d0/
      data gspm   ( 80)/       9.3000000d0/
      data gppm   ( 80)/      14.3000000d0/
      data gp2m   ( 80)/      13.5000000d0/
      data hspm   ( 80)/       1.3000000d0/
      data ddm    ( 80)/       1.7378048d0/
      data qqm    ( 80)/       1.4608064d0/
      data amm    ( 80)/       0.3969129d0/
      data adm    ( 80)/       0.3047694d0/
      data aqm    ( 80)/       0.3483102d0/
c                    data for element 82        lead
      data refmn  (82)/' pb: (mndo): m.j.s.dewar, et.al organometallics
     14 1973-1980 (1985)              '/
      data ussm   ( 82)/     -47.3196920d0/
      data uppm   ( 82)/     -28.8475600d0/
      data betasm ( 82)/      -8.0423870d0/
      data betapm ( 82)/      -3.0000000d0/
      data zsm    ( 82)/       2.4982860d0/
      data zpm    ( 82)/       2.0820710d0/
      data alpm   ( 82)/       1.7283330d0/
      data eisolm ( 82)/    -105.8345040d0/
      data gssm   ( 82)/       9.8000000d0/
      data gspm   ( 82)/       8.3000000d0/
      data gppm   ( 82)/       7.3000000d0/
      data gp2m   ( 82)/       6.5000000d0/
      data hspm   ( 82)/       1.3000000d0/
      data ddm    ( 82)/       1.5526624d0/
      data qqm    ( 82)/       1.4488558d0/
      data amm    ( 82)/       0.3601617d0/
      data adm    ( 82)/       0.3239309d0/
      data aqm    ( 82)/       0.3502057d0/
c
c     start of "old" elements: these are old parameters which
c     can be used, if desired, by specifying "<chemical symbol>year"
c     as in si1978 or  s1983.
c
c                    data for element 90        silicon
      data refmn  (90)/' si: (mndo): m.j.s.dewar, m.l.mckee, h.s.rzepa,
     1j. am. chem. soc., 100 3607 1978'/
      data ussm   (90)/     -40.5682920d0/
      data uppm   (90)/     -28.0891870d0/
      data betasm (90)/      -4.2562180d0/
      data betapm (90)/      -4.2562180d0/
      data zsm    (90)/       1.4353060d0/
      data zpm    (90)/       1.4353060d0/
      data zdm    (90)/       1.0000000d0/
      data alpm   (90)/       2.1961078d0/
      data eisolm (90)/     -90.5399580d0/
      data ddm    (90)/       1.4078712d0/
      data qqm    (90)/       1.1658281d0/
      data amm    (90)/       0.3608967d0/
      data adm    (90)/       0.3441817d0/
      data aqm    (90)/       0.3999442d0/
      data hspm(90)/1.32d00/
      data gp2m(90)/6.54d00/
      data gppm(90)/7.31d00/
      data gspm(90)/8.36d00/
      data gssm(90)/9.82d00/
      data refmn  (91)/'  s: (mndo): m.j.s.dewar, h.s. rzepa, m.l.mckee,
     1 j.am.chem.soc.100, 3607 (1978).'/
      data ussm   (91)/     -75.2391520d0/
      data uppm   (91)/     -57.8320130d0/
      data betasm (91)/     -11.1422310d0/
      data betapm (91)/     -11.1422310d0/
      data zsm    (91)/       2.6135910d0/
      data zpm    (91)/       2.0343930d0/
      data zdm    (91)/       1.0000000d0/
      data alpm   (91)/       2.4916445d0/
      data eisolm (91)/    -235.4413560d0/
      data ddm    (91)/       0.8231596d0/
      data qqm    (91)/       0.8225156d0/
      data amm    (91)/       0.4733554d0/
      data adm    (91)/       0.5889395d0/
      data aqm    (91)/       0.5632724d0/
      data refmn (102)/' cb: (mndo):  capped bond  (hydrogen-like, takes
     1 on a  zero charge.)            '/
      data ussm  (102)/     -11.9062760d0/
      data betasm(102)/-9999999.0000000d0/
      data zsm   (102)/       4.0000000d0/
      data zpm   (102)/       0.3000000d0/
      data zdm   (102)/       0.3000000d0/
      data alpm  (102)/       2.5441341d0/
      data eisolm(102)/       4.0000000d0/
      data gssm  (102)/      12.8480000d0/
      data hspm  (102)/       0.1000000d0/
      data ddm   (102)/       0.0684105d0/
      data qqm   (102)/       1.0540926d0/
      data amm   (102)/       0.4721793d0/
      data adm   (102)/       0.9262742d0/
      data aqm   (102)/       0.2909059d0/
***********************************************************************
*
*    start of am1 parameters
*
***********************************************************************
c                    data for element  1       am1:   hydrogen
      data refam  ( 1)/'  h: (am1): m.j.s. dewar et al, j. am. chem. soc
     1. 107 3902-3909 (1985)          '/
      data ussam1( 1)/     -11.3964270d0/
      data betasa( 1)/      -6.1737870d0/
      data zs am1( 1)/       1.1880780d0/
      data alpam1( 1)/       2.8823240d0/
      data eisola( 1)/     -11.3964270d0/
      data gssam1( 1)/      12.8480000d0/
      data am am1( 1)/       0.4721793d0/
      data ad am1( 1)/       0.4721793d0/
      data aq am1( 1)/       0.4721793d0/
      data guesa1( 1,1)/       0.1227960d0/
      data guesa2( 1,1)/       5.0000000d0/
      data guesa3( 1,1)/       1.2000000d0/
      data guesa1( 1,2)/       0.0050900d0/
      data guesa2( 1,2)/       5.0000000d0/
      data guesa3( 1,2)/       1.8000000d0/
      data guesa1( 1,3)/      -0.0183360d0/
      data guesa2( 1,3)/       2.0000000d0/
      data guesa3( 1,3)/       2.1000000d0/
c                    data for element  3       am1:   lithium    *
      data refam  ( 3)/' li: (mndo):  taken from mndoc by w.thiel,
     1qcpe no.438, v. 2, p.63, (1982).'/
      data ussam1(  3)/      -5.1280000d0/
      data uppam1(  3)/      -2.7212000d0/
      data betasa(  3)/      -1.3500400d0/
      data betapa(  3)/      -1.3500400d0/
      data zs am1(  3)/       0.7023800d0/
      data zp am1(  3)/       0.7023800d0/
      data alpam1(  3)/       1.2501400d0/
      data eisola(  3)/      -5.1280000d0/
      data gssam1(  3)/       7.3000000d0/
      data gspam1(  3)/       5.4200000d0/
      data gppam1(  3)/       5.0000000d0/
      data gp2am1(  3)/       4.5200000d0/
      data hspam1(  3)/       0.8300000d0/
      data dd am1(  3)/       2.0549783d0/
      data qq am1(  3)/       1.7437069d0/
      data am am1(  3)/       0.2682837d0/
      data ad am1(  3)/       0.2269793d0/
      data aq am1(  3)/       0.2614581d0/
c                    data for element  4       am1:   beryllium  *
      data refam  ( 4)/' be: (mndo):  m.j.s. dewar, h.s. rzepa, j. am. c
     1hem. soc., 100, 777, (1978)     '/
      data ussam1( 4)/     -16.6023780d0/
      data uppam1( 4)/     -10.7037710d0/
      data betasa( 4)/      -4.0170960d0/
      data betapa( 4)/      -4.0170960d0/
      data zs am1( 4)/       1.0042100d0/
      data zp am1( 4)/       1.0042100d0/
      data alpam1( 4)/       1.6694340d0/
      data eisola( 4)/     -24.2047560d0/
      data gssam1( 4)/       9.0000000d0/
      data gspam1( 4)/       7.4300000d0/
      data gppam1( 4)/       6.9700000d0/
      data gp2am1( 4)/       6.2200000d0/
      data hspam1( 4)/       1.2800000d0/
      data dd am1( 4)/       1.4373245d0/
      data qq am1( 4)/       1.2196103d0/
      data am am1( 4)/       0.3307607d0/
      data ad am1( 4)/       0.3356142d0/
      data aq am1( 4)/       0.3846373d0/
c                    data for element  5       am1:   boron  *
      data refam  ( 5)/'  b: (am1):  m.j.s. dewar, c. jie, e. g. zoebisc
     1h organometallics 7, 513 (1988) '/
c                    data for element  5
      data ussam1(  5)/     -34.4928700d0/
      data uppam1(  5)/     -22.6315250d0/
      data betasa(  5)/      -9.5991140d0/
      data betapa(  5)/      -6.2737570d0/
      data zs am1(  5)/       1.6117090d0/
      data zp am1(  5)/       1.5553850d0/
      data alpam1(  5)/       2.4469090d0/
      data eisola(  5)/     -63.7172650d0/
      data gssam1(  5)/      10.5900000d0/
      data gspam1(  5)/       9.5600000d0/
      data gppam1(  5)/       8.8600000d0/
      data gp2am1(  5)/       7.8600000d0/
      data hspam1(  5)/       1.8100000d0/
      data dd am1(  5)/       0.9107622d0/
      data qq am1(  5)/       0.7874223d0/
      data am am1(  5)/       0.3891951d0/
      data ad am1(  5)/       0.5045152d0/
      data aq am1(  5)/       0.5678856d0/
c                    data for element  6       am1:   carbon
      data refam  ( 6)/'  c: (am1): m.j.s. dewar et al, j. am. chem. soc
     1. 107 3902-3909 (1985)          '/
      data ussam1( 6)/     -52.0286580d0/
      data uppam1( 6)/     -39.6142390d0/
      data betasa( 6)/     -15.7157830d0/
      data betapa( 6)/      -7.7192830d0/
      data zs am1( 6)/       1.8086650d0/
      data zp am1( 6)/       1.6851160d0/
      data alpam1( 6)/       2.6482740d0/
      data eisola( 6)/    -120.8157940d0/
      data gssam1( 6)/      12.2300000d0/
      data gspam1( 6)/      11.4700000d0/
      data gppam1( 6)/      11.0800000d0/
      data gp2am1( 6)/       9.8400000d0/
      data hspam1( 6)/       2.4300000d0/
      data dd am1( 6)/       0.8236736d0/
      data qq am1( 6)/       0.7268015d0/
      data am am1( 6)/       0.4494671d0/
      data ad am1( 6)/       0.6082946d0/
      data aq am1( 6)/       0.6423492d0/
      data guesa1( 6,1)/       0.0113550d0/
      data guesa2( 6,1)/       5.0000000d0/
      data guesa3( 6,1)/       1.6000000d0/
      data guesa1( 6,2)/       0.0459240d0/
      data guesa2( 6,2)/       5.0000000d0/
      data guesa3( 6,2)/       1.8500000d0/
      data guesa1( 6,3)/      -0.0200610d0/
      data guesa2( 6,3)/       5.0000000d0/
      data guesa3( 6,3)/       2.0500000d0/
      data guesa1( 6,4)/      -0.0012600d0/
      data guesa2( 6,4)/       5.0000000d0/
      data guesa3( 6,4)/       2.6500000d0/
c                    data for element  7       am1:   nitrogen
      data refam  ( 7)/'  n: (am1): m.j.s. dewar et al, j. am. chem. soc
     1. 107 3902-3909 (1985)          '/
      data ussam1( 7)/     -71.8600000d0/
      data uppam1( 7)/     -57.1675810d0/
      data betasa( 7)/     -20.2991100d0/
      data betapa( 7)/     -18.2386660d0/
      data zs am1( 7)/       2.3154100d0/
      data zp am1( 7)/       2.1579400d0/
      data alpam1( 7)/       2.9472860d0/
      data eisola( 7)/    -202.4077430d0/
      data gssam1( 7)/      13.5900000d0/
      data gspam1( 7)/      12.6600000d0/
      data gppam1( 7)/      12.9800000d0/
      data gp2am1( 7)/      11.5900000d0/
      data hspam1( 7)/       3.1400000d0/
      data dd am1( 7)/       0.6433247d0/
      data qq am1( 7)/       0.5675528d0/
      data am am1( 7)/       0.4994487d0/
      data ad am1( 7)/       0.7820840d0/
      data aq am1( 7)/       0.7883498d0/
      data guesa1( 7,1)/       0.0252510d0/
      data guesa2( 7,1)/       5.0000000d0/
      data guesa3( 7,1)/       1.5000000d0/
      data guesa1( 7,2)/       0.0289530d0/
      data guesa2( 7,2)/       5.0000000d0/
      data guesa3( 7,2)/       2.1000000d0/
      data guesa1( 7,3)/      -0.0058060d0/
      data guesa2( 7,3)/       2.0000000d0/
      data guesa3( 7,3)/       2.4000000d0/
c                    data for element  8       am1:   oxygen
      data refam  ( 8)/'  o: (am1): m.j.s. dewar et al, j. am. chem. soc
     1. 107 3902-3909 (1985)          '/
      data ussam1( 8)/     -97.8300000d0/
      data uppam1( 8)/     -78.2623800d0/
      data betasa( 8)/     -29.2727730d0/
      data betapa( 8)/     -29.2727730d0/
      data zs am1( 8)/       3.1080320d0/
      data zp am1( 8)/       2.5240390d0/
      data alpam1( 8)/       4.4553710d0/
      data eisola( 8)/    -316.0995200d0/
      data gssam1( 8)/      15.4200000d0/
      data gspam1( 8)/      14.4800000d0/
      data gppam1( 8)/      14.5200000d0/
      data gp2am1( 8)/      12.9800000d0/
      data hspam1( 8)/       3.9400000d0/
      data dd am1( 8)/       0.4988896d0/
      data qq am1( 8)/       0.4852322d0/
      data am am1( 8)/       0.5667034d0/
      data ad am1( 8)/       0.9961066d0/
      data aq am1( 8)/       0.9065223d0/
      data guesa1( 8,1)/       0.2809620d0/
      data guesa2( 8,1)/       5.0000000d0/
      data guesa3( 8,1)/       0.8479180d0/
      data guesa1( 8,2)/       0.0814300d0/
      data guesa2( 8,2)/       7.0000000d0/
      data guesa3( 8,2)/       1.4450710d0/
c                    data for element  9       am1:   fluorine  *
      data refam  ( 9)/'  f: (am1): m.j.s. dewar and e. g. zoebisch, the
     1ochem, 180, 1 (1988).           '/
      data ussam1( 9)/    -136.1055790d0/
      data uppam1( 9)/    -104.8898850d0/
      data betasa( 9)/     -69.5902770d0/
      data betapa( 9)/     -27.9223600d0/
      data zs am1( 9)/       3.7700820d0/
      data zp am1( 9)/       2.4946700d0/
      data alpam1( 9)/       5.5178000d0/
      data eisola( 9)/    -482.2905830d0/
      data gssam1( 9)/      16.9200000d0/
      data gspam1( 9)/      17.2500000d0/
      data gppam1( 9)/      16.7100000d0/
      data gp2am1( 9)/      14.9100000d0/
      data hspam1( 9)/       4.8300000d0/
      data dd am1( 9)/       0.4145203d0/
      data qq am1( 9)/       0.4909446d0/
      data am am1( 9)/       0.6218302d0/
      data ad am1( 9)/       1.2088792d0/
      data aq am1( 9)/       0.9449355d0/
      data guesa1( 9,1)/       0.2420790d0/
      data guesa2( 9,1)/       4.8000000d0/
      data guesa3( 9,1)/       0.9300000d0/
      data guesa1( 9,2)/       0.0036070d0/
      data guesa2( 9,2)/       4.6000000d0/
      data guesa3( 9,2)/       1.6600000d0/
c                    data for element 13       am1:   aluminum  *
      data refam  (13)/' al: (am1):  m. j. s. dewar, a. j. holder, organ
     1ometallics, 9, 508-511 (1990).  '/
      data ussam1( 13)/     -24.3535850d0/
      data uppam1( 13)/     -18.3636450d0/
      data betasa( 13)/      -3.8668220d0/
      data betapa( 13)/      -2.3171460d0/
      data zsam1 ( 13)/       1.5165930d0/
      data zpam1 ( 13)/       1.3063470d0/
      data zdam1 ( 13)/       1.0000000d0/
      data alpam1( 13)/       1.9765860d0/
      data eisola( 13)/     -46.4208150d0/
      data gssam1( 13)/       8.0900000d0/
      data gspam1( 13)/       6.6300000d0/
      data gppam1( 13)/       5.9800000d0/
      data gp2am1( 13)/       5.4000000d0/
      data hspam1( 13)/       0.7000000d0/
      data ddam1 ( 13)/       1.4040443d0/
      data qqam1 ( 13)/       1.2809154d0/
      data amam1 ( 13)/       0.2973172d0/
      data adam1 ( 13)/       0.2630229d0/
      data aqam1 ( 13)/       0.3427832d0/
      data guesa1( 13,1)/       0.0900000d0/
      data guesa2( 13,1)/      12.3924430d0/
      data guesa3( 13,1)/       2.0503940d0/
c                    data for element 14       am1:   silicon  *
      data refam  (14)/' si: (am1): m.j.s.dewar, c. jie, organometallics
     1, 6, 1486-1490 (1987).          '/
      data ussam1(14)/     -33.9536220d0/
      data uppam1(14)/     -28.9347490d0/
      data betasa(14)/      -3.784852d0/
      data betapa(14)/      -1.968123d0/
      data zs am1(14)/       1.830697d0/
      data zp am1(14)/       1.2849530d0/
      data zd am1(14)/       1.0000000d0/
      data alpam1(14)/       2.257816d0/
      data eisola(14)/     -79.0017420d0/
      data gssam1(14)/       9.8200000d0/
      data gspam1(14)/       8.3600000d0/
      data gppam1(14)/       7.3100000d0/
      data gp2am1(14)/       6.5400000d0/
      data hspam1(14)/       1.3200000d0/
      data dd am1(14)/       1.1631107d0/
      data qq am1(14)/       1.3022422d0/
      data am am1(14)/       0.3608967d0/
      data ad am1(14)/       0.3829813d0/
      data aq am1(14)/       0.3712106d0/
      data guesa1(14,1)/       0.25d0/
      data guesa2(14,1)/       9.000d0/
      data guesa3(14,1)/       0.911453d0/
      data guesa1(14,2)/       0.061513d0/
      data guesa2(14,2)/       5.00d0/
      data guesa3(14,2)/       1.995569d0/
      data guesa1(14,3)/       0.0207890d0/
      data guesa2(14,3)/       5.00d0/
      data guesa3(14,3)/       2.990610d0/
c                    data for element 15        phosphorus
      data refam  (15)/'  p: (am1): m.j.s.dewar, jie, c, theochem, 187,
     11 (1989)                        '/
      data ussam1( 15)/     -42.0298630d0/
      data uppam1( 15)/     -34.0307090d0/
      data betasa( 15)/      -6.3537640d0/
      data betapa( 15)/      -6.5907090d0/
      data zs am1( 15)/       1.9812800d0/
      data zp am1( 15)/       1.8751500d0/
      data zd am1( 15)/       1.0000000d0/
      data alpam1( 15)/       2.4553220d0/
      data eisola( 15)/    -124.4368355d0/
      data gssam1( 15)/      11.5600050d0/
      data gspam1( 15)/       5.2374490d0/
      data gppam1( 15)/       7.8775890d0/
      data gp2am1( 15)/       7.3076480d0/
      data hspam1( 15)/       0.7792380d0/
      data dd am1( 15)/       1.0452022d0/
      data qq am1( 15)/       0.8923660d0/
      data am am1( 15)/       0.4248440d0/
      data ad am1( 15)/       0.3275319d0/
      data aq am1( 15)/       0.4386854d0/
      data guesa1( 15,1)/      -0.0318270d0/
      data guesa2( 15,1)/       6.0000000d0/
      data guesa3( 15,1)/       1.4743230d0/
      data guesa1( 15,2)/       0.0184700d0/
      data guesa2( 15,2)/       7.0000000d0/
      data guesa3( 15,2)/       1.7793540d0/
      data guesa1( 15,3)/       0.0332900d0/
      data guesa2( 15,3)/       9.0000000d0/
      data guesa3( 15,3)/       3.0065760d0/
c                    data for element 16       am1:   sulfur  *
c
      data refam  (16)/'  s: (am1): m.j.s.dewar, y-c yuan, theochem, in
     1 press                          '/
      data ussam1(16)/     -56.6940560d0/
      data uppam1(16)/     -48.7170490d0/
      data betasa(16)/      -3.9205660d0/
      data betapa(16)/      -7.9052780d0/
      data zs am1(16)/       2.3665150d0/
      data zp am1(16)/       1.6672630d0/
      data zd am1(16)/       1.0000000d0/
      data alpam1(16)/       2.4616480d0/
      data eisola(16)/    -191.7321930d0/
      data gssam1(16)/      11.7863290d0/
      data gspam1(16)/       8.6631270d0/
      data gppam1(16)/      10.0393080d0/
      data gp2am1(16)/       7.7816880d0/
      data hspam1(16)/       2.5321370d0/
      data dd am1(16)/       0.9004265d0/
      data qq am1(16)/       1.0036329d0/
      data am am1(16)/       0.4331617d0/
      data ad am1(16)/       0.5907115d0/
      data aq am1(16)/       0.6454943d0/
      data guesa1(16,1)/      -0.5091950d0/
      data guesa2(16,1)/       4.5936910d0/
      data guesa3(16,1)/       0.7706650d0/
      data guesa1(16,2)/      -0.0118630d0/
      data guesa2(16,2)/       5.8657310d0/
      data guesa3(16,2)/       1.5033130d0/
      data guesa1(16,3)/       0.0123340d0/
      data guesa2(16,3)/      13.5573360d0/
      data guesa3(16,3)/       2.0091730d0/
c                    data for element 17       am1:   chlorine  *
      data refam  (17)/' cl: (am1): m.j.s. dewar and e. g. zoebisch, the
     1ochem, 180, 1 (1988).           '/
      data ussam1(17)/    -111.6139480d0/
      data uppam1(17)/     -76.6401070d0/
      data betasa(17)/     -24.5946700d0/
      data betapa(17)/     -14.6372160d0/
      data zs am1(17)/       3.6313760d0/
      data zp am1(17)/       2.0767990d0/
      data zd am1(17)/       1.0000000d0/
      data alpam1(17)/       2.9193680d0/
      data eisola(17)/    -372.1984310d0/
      data gssam1(17)/      15.0300000d0/
      data gspam1(17)/      13.1600000d0/
      data gppam1(17)/      11.3000000d0/
      data gp2am1(17)/       9.9700000d0/
      data hspam1(17)/       2.4200000d0/
      data dd am1(17)/       0.5406286d0/
      data qq am1(17)/       0.8057208d0/
      data am am1(17)/       0.5523705d0/
      data ad am1(17)/       0.7693200d0/
      data aq am1(17)/       0.6133369d0/
      data guesa1(17,1)/       0.0942430d0/
      data guesa2(17,1)/       4.0000000d0/
      data guesa3(17,1)/       1.3000000d0/
      data guesa1(17,2)/       0.0271680d0/
      data guesa2(17,2)/       4.0000000d0/
      data guesa3(17,2)/       2.1000000d0/
c                    data for element 30        zinc
      data refam  (30)/' zn: (am1):  m.j.s. dewar, k.m. merz, organomet
     1allics, 7, 522-524 (1988)       '/
      data ussam1( 30)/     -21.0400080d0/
      data uppam1( 30)/     -17.6555740d0/
      data betasa( 30)/      -1.9974290d0/
      data betapa( 30)/      -4.7581190d0/
      data zs am1( 30)/       1.9542990d0/
      data zp am1( 30)/       1.3723650d0/
      data zd am1( 30)/       1.0000000d0/
      data alpam1( 30)/       1.4845630d0/
      data eisola( 30)/     -30.2800160d0/
      data gssam1( 30)/      11.8000000d0/
      data gspam1( 30)/      11.1820180d0/
      data gppam1( 30)/      13.3000000d0/
      data gp2am1( 30)/      12.9305200d0/
      data hspam1( 30)/       0.4846060d0/
      data dd am1( 30)/       1.3581113d0/
      data qq am1( 30)/       1.5457406d0/
      data am am1( 30)/       0.4336641d0/
      data ad am1( 30)/       0.2317423d0/
      data aq am1( 30)/       0.2621165d0/
c                    data for element 32        germanium
      data refam  (32)/' ge: (am1): m.j.s.dewar and c.jie, organometalli
     1cs, 8, 1544, (1989)             '/
      data ussam1( 32)/     -34.1838890d0/
      data uppam1( 32)/     -28.6408110d0/
      data betasa( 32)/      -4.3566070d0/
      data betapa( 32)/      -0.9910910d0/
      data zs am1( 32)/       1.2196310d0/
      data zp am1( 32)/       1.9827940d0/
      data alpam1( 32)/       2.1364050d0/
      data eisola( 32)/     -78.7084810d0/
      data gssam1( 32)/      10.1686050d0/
      data gspam1( 32)/       8.1444730d0/
      data gppam1( 32)/       6.6719020d0/
      data gp2am1( 32)/       6.2697060d0/
      data hspam1( 32)/       0.9370930d0/
      data dd am1( 32)/       1.2472095d0/
      data qq am1( 32)/       1.0698642d0/
      data am am1( 32)/       0.3737084d0/
      data ad am1( 32)/       0.3180309d0/
      data aq am1( 32)/       0.3485612d0/
c                    data for element 35       am1:   bromine  *
      data refam  (35)/' br: (am1): m.j.s. dewar and e. g. zoebisch, the
     1ochem, 180, 1 (1988).           '/
      data ussam1(35)/    -104.6560630d0/
      data uppam1(35)/     -74.9300520d0/
      data betasa(35)/     -19.3998800d0/
      data betapa(35)/      -8.9571950d0/
      data zs am1(35)/       3.0641330d0/
      data zp am1(35)/       2.0383330d0/
      data zd am1(35)/       1.0000000d0/
      data alpam1(35)/       2.5765460d0/
      data eisola(35)/    -352.3142087d0/
      data gssam1(35)/      15.0364395d0/
      data gspam1(35)/      13.0346824d0/
      data gppam1(35)/      11.2763254d0/
      data gp2am1(35)/       9.8544255d0/
      data hspam1(35)/       2.4558683d0/
      data dd am1(35)/       0.8458104d0/
      data qq am1(35)/       1.0407133d0/
      data am am1(35)/       0.5526071d0/
      data ad am1(35)/       0.6024598d0/
      data aq am1(35)/       0.5307555d0/
      data guesa1(35,1)/       0.0666850d0/
      data guesa2(35,1)/       4.0000000d0/
      data guesa3(35,1)/       1.5000000d0/
      data guesa1(35,2)/       0.0255680d0/
      data guesa2(35,2)/       4.0000000d0/
      data guesa3(35,2)/       2.3000000d0/
c                    data for element 53       am1:   iodine  *
      data refam  (53)/'  i: (am1): m.j.s. dewar and e. g. zoebisch, the
     1ochem, 180, 1 (1988).           '/
      data ussam1(53)/    -103.5896630d0/
      data uppam1(53)/     -74.4299970d0/
      data betasa(53)/      -8.4433270d0/
      data betapa(53)/      -6.3234050d0/
      data zs am1(53)/       2.1028580d0/
      data zp am1(53)/       2.1611530d0/
      data zd am1(53)/       1.0000000d0/
      data alpam1(53)/       2.2994240d0/
      data eisola(53)/    -346.8642857d0/
      data gssam1(53)/      15.0404486d0/
      data gspam1(53)/      13.0565580d0/
      data gppam1(53)/      11.1477837d0/
      data gp2am1(53)/       9.9140907d0/
      data hspam1(53)/       2.4563820d0/
      data dd am1(53)/       1.4878778d0/
      data qq am1(53)/       1.1887388d0/
      data am am1(53)/       0.5527544d0/
      data ad am1(53)/       0.4497523d0/
      data aq am1(53)/       0.4631775d0/
      data guesa1(53,1)/       0.0043610d0/
      data guesa2(53,1)/       2.3000000d0/
      data guesa3(53,1)/       1.8000000d0/
      data guesa1(53,2)/       0.0157060d0/
      data guesa2(53,2)/       3.0000000d0/
      data guesa3(53,2)/       2.2400000d0/
c                    data for element 80        mercury
      data refam  (80)/' hg: (am1): m.j.s.dewar and c.jie, organometalli
     1cs 8, 1547, (1989)              '/
      data ussam1( 80)/     -19.9415780d0/
      data uppam1( 80)/     -11.1108700d0/
      data betasa( 80)/      -0.9086570d0/
      data betapa( 80)/      -4.9093840d0/
      data zs am1( 80)/       2.0364130d0/
      data zp am1( 80)/       1.9557660d0/
      data alpam1( 80)/       1.4847340d0/
      data eisola( 80)/     -29.0831560d0/
      data gssam1( 80)/      10.8000000d0/
      data gspam1( 80)/       9.3000000d0/
      data gppam1( 80)/      14.3000000d0/
      data gp2am1( 80)/      13.5000000d0/
      data hspam1( 80)/       1.3000000d0/
      data dd am1( 80)/       1.8750829d0/
      data qq am1( 80)/       1.5424241d0/
      data am am1( 80)/       0.3969129d0/
      data ad am1( 80)/       0.2926605d0/
      data aq am1( 80)/       0.3360599d0/
c
c     start of "old" elements: these are old parameters which
c     can be used, if desired, by specifying "<chemical symbol>year"
c     as in si1978 or  s1983.
c
c                    data for element 90        silicon
      data refam  (90)/' si: (mndo): m.j.s.dewar, m.l.mckee, h.s.rzepa,
     1j. am. chem. soc., 100 3607 1978'/
      data ussam1 (90)/     -40.5682920d0/
      data uppam1 (90)/     -28.0891870d0/
      data betasa (90)/      -4.2562180d0/
      data betapa (90)/      -4.2562180d0/
      data zsam1  (90)/       1.4353060d0/
      data zpam1  (90)/       1.4353060d0/
      data zdam1  (90)/       1.0000000d0/
      data alpam1  (90)/       2.1961078d0/
      data eisola (90)/     -90.5399580d0/
      data ddam1  (90)/       1.4078712d0/
      data qqam1  (90)/       1.1658281d0/
      data amam1  (90)/       0.3608967d0/
      data adam1  (90)/       0.3441817d0/
      data aqam1  (90)/       0.3999442d0/
      data hspam1 (90)/1.32d00/
      data gp2am1 (90)/6.54d00/
      data gppam1 (90)/7.31d00/
      data gspam1 (90)/8.36d00/
      data gssam1 (90)/9.82d00/
      data refam  (91)/'  s: (mndo): m.j.s.dewar, h.s. rzepa, m.l.mckee,
     1 j.am.chem.soc.100, 3607 (1978).'/
      data ussam1 (91)/     -75.2391520d0/
      data uppam1 (91)/     -57.8320130d0/
      data betasa (91)/     -11.1422310d0/
      data betapa (91)/     -11.1422310d0/
      data zsam1  (91)/       2.6135910d0/
      data zpam1  (91)/       2.0343930d0/
      data zdam1  (91)/       1.0000000d0/
      data alpam1 (91)/       2.4916445d0/
      data eisola (91)/    -235.4413560d0/
      data gssam1 (91)/      12.8800000d0/
      data gspam1 (91)/      11.2600000d0/
      data gppam1 (91)/       9.9000000d0/
      data gp2am1 (91)/       8.8300000d0/
      data hspam1 (91)/       2.2600000d0/
      data ddam1  (91)/       0.8231596d0/
      data qqam1  (91)/       0.8225156d0/
      data amam1  (91)/       0.4733554d0/
      data adam1  (91)/       0.5889395d0/
      data aqam1  (91)/       0.5632724d0/
      data refam (102)/' cb: (am1):  capped bond  (hydrogen-like, takes
     1 on zero charge.)               '/
c                    data for element102
      data ussam1 (102)/     -11.9062760d0/
      data betasa (102)/-9999999.0000000d0/
      data zsam1  (102)/       4.0000000d0/
      data zpam1  (102)/       0.3000000d0/
      data zdam1  (102)/       0.3000000d0/
      data alpam1 (102)/       2.5441341d0/
      data eisola (102)/       4.0000000d0/
      data gssam1 (102)/      12.8480000d0/
      data hspam1 (102)/       0.1000000d0/
      data ddam1  (102)/       0.0684105d0/
      data qqam1  (102)/       1.0540926d0/
      data amam1  (102)/       0.4721793d0/
      data adam1  (102)/       0.9262742d0/
      data aqam1  (102)/       0.2909059d0/
c
c     start of mndo-pm3 parameter set
c
c                    data for element  1        hydrogen
      data refpm3 ( 1)/'  h: (pm3): j. j. p. stewart, j. comp. chem.
     1 10, 209 (1989).                '/
      data usspm3(  1)/     -13.0733210d0/
      data betasp(  1)/      -5.6265120d0/
      data zspm3 (  1)/       0.9678070d0/
      data alppm3(  1)/       3.3563860d0/
      data eisolp(  1)/     -13.0733210d0/
      data gsspm3(  1)/      14.7942080d0/
      data ampm3 (  1)/       0.5437048d0/
      data adpm3 (  1)/       0.5437048d0/
      data aqpm3 (  1)/       0.5437048d0/
      data guesp1(  1,1)/       1.1287500d0/
      data guesp2(  1,1)/       5.0962820d0/
      data guesp3(  1,1)/       1.5374650d0/
      data guesp1(  1,2)/      -1.0603290d0/
      data guesp2(  1,2)/       6.0037880d0/
      data guesp3(  1,2)/       1.5701890d0/
c                    data for element  4        beryllium
      data refpm3( 4)/ ' be: (pm3): j. j. p. stewart, j. comp. chem.
     1(accepted)                      '/
      data usspm3(  4)/     -17.2647520d0/
      data upppm3(  4)/     -11.3042430d0/
      data betasp(  4)/      -3.9620530d0/
      data betapp(  4)/      -2.7806840d0/
      data zspm3 (  4)/       0.8774390d0/
      data zppm3 (  4)/       1.5087550d0/
      data alppm3(  4)/       1.5935360d0/
      data eisolp(  4)/     -25.5166530d0/
      data gsspm3(  4)/       9.0128510d0/
      data gsppm3(  4)/       6.5761990d0/
      data gpppm3(  4)/       6.0571820d0/
      data gp2pm3(  4)/       9.0052190d0/
      data hsppm3(  4)/       0.5446790d0/
      data ddpm3 (  4)/       1.0090531d0/
      data qqpm3 (  4)/       0.8117586d0/
      data ampm3 (  4)/       0.3312330d0/
      data adpm3 (  4)/       0.2908996d0/
      data aqpm3 (  4)/       0.3530008d0/
      data guesp1(  4,1)/       1.6315720d0/
      data guesp2(  4,1)/       2.6729620d0/
      data guesp3(  4,1)/       1.7916860d0/
      data guesp1(  4,2)/      -2.1109590d0/
      data guesp2(  4,2)/       1.9685940d0/
      data guesp3(  4,2)/       1.7558710d0/
c                    data for element  6        carbon
      data refpm3 ( 6)/'  c: (pm3): j. j. p. stewart, j. comp. chem.
     1 10, 209 (1989).                '/
      data usspm3(  6)/     -47.2703200d0/
      data upppm3(  6)/     -36.2669180d0/
      data betasp(  6)/     -11.9100150d0/
      data betapp(  6)/      -9.8027550d0/
      data zspm3 (  6)/       1.5650850d0/
      data zppm3 (  6)/       1.8423450d0/
      data alppm3(  6)/       2.7078070d0/
      data eisolp(  6)/    -111.2299170d0/
      data gsspm3(  6)/      11.2007080d0/
      data gsppm3(  6)/      10.2650270d0/
      data gpppm3(  6)/      10.7962920d0/
      data gp2pm3(  6)/       9.0425660d0/
      data hsppm3(  6)/       2.2909800d0/
      data ddpm3 (  6)/       0.8332396d0/
      data qqpm3 (  6)/       0.6647750d0/
      data ampm3 (  6)/       0.4116394d0/
      data adpm3 (  6)/       0.5885862d0/
      data aqpm3 (  6)/       0.7647667d0/
      data guesp1(  6,1)/       0.0501070d0/
      data guesp2(  6,1)/       6.0031650d0/
      data guesp3(  6,1)/       1.6422140d0/
      data guesp1(  6,2)/       0.0507330d0/
      data guesp2(  6,2)/       6.0029790d0/
      data guesp3(  6,2)/       0.8924880d0/
c                    data for element  7        nitrogen
      data refpm3 ( 7)/'  n: (pm3): j. j. p. stewart, j. comp. chem.
     1 10, 209 (1989).                '/
      data usspm3(  7)/     -49.3356720d0/
      data upppm3(  7)/     -47.5097360d0/
      data betasp(  7)/     -14.0625210d0/
      data betapp(  7)/     -20.0438480d0/
      data zspm3 (  7)/       2.0280940d0/
      data zppm3 (  7)/       2.3137280d0/
      data alppm3(  7)/       2.8305450d0/
      data eisolp(  7)/    -157.6137755d0/
      data gsspm3(  7)/      11.9047870d0/
      data gsppm3(  7)/       7.3485650d0/
      data gpppm3(  7)/      11.7546720d0/
      data gp2pm3(  7)/      10.8072770d0/
      data hsppm3(  7)/       1.1367130d0/
      data ddpm3 (  7)/       0.6577006d0/
      data qqpm3 (  7)/       0.5293383d0/
      data ampm3 (  7)/       0.4375151d0/
      data adpm3 (  7)/       0.5030995d0/
      data aqpm3 (  7)/       0.7364933d0/
      data guesp1(  7,1)/       1.5016740d0/
      data guesp2(  7,1)/       5.9011480d0/
      data guesp3(  7,1)/       1.7107400d0/
      data guesp1(  7,2)/      -1.5057720d0/
      data guesp2(  7,2)/       6.0046580d0/
      data guesp3(  7,2)/       1.7161490d0/
c                    data for element  8        oxygen
      data refpm3 ( 8)/'  o: (pm3): j. j. p. stewart, j. comp. chem.
     1 10, 209 (1989).                '/
      data usspm3(  8)/     -86.9930020d0/
      data upppm3(  8)/     -71.8795800d0/
      data betasp(  8)/     -45.2026510d0/
      data betapp(  8)/     -24.7525150d0/
      data zspm3 (  8)/       3.7965440d0/
      data zppm3 (  8)/       2.3894020d0/
      data alppm3(  8)/       3.2171020d0/
      data eisolp(  8)/    -289.3422065d0/
      data gsspm3(  8)/      15.7557600d0/
      data gsppm3(  8)/      10.6211600d0/
      data gpppm3(  8)/      13.6540160d0/
      data gp2pm3(  8)/      12.4060950d0/
      data hsppm3(  8)/       0.5938830d0/
      data ddpm3 (  8)/       0.4086173d0/
      data qqpm3 (  8)/       0.5125738d0/
      data ampm3 (  8)/       0.5790430d0/
      data adpm3 (  8)/       0.5299630d0/
      data aqpm3 (  8)/       0.8179630d0/
      data guesp1(  8,1)/      -1.1311280d0/
      data guesp2(  8,1)/       6.0024770d0/
      data guesp3(  8,1)/       1.6073110d0/
      data guesp1(  8,2)/       1.1378910d0/
      data guesp2(  8,2)/       5.9505120d0/
      data guesp3(  8,2)/       1.5983950d0/
c                    data for element  9        fluorine
      data refpm3 ( 9)/'  f: (pm3): j. j. p. stewart, j. comp. chem.
     1 10, 209 (1989).                '/
      data usspm3(  9)/    -110.4353030d0/
      data upppm3(  9)/    -105.6850470d0/
      data betasp(  9)/     -48.4059390d0/
      data betapp(  9)/     -27.7446600d0/
      data zspm3 (  9)/       4.7085550d0/
      data zppm3 (  9)/       2.4911780d0/
      data alppm3(  9)/       3.3589210d0/
      data eisolp(  9)/    -437.5171690d0/
      data gsspm3(  9)/      10.4966670d0/
      data gsppm3(  9)/      16.0736890d0/
      data gpppm3(  9)/      14.8172560d0/
      data gp2pm3(  9)/      14.4183930d0/
      data hsppm3(  9)/       0.7277630d0/
      data ddpm3 (  9)/       0.3125302d0/
      data qqpm3 (  9)/       0.4916328d0/
      data ampm3 (  9)/       0.3857650d0/
      data adpm3 (  9)/       0.6768503d0/
      data aqpm3 (  9)/       0.6120047d0/
      data guesp1(  9,1)/      -0.0121660d0/
      data guesp2(  9,1)/       6.0235740d0/
      data guesp3(  9,1)/       1.8568590d0/
      data guesp1(  9,2)/      -0.0028520d0/
      data guesp2(  9,2)/       6.0037170d0/
      data guesp3(  9,2)/       2.6361580d0/
c                    data for element 12        magnesium
      data refpm3(12)/ ' mg: (pm3): j. j. p. stewart, j. comp. chem.
     1(accepted)                      '/
      data usspm3( 12)/     -14.6236880d0/
      data upppm3( 12)/     -14.1734600d0/
      data betasp( 12)/      -2.0716910d0/
      data betapp( 12)/      -0.5695810d0/
      data zspm3 ( 12)/       0.6985520d0/
      data zppm3 ( 12)/       1.4834530d0/
      data alppm3( 12)/       1.3291470d0/
      data eisolp( 12)/     -22.5530760d0/
      data gsspm3( 12)/       6.6943000d0/
      data gsppm3( 12)/       6.7939950d0/
      data gpppm3( 12)/       6.9104460d0/
      data gp2pm3( 12)/       7.0908230d0/
      data hsppm3( 12)/       0.5433000d0/
      data ddpm3 ( 12)/       1.1403950d0/
      data qqpm3 ( 12)/       1.1279899d0/
      data ampm3 ( 12)/       0.2460235d0/
      data adpm3 ( 12)/       0.2695751d0/
      data aqpm3 ( 12)/       0.2767522d0/
      data guesp1( 12,1)/       2.1170500d0/
      data guesp2( 12,1)/       6.0094770d0/
      data guesp3( 12,1)/       2.0844060d0/
      data guesp1( 12,2)/      -2.5477670d0/
      data guesp2( 12,2)/       4.3953700d0/
      data guesp3( 12,2)/       2.0636740d0/
c                    data for element 13        aluminum
      data refpm3 (13)/' al: (pm3): j. j. p. stewart, j. comp. chem.
     1 10, 209 (1989).                '/
      data usspm3( 13)/     -24.8454040d0/
      data upppm3( 13)/     -22.2641590d0/
      data betasp( 13)/      -0.5943010d0/
      data betapp( 13)/      -0.9565500d0/
      data zspm3 ( 13)/       1.7028880d0/
      data zppm3 ( 13)/       1.0736290d0/
      data zdpm3 ( 13)/       1.0000000d0/
      data alppm3( 13)/       1.5217030d0/
      data eisolp( 13)/     -46.8647630d0/
      data gsspm3( 13)/       5.7767370d0/
      data gsppm3( 13)/      11.6598560d0/
      data gpppm3( 13)/       6.3477900d0/
      data gp2pm3( 13)/       6.1210770d0/
      data hsppm3( 13)/       4.0062450d0/
      data ddpm3 ( 13)/       1.2102799d0/
      data qqpm3 ( 13)/       1.5585645d0/
      data ampm3 ( 13)/       0.2123020d0/
      data adpm3 ( 13)/       0.6418584d0/
      data aqpm3 ( 13)/       0.2262838d0/
      data guesp1( 13,1)/      -0.4730900d0/
      data guesp2( 13,1)/       1.9158250d0/
      data guesp3( 13,1)/       1.4517280d0/
      data guesp1( 13,2)/      -0.1540510d0/
      data guesp2( 13,2)/       6.0050860d0/
      data guesp3( 13,2)/       2.5199970d0/
c                    data for element 14        silicon
      data refpm3 (14)/' si: (pm3): j. j. p. stewart, j. comp. chem.
     1 10, 209 (1989).                '/
      data usspm3( 14)/     -26.7634830d0/
      data upppm3( 14)/     -22.8136350d0/
      data betasp( 14)/      -2.8621450d0/
      data betapp( 14)/      -3.9331480d0/
      data zspm3 ( 14)/       1.6350750d0/
      data zppm3 ( 14)/       1.3130880d0/
      data zdpm3 ( 14)/       1.0000000d0/
      data alppm3( 14)/       2.1358090d0/
      data eisolp( 14)/     -67.7882140d0/
      data gsspm3( 14)/       5.0471960d0/
      data gsppm3( 14)/       5.9490570d0/
      data gpppm3( 14)/       6.7593670d0/
      data gp2pm3( 14)/       5.1612970d0/
      data hsppm3( 14)/       0.9198320d0/
      data ddpm3 ( 14)/       1.3144550d0/
      data qqpm3 ( 14)/       1.2743396d0/
      data ampm3 ( 14)/       0.1854905d0/
      data adpm3 ( 14)/       0.3060715d0/
      data aqpm3 ( 14)/       0.4877432d0/
      data guesp1( 14,1)/      -0.3906000d0/
      data guesp2( 14,1)/       6.0000540d0/
      data guesp3( 14,1)/       0.6322620d0/
      data guesp1( 14,2)/       0.0572590d0/
      data guesp2( 14,2)/       6.0071830d0/
      data guesp3( 14,2)/       2.0199870d0/
c                    data for element 15        phosphorus
      data refpm3 (15)/'  p: (pm3): j. j. p. stewart, j. comp. chem.
     1 10, 209 (1989).                '/
      data usspm3( 15)/     -40.4130960d0/
      data upppm3( 15)/     -29.5930520d0/
      data betasp( 15)/     -12.6158790d0/
      data betapp( 15)/      -4.1600400d0/
      data zspm3 ( 15)/       2.0175630d0/
      data zppm3 ( 15)/       1.5047320d0/
      data zdpm3 ( 15)/       1.0000000d0/
      data alppm3( 15)/       1.9405340d0/
      data eisolp( 15)/    -117.9591740d0/
      data gsspm3( 15)/       7.8016150d0/
      data gsppm3( 15)/       5.1869490d0/
      data gpppm3( 15)/       6.6184780d0/
      data gp2pm3( 15)/       6.0620020d0/
      data hsppm3( 15)/       1.5428090d0/
      data ddpm3 ( 15)/       1.0644947d0/
      data qqpm3 ( 15)/       1.1120386d0/
      data ampm3 ( 15)/       0.2867187d0/
      data adpm3 ( 15)/       0.4309446d0/
      data aqpm3 ( 15)/       0.3732517d0/
      data guesp1( 15,1)/      -0.6114210d0/
      data guesp2( 15,1)/       1.9972720d0/
      data guesp3( 15,1)/       0.7946240d0/
      data guesp1( 15,2)/      -0.0939350d0/
      data guesp2( 15,2)/       1.9983600d0/
      data guesp3( 15,2)/       1.9106770d0/
c                    data for element 16        sulfur
      data refpm3 (16)/'  s: (pm3): j. j. p. stewart, j. comp. chem.
     1 10, 209 (1989).                '/
      data usspm3( 16)/     -49.8953710d0/
      data upppm3( 16)/     -44.3925830d0/
      data betasp( 16)/      -8.8274650d0/
      data betapp( 16)/      -8.0914150d0/
      data zspm3 ( 16)/       1.8911850d0/
      data zppm3 ( 16)/       1.6589720d0/
      data zdpm3 ( 16)/       1.0000000d0/
      data alppm3( 16)/       2.2697060d0/
      data eisolp( 16)/    -183.4537395d0/
      data gsspm3( 16)/       8.9646670d0/
      data gsppm3( 16)/       6.7859360d0/
      data gpppm3( 16)/       9.9681640d0/
      data gp2pm3( 16)/       7.9702470d0/
      data hsppm3( 16)/       4.0418360d0/
      data ddpm3 ( 16)/       1.1214313d0/
      data qqpm3 ( 16)/       1.0086488d0/
      data ampm3 ( 16)/       0.3294622d0/
      data adpm3 ( 16)/       0.6679118d0/
      data aqpm3 ( 16)/       0.6137472d0/
      data guesp1( 16,1)/      -0.3991910d0/
      data guesp2( 16,1)/       6.0006690d0/
      data guesp3( 16,1)/       0.9621230d0/
      data guesp1( 16,2)/      -0.0548990d0/
      data guesp2( 16,2)/       6.0018450d0/
      data guesp3( 16,2)/       1.5799440d0/
c                    data for element 17        chlorine
      data refpm3 (17)/' cl: (pm3): j. j. p. stewart, j. comp. chem.
     1 10, 209 (1989).                '/
      data usspm3( 17)/    -100.6267470d0/
      data upppm3( 17)/     -53.6143960d0/
      data betasp( 17)/     -27.5285600d0/
      data betapp( 17)/     -11.5939220d0/
      data zspm3 ( 17)/       2.2462100d0/
      data zppm3 ( 17)/       2.1510100d0/
      data zdpm3 ( 17)/       1.0000000d0/
      data alppm3( 17)/       2.5172960d0/
      data eisolp( 17)/    -315.1949480d0/
      data gsspm3( 17)/      16.0136010d0/
      data gsppm3( 17)/       8.0481150d0/
      data gpppm3( 17)/       7.5222150d0/
      data gp2pm3( 17)/       7.5041540d0/
      data hsppm3( 17)/       3.4811530d0/
      data ddpm3 ( 17)/       0.9175856d0/
      data qqpm3 ( 17)/       0.7779230d0/
      data ampm3 ( 17)/       0.5885190d0/
      data adpm3 ( 17)/       0.6814522d0/
      data aqpm3 ( 17)/       0.3643694d0/
      data guesp1( 17,1)/      -0.1715910d0/
      data guesp2( 17,1)/       6.0008020d0/
      data guesp3( 17,1)/       1.0875020d0/
      data guesp1( 17,2)/      -0.0134580d0/
      data guesp2( 17,2)/       1.9666180d0/
      data guesp3( 17,2)/       2.2928910d0/
c                    data for element 30        zinc
      data refpm3(30)/ ' zn: (pm3): j. j. p. stewart, j. comp. chem.
     1(accepted)                      '/
      data usspm3( 30)/     -18.5321980d0/
      data upppm3( 30)/     -11.0474090d0/
      data betasp( 30)/      -0.7155780d0/
      data betapp( 30)/      -6.3518640d0/
      data zspm3 ( 30)/       1.8199890d0/
      data zppm3 ( 30)/       1.5069220d0/
      data zdpm3 ( 30)/       1.0000000d0/
      data alppm3( 30)/       1.3501260d0/
      data eisolp( 30)/     -27.3872000d0/
      data gsspm3( 30)/       9.6771960d0/
      data gsppm3( 30)/       7.7362040d0/
      data gpppm3( 30)/       4.9801740d0/
      data gp2pm3( 30)/       4.6696560d0/
      data hsppm3( 30)/       0.6004130d0/
      data ddpm3 ( 30)/       1.5005758d0/
      data qqpm3 ( 30)/       1.4077174d0/
      data ampm3 ( 30)/       0.3556485d0/
      data adpm3 ( 30)/       0.2375689d0/
      data aqpm3 ( 30)/       0.2661069d0/
      data guesp1( 30,1)/      -0.1112340d0/
      data guesp2( 30,1)/       6.0014780d0/
      data guesp3( 30,1)/       1.5160320d0/
      data guesp1( 30,2)/      -0.1323700d0/
      data guesp2( 30,2)/       1.9958390d0/
      data guesp3( 30,2)/       2.5196420d0/
c                    data for element 31        gallium
      data refpm3(31)/ ' ga: (pm3): j. j. p. stewart, j. comp. chem.
     1(accepted)                      '/
      data usspm3( 31)/     -29.8555930d0/
      data upppm3( 31)/     -21.8753710d0/
      data betasp( 31)/      -4.9456180d0/
      data betapp( 31)/      -0.4070530d0/
      data zspm3 ( 31)/       1.8470400d0/
      data zppm3 ( 31)/       0.8394110d0/
      data alppm3( 31)/       1.6051150d0/
      data eisolp( 31)/     -57.3280250d0/
      data gsspm3( 31)/       8.4585540d0/
      data gsppm3( 31)/       8.9256190d0/
      data gpppm3( 31)/       5.0868550d0/
      data gp2pm3( 31)/       4.9830450d0/
      data hsppm3( 31)/       2.0512600d0/
      data ddpm3 ( 31)/       0.9776692d0/
      data qqpm3 ( 31)/       2.5271534d0/
      data ampm3 ( 31)/       0.3108620d0/
      data adpm3 ( 31)/       0.5129360d0/
      data aqpm3 ( 31)/       0.1546208d0/
      data guesp1( 31,1)/      -0.5601790d0/
      data guesp2( 31,1)/       5.6232730d0/
      data guesp3( 31,1)/       1.5317800d0/
      data guesp1( 31,2)/      -0.2727310d0/
      data guesp2( 31,2)/       1.9918430d0/
      data guesp3( 31,2)/       2.1838640d0/
c                    data for element 32        germanium
      data refpm3(32)/ ' ge: (pm3): j. j. p. stewart, j. comp. chem.
     1(accepted)                      '/
      data usspm3( 32)/     -35.4671955d0/
      data upppm3( 32)/     -31.5863583d0/
      data betasp( 32)/      -5.3250024d0/
      data betapp( 32)/      -2.2501567d0/
      data zspm3 ( 32)/       2.2373526d0/
      data zppm3 ( 32)/       1.5924319d0/
      data alppm3( 32)/       1.9723370d0/
      data eisolp( 32)/     -84.0156006d0/
      data gsspm3( 32)/       5.3769635d0/
      data gsppm3( 32)/      10.2095293d0/
      data gpppm3( 32)/       7.6718647d0/
      data gp2pm3( 32)/       6.9242663d0/
      data hsppm3( 32)/       1.3370204d0/
      data ddpm3 ( 32)/       1.1920304d0/
      data qqpm3 ( 32)/       1.3321263d0/
      data ampm3 ( 32)/       0.1976098d0/
      data adpm3 ( 32)/       0.3798182d0/
      data aqpm3 ( 32)/       0.3620669d0/
      data guesp1( 32,1)/       0.9631726d0/
      data guesp2( 32,1)/       6.0120134d0/
      data guesp3( 32,1)/       2.1633655d0/
      data guesp1( 32,2)/      -0.9593891d0/
      data guesp2( 32,2)/       5.7491802d0/
      data guesp3( 32,2)/       2.1693724d0/
c                    data for element 33        arsenic
      data refpm3(33)/ ' as: (pm3): j. j. p. stewart, j. comp. chem.
     1(accepted)                      '/
      data usspm3( 33)/     -38.5074240d0/
      data upppm3( 33)/     -35.1524150d0/
      data betasp( 33)/      -8.2321650d0/
      data betapp( 33)/      -5.0173860d0/
      data zspm3 ( 33)/       2.6361770d0/
      data zppm3 ( 33)/       1.7038890d0/
      data alppm3( 33)/       1.7944770d0/
      data eisolp( 33)/    -122.6326140d0/
      data gsspm3( 33)/       8.7890010d0/
      data gsppm3( 33)/       5.3979830d0/
      data gpppm3( 33)/       8.2872500d0/
      data gp2pm3( 33)/       8.2103460d0/
      data hsppm3( 33)/       1.9510340d0/
      data ddpm3 ( 33)/       0.9679655d0/
      data qqpm3 ( 33)/       1.2449874d0/
      data ampm3 ( 33)/       0.3230063d0/
      data adpm3 ( 33)/       0.5042239d0/
      data aqpm3 ( 33)/       0.2574219d0/
      data guesp1( 33,1)/      -0.4600950d0/
      data guesp2( 33,1)/       1.9831150d0/
      data guesp3( 33,1)/       1.0867930d0/
      data guesp1( 33,2)/      -0.0889960d0/
      data guesp2( 33,2)/       1.9929440d0/
      data guesp3( 33,2)/       2.1400580d0/
c                    data for element 34        selenium
      data refpm3(34)/ ' se: (pm3): j. j. p. stewart, j. comp. chem.
     1(accepted)                      '/
      data usspm3( 34)/     -55.3781350d0/
      data upppm3( 34)/     -49.8230760d0/
      data betasp( 34)/      -6.1578220d0/
      data betapp( 34)/      -5.4930390d0/
      data zspm3 ( 34)/       2.8280510d0/
      data zppm3 ( 34)/       1.7325360d0/
      data alppm3( 34)/       3.0439570d0/
      data eisolp( 34)/    -192.7748115d0/
      data gsspm3( 34)/       7.4325910d0/
      data gsppm3( 34)/      10.0604610d0/
      data gpppm3( 34)/       9.5683260d0/
      data gp2pm3( 34)/       7.7242890d0/
      data hsppm3( 34)/       4.0165580d0/
      data ddpm3 ( 34)/       0.8719813d0/
      data qqpm3 ( 34)/       1.2244019d0/
      data ampm3 ( 34)/       0.2731566d0/
      data adpm3 ( 34)/       0.7509697d0/
      data aqpm3 ( 34)/       0.5283737d0/
      data guesp1( 34,1)/       0.0478730d0/
      data guesp2( 34,1)/       6.0074000d0/
      data guesp3( 34,1)/       2.0817170d0/
      data guesp1( 34,2)/       0.1147200d0/
      data guesp2( 34,2)/       6.0086720d0/
      data guesp3( 34,2)/       1.5164230d0/
c                    data for element 35        bromine
      data refpm3 (35)/' br: (pm3): j. j. p. stewart, j. comp. chem.
     1 10, 209 (1989).                '/
      data usspm3( 35)/    -116.6193110d0/
      data upppm3( 35)/     -74.2271290d0/
      data betasp( 35)/     -31.1713420d0/
      data betapp( 35)/      -6.8140130d0/
      data zspm3 ( 35)/       5.3484570d0/
      data zppm3 ( 35)/       2.1275900d0/
      data zdpm3 ( 35)/       1.0000000d0/
      data alppm3( 35)/       2.5118420d0/
      data eisolp( 35)/    -352.5398970d0/
      data gsspm3( 35)/      15.9434250d0/
      data gsppm3( 35)/      16.0616800d0/
      data gpppm3( 35)/       8.2827630d0/
      data gp2pm3( 35)/       7.8168490d0/
      data hsppm3( 35)/       0.5788690d0/
      data ddpm3 ( 35)/       0.2759025d0/
      data qqpm3 ( 35)/       0.9970532d0/
      data ampm3 ( 35)/       0.5859399d0/
      data adpm3 ( 35)/       0.6755383d0/
      data aqpm3 ( 35)/       0.3823719d0/
      data guesp1( 35,1)/       0.9604580d0/
      data guesp2( 35,1)/       5.9765080d0/
      data guesp3( 35,1)/       2.3216540d0/
      data guesp1( 35,2)/      -0.9549160d0/
      data guesp2( 35,2)/       5.9447030d0/
      data guesp3( 35,2)/       2.3281420d0/
c                    data for element 48        cadmium
      data refpm3(48)/ ' cd: (pm3): j. j. p. stewart, j. comp. chem.
     1(accepted)                      '/
      data usspm3( 48)/     -15.8285840d0/
      data upppm3( 48)/       8.7497950d0/
      data betasp( 48)/      -8.5819440d0/
      data betapp( 48)/      -0.6010340d0/
      data zspm3 ( 48)/       1.6793510d0/
      data zppm3 ( 48)/       2.0664120d0/
      data alppm3( 48)/       1.5253820d0/
      data eisolp( 48)/     -22.4502080d0/
      data gsspm3( 48)/       9.2069600d0/
      data gsppm3( 48)/       8.2315390d0/
      data gpppm3( 48)/       4.9481040d0/
      data gp2pm3( 48)/       4.6696560d0/
      data hsppm3( 48)/       1.6562340d0/
      data ddpm3 ( 48)/       1.5982681d0/
      data qqpm3 ( 48)/       1.2432402d0/
      data ampm3 ( 48)/       0.3383668d0/
      data adpm3 ( 48)/       0.3570290d0/
      data aqpm3 ( 48)/       0.2820582d0/
c                    data for element 49        indium
      data refpm3(49)/ ' in: (pm3): j. j. p. stewart, j. comp. chem.
     1(accepted)                      '/
      data usspm3( 49)/     -26.1762050d0/
      data upppm3( 49)/     -20.0058220d0/
      data betasp( 49)/      -2.9933190d0/
      data betapp( 49)/      -1.8289080d0/
      data zspm3 ( 49)/       2.0161160d0/
      data zppm3 ( 49)/       1.4453500d0/
      data alppm3( 49)/       1.4183850d0/
      data eisolp( 49)/     -51.9750470d0/
      data gsspm3( 49)/       6.5549000d0/
      data gsppm3( 49)/       8.2298730d0/
      data gpppm3( 49)/       6.2992690d0/
      data gp2pm3( 49)/       4.9842110d0/
      data hsppm3( 49)/       2.6314610d0/
      data ddpm3 ( 49)/       1.5766241d0/
      data qqpm3 ( 49)/       1.7774563d0/
      data ampm3 ( 49)/       0.2409004d0/
      data adpm3 ( 49)/       0.4532655d0/
      data aqpm3 ( 49)/       0.3689812d0/
      data guesp1( 49,1)/      -0.3431380d0/
      data guesp2( 49,1)/       1.9940340d0/
      data guesp3( 49,1)/       1.6255160d0/
      data guesp1( 49,2)/      -0.1095320d0/
      data guesp2( 49,2)/       5.6832170d0/
      data guesp3( 49,2)/       2.8670090d0/
c                    data for element 50        tin
      data refpm3(50)/ ' sn: (pm3): j. j. p. stewart, j. comp. chem.
     1(accepted)                      '/
      data usspm3( 50)/     -34.5501920d0/
      data upppm3( 50)/     -25.8944190d0/
      data betasp( 50)/      -2.7858020d0/
      data betapp( 50)/      -2.0059990d0/
      data zspm3 ( 50)/       2.3733280d0/
      data zppm3 ( 50)/       1.6382330d0/
      data alppm3( 50)/       1.6996500d0/
      data eisolp( 50)/     -78.8877790d0/
      data gsspm3( 50)/      10.1900330d0/
      data gsppm3( 50)/       7.2353270d0/
      data gpppm3( 50)/       5.6738100d0/
      data gp2pm3( 50)/       5.1822140d0/
      data hsppm3( 50)/       1.0331570d0/
      data ddpm3 ( 50)/       1.3120038d0/
      data qqpm3 ( 50)/       1.5681814d0/
      data ampm3 ( 50)/       0.3744959d0/
      data adpm3 ( 50)/       0.3218163d0/
      data aqpm3 ( 50)/       0.2832529d0/
      data guesp1( 50,1)/      -0.1503530d0/
      data guesp2( 50,1)/       6.0056940d0/
      data guesp3( 50,1)/       1.7046420d0/
      data guesp1( 50,2)/      -0.0444170d0/
      data guesp2( 50,2)/       2.2573810d0/
      data guesp3( 50,2)/       2.4698690d0/
c                    data for element 51        antimony
      data refpm3(51)/ ' sb: (pm3): j. j. p. stewart, j. comp. chem.
     1(accepted)                      '/
      data usspm3( 51)/     -56.4321960d0/
      data upppm3( 51)/     -29.4349540d0/
      data betasp( 51)/     -14.7942170d0/
      data betapp( 51)/      -2.8179480d0/
      data zspm3 ( 51)/       2.3430390d0/
      data zppm3 ( 51)/       1.8999920d0/
      data alppm3( 51)/       2.0343010d0/
      data eisolp( 51)/    -148.9382890d0/
      data gsspm3( 51)/       9.2382770d0/
      data gsppm3( 51)/       5.2776800d0/
      data gpppm3( 51)/       6.3500000d0/
      data gp2pm3( 51)/       6.2500000d0/
      data hsppm3( 51)/       2.4244640d0/
      data ddpm3 ( 51)/       1.4091903d0/
      data qqpm3 ( 51)/       1.3521354d0/
      data ampm3 ( 51)/       0.3395177d0/
      data adpm3 ( 51)/       0.4589010d0/
      data aqpm3 ( 51)/       0.2423472d0/
      data guesp1( 51,1)/       3.0020280d0/
      data guesp2( 51,1)/       6.0053420d0/
      data guesp3( 51,1)/       0.8530600d0/
      data guesp1( 51,2)/      -0.0188920d0/
      data guesp2( 51,2)/       6.0114780d0/
      data guesp3( 51,2)/       2.7933110d0/
c                    data for element 52        tellurium
      data refpm3(52)/ ' te: (pm3): j. j. p. stewart, j. comp. chem.
     1(accepted)                      '/
      data usspm3( 52)/     -44.9380360d0/
      data upppm3( 52)/     -46.3140990d0/
      data betasp( 52)/      -2.6651460d0/
      data betapp( 52)/      -3.8954300d0/
      data zspm3 ( 52)/       4.1654920d0/
      data zppm3 ( 52)/       1.6475550d0/
      data alppm3( 52)/       2.4850190d0/
      data eisolp( 52)/    -168.0945925d0/
      data gsspm3( 52)/      10.2550730d0/
      data gsppm3( 52)/       8.1691450d0/
      data gpppm3( 52)/       7.7775920d0/
      data gp2pm3( 52)/       7.7551210d0/
      data hsppm3( 52)/       3.7724620d0/
      data ddpm3 ( 52)/       0.3484177d0/
      data qqpm3 ( 52)/       1.5593085d0/
      data ampm3 ( 52)/       0.3768862d0/
      data adpm3 ( 52)/       1.1960743d0/
      data aqpm3 ( 52)/       0.2184786d0/
      data guesp1( 52,1)/       0.0333910d0/
      data guesp2( 52,1)/       5.9563790d0/
      data guesp3( 52,1)/       2.2775750d0/
      data guesp1( 52,2)/      -1.9218670d0/
      data guesp2( 52,2)/       4.9732190d0/
      data guesp3( 52,2)/       0.5242430d0/
c                    data for element 53        iodine
      data refpm3 (53)/'  i: (pm3): j. j. p. stewart, j. comp. chem.
     1 10, 209 (1989).                '/
      data usspm3( 53)/     -96.4540370d0/
      data upppm3( 53)/     -61.0915820d0/
      data betasp( 53)/     -14.4942340d0/
      data betapp( 53)/      -5.8947030d0/
      data zspm3 ( 53)/       7.0010130d0/
      data zppm3 ( 53)/       2.4543540d0/
      data zdpm3 ( 53)/       1.0000000d0/
      data alppm3( 53)/       1.9901850d0/
      data eisolp( 53)/    -288.3160860d0/
      data gsspm3( 53)/      13.6319430d0/
      data gsppm3( 53)/      14.9904060d0/
      data gpppm3( 53)/       7.2883300d0/
      data gp2pm3( 53)/       5.9664070d0/
      data hsppm3( 53)/       2.6300350d0/
      data ddpm3 ( 53)/       0.1581469d0/
      data qqpm3 ( 53)/       1.0467302d0/
      data ampm3 ( 53)/       0.5009902d0/
      data adpm3 ( 53)/       1.6699104d0/
      data aqpm3 ( 53)/       0.5153082d0/
      data guesp1( 53,1)/      -0.1314810d0/
      data guesp2( 53,1)/       5.2064170d0/
      data guesp3( 53,1)/       1.7488240d0/
      data guesp1( 53,2)/      -0.0368970d0/
      data guesp2( 53,2)/       6.0101170d0/
      data guesp3( 53,2)/       2.7103730d0/
c                    data for element 80        mercury
      data refpm3(80)/ ' hg: (pm3): j. j. p. stewart, j. comp. chem.
     1(accepted)                      '/
      data usspm3( 80)/     -17.7622290d0/
      data upppm3( 80)/     -18.3307510d0/
      data betasp( 80)/      -3.1013650d0/
      data betapp( 80)/      -3.4640310d0/
      data zspm3 ( 80)/       1.4768850d0/
      data zppm3 ( 80)/       2.4799510d0/
      data alppm3( 80)/       1.5293770d0/
      data eisolp( 80)/     -28.8997380d0/
      data gsspm3( 80)/       6.6247200d0/
      data gsppm3( 80)/      10.6392970d0/
      data gpppm3( 80)/      14.7092830d0/
      data gp2pm3( 80)/      16.0007400d0/
      data hsppm3( 80)/       2.0363110d0/
      data ddpm3 ( 80)/       1.2317811d0/
      data qqpm3 ( 80)/       1.2164033d0/
      data ampm3 ( 80)/       0.2434664d0/
      data adpm3 ( 80)/       0.4515472d0/
      data aqpm3 ( 80)/       0.2618394d0/
      data guesp1( 80,1)/       1.0827200d0/
      data guesp2( 80,1)/       6.4965980d0/
      data guesp3( 80,1)/       1.1951460d0/
      data guesp1( 80,2)/      -0.0965530d0/
      data guesp2( 80,2)/       3.9262810d0/
      data guesp3( 80,2)/       2.6271600d0/
c                    data for element 81        thallium
      data refpm3(81)/ ' tl: (pm3): j. j. p. stewart, j. comp. chem.
     1(accepted)                      '/
      data usspm3( 81)/     -30.0531700d0/
      data upppm3( 81)/     -26.9206370d0/
      data betasp( 81)/      -1.0844950d0/
      data betapp( 81)/      -7.9467990d0/
      data zspm3 ( 81)/       6.8679210d0/
      data zppm3 ( 81)/       1.9694450d0/
      data alppm3( 81)/       1.3409510d0/
      data eisolp( 81)/     -56.6492050d0/
      data gsspm3( 81)/      10.4604120d0/
      data gsppm3( 81)/      11.2238830d0/
      data gpppm3( 81)/       4.9927850d0/
      data gp2pm3( 81)/       8.9627270d0/
      data hsppm3( 81)/       2.5304060d0/
      data ddpm3 ( 81)/       0.0781362d0/
      data qqpm3 ( 81)/       1.5317110d0/
      data ampm3 ( 81)/       0.3844326d0/
      data adpm3 ( 81)/       2.5741815d0/
      data aqpm3 ( 81)/       0.2213264d0/
      data guesp1( 81,1)/      -1.3613990d0/
      data guesp2( 81,1)/       3.5572260d0/
      data guesp3( 81,1)/       1.0928020d0/
      data guesp1( 81,2)/      -0.0454010d0/
      data guesp2( 81,2)/       2.3069950d0/
      data guesp3( 81,2)/       2.9650290d0/
c                    data for element 82        lead
      data refpm3(82)/ ' pb: (pm3): j. j. p. stewart, j. comp. chem.
     1(accepted)                      '/
      data usspm3( 82)/     -30.3227560d0/
      data upppm3( 82)/     -24.4258340d0/
      data betasp( 82)/      -6.1260240d0/
      data betapp( 82)/      -1.3954300d0/
      data zspm3 ( 82)/       3.1412890d0/
      data zppm3 ( 82)/       1.8924180d0/
      data alppm3( 82)/       1.6200450d0/
      data eisolp( 82)/     -73.4660775d0/
      data gsspm3( 82)/       7.0119920d0/
      data gsppm3( 82)/       6.7937820d0/
      data gpppm3( 82)/       5.1837800d0/
      data gp2pm3( 82)/       5.0456510d0/
      data hsppm3( 82)/       1.5663020d0/
      data ddpm3 ( 82)/       0.9866290d0/
      data qqpm3 ( 82)/       1.5940562d0/
      data ampm3 ( 82)/       0.2576991d0/
      data adpm3 ( 82)/       0.4527678d0/
      data aqpm3 ( 82)/       0.2150175d0/
      data guesp1( 82,1)/      -0.1225760d0/
      data guesp2( 82,1)/       6.0030620d0/
      data guesp3( 82,1)/       1.9015970d0/
      data guesp1( 82,2)/      -0.0566480d0/
      data guesp2( 82,2)/       4.7437050d0/
      data guesp3( 82,2)/       2.8618790d0/
c                    data for element 83        bismuth
      data refpm3(83)/ ' bi: (pm3): j. j. p. stewart, j. comp. chem.
     1(accepted)                      '/
      data usspm3( 83)/     -33.4959380d0/
      data upppm3( 83)/     -35.5210260d0/
      data betasp( 83)/      -5.6072830d0/
      data betapp( 83)/      -5.8001520d0/
      data zspm3 ( 83)/       4.9164510d0/
      data zppm3 ( 83)/       1.9349350d0/
      data alppm3( 83)/       1.8574310d0/
      data eisolp( 83)/    -109.2774910d0/
      data gsspm3( 83)/       4.9894800d0/
      data gsppm3( 83)/       6.1033080d0/
      data gpppm3( 83)/       8.6960070d0/
      data gp2pm3( 83)/       8.3354470d0/
      data hsppm3( 83)/       0.5991220d0/
      data ddpm3 ( 83)/       0.2798609d0/
      data qqpm3 ( 83)/       1.5590294d0/
      data ampm3 ( 83)/       0.1833693d0/
      data adpm3 ( 83)/       0.6776013d0/
      data aqpm3 ( 83)/       0.2586520d0/
      data guesp1( 83,1)/       2.5816930d0/
      data guesp2( 83,1)/       5.0940220d0/
      data guesp3( 83,1)/       0.4997870d0/
      data guesp1( 83,2)/       0.0603200d0/
      data guesp2( 83,2)/       6.0015380d0/
      data guesp3( 83,2)/       2.4279700d0/
c                    data for element  103      capped bond
      data refpm3(102)/' cb: (pm3):  capped bond  (hydrogen-like, takes
     1on a  zero charge.)             '/
      data usspm3(102)/     -11.9062760d0/
      data betasp(102)/-9999999.0000000d0/
      data zspm3 (102)/       4.0000000d0/
      data zppm3 (102)/       0.3000000d0/
      data zdpm3 (102)/       0.3000000d0/
      data alppm3(102)/       2.5441341d0/
      data eisolp(102)/       4.0000000d0/
      data gsspm3(102)/      12.8480000d0/
      data hsppm3(102)/       0.1000000d0/
      data ddpm3 (102)/       0.0684105d0/
      data qqpm3 (102)/       1.0540926d0/
      data ampm3 (102)/       0.4721793d0/
      data adpm3 (102)/       0.9262742d0/
      data aqpm3 (102)/       0.2909059d0/
      end
      function aababc(iocca1, ioccb1, iocca2, nmos)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      dimension iocca1(nmos), ioccb1(nmos), iocca2(nmos)
***********************************************************************
*
* aababc evaluates the c.i. matrix element for two microstates differing
*       by beta electron. that is, one microstate has a beta electron
*       in psi(i) which, in the other microstate is in psi(j)
*
***********************************************************************
      common /xyijkl/ xy(nmeci,nmeci,nmeci,nmeci)
      common /baseoc/ occa(nmeci)
      do 10 i=1,nmos
   10 if(iocca1(i).ne.iocca2(i)) goto 20
   20 ij=ioccb1(i)
      do 30 j=i+1,nmos
         if(iocca1(j).ne.iocca2(j)) goto 40
   30 ij=ij+iocca1(j)+ioccb1(j)
   40 sum=0.d0
      do 50 k=1,nmos
   50 sum=sum+ (xy(i,j,k,k)-xy(i,k,j,k))*(iocca1(k)-occa(k)) +
     1          xy(i,j,k,k)             *(ioccb1(k)-occa(k))
      if(mod(ij,2).eq.1)sum=-sum
      aababc=sum
      return
      end
      function aabacd(iocca1, ioccb1, iocca2, ioccb2, nmos)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      dimension iocca1(nmos), ioccb1(nmos), iocca2(nmos), ioccb2(nmos)
***********************************************************************
*
* aabacd evaluates the c.i. matrix element for two microstates differing
*       by two alpha mos. one microstate has alpha electrons in
*       m.o.s psi(i) and psi(j) for which the other microstate has
*       electrons in psi(k) and psi(l)
*
***********************************************************************
      common /xyijkl/ xy(nmeci,nmeci,nmeci,nmeci)
      ij=0
      do 10 i=1,nmos
   10 if(iocca1(i) .lt. iocca2(i)) goto 20
   20 do 30 j=i+1,nmos
         if(iocca1(j) .lt. iocca2(j)) goto 40
   30 ij=ij+iocca2(j)+ioccb2(j)
   40 do 50 k=1,nmos
   50 if(iocca1(k) .gt. iocca2(k)) goto 60
   60 do 70 l=k+1,nmos
         if(iocca1(l) .gt. iocca2(l)) goto 80
   70 ij=ij+iocca1(l)+ioccb1(l)
   80 ij=ij+ioccb2(i)+ioccb1(k)
      sum=(xy(i,k,j,l)-xy(i,l,k,j))
      if(mod(ij,2).eq.1)sum=-sum
      aabacd=sum
      return
      end
      function aabbcd(iocca1, ioccb1, iocca2, ioccb2, nmos)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      dimension iocca1(nmos), ioccb1(nmos), iocca2(nmos), ioccb2(nmos)
***********************************************************************
*
* aabbcd evaluates the c.i. matrix element for two microstates differing
*       by two sets of m.o.s. one microstate has an alpha electron
*       in psi(i) and a beta electron in psi(k) for which the other
*       microstate has an alpha electron in psi(j) and a beta electron
*       in psi(l)
*
***********************************************************************
      common /xyijkl/ xy(nmeci,nmeci,nmeci,nmeci)
      common /spqr/ ispqr(nmeci*nmeci,nmeci),is,iloop, jloop
      do 10 i=1,nmos
   10 if(iocca1(i) .ne. iocca2(i)) goto 20
   20 do 30 j=i+1,nmos
   30 if(iocca1(j) .ne. iocca2(j)) goto 40
   40 do 50 k=1,nmos
   50 if(ioccb1(k) .ne. ioccb2(k)) goto 60
   60 do 70 l=k+1,nmos
   70 if(ioccb1(l) .ne. ioccb2(l)) goto 80
   80 if( i.eq.k .and. j.eq.l .and. iocca1(i).ne.ioccb1(i)) then
         ispqr(iloop,is)=jloop
         is=is+1
      endif
      if(iocca1(i) .lt. iocca2(i)) then
         m=i
         i=j
         j=m
      endif
      if(ioccb1(k) .lt. ioccb2(k)) then
         m=k
         k=l
         l=m
      endif
      xr=xy(i,j,k,l)
c#      write(6,'(4i5,f12.6)')i,j,k,l,xr
c
c   now untangle the microstates
c
      ij=1
      if( i.gt.k .and. j.gt.l .or. i.le.k .and. j.le.l)ij=0
      if( i.gt.k ) ij=ij+iocca1(k)+ioccb1(i)
      if( j.gt.l ) ij=ij+iocca2(l)+ioccb2(j)
      if(i.gt.k)then
         m=i
         i=k
         k=m
      endif
      do 90 m=i,k
   90 ij=ij+ioccb1(m)+iocca1(m)
      if(j.gt.l)then
         m=j
         j=l
         l=m
      endif
      do 100 m=j,l
  100 ij=ij+ioccb2(m)+iocca2(m)
c
c   ij in the permutation number, .equiv. -1 if ij is odd.
c
      if(mod(ij,2).eq.1)xr=-xr
      aabbcd=xr
      return
      end
      subroutine aintgs (x,k)
      implicit REAL (a-h,o-z)
      common /cmops/ a(7),b(7),sdum(3),idum(2)
c***********************************************************************
c
c    aintgs forms the "a" integrals for the overlap calculation.
c
c***********************************************************************
      c=dexp(-x)
      a(1)=c/x
      do 10 i=1,k
         a(i+1)=(a(i)*i+c)/x
   10 continue
      return
c
      end
      subroutine analyt(psum,palpha,pbeta,coord,nat,jja,jjd,
     1iia,iid,eng)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      dimension coord(3,*),eng(3), psum(*), palpha(*), pbeta(*),nat(*)
************************************************************************
*                                                                      *
*         calculation of analytical derivatives                        *
*                                                                      *
************************************************************************
c
c common blocks 'owned' by rest of program.
c
      common /corec/ core(107)
      common /betas/ betas(107),betap(107),betad(107)
      common /expont/ zs(107),zp(107),zd(107)
      common /alpha/ alpa(107)
      common /twoel3/ f03(107)
      common /cmporb/ natorb(107)
      common /alpha3/ alp3(153)
      common /ideas/ fn1(107,10),fn2(107,10),fn3(107,10)
      common /wmatrc/ w(n2elec*2)
      common /natype/ nztype(107),mtype(30),ltype
      common /beta3/ beta3(153)
      common /vsips/ vs(107),vp(107),vd(107)
      common /keywrd/ keywrd
c
c common blocks 'owned' by ant
c
      common /derivs/ ds(16),dg(22),dr(100),tdx(3),tdy(3),tdz(3)
      common /cmpex/  g(22), txyz(9)
c
c on return, eng holds analytical derivatives
c
      common /force3/ idmy(5),i3n,ix
      common /numcal/ numcal
      dimension eaa(3),eab(3),enuc(3), bi(4), bj(4)
      character*241 keywrd
      save am1, mindo3
      logical am1, mindo3
      save icalcn
      data icalcn/0/
      if (icalcn.ne.numcal) then
         icalcn=numcal
         am1=(index(keywrd,'am1')+index(keywrd,'pm3').ne.0)
         mindo3=(index(keywrd,'mindo').ne.0)
      endif
      a0=0.529167d0
      jd=jjd-jja+1
      ja=1
      id=iid-iia+1+jd
      ia=jd+1
      do 10 j=1,3
         eaa(j)=0.0d0
         eab(j)=0.0d0
         enuc(j)=0.0d0
         eng(j)=0.0d0
   10 continue
      i=2
      ni=nat(i)
      istart=nztype(ni)*4-3
      j=1
      nj=nat(j)
      jstart=nztype(nj)*4-3
      r2=(coord(1,i)-coord(1,j))**2+(coord(2,i)-coord(2,j))**2
     1   + (coord(3,i)-coord(3,j))**2
      rij=dsqrt(r2)
      r0=rij/a0
      rr=r2/(a0*a0)
      do 150 ix=1,3
         del1=coord(ix,i)-coord(ix,j)
         termaa=0.0d0
         termab=0.0d0
         isp=0
         iol=0
c   the first derivatives of overlap integrals
         do 30 k=ia,id
            ka=k-ia
            kg=istart+ka
            do 30 l=ja,jd
               la=l-ja
               lg=jstart+la
               iol=iol+1
               ds(iol)=0.0d0
               if(ka.eq.0.and.la.eq.0) then
c   (s/s) term
                  if(dabs(del1).le.1.0d-6) go to 30
                  is=1
               elseif(ka.eq.0.and.la.gt.0) then
c   (s/p) term
                  is=3
                  if(ix.eq.la) go to 20
                  if(dabs(del1).le.1.0d-6) go to 30
                  is=2
                  del2=coord(la,i)-coord(la,j)
               elseif(ka.gt.0.and.la.eq.0) then
c   (p/s) term
                  is=5
                  if(ix.eq.ka) go to 20
                  if(dabs(del1).le.1.0d-6) go to 30
                  is=4
                  del2=coord(ka,i)-coord(ka,j)
               else
c   (p/p) term
                  if(ka.eq.la) then
c    p/p
                     is=9
                     if(ix.eq.ka) go to 20
                     if(dabs(del1).le.1.0d-6) go to 30
c    p'/p'
                     is=8
                     del2=coord(ka,i)-coord(ka,j)
                  elseif(ix.ne.ka.and.ix.ne.la) then
c    p'/p"
                     if(dabs(del1).le.1.0d-6) go to 30
                     is=7
                     del2=coord(ka,i)-coord(ka,j)
                     del3=coord(la,i)-coord(la,j)
                  else
c    p/p' or p'/p
                     del2=coord(ka+la-ix,i)-coord(ka+la-ix,j)
                     is=6
                  endif
               endif
c
c        calculate overlap derivatives, store results in ds
c
   20          call ders(kg,lg,rr,del1,del2,del3,is,iol)
   30    continue
         if(.not.mindo3.and.ix.eq.1) read (2) (g(i22),i22=1,22)
         if(.not.mindo3) call delri(dg,ni,nj,r0,del1)
         call delmol(coord,i,j,ni,nj,ia,id,ja,jd,ix,rij,del1,isp)
c
c   the first derivative of nuclear repulsion term
         if(mindo3)then
            ii=max0(ni,nj)
            nbond=(ii*(ii-1))/2+ni+nj-ii
            alpha=0
            if(nbond.lt.154)then
               alpha=alp3(nbond)
            else
               alph1=100
               alph2=100
               if(natorb(ni).eq.0)alph1=alpa(ni)
               if(natorb(nj).eq.0)alph2=alpa(nj)
            endif
            c2=(7.1995d0/f03(ni)+7.1995d0/f03(nj))**2
            c1=del1/rij*core(ni)*core(nj)*14.399d0
            c3=del1/rij*dabs(core(ni)*core(nj))*14.399d0
            if(nbond.eq.22.or.nbond.eq.29)then
               termnc=-c1*alpha*(1.d0/rij**2 - rij*(rij**2+c2)**(-1.5d0)
     1 +  1.d0/rij - 1.d0/dsqrt(rij**2+c2)) * dexp(-rij) -
     2c1*rij*(rij**2+c2)**(-1.5d0)
            elseif (rij.lt.1.d0.and.natorb(ni)*natorb(nj).eq.0) then
               termnc=0.d0
            elseif(nbond.ge.154) then
c
c  special case involving sparkles
c
               exp1=dexp(-dmin1(alph1*rij,20.d0))
               exp2=dexp(-dmin1(alph2*rij,20.d0))
               part1=-c3*(1.d0/rij**2 - rij*(rij**2+c2)**(-1.5d0))
     1*(exp1+exp2)
               part2=-c3*(1.d0/rij -1.d0/dsqrt(rij**2+c2))
     1*(alph1*exp1 + alph2*exp2)
               part3=-c1*rij*(rij**2+c2)**(-1.5d0)
               termnc=part1+part2+part3
c#            write(6,'(4f13.6)')part1,part2,part3,termnc
            else
               termnc=-c1*(1.d0/rij**2 - rij*(rij**2+c2)**(-1.5d0) +
     1alpha/rij - alpha/dsqrt(rij**2+c2)) * dexp(-alpha*rij) -
     2c1*rij*(rij**2+c2)**(-1.5d0)
            endif
            dr1=del1/rij*14.399d0*rij*(rij**2+c2)**(-1.5d0)
         else
c
c      core-core terms, mndo and am1
c
c
c  special treatment for n-h and o-h terms
c
            if(rij.lt.1.d0.and.natorb(ni)*natorb(nj).eq.0)then
               termnc=0.d0
               goto 50
            endif
            c1=core(ni)*core(nj)
            if(ni.eq.1.and.(nj.eq.7.or.nj.eq.8)) then
               f3=1.0d0+dexp(-alpa(1)*rij)+rij*dexp(-alpa(nj)*rij)
               dd=(dg(1)*f3-g(1)*(del1/rij)*(alpa(1)*dexp(-alpa(1)*rij)
     1 +(alpa(nj)*rij-1.0d0)*dexp(-alpa(nj)*rij)))*c1
            elseif((ni.eq.7.or.ni.eq.8).and.nj.eq.1) then
               f3=1.0d0+dexp(-alpa(1)*rij)+rij*dexp(-alpa(ni)*rij)
               dd=(dg(1)*f3-g(1)*(del1/rij)*(alpa(1)*dexp(-alpa(1)*rij)
     1 +(alpa(ni)*rij-1.0d0)*dexp(-alpa(ni)*rij)))*c1
            else
c#            elseif(natorb(ni)+natorb(nj).eq.0) then
c
c  special case of two sparkles
c
               part1=dg(1)*c1
               part2=-(g(1)*(del1/rij)*(alpa(ni)*dexp(-alpa(ni)*ri
     1j) +alpa(nj)*dexp(-alpa(nj)*rij)))*dabs(c1)
               part3=dg(1)*(dexp(-alpa(ni)*rij)+dexp(-alpa(nj)*rij))*
     + dabs(c1)
               dd=part1+part2+part3
c#            write(6,'(4f13.6)')part1,part2,part3,dd
c#            else
c
c   the general case
c
c#               f3=1.0d0+exp(-alpa(ni)*rij)+exp(-alpa(nj)*rij)
c#               dd=(dg(1)*f3-g(1)*(del1/rij)*(alpa(ni)*exp(-alpa(ni)*ri
c#     1j) +alpa(nj)*exp(-alpa(nj)*rij)))*c1
            endif
            termnc=dd
         endif
c
c   ****   start of the am1 specific derivative code   ***
c
c      analyt=-a*(1/(r*r)+2.d0*b*(r-c)/r)*exp(-b*(r-c)**2)
c
c    analytical derivatives
c
         if( am1 )then
            anam1=0.0d0
            do 40 ig=1,10
               if(dabs(fn1(ni,ig)).gt.0.d0)
     1anam1=anam1+fn1(ni,ig)*
     2(1.d0/(rij*rij)+2.d0*fn2(ni,ig)*(rij-fn3(ni,ig))/rij)*
     3dexp(dmax1(-30.d0,-fn2(ni,ig)*(rij-fn3(ni,ig))**2))
               if(dabs(fn1(nj,ig)).gt.0.d0)
     1anam1=anam1+fn1(nj,ig)*
     2(1.d0/(rij*rij)+2.d0*fn2(nj,ig)*(rij-fn3(nj,ig))/rij)*
     3dexp(dmax1(-30.d0,-fn2(nj,ig)*(rij-fn3(nj,ig))**2))
   40       continue
            anam1=anam1*core(ni)*core(nj)
            termnc=termnc-anam1*del1/rij
         endif
c
c   ****   end of the am1 specific derivative code   ***
c
   50    continue
c
c   combine together the overlap derivative parts
c
         if(mindo3)then
            ii=max0(ni,nj)
            nbond=(ii*(ii-1))/2+ni+nj-ii
            if(nbond.gt.153)goto 60
            bi(1)=beta3(nbond)*vs(ni)*2.d0
            bi(2)=beta3(nbond)*vp(ni)*2.d0
            bi(3)=bi(2)
            bi(4)=bi(2)
            bj(1)=beta3(nbond)*vs(nj)*2.d0
            bj(2)=beta3(nbond)*vp(nj)*2.d0
            bj(3)=bj(2)
            bj(4)=bj(2)
   60       continue
         else
            bi(1)=betas(ni)
            bi(2)=betap(ni)
            bi(3)=bi(2)
            bi(4)=bi(2)
            bj(1)=betas(nj)
            bj(2)=betap(nj)
            bj(3)=bj(2)
            bj(4)=bj(2)
         endif
c
c       code common to mindo/3, mndo, and am1
c
         iol=0
         do 70 k=ia,id
            do 70 l=ja,jd
               lk=l+k*(k-1)/2
               termk=bi(k-ia+1)
               terml=bj(l-ja+1)
               iol=iol+1
               termab=termab+(termk+terml)
     1*psum(lk)*ds(iol)
   70    continue
         if(mindo3)then
c
c        first, core-electron attraction derivatives (mindo/3)
c
c          atom core i affecting a.o.s on j
            do 80 m=ja,jd
               mn=(m*(m+1))/2
   80       termab=termab+core(ni)*psum(mn)*dr1
c          atom core j affecting a.o.s on i
            do 90 m=ia,id
               mn=(m*(m+1))/2
   90       termab=termab+core(nj)*psum(mn)*dr1
c
c   now for coulomb and exchange terms (mindo/3)
c
            do 100 i1=ia,id
               ii=(i1*(i1+1))/2
               do 100 j1=ja,jd
                  jj=(j1*(j1+1))/2
                  ij=j1+(i1*(i1-1))/2
c
c           coulomb term
c
                  termaa=termaa-psum(ii)*dr1*psum(jj)
c
c           exchange term
c
                  termaa=termaa+(palpha(ij)*palpha(ij)+pbeta(ij)*pbeta(i
     1j))*dr1
  100       continue
         else
c
c        first, core-electron attraction derivatives (mndo and am1)
c
c          atom core i affecting a.o.s on j
            isp=0
            do 110 m=ja,jd
               bb=1.d0
               do 110 n=m,jd
                  mn=m+n*(n-1)/2
                  isp=isp+1
                  termab=termab-bb*core(ni)*psum(mn)*dr(isp)
  110       bb=2.d0
c          atom core j affecting a.o.s on i
            k=max0(jd-ja+1,1)
            k=(k*(k+1))/2
            isp=-k+1
            do 120 m=ia,id
               bb=1.d0
               do 120 n=m,id
                  mn=m+n*(n-1)/2
                  isp=isp+k
                  termab=termab-bb*core(nj)*psum(mn)*dr(isp)
  120       bb=2.d0
            isp=0
c
c   now for coulomb and exchange terms (mndo and am1)
c
            do 140 k=ia,id
               aa=1.d0
               kk=(k*(k-1))/2
               do 140 l=k,id
                  ll=(l*(l-1))/2
                  do 130 m=ja,jd
                     bb=1.d0
                     do 130 n=m,jd
                        isp=isp+1
                        kl=k+ll
                        mn=m+n*(n-1)/2
c
c    coulomb term
c
                        termaa=termaa+aa*bb*psum(kl)*psum(mn)*dr(isp)
                        mk=m+kk
                        nk=n+kk
                        ml=m+ll
                        nl=n+ll
c
c    exchange term
c
                        termaa= termaa-0.5d0*aa*bb*(palpha(m
     1k)*palpha(nl)+palpha(nk)*palpha(ml)+pbeta(mk)*pbeta(nl)+pbeta(nk)*
     2pbeta(ml))*dr(isp)
  130             bb=2.d0
  140       aa=2.d0
c           end of mndo and am1 specific code
         endif
         eaa(ix)=eaa(ix)+termaa
         eab(ix)=eab(ix)+termab
         enuc(ix)=enuc(ix)+termnc
  150 continue
c#            write(6,*)eaa,eab,enuc,nat(1),nat(2)
      do 180 j=1,3
         eng(j)=eaa(j)+eab(j)+enuc(j)
         eng(j) = -eng(j)*23.061d0
  180 continue
      return
      end
      subroutine anavib(coord,eigs,dipt,n3,vibs,rij,hess,travel,redmas)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      dimension coord(3,numatm),eigs(n3),vibs(n3,n3), dipt(n3),
     1rij(maxhes), travel(n3), hess(*), redmas(*)
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),
     1                nlast(numatm), norbs, nelecs,nalpha,nbeta,
     2                nclose,nopen,ndumy,fract
      common /elemts/ elemnt(107)
      common/iofile/mfgr,mfgw
      logical vib1, vib2, vib3, vib4, vib5
      common /fokmat/ f(mpack*2)
      character*2 elemnt
      dimension vanrad(107), ijf(10), fij(10)
      save vanrad, fact
      data vanrad/
     1   0.32,0.93,
     2   1.23, 0.90, 0.82, 0.77, 0.75, 0.73, 0.72, 0.71,
     3   1.54, 1.36, 1.18, 1.11, 1.06, 1.02, 0.99, 0.98,
     4   2.03, 1.74, 1.44, 1.32, 1.22, 1.18, 1.17, 1.17, 1.16,
     5   1.15, 1.17, 1.25, 1.26, 1.22, 1.20, 1.16, 1.14, 1.12,
     6   2.16, 1.91, 1.62, 1.45, 1.34, 1.30, 1.27, 1.25, 1.25,
     7   1.28, 1.34, 1.48, 1.44, 1.41, 1.40, 1.36, 1.33, 1.31,
     8   2.35, 1.98, 1.69,
     9   1.65, 1.65, 1.64, 1.63, 1.62, 1.85, 1.61, 1.59, 1.59, 1.58,
     1   1.57, 1.56, 1.56, 1.56,
     2   1.44, 1.34, 1.30, 1.28, 1.26, 1.27, 1.30, 1.34,
     3   1.49, 1.48, 1.47, 1.46, 1.46, 1.45,1.45,21*1.45/
      data fact/6.023d23/
      c2pi=1.d0/(2.998d10*3.141592653598d0*2.d0)
      n3=numat*3
c
c    compute interatomic distances.
c
      l=0
      do 10 i=1,numat
         do 10 j=1,i-1
            l=l+1
   10 rij(l)=dsqrt((coord(1,j)-coord(1,i))**2+
     1            (coord(2,j)-coord(2,i))**2+
     2            (coord(3,j)-coord(3,i))**2)+1.d-10
c
c     analyse vibrations
c
      write(mfgw,'(''1'',//10x,''description of vibrations'',/)')
      iline=0
      do 120 k=1,n3
         if(dabs(eigs(k)).lt.50.0d0) goto 120
         vib1=.true.
         vib2=.true.
         vib3=.true.
         vib4=.true.
         vib5=.true.
         j3=0
         l=0
         tot=0.d0
         linear=0
         j1=-2
         do 70 j=1,numat
            j1=j1+3
            i1=-2
            do 70 i=1,j-1
               i1=i1+3
               vdw=(vanrad(nat(i))+vanrad(nat(j)))*1.5d0
               l=l+1
               f(l)=0.d0
               if(   rij(l)  .lt.  vdw) then
c
c calculate energy term between the two atoms
c
                  eab=0.d0
                  do 20 jj=j1,j1+2
                     do 20 ii=i1,i1+2
   20             eab=eab+vibs(jj,k)*hess((jj*(jj-1))/2+ii)*vibs(ii,k)
                  eb=0.d0
                  do 40 jj=j1,j1+2
                     do 30 ii=j1,jj
   30                eb=eb+vibs(jj,k)*hess((jj*(jj-1))/2+ii)*vibs(ii,k)*
     12.d0
   40             eb=eb-vibs(jj,k)*hess((jj*(jj+1))/2)*vibs(jj,k)
                  ea=0.d0
                  do 60 jj=i1,i1+2
                     do 50 ii=i1,jj
   50                ea=ea+vibs(jj,k)*hess((jj*(jj-1))/2+ii)*vibs(ii,k)*
     12.d0
   60             ea=ea-vibs(jj,k)*hess((jj*(jj+1))/2)*vibs(jj,k)
                  linear=linear+1
                  f(l)=ea+eab*2.d0+eb
                  tot=tot+f(l)
               endif
   70    continue
c
c  now to sort f into decending order
c
         do 90 i=1,10
            sum=-100.d0
            do 80 j=1,l
               if(dabs(f(j)).gt.sum)then
                  jj=j
                  sum=dabs(f(j))
               endif
   80       continue
            if(sum.lt.0.d0)goto 100
            fij(i)=sum
            f(jj)=-1.d-5
            ijf(i)=jj
c#      write(mfgw,*)fij(i),ijf(i)
   90    continue
         i=10
  100    linear=i
         sum=1.d0/(tot+1.d-8)
         do 110 ij=1,linear
            j=0.5d0*(0.99d0+dsqrt(1.d0+8.d0*ijf(ij)))
            i=ijf(ij)-(j*(j-1))/2
            j=j+1
            xj=coord(1,j)
            yj=coord(2,j)
            zj=coord(3,j)
            j1=3*j-2
            j2=j1+1
            j3=j2+1
            i3=0
            xi=coord(1,i)
            yi=coord(2,i)
            zi=coord(3,i)
            i1=3*i-2
            i2=i1+1
            i3=i2+1
            x= vibs(j1,k)-vibs(i1,k)
            y= vibs(j2,k)-vibs(i2,k)
            z= vibs(j3,k)-vibs(i3,k)
            e=fij(ij)*sum*100.d0
c#            if(dabs(e).gt.110)goto 120
            shift=x*x+y*y+z*z+1.d-30
            if(dabs(e).gt.10.0d0.or.ij.lt.5.and.
     +         dabs(e).gt.0.1d0) then
               shift=dsqrt(shift)
               radial=((x*(xi-xj)+y*(yi-yj)+z*(zi-zj))
     1                  /(shift*rij(ijf(ij))))**2*100.d0
               if (vib1) then
               write(mfgw,'(/,'' vibration'',i4,''            atom pair
     1 '',''    energy contribution              radial'')')k
                  ans=100.d0*dsqrt(fij(ij)*1.d5*6.023d23)/
     +                (2.998d10*3.14159d0*2.d0)/eigs(k)
                  ans=dmin1(999.9d0,dmax1(-99.9d0,ans))
               write(mfgw,'('' freq.   '',f9.2,6x,1a2,i2,
     1'' -- '',a2,i2, ''         '',f6.1,''% ('',f5.1,''%)'',f18.1
     2,''%'')')
     3eigs(k),elemnt(nat(i)),i,elemnt(nat(j)),j,e,ans,radial
c#      write(mfgw,*)ans
                  vib1=.false.
               elseif (vib2) then
                  vib2=.false.
                  write(mfgw,'('' t-dipmom'',f9.4,6x,1a2,i2,
     1'' -- '',a2,i2, ''         '',f6.1,''%'',f27.1,''%'')')
     2dipt(k),elemnt(nat(i)),i,elemnt(nat(j)),j,e,radial
               elseif (vib3) then
                  vib3=.false.
                  write(mfgw,'('' travel  '',f9.4,6x,1a2,i2,
     1'' -- '',a2,i2, ''         '',f6.1,''%'',f27.1,''%'')')
     2travel(k),elemnt(nat(i)),i,elemnt(nat(j)),j,e,radial
               elseif (vib4) then
                  vib4=.false.
                  write(mfgw,'('' red. mass'',f8.4,6x,1a2,i2,
     1'' -- '',a2,i2, ''         '',f6.1,''%'',f27.1,''%'')')
     2redmas(k),elemnt(nat(i)),i,elemnt(nat(j)),j,e,radial
               else
                  iline=iline+1
               write(mfgw,'(''                        '',1a2,i2,
     1'' -- '',a2,i2, ''         '',f6.1,''%'',f27.1,''%'')')
     2elemnt(nat(i)),i,elemnt(nat(j)),j,e,radial
               endif
            endif
  110    continue
         iline=iline+6
         if(vib1)write(mfgw,'(/,'' vibration'',i4)')k
         if(vib1)write(mfgw,'(  '' freq.    '',f8.2)')eigs(k)
         if(vib2)write(mfgw,'(  '' t-dipmom '',f8.4)')dipt(k)
         if(vib3)write(mfgw,'(  '' travel   '',f8.4)')travel(k)
         if(vib4)write(mfgw,'(  '' red. mass'',f8.4)')redmas(k)
         if(iline.gt.52)then
            iline=0
            write(mfgw,'(''1'')')
         endif
  120 continue
      return
      end
      subroutine axis(coord,numat,a,b,c,sumw, mass,evec)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      dimension coord(3,numat)
      common /keywrd/ keywrd
************************************************************************
*
*  axis calculates the three moments of inertia and the molecular
*       weight.  the moments of inertia are returned in a, b, and c.
*       the molecular weight in sumw.
*       the units of inertia are 10**(-40)gram-cm**2,
*       and mol.weight in atomic-mass-units. (amu's)
************************************************************************
      common /numcal/ numcal
      common /atmass/ atmass(numatm)
      common/iofile/mfgr,mfgw
      dimension t(6), x(numatm), y(numatm),
     1          z(numatm), rot(3), xyzmom(3), eig(3), evec(3,3)
      logical first
      character*241 keywrd
      save icalcn, t, first, eig, rot, xyzmom
      data t /6*0.d0/
      data icalcn /0/
      if (icalcn.ne.numcal) then
         icalcn=numcal
         first=.true.
      endif
************************************************************************
*     const1 =  10**40/(n*a*a)
*               n = avergadro's number
*               a = cm in an angstrom
*               10**40 is to allow units to be 10**(-40)gram-cm**2
*
************************************************************************
      const1 = 1.66053d0
************************************************************************
*
*     const2 = conversion factor from angstrom-amu to cm**(-1)
*
*            = (planck's constant*n*10**16)/(8*pi*pi*c)
*            = 6.62618*10**(-27)[erg-sec]*6.02205*10**23*10**16/
*              (8*(3.1415926535)**2*2.997925*10**10[cm/sec])
*
************************************************************************
      const2=16.8576522d0
c    first we centre the molecule about the centre of gravity,
c    this depends on the isotopic masses, and the cartesian geometry.
c
      sumw=1.d-20
      sumwx=0.d0
      sumwy=0.d0
      sumwz=0.d0
c
      if(mass.gt.0) then
         do 10 i=1,numat
            sumw=sumw+atmass(i)
            sumwx=sumwx+atmass(i)*coord(1,i)
            sumwy=sumwy+atmass(i)*coord(2,i)
            sumwz=sumwz+atmass(i)*coord(3,i)
   10    continue
      else
         sumw=sumw+dfloat(numat)
         do 20 i=1,numat
            sumwx=sumwx+coord(1,i)
            sumwy=sumwy+coord(2,i)
            sumwz=sumwz+coord(3,i)
   20    continue
      endif
c
      if(mass.gt.0.and.first)
     1 write(mfgw,'(/10x,''molecular weight ='',f8.2,/)')
     2dmin1(99999.99d0,sumw)
      sumwx=sumwx/sumw
      sumwy=sumwy/sumw
      sumwz=sumwz/sumw
      do 30 i=1,numat
         x(i)=coord(1,i)-sumwx
         y(i)=coord(2,i)-sumwy
   30 z(i)=coord(3,i)-sumwz
************************************************************************
*
*    matrix for moments of inertia is of form
*
*           |   y**2+z**2                         |
*           |    -y*x       z**2+x**2             | -i =0
*           |    -z*x        -z*y       x**2+y**2 |
*
************************************************************************
c
c$doit asis
      do 40 i=1,6
   40 t(i)=dfloat(i)*1.0d-10
c
      if(mass.gt.0) then
         do 50 i=1,numat
            t(1)=t(1)+atmass(i)*(y(i)**2+z(i)**2)
            t(2)=t(2)-atmass(i)*x(i)*y(i)
            t(3)=t(3)+atmass(i)*(z(i)**2+x(i)**2)
            t(4)=t(4)-atmass(i)*z(i)*x(i)
            t(5)=t(5)-atmass(i)*y(i)*z(i)
            t(6)=t(6)+atmass(i)*(x(i)**2+y(i)**2)
   50    continue
      else
         do 60 i=1,numat
            t(1)=t(1)+(y(i)**2+z(i)**2)
            t(2)=t(2)-x(i)*y(i)
            t(3)=t(3)+(z(i)**2+x(i)**2)
            t(4)=t(4)-z(i)*x(i)
            t(5)=t(5)-y(i)*z(i)
            t(6)=t(6)+(x(i)**2+y(i)**2)
   60    continue
      endif
c
      call rsp(t,3,3,eig,evec)
      if(mass.gt.0.and. first.and.index(keywrd,'rc=').eq.0) then
      write(mfgw,'(//10x,'' principal moments of inertia in cm(-1)'',/)'
     1)
c$doit asis
         do 70 i=1,3
            if(eig(i).lt.3.d-4) then
               eig(i)=0.d0
               rot(i)=0.d0
            else
               rot(i)=const2/eig(i)
            endif
   70    xyzmom(i)=eig(i)*const1
         write(mfgw,'(10x,''a ='',f12.6,''   b ='',f12.6,
     1''   c ='',f12.6,/)')(rot(i),i=1,3)
         if(index(keywrd,'rc=').eq.0)
     1write(mfgw,'(//10x,'' principal moments of inertia in '',
     2''units of 10**(-40)*gram-cm**2'',/)')
         write(mfgw,'(10x,''a ='',f12.6,''   b ='',f12.6,
     1''   c ='',f12.6,/)')(xyzmom(i),i=1,3)
         c=rot(1)
         b=rot(2)
         a=rot(3)
      endif
c
c   now to orient the molecule so the chirality is preserved
c
      sum=evec(1,1)*(evec(2,2)*evec(3,3)-evec(3,2)*evec(2,3)) +
     1    evec(1,2)*(evec(2,3)*evec(3,1)-evec(2,1)*evec(3,3)) +
     2    evec(1,3)*(evec(2,1)*evec(3,2)-evec(2,2)*evec(3,1))
      if( sum .lt. 0) then
c$doit asis
         do 80 j=1,3
   80    evec(j,1)=-evec(j,1)
      endif
      do 90 i=1,numat
         coord(1,i)=x(i)
         coord(2,i)=y(i)
         coord(3,i)=z(i)
   90 continue
      if(mass.gt.0)first=.false.
      end
      function babbbc(iocca1, ioccb1, ioccb2, nmos)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      dimension iocca1(nmos), ioccb1(nmos), ioccb2(nmos)
***********************************************************************
*
* babbbc evaluates the c.i. matrix element for two microstates differing
*       by one beta electron. that is, one microstate has a beta
*       electron in psi(i) and the other microstate has an electron in
*       psi(j).
***********************************************************************
      common /xyijkl/ xy(nmeci,nmeci,nmeci,nmeci)
      common /baseoc/ occa(nmeci)
      do 10 i=1,nmos
   10 if(ioccb1(i).ne.ioccb2(i)) goto 20
   20 ij=0
      do 30 j=i+1,nmos
         if(ioccb1(j).ne.ioccb2(j)) goto 40
   30 ij=ij+iocca1(j)+ioccb1(j)
   40 ij=ij+iocca1(j)
c
c   the unpaired m.o.s are i and j
      sum=0.d0
      do 50 k=1,nmos
   50 sum=sum+ (xy(i,j,k,k)-xy(i,k,j,k))*(ioccb1(k)-occa(k)) +
     1          xy(i,j,k,k)             *(iocca1(k)-occa(k))
      if(mod(ij,2).eq.1)sum=-sum
      babbbc=sum
      return
      end
      function babbcd(iocca1, ioccb1, iocca2, ioccb2, nmos)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      dimension iocca1(nmos), ioccb1(nmos), iocca2(nmos), ioccb2(nmos)
***********************************************************************
*
* babbcd evaluates the c.i. matrix element for two microstates differing
*       by two beta mos. one microstate has beta electrons in
*       m.o.s psi(i) and psi(j) for which the other microstate has
*       electrons in psi(k) and psi(l)
*
***********************************************************************
      common /xyijkl/ xy(nmeci,nmeci,nmeci,nmeci)
      ij=0
      do 10 i=1,nmos
   10 if(ioccb1(i) .lt. ioccb2(i)) goto 20
   20 do 30 j=i+1,nmos
         if(ioccb1(j) .lt. ioccb2(j)) goto 40
   30 ij=ij+iocca2(j)+ioccb2(j)
   40 ij=ij+iocca2(j)
      do 50 k=1,nmos
   50 if(ioccb1(k) .gt. ioccb2(k)) goto 60
   60 do 70 l=k+1,nmos
         if(ioccb1(l) .gt. ioccb2(l)) goto 80
   70 ij=ij+iocca1(l)+ioccb1(l)
   80 ij=ij+iocca1(l)
      if((ij/2)*2.eq.ij) then
         one=1.d0
      else
         one=-1.d0
      endif
      babbcd=(xy(i,k,j,l)-xy(i,l,j,k))*one
      return
      end
      subroutine bangle(xyz,i,j,k,angle)
      implicit REAL (a-h,o-z)
      dimension xyz(3,*)
*********************************************************************
*
* bangle calculates the angle between atoms i,j, and k. the
*        cartesian coordinates are in xyz.
*
*********************************************************************
      d2ij = (xyz(1,i)-xyz(1,j))**2+
     1       (xyz(2,i)-xyz(2,j))**2+
     2       (xyz(3,i)-xyz(3,j))**2
      d2jk = (xyz(1,j)-xyz(1,k))**2+
     1       (xyz(2,j)-xyz(2,k))**2+
     2       (xyz(3,j)-xyz(3,k))**2
      d2ik = (xyz(1,i)-xyz(1,k))**2+
     1       (xyz(2,i)-xyz(2,k))**2+
     2       (xyz(3,i)-xyz(3,k))**2
      xy = dsqrt(d2ij*d2jk)
      temp = 0.5d0 * (d2ij+d2jk-d2ik) / xy
      if (temp .gt. 1.0d0) temp=1.0d0
      if (temp .lt. -1.0d0) temp=-1.0d0
      angle = dacos( temp )
      return
      end
      subroutine bfn(x,bf)
      implicit REAL (a-h,o-z)
      dimension bf(13)
c**********************************************************************
c
c     bintgs forms the "b" integrals for the overlap calculation.
c
c**********************************************************************
      dimension fact(17)
      save fact
      data fact/1.d0,2.d0,6.d0,24.d0,120.d0,720.d0,5040.d0,40320.d0,
     1362880.d0,3628800.d0,39916800.d0,479001600.d0,6227020800.d0,
     28.71782912d10,1.307674368d12,2.092278989d13,3.556874281d14/
      k=12
      io=0
      absx = dabs(x)
      if (absx.gt.3.d00) go to 40
      if (absx.le.2.d00) go to 10
      last=15
      go to 60
   10 if (absx.le.1.d00) go to 20
      last=12
      go to 60
   20 if (absx.le.0.5d00) go to 30
      last=7
      go to 60
   30 if (absx.le.1.d-6) goto 90
      last=6
      go to 60
   40 expx=dexp(x)
      expmx=1.d00/expx
      bf(1)=(expx-expmx)/x
      do 50 i=1,k
   50 bf(i+1)=(i*bf(i)+(-1.d00)**i*expx-expmx)/x
      go to 110
   60 do 80 i=io,k
         y=0.0d00
         do 70 m=io,last
            xf=1.0d00
            if(m.ne.0) xf=fact(m)
   70    y=y+(-x)**m*(2*mod(m+i+1,2))/(xf*(m+i+1))
   80 bf(i+1)=y
      go to 110
   90 do 100 i=io,k
  100 bf(i+1)=(2*mod(i+1,2))/(i+1.d0)
  110 continue
      return
c
      end
      subroutine bintgs (x,k)
      implicit REAL (a-h,o-z)
      common /cmops/ a(7),b(7),sdum(3),idum(2)
      dimension fact(17)
c**********************************************************************
c
c     bintgs forms the "b" integrals for the overlap calculation.
c
c**********************************************************************
      save fact
      data fact/1.d0,2.d0,6.d0,24.d0,120.d0,720.d0,5040.d0,40320.d0,
     1362880.d0,3628800.d0,39916800.d0,479001600.d0,6227020800.d0,
     28.71782912d10,1.307674368d12,2.092278989d13,3.556874281d14/
      io=0
      absx = dabs(x)
      if (absx.gt.3.d00) go to 40
      if (absx.le.2.d00) go to 10
      if (k.le.10) go to 40
      last=15
      go to 60
   10 if (absx.le.1.d00) go to 20
      if (k.le.7) go to 40
      last=12
      go to 60
   20 if (absx.le.0.5d00) go to 30
      if (k.le.5) go to 40
      last=7
      go to 60
   30 if (absx.le.1.d-6) goto 90
      last=6
      go to 60
   40 expx=dexp(x)
      expmx=1.d00/expx
      b(1)=(expx-expmx)/x
      do 50 i=1,k
   50 b(i+1)=(i*b(i)+(-1.d00)**i*expx-expmx)/x
      go to 110
   60 do 80 i=io,k
         y=0.0d00
         do 70 m=io,last
            xf=1.0d00
            if(m.ne.0) xf=fact(m)
   70    y=y+(-x)**m*(2*mod(m+i+1,2))/(xf*(m+i+1))
   80 b(i+1)=y
      go to 110
   90 do 100 i=io,k
  100 b(i+1)=(2*mod(i+1,2))/(i+1.d0)
  110 continue
      return
c
      end
      subroutine bkrsav(tt0,hess,funct,grad,xparam,pmat,il,jl,bmat,ipow)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
INCLUDE(../m4/common/utilc)
      character elemnt*2, keywrd*241, koment*81, title*81
_IF(ipsc,tools)
      logical oroot
_ENDIF
      dimension hess(maxpar,*),grad(*),bmat(maxpar,*),ipow(9),
     1 xparam(*), pmat(*)
**********************************************************************
*
* bkrsav stores and retrieve data used in the ef geometry
*        optimisation. very similar to powsav.
*
*  on input hess   = hessian matrix, partial or whole.
*           grad   = gradients.
*           xparam = current state of parameters.
*           il     = index of hessian,
*           jl     = cycle number reached so-far.
*           bmat   = "b" matrix!
*           ipow   = indices and flags.
*           ipow(9)= 0 for restore, 1 for dump, 2 for silent dump
*
**********************************************************************
      common /geovar/ nvar,loc(2,maxpar), idumy, dumy(maxpar)
      common /elemts/ elemnt(107)
      common /geosym/ ndep,locpar(maxpar),idepfn(maxpar),
     1                     locdep(maxpar)
      common /fmatrx/oldf(maxpar),d(maxpar),vmode(maxpar),
     1u(maxpar,maxpar),dd,mode,nstep,negreq,iprnt
      common /titles/ koment,title
      common /geokst/ natoms,labels(numatm),
     1                na(numatm),nb(numatm),nc(numatm)
      common /cmpg/ geo(3,numatm)
      common /locvar/ locvar(2,maxpar)
      common /numscf/ nscf
      common /keywrd/ keywrd
      common /valvar/ valvar(maxpar),numvar
      common /densty/ p(mpack), pa(mpack), pb(mpack)
      common /alparm/ alparm(3,maxpar),x0, x1, x2, jloop
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),
     1                nlast(numatm), norbs, nelecs,nalpha,nbeta,
     2                nclose,nopen,ndumy,fract
      common /path/ latom,lparam,react(200)
      common/iofile/mfgr,mfgw
      character*80 getmop
c
_IF(ipsc,tools)
      if(oroot().and.odumpm) then
_ELSE
      if(odumpm) then
_ENDIF
      open(unit=9,file=getmop(3)
     +                         ,status='unknown',form='unformatted')
      rewind 9
      open(unit=10,file=getmop(4)
     +                         ,status='unknown',form='unformatted')
      rewind 10
      endif
      ir=9
      if(ipow(9) .eq. 1 .or. ipow(9) .eq. 2) then
         funct1=dsqrt(ddot(nvar,grad,1,grad,1))
         if(ipow(9).eq.1)then
            write(mfgw,'(//10x,''current value of gradient norm =''
     1  ,f12.6)')funct1
            write(mfgw,'(/10x,''current value of geometry'',/)')
            call geout(6)
         endif
c
c  ipow(1) and ipow(9) are used already, the rest are free for use
c
         ipow(8)=nscf
_IF(ipsc,tools)
       if(oroot().and.odumpm) then
_ELSE
       if(odumpm) then
_ENDIF
         write(ir)ipow,il,jl,funct,tt0
         write(ir)(xparam(i),i=1,nvar)
         write(ir)(  grad(i),i=1,nvar)
         write(ir)((hess(j,i),j=1,nvar),i=1,nvar)
         write(ir)((bmat(j,i),j=1,nvar),i=1,nvar)
         write(ir)(oldf(i),i=1,nvar),(d(i),i=1,nvar),(vmode(i),i=1,nvar)
         write(ir)dd,mode,nstep,negreq
         linear=(nvar*(nvar+1))/2
         write(ir)(pmat(i),i=1,linear)
         linear=(norbs*(norbs+1))/2
         write(10)(pa(i),i=1,linear)
         if(nalpha.ne.0)write(10)(pb(i),i=1,linear)
         if(latom .ne. 0) then
            write(ir)((alparm(j,i),j=1,3),i=1,nvar)
            write(ir)jloop,x0, x1, x2
         endif
        endif
         return
      else
c#         write(6,'(//10x,'' reading data from disk''/)')
_IF(ipsc,tools)
       if(oroot()) then
_ENDIF
         read(ir,end=10,err=10)ipow,il,jl,funct,tt0
         nscf=ipow(8)
         i=tt0/1000000
         tt0=tt0-i*1000000
         write(mfgw,'(//10x,''total time used so far:'',
     1    f13.2,'' seconds'')')tt0
         write(mfgw,'(  10x,''              function:'',f17.6)')
     +     funct
         read(ir)(xparam(i),i=1,nvar)
         read(ir)(  grad(i),i=1,nvar)
         read(ir)((hess(j,i),j=1,nvar),i=1,nvar)
         read(ir)((bmat(j,i),j=1,nvar),i=1,nvar)
         read(ir)(oldf(i),i=1,nvar),(d(i),i=1,nvar),(vmode(i),i=1,nvar)
         read(ir)dd,mode,nstep,negreq
         linear=(nvar*(nvar+1))/2
         read(ir)(pmat(i),i=1,linear)
         linear=(norbs*(norbs+1))/2
c        read density matrix
         read(10)(pa(i),i=1,linear)
         if(nalpha.ne.0)read(10)(pb(i),i=1,linear)
         if(latom.ne.0) then
            read(ir)((alparm(j,i),j=1,3),i=1,nvar)
            read(ir)jloop,x0, x1, x2
            il=il+1
         endif
_IF(ipsc,tools)
        else
         write(mfgw,*)' restart not yet implemented in bkrsav'
         go to 11
        endif
_ENDIF
         return
   10    write(mfgw,'(//10x,''no restart file exists!'')')
_IF(ipsc,tools)
   11    call pend
_ELSE
         stop
_ENDIF
      endif
      end
      subroutine bonds(p)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      parameter (natms2=maxpar*maxpar-maxorb*maxorb)
      dimension p(*)
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),
     1                nlast(numatm), norbs, nelecs,nalpha,nbeta,
     2                nclose,nopen,ndumy,fract
      common /scrach/ b(maxorb,maxorb), bondab(natms2)
      common/iofile/mfgr,mfgw
c***********************************************************************
c
c   calculates, and prints, the bond indices and valencies of atoms
c
c  for reference, see "bond indices and valency", j. c. s. dalton,
c  armstrong, d.r., perkins, p.g., and stewart, j.j.p., 838 (1973)
c
c   on input
c            p = density matrix, lower half triangle, packed.
c            p   is not altered by bonds.
c
c***********************************************************************
      write(mfgw,10)
   10 format(//20x,'bond orders and valencies',//)
      k=0
      do 20 i=1,norbs
         do 20 j=1,i
            k=k+1
            b(i,j)=p(k)
   20 b(j,i)=p(k)
      ij = 0
      do 60 i=1,numat
         l=nfirst(i)
         ll=nlast(i)
         do 40 j=1,i
            ij = ij + 1
            k=nfirst(j)
            kk=nlast(j)
            x=0.0d0
            do 30 il=l,ll
               do 30 ih=k,kk
   30       x=x+b(il,ih)*b(il,ih)
   40    bondab(ij)=x
         x=-bondab(ij)
         do 50 j=l,ll
   50    x=x+2.d0*b(j,j)
         bondab(ij)=x
   60 continue
      call vecprt( bondab, numat)
c
c this routine call added by vic l. to write out the bond indices
c  to the sybyl mopac output file *.syb. (29july86)
c  subroutine mpc_bonds is in module write.for.
c
      if(isybyl.eq.1)call mpcbds(bondab,numat,natms2)
      return
      end
      subroutine brlzon(fmatrx,fmat2d,n3,sec,vec, b, mono3, step,mode)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      dimension fmatrx((n3*(n3+1))/2), fmat2d(n3,n3), b(mono3,*)
      COMPLEX      sec(mono3,mono3), vec(mono3,mono3)
***********************************************************************
*
*   if mode is 1 then
*   brlzon computes the phonon spectrum of a linear polymer given
*   the weighted hessian matrix.
*   if mode is 2 then
*   brlzon computes the electronic energy band structure of a linear
*   polymer given the fock matrix.
*
*                 on input
*
*   if mode is 1 then
*         fmatrx is the mass-weighted hessian matrix, packed lower
*                   half triangle
*         n3     is 3*(number of atoms in unit cell) = size of fmatrx
*         mono3  is 3*(number of atoms in primitive unit cell)
*         fmat2d, sec, vec are scratch arrays
*   if mode is 2 then
*         fmatrx is the fock matrix, packed lower half triangle
*         n3     is number of atomic orbitals in system = size of fmatrx
*         mono3  is number of atomic orbitals in fundamental unit cell
*         fmat2d, sec, vec are scratch arrays
*
***********************************************************************
      common /keywrd/ keywrd
      common/iofile/mfgr,mfgw
      character keywrd*241
      REAL  eigs(maxpar)
      COMPLEX      phase
      fact=6.023d23
      c=2.998d10
      twopi=2.d0*dacos(-1.d0)
c
c  ncells is the number of primitive unit cells in the unit cell
c
      ncells=n3/mono3
c
c  put the energy matrix into square matrix form
c
      k=0
      do 10 i=1,n3
         do 10 j=1,i
            k=k+1
   10 fmat2d(i,j)=fmatrx(k)
c
c   step is the step size in the brillouin zone (boundaries: 0.0 - 0.5),
c   there are m of these.
c   mono3 is the size of one mer (monomeric unit)
c
      m=0.5d0/step+1
      do 70 loop=1,m
         do 20 i=1,mono3
            do 20 j=1,mono3
   20    sec(i,j)=0
         cay=(loop-1)*step
         do 40 i=1,n3,mono3
            ri=(i-1)/mono3
c
c if the primitive unit cell is more than half way across the unit cell,
c consider it as being less than half way across, but in the opposite
c direction.
c
            if(ri.gt.ncells/2) ri=ri-ncells
c
c  phase is the complex phase exp(i.k.r(i)/(2pi))
c
            phase=exp(sqrt(cmplx(-1.d0,0.d0))*cay*ri*twopi)
            do 30 ii=1,mono3
               iii=ii+i-1
               do 30 jj=1,ii
   30       sec(ii,jj)=sec(ii,jj)+fmat2d(iii,jj)*phase
   40    continue
         call cdiag(sec,eigs,vec,mono3, 0)
         if(mode.eq.1)then
c
c  convert into reciprical centimeters
c
            do 50 i=1,mono3
   50       b(i,loop)=dsign(dsqrt(fact*dabs(eigs(i)*1.d5))/(c*twopi),
     1                (eigs(i)))
         else
            do 60 i=1,mono3
   60       b(i,loop)=eigs(i)
         endif
   70 continue
      bottom=1.d6
      top=-1.d6
      do 80 i=1,mono3
         do 80 j=1,m
            bottom=dmin1(bottom,b(i,j))
   80 top=dmax1(top,b(i,j))
      if(mode.eq.1)then
         write(mfgw,'(//,a,f6.3,/)')
     1' frequencies in cm(-1) for phonon spectrum across brillouin zone'
         do 90 i=1,mono3
            write(mfgw,'(/,a,i4,/)')'  band:',i
   90    write(mfgw,'(6(f6.3,f7.1))')((j-1)*step,b(i,j),j=1,m)
_IF(ipsc,tools)
         call pend
_ELSE
         stop
_ENDIF
      else
         write(mfgw,'(//,a,f6.3,/)')
     1' energies (in ev) of electronic bands in band structure'
         do 100 i=1,mono3
            write(mfgw,'(a,/,a,i4,/,a)')'  .','  curve',i,
     +      'curve data are'
  100    write(mfgw,'(6(f6.3,f7.2))')((j-1)*step,b(i,j),j=1,m)
      endif
      call dofs(b,mono3,m,fmat2d,500,bottom,top)
      return
      end
      subroutine calpar
      implicit REAL (a-h,o-z)
      common /cmpone/ uss(107),upp(107),udd(107)
      common /atomic/ eisol(107),eheat(107)
      common /alpha/ alp(107)
      common /expont/ zs(107),zp(107),zd(107)
      common /cmpga/ fn1(107),fn2(107)
      common /betas/ betas(107),betap(107),betad(107)
      common /twoele/ gss(107),gsp(107),gpp(107),gp2(107),hsp(107),
     7                gsd(107),gpd(107),gdd(107)
      common /ideas/ guess1(107,10), guess2(107,10), guess3(107,10)
      common /mndo/
     +    ussm(107), uppm(107), uddm(107), zsm(107),zpm(107),
     1zdm(107), betasm(107), betapm(107), betadm(107), alpm(107),
     2eisolm(107), ddm(107), qqm(107), amm(107), adm(107), aqm(107)
     3,gssm(107),gspm(107),gppm(107),gp2m(107),hspm(107), polvom(107)
      common /keywrd/ keywrd
      common/multip/ dd(107),qq(107),am(107),ad(107),aq(107)
      common/iofile/mfgr,mfgw
      dimension nspqn(107)
      character keywrd*241
      dimension ussc(107), uppc(107), gssc(107), gspc(107), hspc(107),
     1gp2c(107), gppc(107), uddc(107), gsdc(107), gddc(107)
      save nspqn, ussc, uppc, uddc, gssc, gspc, hspc, gp2c, gsdc, gddc
      data nspqn/2*1,8*2,8*3,18*4,18*5,32*6,21*0/
c
c the continuation lines indicate the principal quantum number.
c
      data ussc/
     11.d0,                                                      0.d0,
     21.d0,                                               6*2.d0,0.d0,
     31.d0,                                               6*2.d0,0.d0,
     41.d0,4*2.d0,1.d0,4*2.d0,1.d0,                       6*2.d0,0.d0,
     51.d0,3*2.d0,2*1.d0,2.d0,2*1.d0,0.d0,1.d0,           6*2.d0,0.d0,
     61.d0,22*2.d0,1.d0,1.d0,                             6*2.d0,0.d0,
     721*0.d0/
      data  uppc/
     1 2*0.d0,
     2 2*0.d0,1.d0,2.d0,3.d0,4.d0,5.d0,6.d0,
     3 2*0.d0,1.d0,2.d0,3.d0,4.d0,5.d0,6.d0,
     412*0.d0,1.d0,2.d0,3.d0,4.d0,5.d0,6.d0,
     512*0.d0,1.d0,2.d0,3.d0,4.d0,5.d0,6.d0,
     626*0.d0,1.d0,2.d0,3.d0,4.d0,5.d0,6.d0,
     721*0.d0/
      data uddc/18*0.d0,
     1 2*0.d0,1.d0,2.d0,3.d0,5.d0,5.d0,6.d0,7.d0,8.d0,1.d1,1.d1,6*0.d0,
     2 2*0.d0,1.d0,2.d0,4.d0,5.d0,5.d0,7.d0,8.d0,1.d1,1.d1,1.d1,6*0.d0,
     3 2*0.d0,1.d0,6*0.d0,1.d0,6*0.d0,1.d0,2.d0,3.d0,4.d0,
     4                           5.d0,6.d0,7.d0,9.d0,1.d1,1.d1,6*0.d0,
     5 21*0.d0/
      data gssc/2*0.d0,
     1 0.d0,6*1.d0,0.d0,
     2 0.d0,6*1.d0,0.d0,
     3 0.d0,4*1.d0,0.d0,4*1.d0,0.d0,6*1.d0,0.d0,
     4 0.d0,3*1.d0,7*0.d0,6*1.d0,0.d0,
     5 0.d0,22*1.d0,2*1.d0,6*1.d0,0.d0,
     6 21*0.d0/
      data gspc/2*0.d0,
     1 2*0.d0,2.d0,4.d0,6.d0,8.d0,10.d0,0.d0,
     2 2*0.d0,2.d0,4.d0,6.d0,8.d0,10.d0,0.d0,
     312*0.d0,2.d0,4.d0,6.d0,8.d0,10.d0,0.d0,
     412*0.d0,2.d0,4.d0,6.d0,8.d0,10.d0,0.d0,
     526*0.d0,2.d0,4.d0,6.d0,8.d0,10.d0,0.d0,
     621*0.d0/
      data hspc/2*0.d0,
     1 2*0.d0,-1.d0,-2.d0,-3.d0,-4.d0,-5.d0,0.d0,
     2 2*0.d0,-1.d0,-2.d0,-3.d0,-4.d0,-5.d0,0.d0,
     312*0.d0,-1.d0,-2.d0,-3.d0,-4.d0,-5.d0,0.d0,
     412*0.d0,-1.d0,-2.d0,-3.d0,-4.d0,-5.d0,0.d0,
     526*0.d0,-1.d0,-2.d0,-3.d0,-4.d0,-5.d0,0.d0,
     621*0.d0/
      data gp2c/2*0.d0,
     1 3*0.d0,1.5d0,4.5d0,6.5d0,10.d0,0.d0,
     2 3*0.d0,1.5d0,4.5d0,6.5d0,10.d0,0.d0,
     313*0.d0,1.5d0,4.5d0,6.5d0,10.d0,0.d0,
     413*0.d0,1.5d0,4.5d0,6.5d0,10.d0,0.d0,
     527*0.d0,1.5d0,4.5d0,6.5d0,10.d0,0.d0,
     621*0.d0/
      data gppc/2*0.d0,
     1 3*0.d0,-0.5d0,-1.5d0,-0.5d0,2*0.d0,
     2 3*0.d0,-0.5d0,-1.5d0,-0.5d0,2*0.d0,
     313*0.d0,-0.5d0,-1.5d0,-0.5d0,2*0.d0,
     413*0.d0,-0.5d0,-1.5d0,-0.5d0,2*0.d0,
     527*0.d0,-0.5d0,-1.5d0,-0.5d0,2*0.d0,
     621*0.d0/
     7gsdc/18*0.d0,
     8 2*0.d0,2.d0,4.d0,6.d0,5.d0,10.d0,12.d0,14.d0,16.d0,10.d0,7*0.d0,
     9 2*0.d0,2.d0,4.d0,4.d0,5.d0,6.d0,7.d0,8.d0,0.d0,1.d1,7*0.d0,
     1 2*0.d0,2.d0,6*0.d0,2.d0,6*0.d0,2.d0,4.d0,6.d0,8.d0,10.d0,12.d0,
     2                                         14.d0,9.d0,10.d0,7*0.d0,
     321*0.d0/
      data gddc/18*0.d0,
     1 3*0.d0,1.d0,3.d0,10.d0,10.d0,15.d0,21.d0,28.d0,8*0.d0,
     2 3*0.d0,1.d0,6.d0,10.d0,15.d0,21.d0,28.d0,45.d0,8*0.d0,
     317*0.d0,1.d0,3.d0, 6.d0,10.d0,15.d0,21.d0,36.d0,8*0.d0,
     421*0.d0/
c  the data block shown above is derived from the ground-state atomic
c  configuration of the elements.  in checking it, pay careful attention
c  to the actual ground-state configuration. note also that there are no
c  configurations which have both p and d electrons in the valence shell
c
c     set scaling parameter.
      p=2.d0
      third = 1.0d0/3.0d0
      p2=p*p
      p4=p**4
      do 30 i=2,98
         if(zp(i).lt.1.d-4.and.zs(i).lt.1.d-4)goto 30
**********************************************************************
*
*   constraints on the possible values of parameters
*
**********************************************************************
         if(zp(i).lt.0.3d0) zp(i)=0.3d0
c  put in any constraints at this point
**********************************************************************
         hpp=0.5d0*(gpp(i)-gp2(i))
         hpp=dmax1(0.1d0,hpp)
         hsp(i)=dmax1(1.d-7,hsp(i))
         eisol(i)=uss(i)*ussc(i)+upp(i)*uppc(i)+udd(i)*uddc(i)+
     1         gss(i)*gssc(i)+gpp(i)*gppc(i)+gsp(i)*gspc(i)+
     2         gp2(i)*gp2c(i)+hsp(i)*hspc(i)+gsd(i)*gsdc(i)+
     3         gdd(i)*gddc(i)
         qn=nspqn(i)
         dd(i)=(2.d0*qn+1)*(4.d0*zs(i)*zp(i))**(qn+0.5d0)/(zs(i)+zp(i))
     1**(2.d0*qn+2)/dsqrt(3.d0)
         ddm(i)=dd(i)
         qq(i)=dsqrt((4.d0*qn*qn+6.d0*qn+2.d0)/20.d0)/zp(i)
         qqm(i)=qq(i)
c     calculate additive terms, in atomic units.
         jmax=5
         gdd1= (p2*hsp(i)/(27.21d0* 4.d0*dd(i)**2))**(third)
         gqq= (p4*hpp/(27.21d0*48.d0*qq(i)**4))**0.2d0
         d1=gdd1
         d2=gdd1+0.04d0
         q1=gqq
         q2=gqq+0.04d0
         do 10 j=1,jmax
            df=d2-d1
            hsp1= 2.*d1 - 2.d0/dsqrt(4.d0*dd(i)**2+1.d0/d1**2)
            hsp2= 2.*d2 - 2.d0/dsqrt(4.d0*dd(i)**2+1.d0/d2**2)
            hsp1= hsp1/p2
            hsp2= hsp2/p2
            d3= d1 + df*(hsp(i)/27.21d0-hsp1)/(hsp2-hsp1)
            d1= d2
            d2= d3
   10    continue
         do 20 j=1,jmax
            qf=q2-q1
            hpp1= 4.d0*q1 - 8.d0/dsqrt(4.d0*qq(i)**2+1.d0/q1**2)
     1            + 4.d0/dsqrt(8.d0*qq(i)**2+1.d0/q1**2)
            hpp2= 4.d0*q2 - 8.d0/dsqrt(4.d0*qq(i)**2+1.d0/q2**2)
     1            + 4.d0/dsqrt(8.d0*qq(i)**2+1.d0/q2**2)
            hpp1= hpp1/p4
            hpp2= hpp2/p4
            q3= q1 + qf*(hpp/27.21d0-hpp1)/(hpp2-hpp1)
            q1= q2
            q2= q3
   20    continue
         am(i)= gss(i)/27.21d0
         ad(i)= d2
         aq(i)= q2
         amm(i)=am(i)
         adm(i)=ad(i)
         aqm(i)=aq(i)
   30 continue
      eisol(1)=uss(1)
      am(1)=gss(1)/27.21d0
      ad(1)=am(1)
      aq(1)=am(1)
      amm(1)=am(1)
      adm(1)=ad(1)
      aqm(1)=aq(1)
c
c     debug printing.
c     this is formatted for direct insertion into 'param'
c
      if(index(keywrd,'dep').eq.0) return
      write(mfgw,50)
      do 60 i=1,107
         if(zs(i).eq.0) goto 60
         write(mfgw,'(''c'',20x,''data for element'',i3)')i
         write(mfgw,'(6x,''data usspm3('',i3,'')/'',f16.7,
     +     ''d0/'')') i,uss(i)
         if(upp(i) .ne. 0.d0)
     1write(mfgw,'(6x,''data upppm3('',i3,'')/'',f16.7,''d0/'')')
     +     i,upp(i)
         if(udd(i) .ne. 0.d0)
     1write(mfgw,'(6x,''data uddpm3('',i3,'')/'',f16.7,''d0/'')')
     +     i,udd(i)
         if(betas(i) .ne. 0.d0)
     1write(mfgw,'(6x,''data betasp('',i3,'')/'',f16.7,''d0/'')')
     2i,betas(i)
         if(betap(i) .ne. 0.d0)
     1write(mfgw,'(6x,''data betapp('',i3,'')/'',f16.7,''d0/'')')
     2i,betap(i)
         if(betad(i) .ne. 0.d0)
     1write(mfgw,'(6x,''data betadp('',i3,'')/'',f16.7,''d0/'')')
     2i,betad(i)
         write(mfgw,'(6x,''data zspm3 ('',i3,'')/'',f16.7,
     +    ''d0/'')') i,zs(i)
         if(zp(i) .ne. 0.d0)
     1write(mfgw,'(6x,''data zppm3 ('',i3,'')/'',f16.7,
     +  ''d0/'')')i,zp(i)
         if(zd(i) .ne. 0.d0)
     1write(mfgw,'(6x,''data zdpm3 ('',i3,'')/'',f16.7,''d0/'')')
     + i,zd(i)
      write(mfgw,'(6x,''data alppm3('',i3,'')/'',f16.7,''d0/'')')
     1i,alp(i)
      write(mfgw,'(6x,''data eisolp('',i3,'')/'',f16.7,''d0/'')')
     1i,eisol(i)
         if(gss(i) .ne. 0.d0)
     1write(mfgw,'(6x,''data gsspm3('',i3,'')/'',f16.7,''d0/'')')
     2i,gss(i)
         if(gsp(i) .ne. 0.d0)
     1write(mfgw,'(6x,''data gsppm3('',i3,'')/'',f16.7,''d0/'')')
     2i,gsp(i)
         if(gpp(i) .ne. 0.d0)
     1write(mfgw,'(6x,''data gpppm3('',i3,'')/'',f16.7,''d0/'')')
     2i,gpp(i)
         if(gp2(i) .ne. 0.d0)
     1write(mfgw,'(6x,''data gp2pm3('',i3,'')/'',f16.7,''d0/'')')
     2i,gp2(i)
         if(hsp(i) .ne. 0.d0)
     1write(mfgw,'(6x,''data hsppm3('',i3,'')/'',f16.7,''d0/'')')
     2i,hsp(i)
         if(dd(i) .ne. 0.d0)
     1write(mfgw,'(6x,''data ddpm3 ('',i3,'')/'',f16.7,''d0/'')')
     +   i,dd(i)
         if(qq(i) .ne. 0.d0)
     1write(mfgw,'(6x,''data qqpm3 ('',i3,'')/'',f16.7,''d0/'')')
     +   i,qq(i)
      write(mfgw,'(6x,''data ampm3 ('',i3,'')/'',f16.7,''d0/'')')
     1i,am(i)
         if(ad(i) .ne. 0.d0)
     1write(mfgw,'(6x,''data adpm3 ('',i3,'')/'',f16.7,''d0/'')')
     +   i,ad(i)
         if(aq(i) .ne. 0.d0)
     1write(mfgw,'(6x,''data aqpm3 ('',i3,'')/'',f16.7,''d0/'')')
     +   i,aq(i)
         if(fn1(i) .ne. 0.d0)
     1write(mfgw,'(6x,''data fn1pm3('',i3,'')/'',f16.7,''d0/'')')
     +   i,fn1(i)
         if(fn2(i) .ne. 0.d0)
     1write(mfgw,'(6x,''data fn2pm3('',i3,'')/'',f16.7,''d0/'')')
     +   i,fn2(i)
         do 40 j=1,10
            if(guess1(i,j) .eq.0.d0) goto 40
            write(mfgw,'(6x,''data guesp1('',i3,'','',i1,'')/'',
     1f16.7,''d0/'')')i,j,guess1(i,j)
            write(mfgw,'(6x,''data guesp2('',i3,'','',i1,'')/'',
     1f16.7,''d0/'')')i,j,guess2(i,j)
            write(mfgw,'(6x,''data guesp3('',i3,'','',i1,'')/'',
     1f16.7,''d0/'')')i,j,guess3(i,j)
   40    continue
   50    format(1h ,1x,'output includes debug information',//)
   60 continue
      return
      end
      function capcor(nat,nfirst,nlast,numat,p,h)
      implicit REAL (a-h,o-z)
      dimension p(*), h(*), nfirst(numat), nlast(numat), nat(numat)
******************************************************************
*
*    correction to electronic energy due to capped bonds
*
******************************************************************
      sum=0.d0
      do 40 i=1,numat
         ni=nat(i)
         il=nfirst(i)
         iu=nlast(i)
         if(ni.eq.102) then
c
c   do entire row - no need to check further.
c
            j=(nlast(i)*(nlast(i)+1))/2
            ii=iu-1
            do 10 k=1,ii
               j=j-1
   10       sum=sum+p(j)*h(j)
         else
            do 30 j=1,i
               jl=nfirst(j)
               if(nat(j).eq.102)then
                  do  20 k=il,iu
                     kk=(k*(k-1))/2+jl
   20             sum=sum+p(kk)*h(kk)
               endif
   30       continue
         endif
   40 continue
c
c   double sum since we only calculated lower half, and capcor
c   will appear in 1/2*p(h+f).  only h part of f will be used.
      capcor=-sum*2.d0
      return
      end
      subroutine cdiag(a,value,vec,n, need)
c
c to find the eigenvalues and eigenvectors of a hermitian matrix.
      REAL  value(*),h
      COMPLEX      w(6000)
      COMPLEX      a(n,*),vec(n,*)
      COMPLEX      fm06as
      ia=n
      iv=n
c
c reduce matrix to a tri-diagonal hermitian matrix.
      call me08a(a,w,w(n+1),n,ia,w(2*n+1))
c
c find the eigenvalues and eigenvectors of the tri-diagonal matrix
      call ec08c(w,w(n+1),value,vec,n,iv,w(2*n+1))
      if(need.eq.0) goto 50
      if(n.lt.2)return
c
c the eigenvectors of the original matrix are now found by
c back transformation using information store in the upper
c triangle of matrix a (by me08)
      do 40 ii=3,n
         i=n-ii+1
         h=w(n+i+1)*conjg(a(i,i+1))
         if(h)10,40,10
   10    do30l=1,n
            i1=i+1
            s=fm06as(n-i,a(i,i+1),ia,vec(i+1,l),1)
            s=s/h
            do20k=i1,n
   20       vec(k,l)=vec(k,l)+conjg(a(i,k))*s
   30    continue
   40 continue
   50 call mops(value,vec,n)
      return
      end
      subroutine chrge(p,q)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      dimension p(*),q(*)
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),
     1                nlast(numatm), norbs, nelecs,nalpha,nbeta,
     2                nclose,nopen,ndumy,fract
c***********************************************************************
c
c      chrge stores in q the total electron densities on the atoms
c
c      on input p      = density matrix
c
c      on output q     = atom electron densities
c
c***********************************************************************
      k=0
      do 10 i=1,numat
         ia=nfirst(i)
         ib=nlast(i)
         q(i)=0.d0
         do 10 j=ia,ib
            k=k+j
   10 q(i)=q(i)+p(k)
      return
      end
      subroutine cnvg(pnew, p, p1,norbs, niter, pl)
      implicit REAL (a-h,o-z)
      dimension p1(*), p(*), pnew(*)
      logical extrap
c***********************************************************************
c
c  cnvg is a two-point interpolation routine for speeding convergence
c       of the density matrix.
c
c on output p      = new density matrix
c           p1     = diagonal of old density matrix
c           pl     = largest difference between old and new density
c                    matrix diagonal elements
c***********************************************************************
      common/keywrd/ keywrd
      common /numcal/ numcal
      save rhfuhf
      character*241 keywrd
      save icalcn
      data icalcn/0/
      if (icalcn.ne.numcal) then
         icalcn=numcal
         if(index(keywrd,'uhf').ne.0)then
            rhfuhf=1.d0
         else
            rhfuhf=2.d0
         endif
      endif
      pl=0.0d00
      faca=0.0d00
      damp=1.d10
      if(niter.gt.3)damp=0.05d0
      facb=0.0d00
      fac=0.0d00
      ii=mod(niter,3)
      extrap=ii.ne.0
      sum1=0.d0
      k=0
      do 20 i=1,norbs
         k=k+i
         a=pnew(k)
         sum1=sum1+a
         sa=dabs(a-p(k))
         if (sa.gt.pl) pl=sa
         if (extrap) go to 10
         faca=faca+sa**2
         facb=facb+(a-2.d00*p(k)+p1(i))**2
   10    p1(i)=p(k)
   20 p(k)=a
      if (facb.le.0.0d00) go to 30
      if (faca.lt.(100.d00*facb)) fac=dsqrt(faca/facb)
   30 ie=0
      sum2=0.d0
      do 50 i=1,norbs
         ii=i-1
         do 40 j=1,ii
            ie=ie+1
            a=pnew(ie)
            p(ie)=a+fac*(a-p(ie))
            pnew(ie)=p(ie)
   40    continue
         ie=ie+1
         if(dabs(p(ie)-p1(i)) .gt. damp) then
            p(ie)=p1(i)+dsign(damp,p(ie)-p1(i))
         else
            p(ie)=p(ie)+fac*(p(ie)-p1(i))
         endif
         p(ie)=dmin1(rhfuhf,dmax1(p(ie),0.d0))
         sum2=sum2+p(ie)
   50 pnew(ie)=p(ie)
c
c   re-normalize if any density matrix elements have been truncated
c
      sum0=sum1
   60 if(sum2.gt.1.d-3)then
         sum=sum1/sum2
      else
         sum=0.d0
      endif
      sum1=sum0
      if(sum2.gt.1.d-3.and.dabs(sum-1.d0).gt.1.d-5)then
c#      write(6,'(6f12.6)')(p((i*(i+1))/2),i=1,norbs)
         sum2=0.d0
         do 70 i=1,norbs
            j=(i*(i+1))/2
c
c   add on a small number in case an occupancy is exactly zero
c
            p(j)=p(j)*sum+1.d-20
            p(j)=dmax1(p(j),0.d0)
c
c  set up renormalization over partly occupied m.o.'s only.  full m.o.'s
c  can't be filled any more
c
            if(p(j).gt.rhfuhf)then
               p(j)=rhfuhf
               sum1=sum1-rhfuhf
            else
               sum2=sum2+p(j)
            endif
   70    pnew(j)=p(j)
         goto 60
      endif
      return
      end
      subroutine coe(x1,y1,z1,x2,y2,z2,pq1,pq2,c,r)
      implicit REAL (a-h,o-z)
      integer pq1,pq2,pq
      dimension c(75)
      xy=(x2-x1)**2+(y2-y1)**2
      r=dsqrt(xy+(z2-z1)**2)
      xy=dsqrt(xy)
      if (xy.lt.1.d-10) go to 10
      ca=(x2-x1)/xy
      cb=(z2-z1)/r
      sa=(y2-y1)/xy
      sb=xy/r
      go to 50
   10 if (z2-z1) 20,30,40
   20 ca=-1.d0
      cb=-1.d0
      sa=0.d0
      sb=0.d0
      go to 50
   30 ca=0.d0
      cb=0.d0
      sa=0.d0
      sb=0.d0
      go to 50
   40 ca=1.d0
      cb=1.d0
      sa=0.d0
      sb=0.d0
   50 continue
      do 60 i=1,75
   60 c(i)=0.d0
      if (pq1.gt.pq2) go to 70
      pq=pq2
      go to 80
   70 pq=pq1
   80 continue
      c(37)=1.d0
      if (pq.lt.2) go to 90
      c(56)=ca*cb
      c(41)=ca*sb
      c(26)=-sa
      c(53)=-sb
      c(38)=cb
      c(23)=0.d0
      c(50)=sa*cb
      c(35)=sa*sb
      c(20)=ca
      if (pq.lt.3) go to 90
      c2a=2*ca*ca-1.d0
      c2b=2*cb*cb-1.d0
      s2a=2*sa*ca
      s2b=2*sb*cb
      c(75)=c2a*cb*cb+0.5d0*c2a*sb*sb
      c(60)=0.5d0*c2a*s2b
      c(45)=0.8660254037841d0*c2a*sb*sb
      c(30)=-s2a*sb
      c(15)=-s2a*cb
      c(72)=-0.5d0*ca*s2b
      c(57)=ca*c2b
      c(42)=0.8660254037841d0*ca*s2b
      c(27)=-sa*cb
      c(12)=sa*sb
      c(69)=0.5773502691894d0*sb*sb*1.5d0
      c(54)=-0.8660254037841d0*s2b
      c(39)=cb*cb-0.5d0*sb*sb
      c(66)=-0.5d0*sa*s2b
      c(51)=sa*c2b
      c(36)=0.8660254037841d0*sa*s2b
      c(21)=ca*cb
      c(6)=-ca*sb
      c(63)=s2a*cb*cb+0.5d0*s2a*sb*sb
      c(48)=0.5d0*s2a*s2b
      c(33)=0.8660254037841d0*s2a*sb*sb
      c(18)=c2a*sb
      c(3)=c2a*cb
   90 continue
      return
      end
      function collidm(cw,rw,cnbr,rnbr,mnbr,nnbr,ishape,
     1jnbr,knbr)
c****************************************************************
c
c     collision check of probe with neighboring atoms
c     used by surfac only.
c
c****************************************************************
      implicit REAL (a-h,o-z)
      logical collidm
      dimension cw(3)
      dimension cnbr(3,200)
      dimension rnbr(200)
      logical mnbr(200)
      if (nnbr .le. 0) go to 20
c
c     check whether probe is too close to any neighbor
c
      do 10 i = 1, nnbr
         if (ishape .gt. 1 .and. i .eq. jnbr) go to 10
         if (ishape .eq. 3 .and. (i .eq. knbr .or. .not. mnbr(i)))
     1   go to 10
         sumrad = rw + rnbr(i)
         vect1 = dabs(cw(1) - cnbr(1,i))
         if (vect1 .ge. sumrad) go to 10
         vect2 = dabs(cw(2) - cnbr(2,i))
         if (vect2 .ge. sumrad) go to 10
         vect3 = dabs(cw(3) - cnbr(3,i))
         if (vect3 .ge. sumrad) go to 10
         sr2 = sumrad ** 2
         dd2 = vect1 ** 2 + vect2 ** 2 + vect3 ** 2
         if (dd2 .lt. sr2) go to 30
   10 continue
   20 continue
      collidm = .false.
      go to 40
   30 continue
      collidm = .true.
   40 continue
      return
      end
      subroutine compfg(xparam,int,escf,fulscf,grad,lgrad)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      dimension xparam(maxpar),grad(maxpar)
      logical lgrad, fulscf
      common /geovar/ nvar,loc(2,maxpar),idumy,dumy(maxpar)
      common /geosym/ ndep,locpar(maxpar),idepfn(maxpar),locdep(maxpar)
      common /cmpg/ geo(3,numatm)
      common /atheat/ atheat
      common /wmatrc/ wj(n2elec), wk(n2elec)
      common /enuclr/ enuclr
      common /natype/ nztype(107),mtype(30),ltype
      common /elect/ elect
      parameter (mdumy=maxpar**2-mpack)
      common /scrach/ rxyz(mpack), xdumy(mdumy)
      common /hmatrx/ h(mpack)
      common /geokst/ natoms,labels(numatm),
     1                na(numatm), nb(numatm), nc(numatm)
      common /errfn/ errfn(maxpar), aicorr(maxpar)
      common /vector/ c(morb2),eigs(maxorb),cbeta(morb2),eigb(maxorb)
      common /last/ last
      common /numcal/ numcal
      common /scftyp/ emin, limscf
      common /molmec/ htype(4),nhco(4,20),nnhco,itype
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),
     2                nlast(numatm), norbs, nelecs,nalpha,nbeta,
     3                nclose,nopen,ndumy,fract
      common/iofile/mfgr,mfgw
c***********************************************************************
c
c   compfg calculates (a) the heat of formation of the system, and
c                     (b) the gradients, if lgrad is .true.
c
c   on input  xparam = array of parameters to be used in internal coords
c             lgrad  = .true. if gradients are needed, .false. otherwise
c             int    = .true. if heat of formation is to be calculated
c             fulscf = .true. if full scf to be done, .false. otherwise.
c
c   on output escf  = heat of formation.
c             grad   = array of gradients, if lgrad = .true.
c
c***********************************************************************
      common /keywrd/keywrd
      character*241 keywrd
      logical debug, int, print, analyt, large, usedci,
     1force, times, aider
      dimension coord(3,numatm), w(n2elec), degree(3), xparef(maxpar)
     1,deltap(nmeci**2) ,delta(nmeci*maxorb)
      equivalence (w,wj)
      save icalcn,times,aider
      save degree, print, debug, analyt, usedci, force, large
      save xparef,coord
      data icalcn /0/
c                 mndo     am1      pm3      mindo/
      if (icalcn.ne.numcal) then
         icalcn=numcal
         htype(1)=6.1737d0
         htype(2)=3.3191d0
         htype(3)=7.1853d0
         htype(4)=1.7712d0
         ltype=0
         do 30 i=1,numat
            if(nat(i).lt.99)then
               do 10 j=1,ltype
   10          if(nat(i).eq.mtype(j)) goto 20
               ltype=ltype+1
               mtype(ltype)=nat(i)
               nztype(nat(i))=ltype
c
c       ltype = number of types of real atom present
c       mtype = types of real atoms present
               j=ltype
   20          continue
            endif
   30    continue
         aider=(index(keywrd,'aider').ne.0)
         times=(index(keywrd,'times').ne.0)
         analyt=(index(keywrd,'analyt').ne.0)
         if(int.and.analyt)call setupg
         degree(1)=1.d0
         if(index(keywrd,' xyz').ne.0)then
            degree(2)=1.d0
         else
            degree(2)=180.d0/3.141592652589d0
         endif
         degree(3)=degree(2)
         usedci=(nclose.ne.nopen.and.fract.ne.2.d0.and.fract.ne.0.d0
     1         .or.(index(keywrd,'c.i.').ne.0))
         force=(index(keywrd,'force').ne.0)
         large=(index(keywrd,'large') .ne. 0)
         print=(index(keywrd,'compfg') .ne. 0)
         debug=(index(keywrd,'debug') .ne. 0 .and. print)
         emin=0.d0
         do 40 i=1,nvar
   40    xparef(i)=xparam(i)
      endif
c
c set up coordinates for current calculation
c
c       place the new values of the variables in the array geo.
c       make changes in the geometry.
      do 50 i=1,nvar
         k=loc(1,i)
         l=loc(2,i)
   50 geo(l,k)=xparam(i)
c      impose the symmetry conditions + compute the dependent-parameters
      if(ndep.ne.0) call mopsym()
c      now compute the atomic coordinates.
      if( debug ) then
         if( large ) then
            k=natoms
         else
            k=min0(5,natoms)
         endif
         write(mfgw,fmt='('' internal coords'',/100(/,3f12.6))')
     1            ((geo(j,i)*degree(j),j=1,3),i=1,k)
      end if
      call gmetry(geo,coord)
      if( debug ) then
         if( large ) then
            k=numat
         else
            k=min0(5,numat)
         endif
         write(mfgw,fmt='('' cartesian coords'',/100(/,3f16.9))')
     1            ((coord(j,i),j=1,3),i=1,k)
      endif
      if(int.and.analyt)rewind 2
      if(times)call timop('before hcore')
      if(int)call mophc(coord,h,w,wj,wk,enuclr)
      if(times)call timop('after hcore')
c
c compute the heat of formation.
c
      if(norbs.gt.0.and.nelecs.gt.0) then
         if(times)call timop('before iter')
         if(int) call iterm(h, w, wj, wk, elect, fulscf,.true.)
         if(times)call timop('after iter')
      else
         elect=0.d0
      endif
      escf=(elect+enuclr)*23.061d0+atheat
      if(escf.lt.emin.or.emin.eq.0.d0)emin=escf
      do 60 i=1,nnhco
         call dihed(coord,nhco(1,i),nhco(2,i),nhco(3,i),nhco(4,i),angle)
         escf=escf+htype(itype)*dsin(angle)**2
   60 continue
c
c find derivatives if desired
c
      if(lgrad) then
         if(times)call timop('before deriv')
         call mopdv(geo,grad)
         if(times)call timop('after deriv')
      endif
      if(aider)then
c
c  add in ab initio correction
c
         do 70 i=1,nvar
   70    escf=escf+(xparam(i)-xparef(i))*aicorr(i)
      endif
      if(int.and.print)
     1write(mfgw,'(/10x,'' heat of formation'',g30.17)')escf
      if(print.and.lgrad)
     1   write(mfgw,fmt='('' gradient       '',8f8.2,(/10f8.2))')
     2                (grad(i),i=1,nvar)
c
c reform density matrix, if a c.i. done and either the last scf or a
c force calculation
c
      if(usedci.and. (last.eq.1 .or. force))
     1call mecip(c,norbs,deltap,delta)
      return
      end
      subroutine dang(a1,a2,b1,b2,rcos)
      implicit REAL (a-h,o-z)
**********************************************************************
*
*    dang  determines the angle between the points (a1,a2), (0,0),
*          and (b1,b2).  the result is put in rcos.
*
**********************************************************************
      pi=2.0d0* dasin(1.0d00)
      zero=1.0d-6
      if(dabs(a1).lt.zero.and.dabs(a2).lt.zero) go to 10
      if(dabs(b1).lt.zero.and.dabs(b2).lt.zero) go to 10
      anorm=1.0d0/ dsqrt(a1**2+a2**2)
      bnorm=1.0d0/ dsqrt(b1**2+b2**2)
      a1=a1*anorm
      a2=a2*anorm
      b1=b1*bnorm
      b2=b2*bnorm
      sinth=(a1*b2)-(a2*b1)
      costh=a1*b1+a2*b2
      if(costh.gt.1.0d0) costh=1.0d0
      if(costh.lt.-1.0d0) costh=-1.0d0
      rcos= dacos(costh)
      if(dabs(rcos).lt.4.0d-4) go to 10
      if(sinth.gt.0.d0) rcos=4.0d0* dasin(1.0d00)-rcos
      rcos=-rcos
      return
   10 rcos=0.0d0
      return
      end
      subroutine datin
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      character numbrs(0:9)*1, partyp(25)*5, files*64, dummy*50,
     1          keywrd*241, text*50, txtnew*50, elemnt(107)*2,
     2          getmop*80
      common /atheat/ atheat
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),
     2                nlast(numatm), norbs, nelecs,nalpha,nbeta,
     3                nclose,nopen,ndumy,fract
      common /atomic/ eisol(107),eheat(107)
      common /keywrd/ keywrd
      common/iofile/mfgr,mfgw
      dimension  ijpars(5,1000), parsij(1000)
      save numbrs, partyp, elemnt
      data numbrs/' ','1','2','3','4','5','6','7','8','9'/
      data partyp/'uss  ','upp  ','udd  ','zs   ','zp   ','zd   ',
     1    'betas','betap','betad','gss  ','gsp  ','gpp  ','gp2  ',
     2    'hsp  ','am1  ','expc ','gauss','alp  ','gsd  ','gpd  ',
     3    'gdd  ','fn1  ','fn2  ','fn3  ','orb  '/
      data (elemnt(i),i=1,107)/'h ','he',
     1 'li','be','b ','c ','n ','o ','f ','ne',
     2 'na','mg','al','si','p ','s ','cl','ar',
     3 'k ','ca','sc','ti','v ','cr','mn','fe','co','ni','cu',
     4 'zn','ga','ge','as','se','br','kr',
     5 'rb','sr','y ','zr','nb','mo','tc','ru','rh','pd','ag',
     6 'cd','in','sn','sb','te','i ','xe',
     7 'cs','ba','la','ce','pr','nd','pm','sm','eu','gd','tb','dy',
     8 'ho','er','tm','yb','lu','hf','ta','w ','re','os','ir','pt',
     9 'au','hg','tl','pb','bi','po','at','rn',
     1 'fr','ra','ac','th','pa','u ','np','pu','am','cm','bk','cf','xx',
     2 'fm','md','cb','++','+','--','-','tv'/
      i=index(keywrd,'external=')+9
      j=index(keywrd(i:),' ')+i-1
      files=getmop(keywrd(i:j))
      write(mfgw,'(//5x,'' parameter type      element    parameter'')
     +')
      open(14,status='unknown',file=files)
      i=0
      nparas=0
   10 read(14,'(a40)',err=90,end=90)text
      nparas=nparas+1
      if(text.eq.' ')goto 90
      if(index(text,'end').ne.0)goto 90
      ilowa = ichar('a')
      ilowz = ichar('z')
      icapa = ichar('a')
************************************************************************
      do 20 i=1,50
         iline=ichar(text(i:i))
         if(iline.ge.ilowa.and.iline.le.ilowz) then
            text(i:i)=char(iline+icapa-ilowa)
         endif
   20 continue
************************************************************************
      if(index(text,'end') .ne. 0) goto 90
      do 30 j=1,25
         if(j.gt.21) then
            it=index(text,'fn')
            txtnew = text(1:it+2)
            if(index(txtnew,partyp(j)) .ne. 0) goto 40
         endif
         if(index(text,partyp(j)) .ne. 0) goto 40
   30 continue
      write(mfgw,'(''  faulty line:'',a)')txtnew
      write(mfgw,'(''  faulty line:'',a)')text
      write(mfgw,'(''   name not found'')')
_IF(ipsc,tools)
      call pend
_ELSE
      stop
_ENDIF
   40 iparam=j
      if(iparam.gt.21) then
         i=index(text,'fn')
         kfn=reada(text,i+3)
      else
         kfn=0
         i=index(text,partyp(j))
      endif
      k=index(text(i:),' ')+1
      dummy=text(k:)
      text=dummy
      do 50 j=1,107
   50 if(index(text,' '//elemnt(j)) .ne. 0) goto 60
      write(mfgw,'('' element not found '')')
      write(mfgw,*)' faulty line: "'//text//'"'
_IF(ipsc,tools)
      call pend
_ELSE
      stop
_ENDIF
   60 ielmnt=j
      param=reada(text,index(text,elemnt(j)))
      do 70 i=1,lpars
         if(ijpars(1,i).eq.kfn.and.ijpars(2,i).eq.ielmnt.and.
     1ijpars(3,i).eq.iparam) goto 80
   70 continue
      lpars=lpars+1
      i=lpars
   80 ijpars(1,i)=kfn
      ijpars(2,i)=ielmnt
      ijpars(3,i)=iparam
      parsij(i)=param
      goto 10
   90 continue
      if(nparas.eq.0)then
      write(mfgw,'(//10x,a)')' external parameters file missing or empty
     1'
_IF(ipsc,tools)
         call pend
_ELSE
         stop
_ENDIF
      endif
      close(14)
      do 120 j=1,107
         do 110 k=1,25
            do 100 i=1,lpars
               iparam=ijpars(3,i)
               kfn=ijpars(1,i)
               ielmnt=ijpars(2,i)
               if(iparam.ne.k) goto 100
               if(ielmnt.ne.j) goto 100
               param=parsij(i)
               if(kfn.ne.0)then
                  write(mfgw,'(10x,a6,11x,a2,f17.6)')
     1partyp(iparam)(:3)//numbrs(kfn)//'  ',
     2elemnt(ielmnt),param
               else
                  write(mfgw,'(10x,a6,11x,a2,f17.6)')
     1partyp(iparam)//numbrs(kfn),
     2elemnt(ielmnt),param
               endif
               call mopupd(iparam,ielmnt,param,1,kfn)
  100       continue
  110    continue
  120 continue
      call moldat(1)
      call calpar
      atheat=0.d0
      eth=0.d0
      do 130 i=1,numat
         ni=nat(i)
         atheat=atheat+eheat(ni)
  130 eth=eth+eisol(ni)
      atheat=atheat-eth*23.061d0
      return
      end
      subroutine dcart (coord,dxyz)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      dimension coord(3,*), dxyz(3,*)
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),
     1                nlast(numatm), norbs, nelecs,nalpha,nbeta,
     2                nclose,nopen,ndumy,fract
      common /densty/ p(mpack), pa(mpack), pb(mpack)
c***********************************************************************
c
c    dcart calculates the derivatives of the energy with respect to the
c          cartesian coordinates. this is done by finite differences.
c
c    the main arrays in dcart are:
c        dxyz   on exit contains the cartesian derivatives.
c
c***********************************************************************
      common /keywrd/ keywrd
      common /euler/ tvec(3,3), id
      common /molmec/ htype(4),nhco(4,20),nnhco,itype
      common /ucell/ l1l,l2l,l3l,l1u,l2u,l3u
      common /dcartc/ k1l,k2l,k3l,k1u,k2u,k3u
      common /numcal/ numcal
      common/iofile/mfgr,mfgw
      character*241 keywrd
      dimension pdi(171),padi(171),pbdi(171),
     1cdi(3,2),ndi(2),lstor1(6), lstor2(6), eng(3)
      logical debug, force, makep, anader, large
      equivalence (lstor1(1),l1l), (lstor2(1), k1l)
      save chnge, chnge2, anader, debug, force, large
      save icalcn
      data icalcn/0/
      data chnge /1.d-4/
      chnge2=chnge*0.5d0
*
* chnge is a machine-precision dependent constant
* chnge2=chnge/2
*
      if (icalcn.ne.numcal) then
         icalcn=numcal
         large = (index(keywrd,'large') .ne. 0)
         anader= (index(keywrd,'analyt') .ne. 0)
         debug = (index(keywrd,'dcart') .ne. 0)
         force = (index(keywrd,'prec')+index(keywrd,'force') .ne. 0)
      endif
      ncells=(l1u-l1l+1)*(l2u-l2l+1)*(l3u-l3l+1)
      do 10 i=1,6
         lstor2(i)=lstor1(i)
   10 lstor1(i)=0
      iofset=(ncells+1)/2
      numtot=numat*ncells
      do 20 i=1,numtot
         do 20 j=1,3
   20 dxyz(j,i)=0.d0
      if(anader) rewind 2
      krep=0
      do 130 ii=1,numat
         iii=ncells*(ii-1)+iofset
         im1=ii
         if=nfirst(ii)
         im=nmidle(ii)
         il=nlast(ii)
         ndi(2)=nat(ii)
         do 30 i=1,3
   30    cdi(i,2)=coord(i,ii)
         do 130 jj=1,im1
            jjj=ncells*(jj-1)
c  form diatomic matrices
            jf=nfirst(jj)
            jm=nmidle(jj)
            jl=nlast(jj)
c   get first atom
            ndi(1)=nat(jj)
            makep=.true.
            do 120 ik=k1l,k1u
               do 120 jk=k2l,k2u
                  do 120 kl=k3l,k3u
                     jjj=jjj+1
                     kkk=kkk-1
                     do 40 l=1,3
   40                cdi(l,1)=coord(l,jj)+tvec(l,1)*ik+tvec(l,2)*jk+tvec
     1(l,3)*kl
                     if(.not. makep) goto 90
                     makep=.false.
                     ij=0
                     do 50 i=jf,jl
                        k=i*(i-1)/2+jf-1
                        do 50 j=jf,i
                           ij=ij+1
                           k=k+1
                           padi(ij)=pa(k)
                           pbdi(ij)=pb(k)
   50                pdi(ij)=p(k)
c get second atom first atom intersection
                     do 80 i=if,il
                        l=i*(i-1)/2
                        k=l+jf-1
                        do 60 j=jf,jl
                           ij=ij+1
                           k=k+1
                           padi(ij)=pa(k)
                           pbdi(ij)=pb(k)
   60                   pdi(ij)=p(k)
                        k=l+if-1
                        do 70 l=if,i
                           k=k+1
                           ij=ij+1
                           padi(ij)=pa(k)
                           pbdi(ij)=pb(k)
   70                   pdi(ij)=p(k)
   80                continue
   90                continue
                     if(ii.eq.jj) goto  120
                     if(anader)then
                        call analyt(pdi,padi,pbdi,cdi,ndi,jf,jl,if,il
     1,                 eng)
                        do 100 k=1,3
                           dxyz(k,iii)=dxyz(k,iii)-eng(k)
  100                   dxyz(k,jjj)=dxyz(k,jjj)+eng(k)
                     else
                        if( .not. force) then
                           cdi(1,1)=cdi(1,1)+chnge2
                           cdi(2,1)=cdi(2,1)+chnge2
                           cdi(3,1)=cdi(3,1)+chnge2
                           call dhc(pdi,padi,pbdi,cdi,ndi,jf,jm,jl,if,im
     1,il,                 norbs,aa,1)
                        endif
                        do 110 k=1,3
                           if( force )then
                              cdi(k,2)=cdi(k,2)-chnge2
                              call dhc(pdi,padi,pbdi,cdi,ndi,jf,jm,jl,if
     1,im,il,                 norbs,aa,1)
                           endif
                           cdi(k,2)=cdi(k,2)+chnge
                           call dhc(pdi,padi,pbdi,cdi,ndi,jf,jm,jl,if,im
     1,il,                 norbs,ee,2)
                           cdi(k,2)=cdi(k,2)-chnge2
                           if( .not. force) cdi(k,2)=cdi(k,2)-chnge2
                           derv=(aa-ee)*23.061d0/chnge
                           dxyz(k,iii)=dxyz(k,iii)-derv
                           dxyz(k,jjj)=dxyz(k,jjj)+derv
  110                   continue
                     endif
  120       continue
  130 continue
      if(nnhco.ne.0)then
c
c   now add in molecular-mechanics correction to the h-n-c=o torsion
c
         del=1.d-8
         do 160 i=1,nnhco
            do 150 j=1,4
               do 140 k=1,3
                  coord(k,nhco(j,i))=coord(k,nhco(j,i))-del
                  call dihed(coord,nhco(1,i),nhco(2,i),nhco(3,i),nhco(4,
     1i),angle)
                  refh=htype(itype)*dsin(angle)**2
                  coord(k,nhco(j,i))=coord(k,nhco(j,i))+del*2.d0
                  call dihed(coord,nhco(1,i),nhco(2,i),nhco(3,i),nhco(4,
     1i),angle)
                  coord(k,nhco(j,i))=coord(k,nhco(j,i))-del
                  heat=htype(itype)*dsin(angle)**2
                  sum=(refh-heat)/(2.d0*del)
                  dxyz(k,nhco(j,i))=dxyz(k,nhco(j,i))-sum
  140          continue
  150       continue
  160    continue
      endif
      do 170 i=1,6
  170 lstor1(i)=lstor2(i)
      if (  .not. debug) return
      write(mfgw,'(//10x,''cartesian coordinate derivatives'',//3x,
     1''number  atom '',5x,''x'',12x,''y'',12x,''z'',/)')
      if(ncells.eq.1)then
         write(mfgw,'(2i6,f13.6,2f13.6)')
     1 (i,nat(i),(dxyz(j,i),j=1,3),i=1,numtot)
      elseif(large)then
         write(mfgw,'(2i6,f13.6,2f13.6)')
     1 (i,nat((i-1)/ncells+1),(dxyz(j,i),j=1,3),i=1,numtot)
      else
         write(mfgw,'(2i6,f13.6,2f13.6)')
     1 (i,nat((i-1)/ncells+1),(dxyz(j,i)+dxyz(j,i+1)+dxyz(j,i+2)
     2,j=1,3),i=1,numtot,3)
      endif
      if (anader) rewind 2
      return
      end
      subroutine delmol(coord,i,j,ni,nj,ia,id,ja,jd,ix,rij,tomb,isp)
      implicit REAL (a-h,o-z)
      dimension coord(3,25)
      common /derivs/ ds(16),dg(22),dr(100),tdx(3),tdy(3),tdz(3)
      common /cmpex/  g(22),tx(3),ty(3),tz(3)
      if(ni.gt.1.or.nj.gt.1) call mopro(coord,i,j,ix,rij,tomb,2)
      ib=max0(ia,id)
      jb=max0(ja,jd)
      do 10 k=ia,ib
         kk=k-ia
         do 10 l=k,ib
            ll=l-ia
            do 10 m=ja,jb
               mm=m-ja
               do 10 n=m,jb
                  nn=n-ja
                  isp=isp+1
                  if(nn.eq.0)then
                     if(ll.eq.0) then
c   (ss/ss)
                        dr(isp)=dg(1)
                     elseif(kk.eq.0) then
c   (sp/ss)
                        dr(isp)=dg(2)*tx(ll)+g(2)*tdx(ll)
                     else
c   (pp/ss)
                        dr(isp)=dg(3)*tx(kk)*tx(ll)
     1       +g(3)*(tdx(kk)*tx(ll)+tx(kk)*tdx(ll))
     2       +dg(4)*(ty(kk)*ty(ll)+tz(kk)*tz(ll))
     3       +g(4)*(tdy(kk)*ty(ll)+ty(kk)*tdy(ll)
     4             +tdz(kk)*tz(ll)+tz(kk)*tdz(ll))
                     endif
                  elseif(mm.eq.0) then
                     if(ll.eq.0) then
c   (ss/sp)
                        dr(isp)=dg(5)*tx(nn)+g(5)*tdx(nn)
                     elseif(kk.eq.0) then
c   (sp/sp)
                        dr(isp)=dg(6)*tx(ll)*tx(nn)
     1       +g(6)*(tdx(ll)*tx(nn)+tx(ll)*tdx(nn))
     2       +dg(7)*(ty(ll)*ty(nn)+tz(ll)*tz(nn))
     3       +g(7)*(tdy(ll)*ty(nn)+ty(ll)*tdy(nn)
     4             +tdz(ll)*tz(nn)+tz(ll)*tdz(nn))
                     else
c   (pp/sp)
                        dr(isp)=dg(8)*tx(kk)*tx(ll)*tx(nn)
     1       +g(8)*(tdx(kk)*tx(ll)*tx(nn)+tx(kk)*tdx(ll)*tx(nn)
     2             +tx(kk)*tx(ll)*tdx(nn))
     3       +dg(9)*(ty(kk)*ty(ll)+tz(kk)*tz(ll))*tx(nn)
     4       +g(9)*((tdy(kk)*ty(ll)+ty(kk)*tdy(ll)
     5              +tdz(kk)*tz(ll)+tz(kk)*tdz(ll))*tx(nn)
     6             +(ty(kk)*ty(ll)+tz(kk)*tz(ll))*tdx(nn))
     7       +dg(10)*(tx(kk)*(ty(ll)*ty(nn)+tz(ll)*tz(nn))
     8               +tx(ll)*(ty(kk)*ty(nn)+tz(kk)*tz(nn)))
     9       +g(10)*(tdx(kk)*(ty(ll)*ty(nn)+tz(ll)*tz(nn))
     1              +tdx(ll)*(ty(kk)*ty(nn)+tz(kk)*tz(nn))
     2              +tx(kk)*(tdy(ll)*ty(nn)+ty(ll)*tdy(nn)
     3                      +tdz(ll)*tz(nn)+tz(ll)*tdz(nn))
     4              +tx(ll)*(tdy(kk)*ty(nn)+ty(kk)*tdy(nn)
     5                      +tdz(kk)*tz(nn)+tz(kk)*tdz(nn)))
                     endif
                  elseif(ll.eq.0) then
c   (ss/pp)
                     dr(isp)=dg(11)*tx(mm)*tx(nn)
     1       +g(11)*(tdx(mm)*tx(nn)+tx(mm)*tdx(nn))
     2       +dg(12)*(ty(mm)*ty(nn)+tz(mm)*tz(nn))
     3       +g(12)*(tdy(mm)*ty(nn)+ty(mm)*tdy(nn)
     4              +tdz(mm)*tz(nn)+tz(mm)*tdz(nn))
                  elseif(kk.eq.0) then
c   (sp/pp)
                     dr(isp)=dg(13)*tx(ll)*tx(mm)*tx(nn)
     1       +g(13)*(tdx(ll)*tx(mm)*tx(nn)+tx(ll)*tdx(mm)*tx(nn)
     2              +tx(ll)*tx(mm)*tdx(nn))
     3       +dg(14)*tx(ll)*(ty(mm)*ty(nn)+tz(mm)*tz(nn))
     4       +g(14)*(tdx(ll)*(ty(mm)*ty(nn)+tz(mm)*tz(nn))
     5              +tx(ll)*(tdy(mm)*ty(nn)+ty(mm)*tdy(nn)
     6                      +tdz(mm)*tz(nn)+tz(mm)*tdz(nn)))
     7       +dg(15)*(ty(ll)*(ty(mm)*tx(nn)+ty(nn)*tx(mm))
     8               +tz(ll)*(tz(mm)*tx(nn)+tz(nn)*tx(mm)))
     9       +g(15)*(tdy(ll)*(ty(mm)*tx(nn)+ty(nn)*tx(mm))
     1              +tdz(ll)*(tz(mm)*tx(nn)+tz(nn)*tx(mm))
     2              +ty(ll)*(tdy(mm)*tx(nn)+ty(mm)*tdx(nn)
     3                      +tdy(nn)*tx(mm)+ty(nn)*tdx(mm))
     4              +tz(ll)*(tdz(mm)*tx(nn)+tz(mm)*tdx(nn)
     5                      +tdz(nn)*tx(mm)+tz(nn)*tdx(mm)))
                  else
c   (pp/pp)
                     dr(isp)=dg(16)*tx(kk)*tx(ll)*tx(mm)*tx(nn)
     1       +g(16)*(tdx(kk)*tx(ll)*tx(mm)*tx(nn)
     2              +tx(kk)*tdx(ll)*tx(mm)*tx(nn)
     3              +tx(kk)*tx(ll)*tdx(mm)*tx(nn)
     4              +tx(kk)*tx(ll)*tx(mm)*tdx(nn))
     5       +dg(17)*(ty(kk)*ty(ll)+tz(kk)*tz(ll))*tx(mm)*tx(nn)
     6       +g(17)*((tdy(kk)*ty(ll)+ty(kk)*tdy(ll)
     7               +tdz(kk)*tz(ll)+tz(kk)*tdz(ll))*tx(mm)*tx(nn)
     8              +(ty(kk)*ty(ll)+tz(kk)*tz(ll))
     9              *(tdx(mm)*tx(nn)+tx(mm)*tdx(nn)))
     1       +dg(18)*tx(kk)*tx(ll)*(ty(mm)*ty(nn)+tz(mm)*tz(nn))
     2       +g(18)*((tdx(kk)*tx(ll)+tx(kk)*tdx(ll))
     3                 *(ty(mm)*ty(nn)+tz(mm)*tz(nn))
     4              +tx(kk)*tx(ll)*(tdy(mm)*ty(nn)+ty(mm)*tdy(nn)
     5                             +tdz(mm)*tz(nn)+tz(mm)*tdz(nn)))
                     dr(isp)=dr(isp)
     1       +dg(19)*(ty(kk)*ty(ll)*ty(mm)*ty(nn)
     2                  +tz(kk)*tz(ll)*tz(mm)*tz(nn))
     3       +g(19)*(tdy(kk)*ty(ll)*ty(mm)*ty(nn)
     4                 +ty(kk)*tdy(ll)*ty(mm)*ty(nn)
     5                 +ty(kk)*ty(ll)*tdy(mm)*ty(nn)
     6                 +ty(kk)*ty(ll)*ty(mm)*tdy(nn)
     7                 +tdz(kk)*tz(ll)*tz(mm)*tz(nn)
     8                 +tz(kk)*tdz(ll)*tz(mm)*tz(nn)
     9                 +tz(kk)*tz(ll)*tdz(mm)*tz(nn)
     1                 +tz(kk)*tz(ll)*tz(mm)*tdz(nn))
     2       +dg(20)*(tx(kk)*(tx(mm)*(ty(ll)*ty(nn)+tz(ll)*tz(nn))
     3                          +tx(nn)*(ty(ll)*ty(mm)+tz(ll)*tz(mm)))
     4                  +tx(ll)*(tx(mm)*(ty(kk)*ty(nn)+tz(kk)*tz(nn))
     5                          +tx(nn)*(ty(kk)*ty(mm)+tz(kk)*tz(mm))))
c      to avoid compiler difficulties this is divided
                     temp1=         tdx(kk)*(tx(mm)*(ty(ll)*ty(nn)+tz(ll
     1)*tz(nn))                          +tx(nn)*(ty(ll)*ty(mm)+tz(ll)*t
     2z(mm)))                 +tdx(ll)*(tx(mm)*(ty(kk)*ty(nn)+tz(kk)*tz(
     3nn))                          +tx(nn)*(ty(kk)*ty(mm)+tz(kk)*tz(mm)
     4))                 +tx(kk)*(tdx(mm)*(ty(ll)*ty(nn)+tz(ll)*tz(nn))
     5                         +tdx(nn)*(ty(ll)*ty(mm)+tz(ll)*tz(mm)))
     6                 +tx(ll)*(tdx(mm)*(ty(kk)*ty(nn)+tz(kk)*tz(nn))
     7                         +tdx(nn)*(ty(kk)*ty(mm)+tz(kk)*tz(mm)))
                     temp2=            tx(kk)*(tx(mm)*(tdy(ll)*ty(nn)+ty
     1(ll)*tdy(nn)                                 +tdz(ll)*tz(nn)+tz(ll
     2)*tdz(nn))                         +tx(nn)*(tdy(ll)*ty(mm)+ty(ll)*
     3tdy(mm)                                 +tdz(ll)*tz(mm)+tz(ll)*tdz
     4(mm)))                 +tx(ll)*(tx(mm)*(tdy(kk)*ty(nn)+ty(kk)*tdy(
     5nn)                                 +tdz(kk)*tz(nn)+tz(kk)*tdz(nn)
     6)                         +tx(nn)*(tdy(kk)*ty(mm)+ty(kk)*tdy(mm)
     7                                 +tdz(kk)*tz(mm)+tz(kk)*tdz(mm)))
                     dr(isp)=dr(isp)+g(20)*(temp1+temp2)
                     dr(isp)=dr(isp)
     1       +dg(21)*(ty(kk)*ty(ll)*tz(mm)*tz(nn)
     2                 +tz(kk)*tz(ll)*ty(mm)*ty(nn))
     3       +g(21)*(tdy(kk)*ty(ll)*tz(mm)*tz(nn)
     4                 +ty(kk)*tdy(ll)*tz(mm)*tz(nn)
     5                 +ty(kk)*ty(ll)*tdz(mm)*tz(nn)
     6                 +ty(kk)*ty(ll)*tz(mm)*tdz(nn)
     7                 +tdz(kk)*tz(ll)*ty(mm)*ty(nn)
     8                 +tz(kk)*tdz(ll)*ty(mm)*ty(nn)
     9                 +tz(kk)*tz(ll)*tdy(mm)*ty(nn)
     1                 +tz(kk)*tz(ll)*ty(mm)*tdy(nn))
                     dr(isp)=dr(isp)
     1       +dg(22)*(ty(kk)*tz(ll)+tz(kk)*ty(ll))
     2                 *(ty(mm)*tz(nn)+tz(mm)*ty(nn))
     3       +g(22)*((tdy(kk)*tz(ll)+ty(kk)*tdz(ll)
     4                  +tdz(kk)*ty(ll)+tz(kk)*tdy(ll))
     5                 *(ty(mm)*tz(nn)+tz(mm)*ty(nn))
     6                 +(ty(kk)*tz(ll)+tz(kk)*ty(ll))
     7                 *(tdy(mm)*tz(nn)+ty(mm)*tdz(nn)
     8                  +tdz(mm)*ty(nn)+tz(mm)*tdy(nn)))
                  endif
   10 continue
      return
      end
      subroutine delri(dg,ni,nj,rr,del1)
      implicit REAL (a-h,o-z)
      dimension dg(22)
************************************************************************
*                                                                      *
*    on input ni = atomic number of first atom                         *
*             nj = atomic number of second atom                        *
*             rr = interatomic distance in bohrs                       *
*                                                                      *
************************************************************************
      common  /multip/  dd(107),qq(107),bdd(107,3)
      common /twoel3/ f03(107)
      common /cmporb/ natorb(107)
      common /alpha3/ alp3(153)
      common /keywrd/ keywrd
      common /numcal/ numcal
      save mindo3
      character*241 keywrd
      logical mindo3
      save icalcn
      data icalcn/0/
      if (icalcn.ne.numcal) then
         icalcn=numcal
         mindo3=(index(keywrd,'mindo').ne.0)
      endif
      a0=0.529167d0
      term=(27.21d0*del1)/(rr*a0*a0)
      da=dd(ni)
      db=dd(nj)
      qa=qq(ni)
      qb=qq(nj)
c   hydrogen-hydrogen
      aee=0.25d0*(1.0d0/bdd(ni,1)+1.0d0/bdd(nj,1))**2
      ee    =-rr/(dsqrt(rr**2+aee))**3
      dg(1)=term*ee
      if(natorb(ni).le.2.and.natorb(nj).le.2) return
      if(natorb(ni).le.2) go to 10
c   heavy atom-hydrogen
      ade=0.25d0*(1.0d0/bdd(ni,2)+1.0d0/bdd(nj,1))**2
      aqe=0.25d0*(1.0d0/bdd(ni,3)+1.0d0/bdd(nj,1))**2
      dze   = (rr+da)/(dsqrt((rr+da)**2+ade))**3
     1       -(rr-da)/(dsqrt((rr-da)**2+ade))**3
      qzze  =-(rr+2.0d0*qa)/(dsqrt((rr+2.0d0*qa)**2+aqe))**3
     1       -(rr-2.0d0*qa)/(dsqrt((rr-2.0d0*qa)**2+aqe))**3
     2       +(2.0d0*rr)/(dsqrt(rr**2+aqe))**3
      qxxe  =-(2.0d0*rr)/(dsqrt(rr**2+4.0d0*qa**2+aqe))**3
     1       +(2.0d0*rr)/(dsqrt(rr**2+aqe))**3
      dg(2)=-(term*dze)/2.0d0
      dg(3)=term*(ee+qzze/4.0d0)
      dg(4)=term*(ee+qxxe/4.0d0)
      if(natorb(nj).le.2) return
c   hydrogen-heavy atom
   10 aed=0.25d0*(1.0d0/bdd(ni,1)+1.0d0/bdd(nj,2))**2
      aeq=0.25d0*(1.0d0/bdd(ni,1)+1.0d0/bdd(nj,3))**2
      edz   = (rr-db)/(dsqrt((rr-db)**2+aed))**3
     1       -(rr+db)/(dsqrt((rr+db)**2+aed))**3
      eqzz  =-(rr-2.0d0*qb)/(dsqrt((rr-2.0d0*qb)**2+aeq))**3
     1       -(rr+2.0d0*qb)/(dsqrt((rr+2.0d0*qb)**2+aeq))**3
     2       +(2.0d0*rr)/(dsqrt(rr**2+aeq))**3
      eqxx  =-(2.0d0*rr)/(dsqrt(rr**2+4.0d0*qb**2+aeq))**3
     1       +(2.0d0*rr)/(dsqrt(rr**2+aeq))**3
      dg(5)=-(term*edz)/2.0d0
      dg(11)=term*(ee+eqzz/4.0d0)
      dg(12)=term*(ee+eqxx/4.0d0)
      if(natorb(ni).le.2) return
c   heavy atom-heavy atom
      add=0.25d0*(1.d0/bdd(ni,2)+1.d0/bdd(nj,2))**2
      adq=0.25d0*(1.d0/bdd(ni,2)+1.d0/bdd(nj,3))**2
      aqd=0.25d0*(1.d0/bdd(ni,3)+1.d0/bdd(nj,2))**2
      aqq=0.25d0*(1.d0/bdd(ni,3)+1.d0/bdd(nj,3))**2
      dxdx  =-(2.d0*rr)/(dsqrt(rr**2+(da-db)**2+add))**3
     1       +(2.d0*rr)/(dsqrt(rr**2+(da+db)**2+add))**3
      dzdz  =-(rr+da-db)/(dsqrt((rr+da-db)**2+add))**3
     1       -(rr-da+db)/(dsqrt((rr-da+db)**2+add))**3
     2       +(rr-da-db)/(dsqrt((rr-da-db)**2+add))**3
     3       +(rr+da+db)/(dsqrt((rr+da+db)**2+add))**3
      dzqxx = 2.d0*(rr+da)/(dsqrt((rr+da)**2+4.d0*qb**2+adq))**3
     1       -2.d0*(rr-da)/(dsqrt((rr-da)**2+4.d0*qb**2+adq))**3
     2       -2.d0*(rr+da)/(dsqrt((rr+da)**2+adq))**3
     3       +2.d0*(rr-da)/(dsqrt((rr-da)**2+adq))**3
      qxxdz = 2.d0*(rr-db)/(dsqrt((rr-db)**2+4.d0*qa**2+aqd))**3
     1       -2.d0*(rr+db)/(dsqrt((rr+db)**2+4.d0*qa**2+aqd))**3
     2       -2.d0*(rr-db)/(dsqrt((rr-db)**2+aqd))**3
     3       +2.d0*(rr+db)/(dsqrt((rr+db)**2+aqd))**3
      dzqzz = (rr+da-2.d0*qb)/(dsqrt((rr+da-2.d0*qb)**2+adq))**3
     1       -(rr-da-2.d0*qb)/(dsqrt((rr-da-2.d0*qb)**2+adq))**3
     2       +(rr+da+2.d0*qb)/(dsqrt((rr+da+2.d0*qb)**2+adq))**3
     3       -(rr-da+2.d0*qb)/(dsqrt((rr-da+2.d0*qb)**2+adq))**3
     4       +2.d0*(rr-da)/(dsqrt((rr-da)**2+adq))**3
     5       -2.d0*(rr+da)/(dsqrt((rr+da)**2+adq))**3
      qzzdz = (rr+2.d0*qa-db)/(dsqrt((rr+2.d0*qa-db)**2+aqd))**3
     1       -(rr+2.d0*qa+db)/(dsqrt((rr+2.d0*qa+db)**2+aqd))**3
     2       +(rr-2.d0*qa-db)/(dsqrt((rr-2.d0*qa-db)**2+aqd))**3
     3       -(rr-2.d0*qa+db)/(dsqrt((rr-2.d0*qa+db)**2+aqd))**3
     4       -2.d0*(rr-db)/(dsqrt((rr-db)**2+aqd))**3
     5       +2.d0*(rr+db)/(dsqrt((rr+db)**2+aqd))**3
      qxxqxx=-(2.d0*rr)/(dsqrt(rr**2+4.d0*(qa-qb)**2+aqq))**3
     1       -(2.d0*rr)/(dsqrt(rr**2+4.d0*(qa+qb)**2+aqq))**3
     2       +(4.d0*rr)/(dsqrt(rr**2+4.d0*qa**2+aqq))**3
     3       +(4.d0*rr)/(dsqrt(rr**2+4.d0*qb**2+aqq))**3
     4       -(4.d0*rr)/(dsqrt(rr**2+aqq))**3
      qxxqyy=-(4.d0*rr)/(dsqrt(rr**2+4.d0*qa**2+4.d0*qb**2+aqq))**3
     1       +(4.d0*rr)/(dsqrt(rr**2+4.d0*qa**2+aqq))**3
     2       +(4.d0*rr)/(dsqrt(rr**2+4.d0*qb**2+aqq))**3
     3       -(4.d0*rr)/(dsqrt(rr**2+aqq))**3
      qxxqzz=
     1   -2.d0*(rr-2.d0*qb)/(dsqrt((rr-2.d0*qb)**2+4.d0*qa**2+aqq))**3
     2   -2.d0*(rr+2.d0*qb)/(dsqrt((rr+2.d0*qb)**2+4.d0*qa**2+aqq))**3
     3     +2.d0*(rr-2.d0*qb)/(dsqrt((rr-2.d0*qb)**2+aqq))**3
     4     +2.d0*(rr+2.d0*qb)/(dsqrt((rr+2.d0*qb)**2+aqq))**3
     5     +(4.d0*rr)/(dsqrt(rr**2+4.d0*qa**2+aqq))**3
     6     -(4.d0*rr)/(dsqrt(rr**2+aqq))**3
      qzzqxx=
     1   -2.d0*(rr+2.d0*qa)/(dsqrt((rr+2.d0*qa)**2+4.d0*qb**2+aqq))**3
     2   -2.d0*(rr-2.d0*qa)/(dsqrt((rr-2.d0*qa)**2+4.d0*qb**2+aqq))**3
     3     +2.d0*(rr+2.d0*qa)/(dsqrt((rr+2.d0*qa)**2+aqq))**3
     4     +2.d0*(rr-2.d0*qa)/(dsqrt((rr-2.d0*qa)**2+aqq))**3
     5     +(4.d0*rr)/(dsqrt(rr**2+4.d0*qb**2+aqq))**3
     6     -(4.d0*rr)/(dsqrt(rr**2+aqq))**3
      qzzqzz=
     1   -(rr+2.d0*qa-2.d0*qb)/(dsqrt((rr+2.d0*qa-2.d0*qb)**2+aqq))**3
     2   -(rr+2.d0*qa+2.d0*qb)/(dsqrt((rr+2.d0*qa+2.d0*qb)**2+aqq))**3
     3   -(rr-2.d0*qa-2.d0*qb)/(dsqrt((rr-2.d0*qa-2.d0*qb)**2+aqq))**3
     4   -(rr-2.d0*qa+2.d0*qb)/(dsqrt((rr-2.d0*qa+2.d0*qb)**2+aqq))**3
     5     +2.d0*(rr-2.d0*qa)/(dsqrt((rr-2.d0*qa)**2+aqq))**3
     6     +2.d0*(rr+2.d0*qa)/(dsqrt((rr+2.d0*qa)**2+aqq))**3
     7     +2.d0*(rr-2.d0*qb)/(dsqrt((rr-2.d0*qb)**2+aqq))**3
     8     +2.d0*(rr+2.d0*qb)/(dsqrt((rr+2.d0*qb)**2+aqq))**3
     9     -(4.d0*rr)/(dsqrt(rr**2+aqq))**3
      dxqxz = 2.d0*(rr-qb)/(dsqrt((rr-qb)**2+(da-qb)**2+adq))**3
     1       -2.d0*(rr+qb)/(dsqrt((rr+qb)**2+(da-qb)**2+adq))**3
     2       -2.d0*(rr-qb)/(dsqrt((rr-qb)**2+(da+qb)**2+adq))**3
     3       +2.d0*(rr+qb)/(dsqrt((rr+qb)**2+(da+qb)**2+adq))**3
      qxzdx = 2.d0*(rr+qa)/(dsqrt((rr+qa)**2+(qa-db)**2+aqd))**3
     1       -2.d0*(rr-qa)/(dsqrt((rr-qa)**2+(qa-db)**2+aqd))**3
     2       -2.d0*(rr+qa)/(dsqrt((rr+qa)**2+(qa+db)**2+aqd))**3
     3       +2.d0*(rr-qa)/(dsqrt((rr-qa)**2+(qa+db)**2+aqd))**3
      qxyqxy=-(4.d0*rr)/(dsqrt(rr**2+2.d0*(qa-qb)**2+aqq))**3
     1       -(4.d0*rr)/(dsqrt(rr**2+2.d0*(qa+qb)**2+aqq))**3
     2       +(8.d0*rr)/(dsqrt(rr**2+2.d0*(qa**2+qb**2)+aqq))**3
      qxzqxz=-2.d0*(rr+qa-qb)/(dsqrt((rr+qa-qb)**2+(qa-qb)**2+aqq))**3
     1       +2.d0*(rr+qa+qb)/(dsqrt((rr+qa+qb)**2+(qa-qb)**2+aqq))**3
     2       +2.d0*(rr-qa-qb)/(dsqrt((rr-qa-qb)**2+(qa-qb)**2+aqq))**3
     3       -2.d0*(rr-qa+qb)/(dsqrt((rr-qa+qb)**2+(qa-qb)**2+aqq))**3
     4       +2.d0*(rr+qa-qb)/(dsqrt((rr+qa-qb)**2+(qa+qb)**2+aqq))**3
     5       -2.d0*(rr+qa+qb)/(dsqrt((rr+qa+qb)**2+(qa+qb)**2+aqq))**3
     6       -2.d0*(rr-qa-qb)/(dsqrt((rr-qa-qb)**2+(qa+qb)**2+aqq))**3
     7       +2.d0*(rr-qa+qb)/(dsqrt((rr-qa+qb)**2+(qa+qb)**2+aqq))**3
      dg(6)=(term*dzdz)/4.0d0
      dg(7)=(term*dxdx)/4.0d0
      dg(8)=-term*(edz/2.0d0+qzzdz/8.0d0)
      dg(9)=-term*(edz/2.0d0+qxxdz/8.0d0)
      dg(10)=-(term*qxzdx)/8.0d0
      dg(13)=-term*(dze/2.0d0+dzqzz/8.0d0)
      dg(14)=-term*(dze/2.0d0+dzqxx/8.0d0)
      dg(15)=-(term*dxqxz)/8.0d0
      dg(16)=term*(ee+eqzz/4.0d0+qzze/4.0d0+qzzqzz/16.0d0)
      dg(17)=term*(ee+eqzz/4.0d0+qxxe/4.0d0+qxxqzz/16.0d0)
      dg(18)=term*(ee+eqxx/4.0d0+qzze/4.0d0+qzzqxx/16.0d0)
      dg(19)=term*(ee+eqxx/4.0d0+qxxe/4.0d0+qxxqxx/16.0d0)
      dg(20)=(term*qxzqxz)/16.0d0
      dg(21)=term*(ee+eqxx/4.0d0+qxxe/4.0d0+qxxqyy/16.0d0)
      dg(22)=term*(qxxqxx-qxxqyy)/32.0d0
      return
      end
      subroutine denrot
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      common /densty/ p(mpack),pa(mpack),pb(mpack)
      common /cmpg/ geo(3,numatm)
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),
     1                nlast(numatm), norbs, nelecs,nalpha,nbeta,
     2                nclose,nopen,ndumy,fract
      common /elemts/ elemnt(107)
      common /scrach/ b(maxorb*maxorb), bondab(maxpar**2-maxorb*maxorb)
      common/iofile/mfgr,mfgw
************************************************************************
*
* denrot prints the density matrix as (s-sigma, p-sigma, p-pi) rather
*        than (s, px, py, pz).
*
************************************************************************
      dimension arot(9,9), c(3,5,5), pab(9,9), vect(9,9)
      dimension natom(maxorb)
      dimension xyz(3,numatm), irot(5,35), isp(9)
      character * 6 line(21)
      character elemnt*2,atorbs(9)*7,itext(maxorb)*7,jtext(maxorb)*2
      save atorbs, irot, isp
      data atorbs/'s-sigma','p-sigma','  p-pi ','  p-pi ','d-sigma',
     1            '  d-pi ','  d-pi ',' d-dell',' d-dell'/
***********************************************************************
* irot is a mapping list. for each element of arot 5 numbers are
* needed. these are, in order, first and second subscripts of arot,
* and first,second, and third subscripts of c, thus the first
* line of irot defines arot(1,1)=c(1,3,3)
*
***********************************************************************
      data irot/1,1,1,3,3, 2,2,2,4,3, 3,2,2,2,3, 4,2,2,3,3, 2,3,2,4,2,
     1          3,3,2,2,2, 4,3,2,3,2, 2,4,2,4,4, 3,4,2,2,4, 4,4,2,3,4,
     2          5,5,3,1,5, 6,5,3,4,3, 7,5,3,3,3, 8,5,3,2,3, 9,5,3,5,3,
     3          5,6,3,1,2, 6,6,3,4,2, 7,7,3,3,2, 8,6,3,2,2, 9,6,3,5,2,
     4          5,7,3,1,4, 6,7,3,4,4, 7,7,3,3,4, 8,7,3,2,4, 9,7,3,5,4,
     5          5,8,3,1,1, 6,8,3,4,1, 7,8,3,3,1, 8,8,3,2,1, 9,8,3,5,1,
     6          5,9,3,1,5, 6,9,3,4,5, 7,9,3,3,5, 8,9,3,2,5, 9,9,3,5,5/
      data isp /1,2,3,3,4,5,5,6,6/
      call gmetry(geo,xyz)
      iprt=0
      do 120 i=1,numat
         if=nfirst(i)
         il=nlast(i)
         ipq=il-if-1
         ii=ipq+2
         if(ii.eq.0)goto 120
         do 10 i1=1,ii
            j1=iprt+isp(i1)
            itext(j1)=atorbs(i1)
            jtext(j1)=elemnt(nat(i))
            natom(j1)=i
   10    continue
         iprt=j1
         if(ipq.ne.2)ipq=min0(max0(ipq,1),3)
         do 110 j=1,i
            jf=nfirst(j)
            jl=nlast(j)
            jpq=jl-jf-1
            jj=jpq+2
            if(jj.eq.0)goto 110
            if(jpq.ne.2)jpq=min0(max0(jpq,1),3)
            do 20 i1=1,9
               do 20 j1=1,9
   20       pab(i1,j1)=0.d0
            kk=0
            do 30 k=if,il
               kk=kk+1
               ll=0
               do 30 l=jf,jl
                  ll=ll+1
   30       pab(kk,ll)=p(l+(k*(k-1))/2)
            call coe(xyz(1,i),xyz(2,i),xyz(3,i),
     1                 xyz(1,j),xyz(2,j),xyz(3,j),ipq,jpq,c,r)
            do 40 i1=1,9
               do 40 j1=1,9
   40       arot(i1,j1)=0.d0
            do 50 i1=1,35
   50       arot(irot(1,i1),irot(2,i1))=
     1            c(irot(3,i1),irot(4,i1),irot(5,i1))
            l1=isp(ii)
            l2=isp(jj)
            do 60 i1=1,9
               do 60 j1=1,9
   60       vect(i1,j1)=-1.d0
            do 70 i1=1,l1
               do 70 j1=1,l2
   70       vect(i1,j1)=0.d0
            if(i.ne.j) then
               ij=max0(ii,jj)
               do 90 i1=1,ii
                  do 90 j1=1,jj
                     sum=0.d0
                     do 80 l1=1,ij
                        do 80 l2=1,ij
   80                sum=sum+arot(l1,i1)*pab(l1,l2)*arot(l2,j1)
   90          vect(isp(i1),isp(j1))=
     1                        vect(isp(i1),isp(j1))+sum**2
            endif
            k=0
            do  100 i1=if,il
               k=k+1
               l=0
               do 100 j1=jf,jl
                  l=l+1
  100       if(j1.le.i1) b(j1+(i1*(i1-1))/2)=vect(k,l)
  110    continue
  120 continue
c
c now to remove all the dead space in p, characterized by -1.0
c
      linear=(norbs*(norbs+1))/2
      l=0
      do 130 i=1,linear
         if(b(i).gt.-0.1) then
            l=l+1
            b(l)=b(i)
         endif
  130 continue
c
c   put atomic orbital valencies onto the diagonal
c
      do 160 i=1,iprt
         sum=0.d0
         ii=(i*(i-1))/2
         do 140 j=1,i
  140    sum=sum+b(j+ii)
         do 150 j=i+1,iprt
  150    sum=sum+b((j*(j-1))/2+i)
  160 b((i*(i+1))/2)=sum
      do 170 i=1,21
  170 line(i)='------'
      limit=(iprt*(iprt+1))/2
      kk=8
      na=1
  180 ll=0
      m=min0((iprt+1-na),6)
      ma=2*m+1
      m=na+m-1
      write(mfgw,'(/16x,10(1x,a7,3x))')(itext(i),i=na,m)
      write(mfgw,'(15x,10(2x,a2,i3,4x))')(jtext(i),natom(i),i=na,m)
      write (mfgw,'(20a6)') (line(k),k=1,ma)
      do 200 i=na,iprt
         ll=ll+1
         k=(i*(i-1))/2
         l=min0((k+m),(k+i))
         k=k+na
         if ((kk+ll).le.50) go to 190
         write (mfgw,'(''1'')')
         write(mfgw,'(/17x,10(1x,a7,3x))')(itext(n),n=na,m)
         write(mfgw,'( 17x,10(2x,a2,i3,4x))')(jtext(n),natom(n),n=na,m)
         write (mfgw,'(20a6)') (line(n),n=1,ma)
         kk=4
         ll=0
  190    write (mfgw,'(1x,a7,1x,a2,i3,10f11.6)')
     1   itext(i),jtext(i),natom(i),(b(n),n=k,l)
  200 continue
      if (l.ge.limit) go to 210
      kk=kk+ll+4
      na=m+1
      if ((kk+iprt+1-na).le.50) go to 180
      kk=4
      write (mfgw,'(''1'')')
      go to 180
  210 return
      end
      subroutine densit( c,mdim, norbs,ndubl, nsingl, fract, p,mode)
      implicit REAL (a-h,o-z)
      dimension p(*), c(mdim,*)
c***********************************************************************
c
c   densit computes the density matrix given the eigenvector matrix, and
c          information about the m.o. occupancy.
c
c  input:  c     = square eigenvector matrix, c is of size mdim by mdim
c                  and the eigenvectors are stored in the top left-hand
c                  corner.
c          norbs = number of orbitals
c          ndubl = number of doubly-occupied m.o.s ( =0 if uhf)
c          nsingl= number of singly or fractionally occupied m.o.s.
c          mode  = 2 if positron equivalent is not to be used
c
c   on exit: p   = density matrix
c
c***********************************************************************
c
c set up limits for sums
c  nl1 = begining of one electron sum
c  nu1 = end of same
c  nl2 = begining of two electron sum
c  nu2 = end of same
c
      norbs2=norbs/2
      nsingl=max0(ndubl,nsingl)
      if(ndubl.ne.0.and.nsingl .gt. norbs2 .and. mode.ne.2) then
c
c    take positron equivalent
c
         sign=-1.d0
         frac=2.d0-fract
         const=2.d0
         nl2=nsingl+1
         nu2=norbs
         nl1=ndubl+1
         nu1=nsingl
      else
c
c    take electron equivalent
c
         sign=1.d0
         frac=fract
         const=0.d0
         nl2=1
         nu2=ndubl
         nl1=ndubl+1
         nu1=nsingl
      endif
      l=0
      do 40 i=1,norbs
         do 30 j=1,i
            l=l+1
_IFN(blas)
            sum2=0.d0
            do 10 k=nl2,nu2
   10       sum2=sum2+c(i,k)*c(j,k)
_ELSE
      sum2=ddot(nu2-nl2+1,c(i,nl2),mdim,c(j,nl2),mdim)
_ENDIF
            sum2=sum2*2.d0
_IFN(blas)
            sum1=0.d0
            do 20 k=nl1,nu1
   20       sum1=sum1+c(i,k)*c(j,k)
_ELSE
      sum1=ddot(nu1-nl1+1,c(i,nl1),mdim,c(j,nl1),mdim)
_ENDIF
   30    p(l)=(sum2+sum1*frac)*sign
   40 p(l)=const+p(l)
      return
      end
      subroutine depvar (a,i,w,l)
      implicit REAL (a-h,o-z)
      dimension a(3,*)
c***********************************************************************
c
c  in subroutine haddon when m, the symmetry operation, is 18 depvar is
c  called. depvar should then contain a user-written symmetry operation.
c  see haddon to get the idea on how to write depvar.
c
c on input:
c           a = array of internal coordinates
c           i = address of reference atom
c on output:
c           l = 1 (if a bond-length is the dependent function)
c             = 2 (if an angle is the dependent function)
c             = 3 (if a dihedral angle is the dependent function)
c           w = value of the function
c
c  note:  it is the writer's responsibility to make certain that the
c         subroutine does not contain any errors!
c***********************************************************************
      common /keywrd/ keywrd
      common /numcal/ numcal
      common/iofile/mfgr,mfgw
      save fact
      character*241 keywrd
      save icalcn
      data icalcn/0/
      if (icalcn.ne.numcal) then
         icalcn=numcal
         fact=reada(keywrd,index(keywrd,'depvar'))
         write(mfgw,'(''  unit cell length ='',f14.7,
     1'' times bond length'')')fact
      endif
      w=a(1,i)*fact
      l=1
      return
      end
      subroutine deri0 (c,e,n, scalar,diiag,fract,nbo)
      implicit REAL (a-h,o-z)
      dimension c(n,n), e(n), scalar(*), diiag(*), nbo(3)
c
c     compute the diagonal dominant part of the super-matrix and
c     define the scalar coefficients applied on each row of the
c     super linear system in order to reduce the eigenvalue spectrum of
c     the electronic hessian,
c     thus speeding convergence of relaxation process in 'deri2'.
c  input
c     c(n,n)           : m.o. coefficients.
c     e(n)             : eigenvalues of fock matrix.
c     n                : number of m.o.
c     nbo(3)           : occupancy boundaries.
c     fract            : partial occupancy of 'open' shells.
c     scalar(minear)   : scale applied on each column and row of the
c                        symmetric super system.
c
      shift=2.36d0
c
c     dominant diagonal part of the super-matrix.
c     -------------------------------------------
      nopen=nbo(1)+nbo(2)
      const=1.d-3
      l=1
      if(nbo(2).gt.0 .and. nbo(1).gt.0) then
c        open-closed
         do 10 j=1,nbo(1)
            do 10 i=nbo(1)+1,nopen
               diiag(l)=(e(i)-e(j))/(2.d0-fract+const)
   10    l=l+1
      endif
      if(nbo(3).gt.0 .and. nbo(1).gt.0) then
c        virtual-closed
         do 20 j=1,nbo(1)
            do 20 i=nopen+1,n
               diiag(l)=(e(i)-e(j))/2.d0
   20    l=l+1
      endif
      if(nbo(3).ne.0 .and. nbo(2).ne.0) then
c        virtual-open
         do 30 j=nbo(1)+1,nopen
            do 30 i=nopen+1,n
               diiag(l)=(e(i)-e(j))/(fract+const)
   30    l=l+1
      endif
c
c     take scale factors as (shift-diag)**(-0.5) .
c     ------------------------------------------
      do 40 i=1,l-1
   40 scalar(i)=dsqrt(1.d0/dmax1(0.3d0*diiag(i),diiag(i)-shift))
      return
      end
      subroutine deri1(c,norbs,coord,number,work,grad
     1                 ,f,minear,fd,wmat,hmat,fmat)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      dimension wmat(mpack),hmat(mpack*2),fmat(mpack*2)
*********************************************************************
*
*     deri1 compute the non-relaxed derivative of the non-variationally
*     optimized wavefunction energy with respect to one cartesian
*     coordinate at a time
*                             and
*     compute the non-relaxed fock matrix derivative in m.o basis as
*     required in the relaxation section (routine 'deri2').
*
*   input
*     c(norbs,norbs) : m.o. coefficients.
*     coord  : cartesian coordinates array.
*     number : location of the required variable in coord.
*     work   : work array of size n*n.
*     wmat     : work arrays for d<pq|rs> (2-centers  a.o)
*   output
*     c,coord,number : not modified.
*     grad   : derivative of the heat of formation with respect to
*              coord(number), without relaxation correction.
*     f(minear) : non-relaxed fock matrix derivative with respect to
*              coord(number), expressed in m.o basis, scaled and
*              packed, off-diagonal blocks only.
*     fd     : idem but unscaled, diagonal blocks, c.i-active only.
*
************************************************************************
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm)
     1               ,nlast(numatm), ndumy1, nelecs,nalpha,nbeta
     2               ,nclose,nopen,ndumy,fract
      common /vector/ cdum(morb2),eigs(maxorb),wdum(morb2),eigb(maxorb)
      common /densty/ p(mpack), pa(mpack), pb(mpack)
      common /cibits/ nmos,lab,nelec,nbo(3)
      common /hmatrx/ h(mpack)
      common /xyijkl/ xy(nmeci,nmeci,nmeci,nmeci)
      common /civect/ conf(nmeci**4+nmeci**2+1)
      common /fokmat/ fdumy(mpack), scalar(mpack)
      common /nvomat/ diag(mpack/2)
      common /keywrd/ keywrd
      common /numcal/ numcal
      common/iofile/mfgr,mfgw
      dimension coord(*),c(norbs,norbs),work(norbs,norbs),f(*),fd(*)
      character keywrd*241
      logical debug
      save icalcn,debug,iprt,linear
      data icalcn /0/
c
      if(icalcn.ne.numcal) then
         debug=index(keywrd,'deri1').ne.0
         iprt=6
         linear=norbs*(norbs+1)/2
         icalcn=numcal
      endif
      if(debug) call timop('before deri1')
      step=1.d-3
c
c     2 points finite difference to get the integral derivatives
c     ----------------------------------------------------------
c     stored in hmat and wmat, without dividing by the step size.
c
      nati=(number-1)/3+1
      natx=number-3*(nati-1)
      call dhcore (coord,hmat,wmat,enucl2,nati,natx,step)
c
c hmat holds the one-electron derivatives of atom nati for direction
c      natx w.r.t. all other atoms
c wmat holds the two-electron derivatives of atom nati for direction
c      natx w.r.t. all other atoms
      step=0.5d0/step
c
c     non-relaxed fock matrix derivative in a.o basis.
c     ------------------------------------------------
c     stored in fmat, divided by step.
c
      call dcopy(linear,hmat,1,fmat,1)
      call dfock2 (fmat,p,pa,wmat,numat,nfirst,nmidle,nlast,nati)
c
c  fmat holds the one plus two - electron derivatives of atom nati for
c       direction natx w.r.t. all other atoms
c
c       derivative of the scf-only energy (i.e before c.i correction)
c
      grad=(helect(norbs,p,hmat,fmat)+enucl2)*step
c     take step into account in fmat
      do 10 i=1,linear
   10 fmat(i)=fmat(i)*step
c
c     right-hand side super-vector f = c' fmat c used in relaxation
c     -----------------------------------------------------------
c     stored in non-standard packed form in f(minear) and fd.
c     the supervector is the non-relaxed fock matrix derivative in
c     m.o basis: f(ij)= ( (c' * fock * c)(i,j) )   with i.gt.j .
c     f is scaled and packed in supervector form with
c                the consecutive following off-diagonal blocks:
c             1) open-closed  i.e. f(ij)=f(i,j) with i open & j closed
c                                  and i running faster than j,
c             2) virtual-closed same rule of ordering,
c             3) virtual-open   same rule of ordering.
c     fd is packed over the c.i-active m.o with
c                the consecutive diagonal blocks:
c             1) closed-closed   in canonical order, without the
c                                diagonal elements,
c             2) open-open       same rule of ordering,
c             3) virtual-virtual same rule of ordering.
c
c     part 1 : work(n,n) = fmat(n,n) * c(n,n)
      do 20 i=1,norbs
   20 call supdot (work(1,i),fmat,c(1,i),norbs,1)
c
c     part 2 : f(ij) =  (c' * work)(i,j) ... off-diagonal blocks.
      l=1
      if(nbo(2).ne.0 .and. nbo(1).ne.0) then
c        open-closed
         call mtxm (c(1,nbo(1)+1),nbo(2),work,norbs,f(l),nbo(1))
         l=l+nbo(2)*nbo(1)
      endif
      if(nbo(3).ne.0 .and. nbo(1).ne.0) then
c        virtual-closed
         call mtxm (c(1,nopen+1),nbo(3),work,norbs,f(l),nbo(1))
         l=l+nbo(3)*nbo(1)
      endif
      if(nbo(3).ne.0 .and. nbo(2).ne.0) then
c        virtual-open
         call mtxm (c(1,nopen+1),nbo(3),work(1,nbo(1)+1),norbs,f(l),nbo(
     12))
      endif
c     scale f according to the diagonal metric tensor 'scalar '.
      do 30 i=1,minear
   30 f(i)=f(i)*scalar(i)
      if(debug)then
         write(mfgw,*)' f in deri1'
         j=min0(20,minear)
         write(mfgw,'(5f12.6)')(f(i),i=1,j)
      endif
c
c     part 3 : super-vector fd, c.i-active diagonal blocks, unscaled.
      l=1
      nend=0
      do 50 loop=1,3
         ninit=nend+1
         nend =nend+nbo(loop)
         n1=max0(ninit,nelec+1   )
         n2=min0(nend ,nelec+nmos)
         if(n2.lt.n1) go to 50
         do 40 i=n1,n2
            if(i.gt.ninit) then
               call mxm (c(1,i),1,work(1,ninit),norbs,fd(l),i-ninit)
               l=l+i-ninit
            endif
   40    continue
   50 continue
c
c     non-relaxed c.i correction to the energy derivative.
c     ----------------------------------------------------
c
c     c.i-active fock eigenvalues derivatives, stored in fd(continued).
      lcut=l
      do 60 i=nelec+1,nelec+nmos
         fd(l)=ddot(norbs,c(1,i),1,work(1,i),1)
   60 l=l+1
c
c     c.i-active 2-electrons integrals derivatives. stored in xy.
c   fmat is used here as scratch space
c
      call dijkl1 (c(1,nelec+1),norbs,nati,wmat,fmat,hmat,fmat)
      do 70 i=1,nmos
         do 70 j=1,nmos
            do 70 k=1,nmos
               do 70 l=1,nmos
   70 xy(i,j,k,l)=xy(i,j,k,l)*step
c
c     build the c.i matrix derivative, stored in wmat.
      call mecid (fd(lcut-nelec),gse,eigb,work)
      if(debug)then
         write(mfgw,*)' gse:',gse
c#      write(mfgw,*)' eigb:',(eigb(i),i=1,10)
c#      write(6,*)' work:',(work(i,1),i=1,10)
      endif
      call mecih (work,wmat,nmos,lab)
c
c     non-relaxed c.i contribution to the energy derivative.
      call supdot (work,wmat,conf,lab,1)
      grad=(grad+ddot(lab,conf,1,work,1))*23.061d0
      if(debug) then
         write(iprt,'('' * * * gradient component number'',i4)')number
         write(iprt,'('' non-relaxed c.i-active fock eigenvalues '',
     1                ''derivatives (e.v.)'')')
         write(iprt,'(8f10.4)')(fd(lcut-1+i),i=1,nmos)
         write(iprt,'('' non-relaxed 2-electrons derivatives (e.v.)''/
     1''    i    j    k    l       d<i(1)j(1)|k(2)l(2)>'')')
         do 80 i=1,nmos
            do 80 j=1,i
               do 80 k=1,i
                  ll=k
                  if(k.eq.i) ll=j
                  do 80 l=1,ll
   80    write(iprt,'(4i5,f20.10)')
     1              nelec+i,nelec+j,nelec+k,nelec+l,xy(i,j,k,l)
         write(iprt,'('' non-relaxed gradient component'',f10.4,
     1'' kcal/mole'')')grad
         call timop('after deri1')
      endif
      return
      end
      subroutine deri2(c,e,norbs, minear, f, fd, fci, ninear,
     1nvar,work,b,nw2,grad,ab,nw3,fb,throld)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      dimension c(norbs,norbs),e(norbs),work(norbs,norbs)
     1         ,f(minear,mpack/minear)
     2         ,fd(ninear,(5*maxpar+mpack)/ninear)
     3         ,fci(ninear,maxorb/ninear)
     4         ,b(minear,(6*mpack-5*maxpar)/minear)
     5         ,ab(minear,6*mpack/minear),fb(nvar,6*mpack/nvar)
     6         ,grad(nvar)
*********************************************************************
*
*     deri2 compute the relaxation part of the derivatives of the
*     non-variationally optimized energy with respect to two
*     coordinates at a time. this is done in three steps.
*
*     the m.o derivatives are solution {x} of a linear system
*                        (d-a) * x = f
*     where d is a diagonal super-matrix of fock eigenvalue differences
*     and a is a super-matrix of 2-electrons integrals in m.o basis.
*     such a system is too large to be inverted directly thus one must
*     uses a relaxation method to get a reasonable estimate of {x}.
*     this requires a basis set {b} to be generated iteratively, after
*     which we solve by direct inversion the linear system projected
*     in this basis {b}. it works quickly but does require a large
*     core memory.
*
*     use a formalism with fock operator thus avoiding the explicit
*     computation (and storage) of the super-matrix a.
*     the semiempirical methods do not involve large c.i calculations.
*     therefore for each gradient component we build the c.i matrix
*     derivative from the m.o. integrals <ij|kl> and fock eigenvalues
*     derivatives, thus providing the relaxation contribution to the
*     gradient without computation and storage of the 2nd order density
*     matrix.
*
*   step 1)
*     use the previous b and the new f vectors to build an initial
*     basis set b.
*   step 2)
*     because the electronic hessian (d-a) is the same for each
*     derivative, we only need to enlarge iteratively the orthonormal
*     basis set {b} used to invert the projected hessian.
*     (derived from the largest residual vector ).
*     this section is carried out in the diagonal metric 'scalar'.
*   step 3) ... loop on the geometric variable :
* 3.1 for each geometric variable, get the m.o derivatives in a.o.
* 3.2 compute the fock eigenvalues and 2-electron integral relaxation.
* 3.3 build the electronic relaxation contribution to the c.i matrix
*     and get the associated eigenstate derivative with respect to
*     the geometric variable.
*
*   input
*     c(norbs,norbs) : m.o. coefficients, in column.
*     e(norbs)       : eigenvalues of the fock matrix.
*     minear         : number of non redundant rotation of the m.o.
*     f(minear,nvar) : non-relaxed fock matrices derivatives
*                    in m.o basis, off-diagonal blocks.
*     fd(ninear,nvar): idem, diagonal blocks, c.i-active only.
*     work           : work array of size n*n.
*     b(minear,nbsize) : initial orthonormalized basis set {b}.
*     grad(nvar)     : gradient vector before relaxation correction.
*     ab(minear,*): storage for the (d-a) * b vectors.
*     fb(nvar,*)  : storage for the matrix product f' * b.
*   output
*     grad   : derivative of the heat of formation with respect to
*              the nvar optimized variables.
*
************************************************************************
      common /fokmat/ fdumy(mpack), scalar(mpack)
      common /nvomat/ diag(mpack/2)
      common /work3/ dijkl(mpack*4)
      common /xyijkl/ xy(nmeci,nmeci,nmeci,nmeci)
      common /civect/ vectci(nmeci**2),babinv(nmeci**3),
     4bcoef(nmeci**4-nmeci**3+1)
      common /keywrd/ keywrd
      common /cibits/ nmos,lab,nelec,nbo(3)
      common /work2/ bab(mmci,mmci),
     +dumy(nmeci**4+2*nmeci**3+nmeci**2-mmci*mmci)
      common /numcal/ numcal
      common/iofile/mfgr,mfgw
      dimension lconv(60)
      logical fail, lconv, debug, lbab
      character keywrd*241
      save icalcn,debug,linear,nopen,maxite,nfirst
      data icalcn/0/
c
c     * * * step 1 * * *
c     build up the initial orthonormalized basis.
c
      if(icalcn.ne.numcal) then
         debug=index(keywrd,' deri2').ne.0
         icalcn=numcal
         linear=norbs*(norbs+1)/2
         nopen =nbo(1)+nbo(2)
         maxite=min0(60,idint(dsqrt(nmeci**3.d0)),mpack*2/nvar)
         maxite=min0(maxite,min0(nw2,nw3)/max0(minear,ninear))
         nfirst=min0(nvar,1+maxite/4)
      endif
      fail=.false.
      nbsize=0
      time1=secmop()
c
c        normal case. use f only.
c
      call deri21 (f,nvar,minear,nfirst,work
     1               ,work(nvar*nvar+1,1),b,nlast)
      lbab=.false.
      nfirst=nbsize+1
      nlast=nbsize+nlast
      do 10 i=1,nvar
   10 lconv(i)=.false.
c
c     * * * step 2 * * *
c     relaxation method with optimum increase of the basis set.
c     ---------------------------------------------------------
c
c     update ab ,fci and bab. (bab is symmetric)
   20 do 30 j=nfirst,nlast
         call deri22(c,b(1,j),work,norbs,work,ab(1,j),minear,
     1            fci(1,j))
         call mxm(ab(1,j),1,b,minear,bab(1,j),nlast)
         do 30 i=1,nfirst-1
   30 bab(j,i)=bab(i,j)
c     invert bab, store in babinv.
   40 l=0
      do 50 j=1,nlast
         do 50 i=1,nlast
            l=l+1
   50 babinv(l)=bab(i,j)
      call osinv (babinv,nlast,deter)
      if (deter.eq.0) then
      if(nlast.ne.1)then
         write(mfgw,'('' the bab matrix of order'',i3,
     1   '' is singular in deri2''/
     2   '' the relaxation is stopped at this point.'')')nlast
         endif
         lbab=.true.
         nlast=nlast-1
         go to 40
      endif
      if (.not.lbab) then
c        update f * b'
         call mtxm (f,nvar,b(1,nfirst),minear,fb(1,nfirst),nlast-nfirst+
     11)
      endif
c     new solutions in basis b , stored in bcoef(nvar,*).
c     bcoef = babinv * fb'
      if(nlast.ne.0)call mopm(babinv,nlast,fb,nlast,bcoef,nvar)
      if(lbab) go to 90
c
c     select the next basis vector as the largest residual vector.
c     and test for convergence on the largest residue.
      nres=0
      test2=0.d0
      do 70 ivar=1,nvar
         if(lconv(ivar)) go to 70
c     get one not-converged residual vector (# ivar),
c     stored in work.
         call mxm  (ab,minear,bcoef(nlast*(ivar-1)+1),nlast,work,1)
         test=0.d0
         do 60 i=1,minear
            work(i,1)=f(i,ivar)-work(i,1)
   60    test=dmax1(dabs(work(i,1)),test)
         if(debug)write(mfgw,*)' test:',test
         test2=dmax1(test2,test)
         if (test.le.throld) then
            lconv(ivar)=.true.
            if(nvar.eq.1) goto 90
            go to 70
         elseif (nlast+nres.eq.maxite-1) then
c        running out of storage
            if (test.le.dmax1(0.01d0,throld*2)) then
               lconv(ivar)=.true.
               go to 70
            endif
         else if (nlast+nres.eq.maxite) then
c
c   completely out of storage
c
            fail=nres.eq.0
            go to 80
         else
c        store the following residue in ab(continued).
            nres=nres+1
            call dcopy(minear,work,1,ab(1,nlast+nres),1)
         endif
   70 continue
   80 if (nres.eq.0) go to 90
c     find optimum following subset, add to b and loop.
      nfirst=nlast+1
      call deri21(ab(1,nfirst),nres,minear,nres,work
     1           ,work(nres*nres+1,1),b(1,nfirst),nadd)
      nlast=nlast+nadd
      go to 20
c
c     convergence achieved or halted.
c     -------------------------------
c
   90 nbsze=nbsize
      if(debug.or.lbab) then
         write(mfgw,'('' relaxation ended in deri2 after'',i3,
     1   '' cycles''/'' required convergence threshold on residuals =''
     2   ,f12.9/'' highest residual on'',i3,'' gradient components = ''
     3   ,f12.9)')nlast-nbsze,throld,nvar,test2
      if(nlast-nbsze.eq.0)then
      write(mfgw,'(a)')
     +' analytic c.i. derivatives do not work for this system'
      write(mfgw,'(a)')' add keyword ''noanci'' and resubmit'
_IF(ipsc,tools)
      call pend
_ELSE
      stop
_ENDIF
      endif
         time2=secmop()
      write(mfgw,'('' elapsed time in relaxation'',f15.3,'' second'')
     1              ')time2-time1
      endif
      if(fail) then
      write(mfgw,'(a)')' analytical derivatives too inaccurate for this'
      write(mfgw,'(a)')' work.  job stopped here.  see manual for ideas'
_IF(ipsc,tools)
         call pend
_ELSE
         stop
_ENDIF
      else
         nbsize=0
c        unscaled solution supervectors, stored in f.
         if(nlast.ne.0)call mxm (b,minear,bcoef,nlast,f,nvar)
         do 100 j=1,nvar
            do 100 i=1,minear
  100    f(i,j)=f(i,j)*scalar(i)
c        fock matrix diagonal blocks over c.i-active m.o.
c        stored in fb.
         if(nlast.ne.0)call mxm (fci,ninear,bcoef,nlast,fb,nvar)
      endif
c
c     * * * step 3 * * *
c     final loop (390) on the geometric variables.
c     --------------------------------------------
c
      do 130 ivar=1,nvar
c
c     c.i-active m.o derivatives into the m.o basis,
c         returned in ab (n,nelec+1,...,nelec+nmos).
c     c.i-active eigenvalues derivatives,
c         returned in bcoef(nelec+1,...,nelec+nmos).
         call deri23 (f(1,ivar),minear,fd(1,ivar),ninear,e
     1            ,fb(ninear*(ivar-1)+1,1),ab,bcoef,norbs)
c
c     derivatives of the 2-electrons integrals over c.i-active m.o.
c     stored in /xyijkl/.
         call dijkl2 (ab(norbs*nelec+1,1),norbs,nmos,dijkl,xy,nmeci)
         if(debug) then
         write(mfgw,'('' * * * gradient component number'',i4)')ivar
            if(index(keywrd,'debu').ne.0) then
            write(mfgw,'('' c.i-active m.o. derivatives in m.o basis'',
     1                   '', in row.'')')
               l=norbs*nelec+1
               do 110 i=nelec+1,nelec+nmos
                  write(mfgw,'(8f10.4)')(ab(k,1),k=l,l+norbs-1)
  110          l=l+norbs
            endif
         write(mfgw,'('' c.i-active fock eigenvalues relaxation (e.v.)''
     1               )')
         write(mfgw,'(8f10.4)')(bcoef(i),i=nelec+1,nelec+nmos)
         write(mfgw,'('' 2-electron integrals relaxation (e.v.)''/
     1''    i    j    k    l       d<i(1)j(1)|k(2)l(2)> relaxation only'
     2')
     3')
            do 120 i=1,nmos
               do 120 j=1,i
                  do 120 k=1,i
                     ll=k
                     if(k.eq.i) ll=j
                     do 120 l=1,ll
  120       write(mfgw,'(4i5,f20.10)')
     1              nelec+i,nelec+j,nelec+k,nelec+l,xy(i,j,k,l)
         endif
c
c     build the c.i matrix derivative, stored in ab.
         call mecid (bcoef,gse,work(lab+1,1),work)
         call mecih (work,ab,nmos,lab)
c     relaxation correction to the c.i energy derivative.
         call supdot (work,ab,vectci,lab,1)
         grad(ivar)=grad(ivar)+ddot(lab,vectci,1,work,1)*23.061d0
         if (debug) then
         write(mfgw,'('' relaxation of the gradient component'',f10.4,
     1'' kcal/mole'')')  ddot(lab,vectci,1,work,1)*23.061d0
         endif
c
c     the end .
  130 continue
      if(debug)
     1write(mfgw,'('' elapsed time in c.i-energy relaxation'',f15.3,
     2             '' second'')')secmop()-time2
      return
      end
      subroutine deri21 (a,nvar,minear,nfirst,vnert,pnert
     1                  ,b,ncut)
      implicit REAL (a-h,o-z)
      dimension a(minear,nvar),vnert(nvar,nvar),pnert(nvar),b(minear,*)
************************************************************************
*
*     least-square analysis of a set of nvar points {a} :
*
*     produce a subset of ncut orthonormalized vectors b, optimum in a
*     least-square sense with respect to the initial space {a}.
*     each new hierarchized vector b extracts a maximum percentage from
*     the remaining dispersion of the set {a} out of the previous
*     {b} subspace.
*   input
*     a(minear,nvar): original set {a}.
*     nfirst        : maximum allowed size of the basis b.
*   output
*     vnert(nvar,nvar)  : eigenvectors of a'* a.
*     pnert(nvar)     : square root of the associated eigenvalues
*                     in decreasing order.
*     b(minear,ncut): optimum orthonormalized subset {b}.
*
************************************************************************
      dimension work(4)
c
c     vnert = a' * a
      cutoff=0.85d0
      sum2=0.d0
      call mtxmc(a,nvar,a,minear,work)
      do 10 i=1,(nvar*(nvar+1))/2
  10      work(i)=-work(i)
c     diagonalize in decreasing order of eigenvalues
      if(dabs(work(1)).lt.1.d-28 .and. nvar.eq.1)then
      pnert(1)=dsqrt(-work(1))
      vnert(1,1)=1.d0
      work(1)=1.d15
      ncut=1
      goto 50
      else
      call hqrii(work,nvar,nvar,pnert, vnert)
c     find ncut according to cutoff, build work = vnert * (pnert)**-0.5
      sum=0.d0
      do 20 i=1,nvar
   20 sum=sum-pnert(i)
      l=1
      do 40 i=1,nfirst
         sum2=sum2-pnert(i)/sum
         pnert(i)=dsqrt(-pnert(i))
         do 30 j=1,nvar
            work(l)=vnert(l,1)/pnert(i)
   30    l=l+1
         if(sum2.ge.cutoff) then
            ncut=i
            go to 50
         endif
   40 continue
      ncut=nfirst
c     orthonormalized basis
c     b(minear,ncut) = a(minear,nvar)*work(nvar,ncut)
      endif
   50 call mxm (a,minear,work,nvar,b,ncut)
      return
      end
      subroutine deri22 (c,b,work,norbs,foc2,ab,minear,fci)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      dimension c(norbs,norbs), b(*), work(norbs,norbs), foc2(*),
     1ab(*), fci(*)
************************************************************************
*  1) build the 2-electron fock matrix depending on b as follows :
*     dp = c * scale*b * c' ...  dp density matrix 'derivative',
*     foc2 = 0.5 * trace ( dp * (2<j>-<k>) ) done in fock2 & fock1.
*  2) half-transform onto m.o. basis : dpt =  foc2 * c
*     and compute diagonal blocks elements of c' * foc2, extracting
*     in fci elements over c.i-active m.o only.
*  3) compute supervector ab = (diag + a) * b defined by the matrix :
*     ab(i,j)= ( diag(i,j)*b(i,j)+dpt(i,j) )*scalar(i,j)  with i.gt.j,
*     diag(i,j)=(eigs(i)-eigs(j))/(o(j)-o(i)) >0, o occupancy numbers,
*     eigs eigenvalues of fock operator with eigenvectors c in a.o.
*
*   input
* c(norbs,norbs)   : m.o. eigenvectors (columnwise).
* b(*)             : b supervector packed by off-diagonal blocks, scaled
* work(*)          : work area of size n*n.
* norbs            : number of m.o.s
* nelec,nmos       : last frozen core m.o. , c.i-active band length.
*           in common
* diag,scalar as defined in 'deri0'.
*   output
* foc2(*)       : 2-electron fock matrix, packed canonical.
* ab(*)         : antisymmetric matrix packed in supervector form with
*                 the consecutive following blocks:
*              1) open-closed  i.e. b(ij)=b(i,j) with i open & j closed
*                 and i running faster than j,
*              2) virtual-closed same rule of ordering,
*              3) virtual-open   same rule of ordering.
* fci(*)        : fock diagonal blocks elements over c.i-active m.o.
*            foc2 can be equivalenced with work in the calling sequence.
************************************************************************
c
c  note: norbs and nord are the same address.  the name norbd is not
c        used here.
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm)
     1               ,nlast(numatm),norbd,nelecs,nalpha,nbeta
     2               ,nclose,nopen,ndumy,fract
      common /wmatrc/ wj(n2elec),wk(n2elec)
      common /densty/ pdumy(mpack*2), dpa(mpack)
      common /fokmat/ fdumy(mpack), scalar(mpack)
      common /nvomat/ diag(mpack/2)
      common /work1/ fdumy2(15*npulay), dp(6*npulay)
      common /cibits/ nmos,lab,nelec,nbo(3)
      dimension w(n2elec)
      equivalence (w,wj)
c
      linear=(norbs*(norbs+1))/2
c
c     derivative of the density matrix in dp (packed,canonical).
c     ----------------------------------------------------------
c     dp = c * b * c' .
c
c     step 0 : unscale vector b.
      do 10 i=1,minear
   10 b(i)=b(i)*scalar(i)
c
c     step 1 : work = c * b    .  dp temporary array.
      l=1
      if(nbo(2).ne.0 .and. nbo(1).ne.0) then
c        open-closed
         call mxm(c(1,nbo(1)+1),norbs,b(l),nbo(2),work,nbo(1))
c        closed-open
         call mopm(c,norbs,b(l),nbo(1),work(1,nbo(1)+1),nbo(2))
         l=l+nbo(2)*nbo(1)
      endif
      if(nbo(3).ne.0 .and. nbo(1).ne.0) then
c        virtual-closed
         if(l.gt.1) then
            call mxm(c(1,nopen+1),norbs,b(l),nbo(3),dp,nbo(1))
            do 20 i=1,norbs*nbo(1)
   20       work(i,1)=work(i,1)+dp(i)
         else
            call mxm(c(1,nopen+1),norbs,b(l),nbo(3),work,nbo(1))
         endif
c        closed-virtual
         call mopm(c,norbs,b(l),nbo(1),work(1,nopen+1),nbo(3))
         l=l+nbo(3)*nbo(1)
      endif
      if(nbo(3).ne.0 .and. nbo(2).ne.0) then
c        virtual-open
         call mxm(c(1,nopen+1),norbs,b(l),nbo(3),dp,nbo(2))
         j=norbs*nbo(1)
         do 30 i=1,norbs*nbo(2)
   30    work(j+i,1)=work(j+i,1)+dp(i)
c        open-virtual
         call mopm(c(1,nbo(1)+1),norbs,b(l),nbo(2),dp,nbo(3))
         j=norbs*nopen
         do 40 i=1,norbs*nbo(3)
   40    work(j+i,1)=work(j+i,1)+dp(i)
      endif
c
c     step 2 : dp= work * c'   with dp packed,canonical.
      l=0
      do 50 i=1,norbs
         do 50 j=1,i
            l=l+1
   50 dp(l)=ddot(norbs,work(i,1),norbs,c(j,1),norbs)
c
c     2-electron fock matrix build with the density matrix derivative.
c     ----------------------------------------------------------------
c     returned in foc2 (packed canonical).
      do 60 i=1,linear
         foc2(i)=0.d0
   60 dpa(i)=0.5d0*dp(i)
      call fock2 (foc2,dp,dpa,w,wj,wk,numat,nfirst,nmidle,nlast)
      call fock1 (foc2,dp,dpa,dpa)
c
c     build dp and extract fci.
c     --------------------------
c
c     dp(norbs,nend) = foc2(norbs,norbs) * c(norbs,nend).
      nend=max0(nopen,nelec+nmos)
      l=1
      do 70 i=1,nopen
         call supdot (dp(l),foc2,c(1,i),norbs,1)
   70 l=l+norbs
c     extract fci
      l=1
      nend=0
      do 90 loop=1,3
         ninit=nend+1
         nend =nend+nbo(loop)
         n1=max0(ninit,nelec+1   )
         n2=min0(nend ,nelec+nmos)
         if(n2.lt.n1) go to 90
         do 80 i=n1,n2
            if(i.gt.ninit) then
               call mxm (c(1,i),1,dp(norbs*(ninit-1)+1),norbs,fci(l),i-n
     1init)
               l=l+i-ninit
            endif
   80    continue
   90 continue
      do 100 i=nelec+1,nelec+nmos
         fci(l)=-ddot(norbs,c(1,i),1,dp(norbs*(i-1)+1),1)
  100 l=l+1
c
c     new supervector ab = (diag + c'* foc2 * c) * b , scaled.
c     --------------------------------------------------------
c
c     part 1 : ab(i,j) = (c' * dp)(i,j) done by blocks.
      l=1
      if(nbo(2).ne.0 .and. nbo(1).ne.0) then
         call mtxm (c(1,nbo(1)+1),nbo(2),dp,norbs,ab(l),nbo(1))
         l=l+nbo(2)*nbo(1)
      endif
      if(nbo(3).ne.0 .and. nbo(1).ne.0) then
         call mtxm (c(1,nopen+1),nbo(3),dp,norbs,ab(l),nbo(1))
         l=l+nbo(3)*nbo(1)
      endif
      if(nbo(3).ne.0 .and. nbo(2).ne.0)
     1call mtxm(c(1,nopen+1),nbo(3),dp(norbs*nbo(1)+1),
     2norbs,ab(l),nbo(2))
c
c     part 2 : ab = scale * (d * b + ab) and rescale basis vector b.
      do 110 i=1,minear
         ab(i)=(diag(i)*b(i)+ab(i))*scalar(i)
  110 b(i)=b(i)/scalar(i)
      return
      end
      subroutine deri23 (f,minear,fd,ninear,e,fci,cmo,emo,norbs)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      dimension f(*), fd(*), e(*), fci(*), cmo(norbs,*), emo(*)
***********************************************************************
*  1) unpack the c.i-active m.o. derivatives in m.o. basis,
*     diagonal blocks included.
*  2) extract the fock eigenvalues relaxation over c.i-active m.o.
*   input
*     f(minear)   : unscaled solutions vector in m.o. basis,
*                   off-diagonal blocks packed as defined in 'deri21'.
*     fd(ninear)  : diagonal blocks of non-relaxed fock matrix
*                   as defined in 'deri1'.
*     e(norbs)    : fock eigenvalues.
*     fci(ninear) : diagonal blocks of relaxation of the fock matrix.
*     norbs       : number of m.o
*     nelec,nmos  : # of last frozen core m.o , c.i-active band length.
*   output
*     cmo(n,nelec+1,...,nelec+nmos): c.i-active m.o derivatives
*                                  in m.o basis.
*     emo(  nelec+1,...,nelec+nmos): c.i-active fock eigenvalue relaxati
*
***********************************************************************
      common /fokmat/ fdumy(mpack), scalar(mpack)
      common /nvomat/ diag(mpack/2)
      common /cibits/ nmos,lab,nelec,nbo(3)
      common /molkst/ ndumy(4*numatm+8),fract
c
      nopen  =nbo(1)+nbo(2)
      const=1.d-3
c
c     part 1.
c     -------
c     compute and unpack diagonal blocks, diagonal terms included,
c     according to cmo(i,j) = (fd(i,j)-fci(i,j))/(e(i)-e(j))
c     and taking   cmo(i,j)=0 if e(i)=e(j) (threshold 1d-4 ev),
c                             i.e when m.o. degeneracy occurs.
      l=1
      nend=0
      do 30 loop=1,3
         ninit=nend+1
         nend =nend+nbo(loop)
         n1=max0(ninit,nelec+1   )
         n2=min0(nend ,nelec+nmos)
         if(n2.lt.n1) go to 30
         do 20 i=n1,n2
            if(i.gt.ninit) then
               do 10 j=ninit,i-1
                  diffe=e(i)-e(j)
                  if(dabs(diffe).gt.1.d-4) then
                     com=(fd(l)-fci(l))/diffe
                  else
                     com=0.d0
                  endif
                  cmo(i,j)=-com
                  cmo(j,i)= com
   10          l=l+1
            endif
   20    cmo(i,i)= 0.d0
   30 continue
c
c     c.i-active eigenvalues relaxation.
      call dcopy(nmos,fci(l),1,emo(nelec+1),1)
c
c     part 2.
c     -------
c     unpack the antisymmetric matrix f in cmo, (off-diagonal blocks).
c
      l=1
      if(nbo(2).gt.0 .and. nbo(1).gt.0) then
c        open-closed
         scal=1.d0/(2.d0-fract+const)
         do 40 j=1       ,nbo(1)
            do 40 i=nbo(1)+1,nopen
               com=f(l)*scal
               cmo(i,j)=-com
               cmo(j,i)= com
   40    l=l+1
      endif
      if(nbo(3).gt.0 .and. nbo(1).gt.0) then
c        virtual-closed
         scal=0.5d0
         do 50 j=1     ,nbo(1)
            do 50 i=nopen+1,norbs
               com=f(l)*scal
               cmo(i,j)=-com
               cmo(j,i)= com
   50    l=l+1
      endif
      if(nbo(3).ne.0 .and. nbo(2).ne.0) then
c        virtual-open
         scal=1.d0/(fract+const)
         do 60 j=nbo(1)+1,nopen
            do 60 i=nopen+1  ,norbs
               com=f(l)*scal
               cmo(i,j)=-com
               cmo(j,i)= com
   60    l=l+1
      endif
      return
      end
      subroutine deritr(errfn,geo)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      dimension geo(3,numatm), errfn(maxpar)
************************************************************************
*
*    deritr calculates the derivatives of the energy with respect to the
*          internal coordinates. this is done by finite differences
*          using full scf calculations.
*
*          this is very time-consuming, and should only be used when
*          no other derivative calculation will do.
*
*    the main arrays in deriv are:
*        loc    integer array, loc(1,i) contains the address of the atom
*               internal coordinate loc(2,i) is to be used in the
*               derivative calculation.
*        geo    array \geo\ holds the internal coordinates.
*
************************************************************************
      common / euler/ tvec(3,3), id
      common /geovar/ nvar,loc(2,maxpar), idumy, dummy(maxpar)
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),
     1                nlast(numatm), norbs, nelecs,nalpha,nbeta,
     2                nclose,nopen,ndumy,fract
      common /geokst/ natoms,labels(numatm),
     1na(numatm),nb(numatm),nc(numatm)
      common /geosym/ ndep, idumys(maxpar,3)
      common /ucell/ l1l,l2l,l3l,l1u,l2u,l3u
      common /enuclr/ enuclr
      common /numcal/ numcal
      common /densty/ p(mpack), pa(mpack), pb(mpack)
      common /wmatrc/ wj(n2elec), wk(n2elec)
      common /hmatrx/ h(mpack)
      common /keywrd/ keywrd
      common/iofile/mfgr,mfgw
      character*241 keywrd
      dimension change(3), coord(3,numatm), cold(3,numatm*27)
     1,         xderiv(3), xparam(maxpar), xjuc(3), w(n2elec)
      REAL wj, wk
      save idelta, xderiv
      logical debug
      equivalence (w,wj)
      save icalcn,debug,change
      data icalcn /0/
      if(icalcn.ne.numcal) then
         debug = (index(keywrd,'deritr') .ne. 0)
         icalcn=numcal
*
*   idelta is a machine-precision dependant integer
*
         idelta=-3
         change(1)= 10.d0**idelta
         change(2)= 10.d0**idelta
         change(3)= 10.d0**idelta
c
c    change(i) is the step size used in calculating the derivatives.
c    because full scf calculations are being done quite large steps
c    are needed.  on the other hand, the step cannot be very large,
c    as the second derivitive in flepo is calculated from the
c    differences of two first derivatives. change(1) is for change in
c    bond length, (2) for angle, and (3) for dihedral.
c
         xderiv(1)= 0.5d0/change(1)
         xderiv(2)= 0.5d0/change(2)
         xderiv(3)= 0.5d0/change(3)
      endif
      do 10 i=1,nvar
   10 xparam(i)=geo(loc(2,i),loc(1,i))
      if(ndep.ne.0) call mopsym()
      call gmetry(geo,coord)
c
c  establish the energy at the current point
c
      call mophc(coord,h,w,wj,wk,enuclr)
      if(norbs*nelecs.gt.0)then
         call iterm(h, w, wj, wk, aa,.true.,.false.)
      else
         aa=0.d0
      endif
      linear=(norbs*(norbs+1))/2
c
c  restore the density matrix (why?)
c
      do 20 i=1,linear
   20 p(i)=pa(i)*2.d0
      aa=(aa+enuclr)
      ij=0
      do 60 ii=1,numat
         do 50 il=l1l,l1u
            do 50 jl=l2l,l2u
               do 50 kl=l3l,l3u
                  do 30 ll=1,3
   30             xjuc(ll)=coord(ll,ii)+tvec(ll,1)*il+tvec(ll,2)*jl+tvec
     1(ll,3)*kl
                  ij=ij+1
                  do 40 kk=1,3
                     cold(kk,ij)=xjuc(kk)
   40             continue
   50    continue
   60 continue
      do 90 i=1,nvar
         k=loc(1,i)
         l=loc(2,i)
         xstore=xparam(i)
         do 70 j=1,nvar
   70    geo(loc(2,j),loc(1,j))=xparam(j)
         geo(l,k)=xstore-change(l)
         if(ndep.ne.0) call mopsym()
         call gmetry(geo,coord)
c
c   if needed, calculate "exact" derivitives.
c
         call mophc(coord,h,w,wj,wk,enuclr)
         if(norbs*nelecs.gt.0)then
            call iterm(h,w, wj, wk,ee,.true.,.false.)
         else
            ee=0.d0
         endif
         do 80 ii=1,linear
   80    p(ii)=pa(ii)*2.d0
         ee=(ee+enuclr)
         errfn(i)=(aa-ee)*23.061d0*xderiv(l)*2.d0
   90 continue
      if(debug)then
         write(mfgw,'('' error function'')')
         write(mfgw,'(10f8.3)')(errfn(i),i=1,nvar)
      endif
      return
      end
      subroutine dernvo(coord,dxyz)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      dimension coord(3,*), dxyz(*)
***********************************************************************
*
*    implementation of analytical formulation for open shell or ci,
*                      variables finite difference methods,
*                      statistical estimate of the errors,
*                   by d. liotard
*                      laboratoire de chimie structurale
*                      universite de pau et des pays de l'adour
*                      avenue de l'universite, 64000, pau (france)
*
*
*   modified by jjps to conform to mopac conventions
*   (note by jjps:  prof. liotard's technique works.  if this
*   implementation does not work, the reason is a fault introduced
*   by jjps, and does not reflect on prof. liotard's ability)
*
*
*    as the wave function is not variationally optimized, i.e.
*    half-electron or ci, the derivatives of the 1 and 2-electron
*    integrals in a.o. basis are evaluated in cartesian coordinates
*    by a 1 or 2 points finite difference formula and stored.
*    thus one gets the non-relaxed (i.e. frozen electronic cloud)
*    contribution to the fock eigenvalues and 2-electron integrals in
*    an m.o. basis.  the non-relaxed gradient comes from the
*    non-relaxed c.i. matrix derivative (subroutine deri1).
*    the derivatives of the m.o. coefficients are then worked out
*    iteratively (ok for both closed shells and half-electron cases)
*    and stored. thus one gets the electronic relaxation contribution to
*    the fock eigenvalues and 2-electron integrals in m.o. basis.
*    finally the relaxation contribution to the c.i. matrix derivative
*    gives the relaxation contribution to the gradient (routine deri2).
*
*
*        coord  holds the cartesian coordinates.
*    input
*        dxyz   not defined.
*    exit
*        dxyz   derivatives of energy w.r.t cartesian coordinates,
*               in kcal/mol/angstrom (3 * numat of these)
*
***********************************************************************
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm)
     1               ,nlast(numatm), norbs, nelecs,nalpha,nbeta
     2               ,nclose,nopen,ndumy,fract
      common /gradnt/ grad(maxpar),gnorm
      common /cibits/ nmos,lab,nelec,nbo(3)
      common /numcal/ numcal
      common /keywrd/ keywrd
      common /vector/ c(morb2),eigs(maxorb),cbeta(morb2)
     3,eigb(maxorb)
      common /fokmat/ fdumy(mpack), scalar(mpack)
      common /nvomat/ diag(mpack/2)
      common /work1/ fmooff(npulay*4), fmoon(npulay*4),
     1work2(9*npulay), work3(4*npulay)
      common/iofile/mfgr,mfgw
      dimension fbwo(5*maxpar)
      character keywrd*241, blank*60
      dimension dxyzr(maxpar), eigbb(6*maxpar)
      logical debug, dcar, large, relaxd, force
      save icalcn,nvax
      save throld,debug,large,force,dcar,dxyzr,minear,ninear
      data icalcn /0/
c
c     select the required option and read keywords
c     --------------------------------------------
c
      if(icalcn.ne.numcal) then
         throld=0.08d0
         debug = (index(keywrd,'dernvo') .ne. 0)
         large = (index(keywrd,'large') .ne. 0)
         force = (index(keywrd,'forc') .ne. 0)
         dcar  = (index(keywrd,'forc') + index(keywrd,'prec') .ne. 0)
         if(dcar)throld=0.004d0
         nvax=3*numat
         do 11 i=1,nvax
   11    dxyzr(i)=0.d0
c        actual sizes for c.i. gradient calculation.
         nbo(1)=nclose
         nbo(2)=nopen-nclose
         nbo(3)=norbs-nopen
         minear=nbo(2)*nbo(1)+nbo(3)*nopen
         ninear=(nmos*(nmos+1))/2+1
         icalcn = numcal
      endif
c        scaling row factors to speed cv of relaxation procedure.
c#      call timop('before deri0')
      call deri0 (c,eigs,norbs,scalar,diag,fract,nbo)
c#      call timop('after deri0')
      nvax=3*numat
c
c   because deri2 is cpu intensive, and the contribution to the
c   derviative due to relaxation of the electron cloud is relatively
c   insensitive to changes in geometry, where possible only calculate
c   the derivative every 2 calls to dernvo
c
      sum=0.d0
      if(dcar)then
         do 10 i=1,nvax
   10    dxyzr(i)=0.d0
         relaxd=.false.
      endif
      do 20 i=1,nvax
   20 sum=sum+dabs(dxyzr(i))
      relaxd=(sum.gt.1.d-7)
c
c  if dxyzr contains data, use it and flush after use.
c
      ilast=0
   30 ifirst=ilast+1
      j=2
      if(min0(nw2,nw3)/max0(minear,ninear).lt.10)j=1
      ilast=min0(nvax,ilast+j)
      j=1-minear
      k=1-ninear
      do 40 i=ifirst,ilast
         k=k+ninear
         j=j+minear
c
c        non-relaxed contribution (frozen electronic cloud) in dxyz
c        and non-relaxed fock matrices in fmooff and fmoon.
c   contents of f-mo-off: open-closed, virtual-closed, and virtual-open
c   contents of f-mo-on:  closed-closed, open-open and virtual-virtual
c   over m.o. indices
c
c#      call timop('before deri1')
         call deri1(c,norbs,coord,i,cbeta,dxyz(i),fmooff(j),minear
     1              ,fmoon(k),work2,work2(6*mpack),work3)
c#      call timop('after deri1')
   40 continue
      if(debug)then
         if(ifirst.eq.1.and.large)then
            write(mfgw,*)' contents of fmooff '
            write(mfgw,*)' open-closed'
            write(mfgw,'(7x,i3,5i12)')(j,j=nclose+1,nopen)
            do 50 i=1,nclose
   50       write(mfgw,'(i3,6f12.6)')i,
     +  (fmooff(j),j=(i-1)*nbo(2)+1,i*nbo(2))
c
c
            write(mfgw,*)' virtual-closed'
            k=nclose*nbo(2)
            write(mfgw,'(7x,i3,5i12)')(j,j=nopen+1,min0(nopen+6,norbs))
            do 60 i=1,nclose
   60       write(mfgw,'(i3,6f12.6)')i,
     1   (fmooff(j+k),j=(i-1)*nbo(3)+1,min0(6+(i-1)*nbo(3),i*nbo(3)))
            k=nclose*nbo(2)+nbo(3)*nclose
c
c
            write(mfgw,*)' virtual-open'
            write(mfgw,'(7x,i3,4i12)')(j,j=nclose+1,nopen)
            do 70 i=1,min0(6,nbo(3))
   70       write(mfgw,'(i3,6f12.6)')i+nopen,
     1   (fmooff(j+k),j=(i-1)*nbo(2)+1,min0((i-1)*nbo(2)+6,i*nbo(2)))
         write(mfgw,*)' contents of fmoon (active-space -- active space)
     1'
            k=(nmos*(nmos-1))/2
            ll=1
            blank=' '
            do 80 i=1,nmos
               l=ll+nmos-i-1
               write(mfgw,'(a,5f12.6)')blank(:12*i),
     +    (fmoon(j),j=ll,l),fmoon(k+i)
   80       ll=l+1
         endif
      endif
c        compute the electronic relaxation contribution.
c
c   dernvo provides the following scratch areas to deri2: eigb, work2,
c          work3, fbwo, cbeta.  these are dimensioned on entry to deri2
c          which is why they are not declared there.  they are not used
c          at all in dernvo.
c
c#      call timop('before deri2')
      if(.not.relaxd)
     1   call deri2 (c,eigs,norbs,minear,fmooff
     2              ,fmoon,eigbb, ninear,ilast-ifirst+1
     3              ,cbeta,work2,nw2,dxyzr(ifirst)
     4              ,work3,nw3,fbwo,throld)
c#      call timop('after deri2')
      if (ilast.lt.nvax) go to 30
      if(debug)then
         sumx=0.d0
         sumy=0.d0
         sumz=0.d0
         do 90 i=1,numat
            sumx=sumx+dxyz(i*3-2)
            sumy=sumy+dxyz(i*3-1)
   90    sumz=sumz+dxyz(i*3)
         write(mfgw,*)' cartesian derivatives due to frozen core'
         write(mfgw,'('' atom    x           y           z'')')
         do 100 i=1,numat
  100    write(mfgw,'(i4,3f12.7)')i,dxyz(i*3-2),dxyz(i*3-1),dxyz(i*3)
         write(mfgw,'(/10x,''residual error'')')
         write(mfgw,'(4x,3f12.7)')sumx,sumy,sumz
         write(mfgw,*)
         sumx=0.d0
         sumy=0.d0
         sumz=0.d0
         do 110 i=1,numat
            sumx=sumx+dxyzr(i*3-2)
            sumy=sumy+dxyzr(i*3-1)
  110    sumz=sumz+dxyzr(i*3)
         write(mfgw,*)' cartesian derivatives due to relaxing core'
         write(mfgw,'('' atom    x           y           z'')')
         do 120 i=1,numat
  120    write(mfgw,'(i4,3f12.7)')i,dxyzr(i*3-2),dxyzr(i*3-1),dxyzr(i*3)
         write(mfgw,'(/10x,''residual error'')')
         write(mfgw,'(4x,3f12.7)')sumx,sumy,sumz
         write(mfgw,*)
      endif
      do 130 i=1,nvax
  130 dxyz(i)=dxyz(i)+dxyzr(i)
      if(relaxd)then
         do 140 i=1,nvax
  140    dxyzr(i)=0.d0
      endif
      sumx=0.d0
      sumy=0.d0
      sumz=0.d0
      do 150 i=1,numat
         sumx=sumx+dxyz(i*3-2)
         sumy=sumy+dxyz(i*3-1)
  150 sumz=sumz+dxyz(i*3)
      sum=dmax1(1.d-10,dabs(sumx)+dabs(sumy)+dabs(sumz))
c
c  here is a rough but simple method for defining throld for deri2
c  it may need more work
c
      if(.not. force .and. gnorm .gt. 0.001d0)
     1 throld=throld*dsqrt(gnorm/(sum*100.d0))
      throld=dmin1(2.d0,dmax1(0.002d0,throld))
      if(debug)then
      write(mfgw,*)'cartesian derivatives from analytical c.i. calculati
     1on'
         write(mfgw,'('' atom    x           y           z'')')
         do 160 i=1,numat
  160    write(mfgw,'(i4,3f12.7)')i,dxyz(i*3-2),dxyz(i*3-1),dxyz(i*3)
         write(mfgw,'(/10x,''residual error'')')
         write(mfgw,'(4x,3f12.7)')sumx,sumy,sumz
         write(mfgw,*)
      endif
      return
      end
      subroutine ders(m,n,rr,del1,del2,del3,is,iol)
      implicit REAL (a-h,o-z)
************************************************************************
*                                                                      *
*    on input m    = index of first atomic orbital                     *
*             n    = index of second atomic orbital                    *
*             rr   = square if interatomic diatance (in bohr)          *
*             del1 = catersian distance in derivative direction        *
*             del2 = cartesian distance in m a.o.'s direction          *
*             del3 = cartesian distance in n a.o.'s direction          *
*             is   = indicates type of a.o.-a.o. interaction           *
*                  = 1 s/s, 2 s/p', 3 s/p, 4 p'/s, 5 p/s, 6 p/p',      *
*                    7 p'/p", 8 p'p', 9 p/p                            *
*             iol  = index for storing derivatives in ds               *
*                                                                      *
************************************************************************
      common /derivs/ ds(16),dg(22),dr(100),tdx(3),tdy(3),tdz(3)
      common /temp/  cg(60,6),zg(60,6)
      dimension ss(6,6)
      a0=0.529167d0
      do 110 i=1,6
         do 110 j=1,6
            ss(i,j)=0.0d0
            apb=zg(m,i)*zg(n,j)
            amb=zg(m,i)+zg(n,j)
            adb=apb/amb
            adr=dmin1(adb*rr,35.d0)
            go to (10,20,30,40,50,60,70,80,90),is
   10       abn=-2.0d0*adb*del1/(a0**2)
            go to 100
   20       abn=-4.0d0*(adb**2)*del1*del2/(dsqrt(zg(n,j))*(a0**3))
            go to 100
   30       abn=(2.0d0*adb/(dsqrt(zg(n,j))*a0))*
     1 (1.0d0-2.0d0*adb*(del1**2)/(a0**2))
            go to 100
   40       abn=4.0d0*(adb**2)*del1*del2/(dsqrt(zg(m,i))*(a0**3))
            go to 100
   50       abn=-(2.0d0*adb/(dsqrt(zg(m,i))*a0))*
     1 (1.0d0-2.0d0*adb*(del1**2)/(a0**2))
            go to 100
   60       abn=-(4.0d0*(adb**2)*del2/(dsqrt(apb)*(a0**2)))*
     1 (1.0d0-2.0d0*adb*(del1**2)/(a0**2))
            go to 100
   70       abn=8.0d0*(adb**3)*del1*del2*del3/(dsqrt(apb)*(a0**4))
            go to 100
   80       abn=-(8.0d0*(adb**2)*del1/(dsqrt(apb)*(a0**2)))*
     1 (0.5d0-adb*(del2**2)/(a0**2))
            go to 100
   90       abn=-(8.0d0*(adb**2)*del1/(dsqrt(apb)*(a0**2)))*
     1 (1.5d0-adb*(del1**2)/(a0**2))
  100       ss(i,j)=dsqrt((2.0d0*dsqrt(apb)/amb)**3)*dexp(-adr)*abn
  110 continue
      do 120 i=1,6
         do 120 j=1,6
            ds(iol)=ds(iol)+ss(i,j)*cg(m,i)*cg(n,j)
  120 continue
      return
      end
      function dex2(m)
      implicit REAL (a-h,o-z)
      if(m .lt. 2) then
         dex2=1
      else
         dex2=1
         do 10 i=1,m,2
   10    dex2=dex2*i
      endif
      return
      end
      subroutine dfock2(f, ptot, p, w, numat, nfirst,
     1nmidle, nlast, nati)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      dimension f(*), ptot(*), nfirst(*), nmidle(*),
     1          nlast(*), p(*), w(*)
c **** original code with wj,wk as (1) was crap ..
      dimension wj(100), wk(100) 
c***********************************************************************
c
c     dfock2 adds the 2-electron 2-center repulsion contribution to
c     the fock matrix derivative within the nddo or mindo formalisms.
c  input
c     f    : 1-electron contributions derivatives.
c     ptot : total density matrix.
c     p    : alpha or beta density matrix. = 0.5 * ptot
c     w    : non vanishing two-electron integral derivatives
c            (ordered as defined in dhcore).
c     nati : # of the atom supporting the varying cartesian coordinate.
c  output
c     f    : fock matrix derivative with respect to the cart. coord.
c
c***********************************************************************
      common /euler/ tvec(3,3), id
      common /numcal/ numcal
      common /keywrd/ keywrd
      common /work4/ ptot2(numatm,16)
      save itype
      common /work6/ ifact(maxorb),i1fact(maxorb), jindex(256), 
     + kindex(256), ijperm(10), llperm(10),
     + pk(16), pja(16), pjb(16), mmperm(10), jjndex(256), ione, lid
      character*241 keywrd
      logical lid
      save icalcn
      data itype /1/
      data icalcn/0/
      if(icalcn.ne.numcal)then
         icalcn=numcal
         itype=0
      endif
   10 continue
      goto (20,270,70) itype
   20 continue
c
c   set up array of lower half triangle indices (pascal's triangle)
c
      do 30 i=1,maxorb
         ifact(i)=(i*(i-1))/2
   30 i1fact(i)=ifact(i)+i
c
c   set up gather-scatter type arrays for use with two-electron
c   integrals.  jindex are the indices of the j-integrals for atom i
c   integrals.  jjndex are the indices of the j-integrals for atom j
c               kindex are the indices of the k-integrals
c
      m=0
      do 40 i=1,4
         do 40 j=1,4
            ij=min0(i,j)
            ji=i+j-ij
            do 40 k=1,4
               ik=min0(i,k)
               ki=i+k-ik
               do 40 l=1,4
                  m=m+1
                  kl=min0(k,l)
                  lk=k+l-kl
                  jl=min0(j,l)
                  lj=j+l-jl
                  kindex(m)= ifact(lj) +jl + 10*( ifact(ki) +ik) -10
   40 jindex(m)=(ifact(ji) + ij)*10 + ifact(lk) + kl - 10
      l=0
      do 50 i=1,4
         i1=(i-1)*4
         do 50 j=1,i
            i1=i1+1
            l=l+1
            ijperm(l)=i1
            mmperm(l)=ijperm(l)-16
            llperm(l)=(i1-1)*16
   50 continue
      l=0
      do 60 i=1,10
         m=mmperm(i)
         l=llperm(i)
         do 60 k=1,16
            l=l+1
            m=m+16
   60 jjndex(l)=jindex(m)
      lid=(id.eq.0)
      ione=1
      if(id.ne.0)ione=0
      if(index(keywrd,'mindo') .ne. 0) then
         itype=2
      else
         itype=3
      endif
      goto 10
   70 kk=0
      l=0
      do 90 i=1,numat
         ia=nfirst(i)
         ib=nlast(i)
         m=0
         do 80 j=ia,ib
            do 80 k=ia,ib
               m=m+1
               jk=min0(j,k)
               kj=k+j-jk
               jk=jk+(kj*(kj-1))/2
               ptot2(i,m)=ptot(jk)
   80    continue
   90 continue
      ii=nati
      ia=nfirst(ii)
      ib=nlast(ii)
      do 260 jj=1,numat
         if(ii.eq.jj) goto 260
         ja=nfirst(jj)
         jb=nlast(jj)
         jc=nmidle(jj)
         if(lid) then
            drep=w(kk+1)
            if(ib-ia.ge.3.and.jb-ja.ge.3)then
c
c                         heavy-atom  - heavy-atom
c
c   extract coulomb terms
c
               do 100 i=1,16
                  pja(i)=ptot2(ii,i)
  100          pjb(i)=ptot2(jj,i)
c
c  coulomb terms
c
               call jab(ia,ja,llperm,jindex, jjndex, pja,pjb,w(kk+1),
     1f)
c
c  exchange terms
c
c
c  extract intersection of atoms ii and jj in the spin density matrix
c
               if(ia.gt.ja)then
                  l=0
                  do 110 i=ia,ib
                     do 110 j=ja,jb
                        l=l+1
  110             pk(l)=p(ifact(i)+j)
               else
                  l=0
                  do 120 i=ia,ib
                     do 120 j=ja,jb
                        l=l+1
  120             pk(l)=p(ifact(j)+i)
               endif
               i1=ia
               j1=ja
               call kab(ia,ja, pk, w(kk+1), kindex, f)
               ia=i1
               ja=j1
               kk=kk+100
            elseif(ib-ia.ge.3)then
c
c                         light-atom  - heavy-atom
c
c
c   coulomb terms
c
               sumdia=0.d0
               sumoff=0.d0
               ll=i1fact(ja)
               k=0
               do 140 i=0,3
                  j1=ifact(ia+i)+ia-1
                  do 130 j=0,i-1
                     k=k+1
                     j1=j1+1
                     f(j1)=f(j1)+ptot(ll)*w(kk+k)
  130             sumoff=sumoff+ptot(j1)*w(kk+k)
                  j1=j1+1
                  k=k+1
                  f(j1)=f(j1)+ptot(ll)*w(kk+k)
  140          sumdia=sumdia+ptot(j1)*w(kk+k)
               f(ll)=f(ll)+sumoff*2.d0+sumdia
c
c  exchange terms
c
c
c  extract intersection of atoms ii and jj in the spin density matrix
c
               if(ia.gt.ja)then
                  k=0
                  do 160 i=ia,ib
                     i1=ifact(i)+ja
                     sum=0.d0
                     do 150 j=ia,ib
                        k=k+1
                        j1=ifact(j)+ja
  150                sum=sum+p(j1)*w(kk+jindex(k))
  160             f(i1)=f(i1)-sum
               else
                  k=0
                  do 180 i=ia,ib
                     i1=ifact(ja)+i
                     sum=0.d0
                     do 170 j=ia,ib
                        k=k+1
                        j1=ifact(ja)+j
  170                sum=sum+p(j1)*w(kk+jindex(k))
  180             f(i1)=f(i1)-sum
               endif
               kk=kk+10
            elseif(jb-ja.ge.3)then
c
c                         heavy-atom - light-atom
c
c
c   coulomb terms
c
               sumdia=0.d0
               sumoff=0.d0
               ll=i1fact(ia)
               k=0
               do 200 i=0,3
                  j1=ifact(ja+i)+ja-1
                  do 190 j=0,i-1
                     k=k+1
                     j1=j1+1
                     f(j1)=f(j1)+ptot(ll)*w(kk+k)
  190             sumoff=sumoff+ptot(j1)*w(kk+k)
                  j1=j1+1
                  k=k+1
                  f(j1)=f(j1)+ptot(ll)*w(kk+k)
  200          sumdia=sumdia+ptot(j1)*w(kk+k)
               f(ll)=f(ll)+sumoff*2.d0+sumdia
c
c  exchange terms
c
c
c  extract intersection of atoms ii and jj in the spin density matrix
c
               if(ia.gt.ja)then
                  k=ifact(ia)+ja
                  j=0
                  do 220 i=k,k+3
                     sum=0.d0
                     do 210 l=k,k+3
                        j=j+1
  210                sum=sum+p(l)*w(kk+jindex(j))
  220             f(i)=f(i)-sum
               else
                  j=0
                  do 240 k=ja,ja+3
                     i=ifact(k)+ia
                     sum=0.d0
                     do 230 ll=ja,ja+3
                        l=ifact(ll)+ia
                        j=j+1
  230                sum=sum+p(l)*w(kk+jindex(j))
  240             f(i)=f(i)-sum
               endif
               kk=kk+10
            else
c
c                         light-atom - light-atom
c
               i1=i1fact(ia)
               j1=i1fact(ja)
               f(i1)=f(i1)+ptot(j1)*w(kk+1)
               f(j1)=f(j1)+ptot(i1)*w(kk+1)
               if(ia.gt.ja)then
                  ij=i1+ja-ia
                  f(ij)=f(ij)-p   (ij)*w(kk+1)
               else
                  ij=j1+ia-ja
                  f(ij)=f(ij)-p   (ij)*w(kk+1)
               endif
               kk=kk+1
            endif
         else
            drep=wj(kk+1)
            do 250 i=ia,ib
               ka=ifact(i)
               do 250 j=ia,i
                  kb=ifact(j)
                  ij=ka+j
                  aa=2.0d00
                  if (i.eq.j) aa=1.0d00
                  do 250 k=ja,jc
                     kc=ifact(k)
                     if(i.ge.k) then
                        ik=ka+k
                     else
                        ik=0
                     endif
                     if(j.ge.k) then
                        jk=kb+k
                     else
                        jk=0
                     endif
                     do 250 l=ja,k
                        if(i.ge.l) then
                           il=ka+l
                        else
                           il=0
                        endif
                        if(j.ge.l) then
                           jl=kb+l
                        else
                           jl=0
                        endif
                        kl=kc+l
                        bb=2.0d00
                        if (k.eq.l) bb=1.0d00
                        kk=kk+1
                        aj=wj(kk)
                        ak=wk(kk)
c
c     a  is the repulsion integral (i,j/k,l) where orbitals i and j are
c     on atom ii, and orbitals k and l are on atom jj.
c     aa and bb are correction factors since
c     (i,j/k,l)=(j,i/k,l)=(i,j/l,k)=(j,i/l,k)
c     ij is the location of the matrix elements between atomic orbitals
c     i and j.  similarly for ik etc.
c
c this forms the two-electron two-center repulsion part of the fock
c matrix.  the code here is hard to follow, and impossible to modify!,
c but it works,
                        if(kl.le.ij)then
                           if(i.eq.k.and.aa+bb.lt.2.1d0)then
                              bb=bb*0.5d0
                              aa=aa*0.5d0
                              f(ij)=f(ij)+bb*aj*ptot(kl)
                              f(kl)=f(kl)+aa*aj*ptot(ij)
                           else
                              f(ij)=f(ij)+bb*aj*ptot(kl)
                              f(kl)=f(kl)+aa*aj*ptot(ij)
                              a=ak*aa*bb*0.25d0
                              f(ik)=f(ik)-a*p(jl)
                              f(il)=f(il)-a*p(jk)
                              f(jk)=f(jk)-a*p(il)
                              f(jl)=f(jl)-a*p(ik)
                           endif
                        endif
  250       continue
         endif
  260 continue
c
      return
  270 kr=0
      ii=nati
      ia=nfirst(ii)
      ib=nlast(ii)
      do 290 jj=1,numat
         if (jj.eq.ii) go to 290
         kr=kr+1
         elrep=w(kr)
         ja=nfirst(jj)
         jb=nlast(jj)
         do 280 i=ia,ib
            ka=ifact(i)
            kk=ka+i
            do 280 k=ja,jb
               ll=i1fact(k)
               if (ja.lt.ia) then
                  ik=ka+k
               else
                  ik=ll+i-k
               endif
               f(kk)=f(kk)+ptot(ll)*elrep
               f(ll)=f(ll)+ptot(kk)*elrep
  280    f(ik)=f(ik)-p(ik)*elrep
  290 continue
      return
      end
      subroutine dfpsav(totime,xparam,gd,xlast,funct1,mdfp,xdfp)
      implicit REAL (a-h,o-z)
_IF(ipsc,tools)
      logical oroot
_ENDIF
INCLUDE(common/sizes)
INCLUDE(../m4/common/utilc)
      dimension xparam(*), gd(*), xlast(*), mdfp(9),xdfp(9)
**********************************************************************
*
* dfpsav stores and restores data used in the d-f-p geometry
*        optimisation.
*
*  on input totime = total cpu time elapsed during the calculation.
*           xparam = current value of parameters.
*           gd     = old gradient.
*           xlast  = old value of parameters.
*           funct1 = current value of heat of formation.
*           mdfp   = integer constants used in d-f-p.
*           xdfp   = real*8  constants used in d-f-p.
*           mdfp(9)= 1 for dump, 0 for restore.
**********************************************************************
      common /keywrd/ keywrd
      common /gradnt/ grad(maxpar),gnorm
      common /geovar/ nvar,loc(2,maxpar), idumy, dumy(maxpar)
      common /densty/ p(mpack), pa(mpack), pb(mpack)
      common /alparm/ alparm(3,maxpar),x0, x1, x2, iloop
      common /pparam/ currt
      common /gparam/ currt1,currt2
      common /profilm/ profil
      common /surf/ surf
      common /kloop/ kloop
      common /ijlp/ ijlp, ilp, jlp, jlp1, ione
      common /reactn/ step, geoa(3,numatm), geovec(3,numatm),calcst
      common /cmpg/ geo(3,numatm)
      common /geokst/ natoms,labels(numatm),
     1                na(numatm),nb(numatm),nc(numatm)
      common /elemts/ elemnt(107)
      character koment*81, title*81
      common /titles/ koment,title
      common /path/ latom,lparam,react(200)
      common /mesh/ latom1,lpara1,latom2,lpara2
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),
     1                nlast(numatm), norbs, nelecs,nalpha,nbeta,
     2                nclose,nopen,ndumy,fract
      common /fmatrx/ hesinv(maxpar**2+maxpar*3+1), idumy2(4)
      common /errfn/ errfn(maxpar), aicorr(maxpar)
      common /numcal/ numcal
      common/iofile/mfgr,mfgw
      dimension coord(3,numatm)
      dimension profil(200)
      dimension surf(23*23)
      character elemnt*2, keywrd*241, getmop*80
      save first
      logical first, intxyz
      data icalcn/0/
      first=(icalcn.eq.numcal)
_IF(ipsc,tools)
      if(oroot().and.odumpm) then
_ELSE
      if(odumpm) then
_ENDIF
      open(unit=9,file=getmop(3)
     +                     ,status='unknown',form='unformatted')
      rewind 9
      open(unit=10,file=getmop(4)
     +                     ,status='unknown',form='unformatted')
      rewind 10
      endif
      degree=57.29577951d0
      ir=9
      if(mdfp(9) .ne. 0) then
         if(mdfp(9) .eq. 1) then
_IF(ipsc,tools)
         if (oroot().and.odumpm) then
_ELSE
         if (odumpm) then
_ENDIF
         write(mfgw,'(//10x,''- - - - - - - time up - - - - - - -'',//)'
     1)
            if(index(keywrd,'saddle') .ne. 0) then
               write(mfgw,'(//10x,'' no restart exists for saddle'',//
     1  10x,'' here is a data-file files that might be suitable'',/
     2  10x,'' for restarting the calculation'',///)')
               write(mfgw,'(a)')keywrd,koment,title
               intxyz=(na(1).eq.0)
               do 30 iloop=1,2
                  if(intxyz)then
                     geo(2,1)=0.d0
                     geo(3,1)=0.d0
                     geo(1,1)=0.d0
                     geo(2,2)=0.d0
                     geo(3,2)=0.d0
                     geo(3,3)=0.d0
                     do 10 i=1,natoms
                        do 10 j=1,3
   10                coord(j,i)=geo(j,i)
                  else
                     call mopxyz(geo,numat,na,nb,nc,1.d0,coord)
                  endif
                  call geout(-6)
                  do 20 i=1,natoms
                     do 20 j=1,3
   20             geo(j,i)=geoa(j,i)
                  na(1)=99
   30          continue
               write(mfgw,'(///10x,''calculation terminated here'')')
_IF(ipsc,tools)
               call pend
_ELSE
               stop
_ENDIF
            endif
         write(mfgw,'(//10x,'' - the calculation is being dumped to disk
     1'',  /10x,''   restart it using the magic word "restart"'')')
            write(mfgw,'(//10x,''current value of heat of formation =''
     1  ,f12.6)')funct1
         endif
         if(mdfp(9) .eq. 1)then
            if(na(1) .eq. 99) then
c
c  convert from cartesian coordinates to internal
c
               do 40 i=1,natoms
                  do 40 j=1,3
   40          coord(j,i)=geo(j,i)
               call mopxyz(coord,numat,na,nb,nc,1.d0,geo)
            endif
            geo(2,1)=0.d0
            geo(3,1)=0.d0
            geo(1,1)=0.d0
            geo(2,2)=0.d0
            geo(3,2)=0.d0
            geo(3,3)=0.d0
            ivar=1
            na(1)=0
            call geout(6)
         endif
         write(ir)mdfp,xdfp,totime,funct1
         write(ir)(xparam(i),i=1,nvar),(gd(i),i=1,nvar)
         write(ir)(xlast(i),i=1,nvar),(grad(i),i=1,nvar)
         linear=(nvar*(nvar+1))/2
         write(ir)(hesinv(i),i=1,linear)
         linear=(norbs*(norbs+1))/2
         write(10)(pa(i),i=1,linear)
         if(nalpha.ne.0)write(10)(pb(i),i=1,linear)
         if(latom.ne.0)then
            if(index(keywrd,'step').ne.0)then
               write(ir) kloop
               write(ir) currt
               write(ir) (profil(i),i=1,kloop)
            else
               write(ir)((alparm(j,i),j=1,3),i=1,nvar)
               write(ir)iloop,x0, x1, x2
            endif
         endif       
         if(index(keywrd,'step1').ne.0)then
            write(ir)ijlp, ilp,jlp,jlp1,ione
            write(ir) currt1,currt2
            write(ir) (surf(i),i=1,ijlp)
         endif
         write(ir)(errfn(i),i=1,nvar)
         close (9)
         close (10)
       endif
      else
         if (first) 
     +     write(mfgw,'(//10x,'' restoring data from disk''/)')
_IF(ipsc,tools)
         if(oroot()) then
_ENDIF
         read(ir,end=60,err=60)mdfp,xdfp,totime,funct1
         if (first) write(mfgw,'(10x,''function ='',f13.6//)')
     +    funct1
         read(ir)(xparam(i),i=1,nvar),(gd(i),i=1,nvar)
         read(ir)(xlast(i),i=1,nvar),(grad(i),i=1,nvar)
         linear=(nvar*(nvar+1))/2
         read(ir)(hesinv(i),i=1,linear)
         linear=(norbs*(norbs+1))/2
         read(10)(pa(i),i=1,linear)
         if(nalpha.ne.0)read(10)(pb(i),i=1,linear)
         if(latom.ne.0)then
            if(index(keywrd,'step').ne.0)then
               read(ir) kloop
               read(ir) currt
               read(ir) (profil(i),i=1,kloop)
            else
               read(ir)((alparm(j,i),j=1,3),i=1,nvar)
               read(ir)iloop,x0, x1, x2
            endif
         endif       
         if(index(keywrd,'step1').ne.0)then
            read(ir)ijlp, ilp,jlp,jlp1,ione
            read(ir) currt1,currt2
            read(ir) (surf(i),i=1,ijlp)
         endif
         read(ir)(errfn(i),i=1,nvar)
         first=.false.
_IF(ipsc,tools)
      else
         write(mfgw,*)' restarts not implemented in dfpsav'
         go to 61
      endif
_ENDIF
         return
   60    write(mfgw,'(//10x,''no restart file exists!'')')
_IF(ipsc,tools)
   61    call pend
_ELSE
         stop
_ENDIF
      endif
      end
      subroutine dhc (p,pa,pb,xi,nat,if,im,il,jf,jm,jl,
     1norbs,dener,mode)
      implicit REAL (a-h,o-z)
      dimension p(*), pa(*), pb(*)
      dimension xi(3,*),nfirst(2),nmidle(2),nlast(2),nat(*)
c***********************************************************************
c
c  dhc calculates the energy contributions from those pairs of atoms
c         that have been moved by routine deriv.
c
c***********************************************************************
      common /keywrd/ keywrd
      common /cmpone/ uss(107),upp(107),udd(107)
      common /euler/ tvec(3,3), id
      common /numcal/ numcal
      save icalcn, wlim, uhf
      character*241 keywrd
      logical uhf, cutoff
      dimension h(171), shmat(9,9), f(171),
     1          wj(100), e1b(10), e2a(10), wk(100), w(100),
     2          wjs(100), wks(100)
      REAL wjs, wks
      data icalcn /0/
      if( icalcn.ne.numcal) then
         icalcn=numcal
         wlim=4.d0
         if(id.eq.0)wlim=0.d0
         uhf=(index(keywrd,'uhf') .ne. 0)
      endif
      nfirst(1)=1
      nmidle(1)=im-if+1
      nlast(1)=il-if+1
      nfirst(2)=nlast(1)+1
      nmidle(2)=nfirst(2)+jm-jf
      nlast(2)=nfirst(2)+jl-jf
      linear=(nlast(2)*(nlast(2)+1))/2
      do 10 i=1,linear
         f(i)=0.d0
   10 h(i)=0.0d00
      do 20 i=1,linear
   20 f(i)=h(i)
      ja=nfirst(2)
      jb=nlast(2)
      jc=nmidle(2)
      ia=nfirst(1)
      ib=nlast(1)
      ic=nmidle(1)
      jt=jb*(jb+1)/2
      j=2
      i=1
      nj=nat(2)
      ni=nat(1)
      call h1elec(ni,nj,xi(1,1),xi(1,2),shmat)
      if(nat(1).eq.102.or.nat(2).eq.102) then
         k=(jb*(jb+1))/2
         do 30 j=1,k
   30    h(j)=0.d0
      else
         j1=0
         do 40 j=ja,jb
            jj=j*(j-1)/2
            j1=j1+1
            i1=0
            do 40 i=ia,ib
               jj=jj+1
               i1=i1+1
               h(jj)=shmat(i1,j1)
               f(jj)=shmat(i1,j1)
   40    continue
      endif
      kr=1
      if(id.eq.0)then
         call moprat(nj,ni,xi(1,2),xi(1,1),w(kr),kr,e2a,e1b,enuclr,
     +  100.d0)
      else
         call solrot (nj,ni,xi(1,2),xi(1,1),wj,wk,kr,e2a,e1b,enuclr,100.
     1d0)
      if(mode.eq.1)cutoff=(wj(1).lt.wlim)
         if(cutoff)then
            do 50 i=1,kr-1
   50       wk(i)=0.d0
         endif
         do 60 i=1,kr-1
            wjs(i)=wj(i)
            wks(i)=wk(i)
   60    continue
      endif
c
c    * enuclr is summed over core-core repulsion integrals.
c
      i2=0
      do 70 i1=ia,ic
         ii=i1*(i1-1)/2+ia-1
         do 70 j1=ia,i1
            ii=ii+1
            i2=i2+1
            h(ii)=h(ii)+e1b(i2)
   70 f(ii)=f(ii)+e1b(i2)
      do  80 i1=ic+1,ib
         ii=(i1*(i1+1))/2
         f(ii)=f(ii)+e1b(1)
   80 h(ii)=h(ii)+e1b(1)
      i2=0
      do 90 i1=ja,jc
         ii=i1*(i1-1)/2+ja-1
         do 90 j1=ja,i1
            ii=ii+1
            i2=i2+1
            h(ii)=h(ii)+e2a(i2)
   90 f(ii)=f(ii)+e2a(i2)
      do 100 i1=jc+1,jb
         ii=(i1*(i1+1))/2
         f(ii)=f(ii)+e2a(1)
  100 h(ii)=h(ii)+e2a(1)
      call fock2(f,p,pa,w, wjs, wks,2,nfirst,nmidle,nlast)
      ee=helect(nlast(2),pa,h,f)
      if( uhf ) then
         do 110 i=1,linear
  110    f(i)=h(i)
         call fock2(f,p,pb,w, wjs, wks,2,nfirst,nmidle,nlast)
         ee=ee+helect(nlast(2),pb,h,f)
      else
         ee=ee*2.d0
      endif
      dener=ee+enuclr
      return
c
      end
      subroutine dhcore (coord,h,w,enuclr,nati,natx,step)
      implicit REAL  (a-h,o-z)
INCLUDE(common/sizes)
      dimension coord(3,*),h(*),w(*)
c
c  dhcore generates the 1-electron  and 2-electron integrals derivatives
c         with respect to the cartesian coordinate coord (natx,nati).
c
c  input
c      coord     : cartesian  coordinates of the molecule.
c      nati,natx : indices of the moving coordinate.
c      step      : step size of the 2-points finite difference.
c  output
c      h         : 1-electron integrals derivatives (packed canonical).
c      w         : 2-electron integrals derivatives (ordered as required
c                             in dfock2 and dijkl1).
c      enuclr    : nuclear energy derivative.
c
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),
     1                nlast(numatm), norbs, nelecs,nalpha,nbeta,
     2                nclose,nopen,ndumy,fract
      common /molorb/ uspd(maxorb),dumy(maxorb)
      common /keywrd/ keywrd
      common /wmatrc/ wdummy(n2elec*2)
      character*241 keywrd
      logical first,mindo
      dimension e1b(10),de1b(10),e2a(10),de2a(10)
     1         ,di(9,9),ddi(9,9),wjd(101),dwjd(101)
     2,nb(0:8)
      data nb/1,0,0,10,0,0,0,0,45/
      data first/.true./
      save first,cutoff,mindo
      if (first) then
         cutoff=1.d10
         first=.false.
         mindo=index(keywrd,'mindo') .ne. 0
      endif
      do 10 i=1,(norbs*(norbs+1))/2
   10 h(i)=0
      enuclr=0.d0
      kr=1
      nrow=0
      i=nati
      csave=coord(natx,nati)
      ia=nfirst(nati)
      ib=nlast(nati)
      ic=nmidle(nati)
      ni=nat(nati)
      nrow=-nb(ib-ia)
      do 20 j=1,numat
   20 nrow=nrow+nb(nlast(j)-nfirst(j))
      ncol=nb(nlast(nati)-nfirst(nati))
      nband2=0
      do 120 j=1,numat
         if (j.eq.nati) go to 120
         ja=nfirst(j)
         jb=nlast(j)
         jc=nmidle(j)
         nj=nat(j)
         coord(natx,nati)=csave+step
         call h1elec(ni,nj,coord(1,nati),coord(1,j),di)
c
c  the following style was necessary to get round a bug in the
c  gould compiler
c
         coord(natx,nati)=csave+step*(-1.d0)
         call h1elec(ni,nj,coord(1,nati),coord(1,j),ddi)
c
c     fill the atom-other atom one-electron matrix.
c
         i2=0
         if (ia.gt.ja) then
            do 30 i1=ia,ib
               ij=i1*(i1-1)/2+ja-1
               i2=i2+1
               j2=0
               do 30 j1=ja,jb
                  ij=ij+1
                  j2=j2+1
   30       h(ij)=h(ij)+(di(i2,j2)-ddi(i2,j2))
         else
            do 40 i1=ja,jb
               ij=i1*(i1-1)/2+ia-1
               i2=i2+1
               j2=0
               do 40 j1=ia,ib
                  ij=ij+1
                  j2=j2+1
   40       h(ij)=h(ij)+(di(j2,i2)-ddi(j2,i2))
         endif
c
c     calculate the two-electron integrals, w; the electron nuclear term
c     e1b and e2a; and the nuclear-nuclear term enuc.
c
         kro=kr
         nband1=nband2+1
         nband2=nband2+nb(nlast(j)-nfirst(j))
         if (mindo) then
            coord(natx,nati)=csave+step
            call moprat(ni,nj,coord(1,nati),coord(1,j),wjd,kr,e1b,e2a,
     +  enuc,cutoff)
            kr=kro
            coord(natx,nati)=csave+step*(-1.d0)
            call moprat(ni,nj,coord(1,nati),coord(1,j),dwjd,kr,de1b,
     +  de2a,denuc,cutoff)
            if (kr.gt.kro) then
               do 50 k=1,kr-kro+1
   50          w(kro+k-1)=wjd(k)-dwjd(k)
            endif
         else
            coord(natx,nati)=csave+step
            call moprat(ni,nj,coord(1,nati),coord(1,j),wjd,kr,e1b,e2a,
     +  enuc,cutoff)
            kr=kro
            coord(natx,nati)=csave+step*(-1.d0)
            call moprat(ni,nj,coord(1,nati),coord(1,j),dwjd,kr,de1b,
     +  de2a,denuc,cutoff)
            if (kr.gt.kro) then
               do 60 k=1,kr-kro+1
   60          wjd(k)=wjd(k)-dwjd(k)
               j7=0
               do 70 i1=kro,kr
                  j7=j7+1
   70          w(i1)=wjd(j7)
            endif
         endif
         coord(natx,nati)=csave
         enuclr = enuclr + enuc-denuc
c
c   add on the electron-nuclear attraction term for atom i.
c
         i2=0
         do 80 i1=ia,ic
            ii=i1*(i1-1)/2+ia-1
            do 80 j1=ia,i1
               ii=ii+1
               i2=i2+1
   80    h(ii)=h(ii)+e1b(i2)-de1b(i2)
c     contrib d, cndo.
         do 90 i1=ic+1,ib
            ii=(i1*(i1+1))/2
   90    h(ii)=h(ii)+e1b(1)-de1b(1)
c
c   add on the electron-nuclear attraction term for atom j.
c
         i2=0
         do 100 i1=ja,jc
            ii=i1*(i1-1)/2+ja-1
            do 100 j1=ja,i1
               ii=ii+1
               i2=i2+1
  100    h(ii)=h(ii)+e2a(i2)-de2a(i2)
c     contrib d, cndo.
         do 110 i1=jc+1,jb
            ii=(i1*(i1+1))/2
  110    h(ii)=h(ii)+e2a(1)-de2a(1)
  120 continue
c
c   'size' of h is nrow * ncol
c
      return
      end
      subroutine diat(ni,nj,xi,xj,di)
      implicit REAL (a-h,o-z)
************************************************************************
*
*   diat calculates the di-atomic overlap integrals between atoms
*        centered at xi and xj.
*
*   on input ni  = atomic number of the first atom.
*            nj  = atomic number of the second atom.
*            xi  = cartesian coordinates of the first atom.
*            xj  = cartesian coordinates of the second atom.
*
*  on output di  = diatomic overlap, in a 9 * 9 matrix. layout of
*                  atomic orbitals in di is
*                  1   2   3   4   5            6     7       8     9
*                  s   px  py  pz  d(x**2-y**2) d(xz) d(z**2) d(yz)d(xy)
*
*   limitations:  in this formulation, ni and nj must be less than 107
*         exponents are assumed to be present in common block expont.
*
************************************************************************
      common /keywrd/keywrd
      character*241 keywrd
      integer a,pq2,b,pq1,aa,bb
      common /numcal/ numcal
      save npq, ival
      logical analyt
      common /expont/ emus(107),emup(107),emud(107)
      dimension di(9,9),s(3,3,3),ul1(3),ul2(3),c(3,5,5),npq(107)
     1          ,xi(3),xj(3), slin(27), ival(3,5)
     2, c1(3,5), c2(3,5), c3(3,5), c4(3,5), c5(3,5)
     3, s1(3,3), s2(3,3), s3(3,3)
      equivalence(slin(1),s(1,1,1))
      equivalence (c1(1,1),c(1,1,1)), (c2(1,1),c(1,1,2)),
     1            (c3(1,1),c(1,1,3)), (c4(1,1),c(1,1,4)),
     2            (c5(1,1),c(1,1,5)), (s1(1,1),s(1,1,1)),
     3            (s2(1,1),s(1,1,2)), (s3(1,1),s(1,1,3))
      data npq/1,0, 2,2,2,2,2,2,2,0, 0,3,3,3,3,3,3,0, 0,4,4,4,4,4,4,4,
     14,4,4,4,4,4,4,4,4,0, 5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5
     2,32*6,15*0,3,5*0/
      data ival/1,0,9,1,3,8,1,4,7,1,2,6,0,0,5/
      save icalcn,analyt
      data icalcn/0/
      if(icalcn.ne.numcal)then
         analyt=(index(keywrd,'analyt').ne.0)
         icalcn=numcal
      endif
      x1=xi(1)
      x2=xj(1)
      y1=xi(2)
      y2=xj(2)
      z1=xi(3)
      z2=xj(3)
      pq1=npq(ni)
      pq2=npq(nj)
      do 20 i=1,9
         do 10 j=1,9
            di(i,j)=0.0d0
   10    continue
   20 continue
      call coe(x1,y1,z1,x2,y2,z2,pq1,pq2,c,r)
      if(pq1.eq.0.or.pq2.eq.0.or.r.ge.10.d0) return
      if(r.lt.0.001)then
         return
      endif
      ia=min0(pq1,3)
      ib=min0(pq2,3)
      a=ia-1
      b=ib-1
      if(analyt)then
         call gover(ni,nj,xi,xj,r,di)
c#      write(mfgw,*)' overlap from gover'
c#      write(mfgw,'(4f15.10)')sg
         return
      endif
      if(ni.lt.18.and.nj.lt.18) then
         call diat2(ni,emus(ni),emup(ni),r,nj,emus(nj),emup(nj),s)
      else
         ul1(1)=emus(ni)
         ul2(1)=emus(nj)
         ul1(2)=emup(ni)
         ul2(2)=emup(nj)
         ul1(3)=dmax1(emud(ni),0.3d0)
         ul2(3)=dmax1(emud(nj),0.3d0)
         do 30 i=1,27
   30    slin(i)=0.0d0
         newk=min0(a,b)
         nk1=newk+1
         do 40 i=1,ia
            iss=i
            ib=b+1
            do 40 j=1,ib
               jss=j
               do 40 k=1,nk1
                  if(k.gt.i.or.k.gt.j) goto 40
                  kss=k
                  s(i,j,k)=ss(pq1,pq2,iss,jss,kss,ul1(i),ul2(j),r)
   40    continue
      endif
      do 50 i=1,ia
         kmin=4-i
         kmax=2+i
         do 50 j=1,ib
            if(j.eq.2)then
               aa=-1
               bb=1
            else
               aa=1
               if(j.eq.3) then
                  bb=-1
               else
                  bb=1
               endif
            endif
            lmin=4-j
            lmax=2+j
            do 50 k=kmin,kmax
               do 50 l=lmin,lmax
                  ii=ival(i,k)
                  jj=ival(j,l)
                  di(ii,jj)=s1(i,j)*(c3(i,k)*c3(j,l))*aa+
     1(c4(i,k)*c4(j,l)+c2(i,k)*c2(j,l))*bb*s2(i,j)+(c5(i,k)*c5(j,l)
     2+c1(i,k)*c1(j,l))*s3(i,j)
   50 continue
c#      write(mfgw,*)' overlap from diat2'
c#      do 12 i=1,4
c#  12  write(mfgw,'(4f15.10)')(di(j,i),j=1,4)
      return
      end
      subroutine diat2(na,esa,epa,r12,nb,esb,epb,s)
      implicit REAL (a-h,o-z)
      dimension s(3,3,3)
c***********************************************************************
c
c overlp calculates overlaps between atomic orbitals for pairs of atoms
c        it can handle the orbitals 1s, 2s, 3s, 2p, and 3p.
c
c***********************************************************************
      common /cmops/ a(7),b(7),sa,sb,factor,isp,ips
      dimension inmb(17),iii(78)
      save inmb, iii
      data inmb/1,0,2,2,3,4,5,6,7,0,8,8,8,9,10,11,12/
c     numbering corresponds to bond type matrix given above
c      the code is
c
c     iii=1      first - first  row elements
c        =2      first - second
c        =3      first - third
c        =4      second - second
c        =5      second - third
c        =6      third - third
      data iii/1,2,4,   2,4,4,   2,4,4,4,   2,4,4,4,4,
     1 2,4,4,4,4,4,   2,4,4,4,4,4,4,   3,5,5,5,5,5,5,6,
     2 3,5,5,5,5,5,5,6,6,   3,5,5,5,5,5,5,6,6,6,   3,5,5,5,5,5,5,6,6,6,6
     3, 3,5,5,5,5,5,5,6,6,6,6,6/
c
c      assigns bond number
c
      jmax=max0(inmb(na),inmb(nb))
      jmin=min0(inmb(na),inmb(nb))
      nbond=(jmax*(jmax-1))/2+jmin
      ii=iii(nbond)
      do 10 i=1,3
         do 10 j=1,3
            do 10 k=1,3
   10 s(i,j,k)=0.d0
      rab=r12/0.529167d0
      goto (20,30,40,50,60,70), ii
c
c     ------------------------------------------------------------------
c *** the ordering of the elements within s is
c *** s(1,1,1)=(s(b)/s(a))
c *** s(1,2,1)=(p-sigma(b)/s(a))
c *** s(2,1,1)=(s(b)/p-sigma(a))
c *** s(2,2,1)=(p-sigma(b)/p-sigma(a))
c *** s(2,2,2)=(p-pi(b)/p-pi(a))
c     ------------------------------------------------------------------
c *** first row - first row overlaps
c
   20 call set (esa,esb,na,nb,rab,nbond,ii)
      s(1,1,1)=.25d00*dsqrt((sa*sb*rab*rab)**3)*(a(3)*b(1)-b(3)*a(1))
      return
c
c *** first row - second row overlaps
c
   30 call set (esa,esb,na,nb,rab,nbond,ii)
      w=dsqrt((sa**3)*(sb**5))*(rab**4)*0.125d00
      s(1,1,1) = dsqrt(1.d00/3.d00)
      s(1,1,1)=w*s(1,1,1)*(a(4)*b(1)-b(4)*a(1)+a(3)*b(2)-b(3)*a(2))
      if (na.gt.1) call set (epa,esb,na,nb,rab,nbond,ii)
      if (nb.gt.1) call set (esa,epb,na,nb,rab,nbond,ii)
      w=dsqrt((sa**3)*(sb**5))*(rab**4)*0.125d00
      s(isp,ips,1)=w*(a(3)*b(1)-b(3)*a(1)+a(4)*b(2)-b(4)*a(2))
      return
c
c *** first row - third row overlaps
c
   40 call set (esa,esb,na,nb,rab,nbond,ii)
      w=dsqrt((sa**3)*(sb**7)/7.5d00)*(rab**5)*0.0625d00
      sroot3 = dsqrt(3.d00)
      s(1,1,1)=w*(a(5)*b(1)-b(5)*a(1)+
     12.d00*(a(4)*b(2)-b(4)*a(2)))/sroot3
      if (na.gt.1) call set (epa,esb,na,nb,rab,nbond,ii)
      if (nb.gt.1) call set (esa,epb,na,nb,rab,nbond,ii)
      w=dsqrt((sa**3)*(sb**7)/7.5d00)*(rab**5)*0.0625d00
      s(isp,ips,1)=w*(a(4)*(b(1)+b(3))-b(4)*(a(1)+a(3))+
     1b(2)*(a(3)+a(5))-a(2)*(b(3)+b(5)))
      return
c
c *** second row - second row overlaps
c
   50 call set (esa,esb,na,nb,rab,nbond,ii)
      w=dsqrt((sa*sb)**5)*(rab**5)*0.0625d00
      rt3=1.d00/dsqrt(3.d00)
      s(1,1,1)=w*(a(5)*b(1)+b(5)*a(1)-2.0d00*a(3)*b(3))/3.0d00
      call set (esa,epb,na,nb,rab,nbond,ii)
      if (na.gt.nb) call set (epa,esb,na,nb,rab,nbond,ii)
      w=dsqrt((sa*sb)**5)*(rab**5)*0.0625d00
      d=a(4)*(b(1)-b(3))-a(2)*(b(3)-b(5))
      e=b(4)*(a(1)-a(3))-b(2)*(a(3)-a(5))
      s(isp,ips,1)=w*rt3*(d+e)
      call set (epa,esb,na,nb,rab,nbond,ii)
      if (na.gt.nb) call set (esa,epb,na,nb,rab,nbond,ii)
      w=dsqrt((sa*sb)**5)*(rab**5)*0.0625d00
      d=a(4)*(b(1)-b(3))-a(2)*(b(3)-b(5))
      e=b(4)*(a(1)-a(3))-b(2)*(a(3)-a(5))
      s(ips,isp,1)=-w*rt3*(e-d)
      call set (epa,epb,na,nb,rab,nbond,ii)
      w=dsqrt((sa*sb)**5)*(rab**5)*0.0625d00
      s(2,2,1)=-w*(b(3)*(a(5)+a(1))-a(3)*(b(5)+b(1)))
      hd = .5d00
      s(2,2,2)=hd*w*(a(5)*(b(1)-b(3))-b(5)*(a(1)-a(3))
     1-a(3)*b(1)+b(3)*a(1))
      return
c
c *** second row - third row overlaps
c
   60 call set (esa,esb,na,nb,rab,nbond,ii)
      w=dsqrt((sa**5)*(sb**7)/7.5d00)*(rab**6)*0.03125d00
      rt3 = 1.d00 / dsqrt(3.d00)
      td = 2.d00
      s(1,1,1)=w*(a(6)*b(1)+a(5)*b(2)-td*(a(4)*b(3)+
     1a(3)*b(4))+a(2)*b(5)+a(
     21)*b(6))/3.d00
      call set (esa,epb,na,nb,rab,nbond,ii)
      if (na.gt.nb) call set (epa,esb,na,nb,rab,nbond,ii)
      w=dsqrt((sa**5)*(sb**7)/7.5d00)*(rab**6)*0.03125d00
      td = 2.d00
      s(isp,ips,1)=w*rt3*(a(6)*b(2)+a(5)*b(1)-td*(a(4)*b(4)+a(3)*b(3))
     1+a(2)*b(6)+a(1)*b(5))
      call set (epa,esb,na,nb,rab,nbond,ii)
      if (na.gt.nb) call set (esa,epb,na,nb,rab,nbond,ii)
      w=dsqrt((sa**5)*sb**7/7.5d00)*(rab**6)*0.03125d00
      td = 2.d00
      s(ips,isp,1)=-w*rt3*(a(5)*(td*b(3)-b(1))-b(5)*(td*a(3)-a(1))-a(2
     1)*(b(6)-td*b(4))+b(2)*(a(6)-td*a(4)))
      call set (epa,epb,na,nb,rab,nbond,ii)
      w=dsqrt((sa**5)*sb**7/7.5d00)*(rab**6)*0.03125d00
      s(2,2,1)=-w*(b(4)*(a(1)+a(5))-a(4)*(b(1)+b(5))
     1+b(3)*(a(2)+a(6))-a(3)*(b(2)+b(6)))
      hd = .5d00
      s(2,2,2)=hd*w*(a(6)*(b(1)-b(3))-b(6)*(a(1)-
     1a(3))+a(5)*(b(2)-b(4))-b(5
     2)*(a(2)-a(4))-a(4)*b(1)+b(4)*a(1)-a(3)*b(2)+b(3)*a(2))
      return
c
c *** third row - third row overlaps
c
   70 call set (esa,esb,na,nb,rab,nbond,ii)
      w=dsqrt((sa*sb*rab*rab)**7)/480.d00
      rt3 = 1.d00 / dsqrt(3.d00)
      s(1,1,1)=w*(a(7)*b(1)-3.d00*(a(5)*b(3)-a(3)*b(5))-a(1)*b(7))/3.d00
      call set (esa,epb,na,nb,rab,nbond,ii)
      if (na.gt.nb) call set (epa,esb,na,nb,rab,nbond,ii)
      w=dsqrt((sa*sb*rab*rab)**7)/480.d00
      d=a(6)*(b(1)-b(3))-2.d00*a(4)*(b(3)-b(5))+a(2)*(b(5)-b(7))
      e=b(6)*(a(1)-a(3))-2.d00*b(4)*(a(3)-a(5))+b(2)*(a(5)-a(7))
      s(isp,ips,1)=w*rt3*(d-e)
      call set (epa,esb,na,nb,rab,nbond,ii)
      if (na.gt.nb) call set (esa,epb,na,nb,rab,nbond,ii)
      w=dsqrt((sa*sb*rab*rab)**7)/480.d00
      d=a(6)*(b(1)-b(3))-2.d00*a(4)*(b(3)-b(5))+a(2)*(b(5)-b(7))
      e=b(6)*(a(1)-a(3))-2.d00*b(4)*(a(3)-a(5))+b(2)*(a(5)-a(7))
      s(ips,isp,1)=-w*rt3*(-d-e)
      call set (epa,epb,na,nb,rab,nbond,ii)
      w=dsqrt((sa*sb*rab*rab)**7)/480.d00
      td = 2.d00
      s(2,2,1)=-w*(a(3)*(b(7)+td*b(3))-a(5)*(b(1)+
     1td*b(5))-b(5)*a(1)+a(7)*b(3))
      hd = .5d00
      s(2,2,2)=hd*w*(a(7)*(b(1)-b(3))+b(7)*(a(1)-
     1a(3))+a(5)*(b(5)-b(3)-b(1)
     2)+b(5)*(a(5)-a(3)-a(1))+2.d00*a(3)*b(3))
      return
c
      end
      function digit(string,istart)
c     fortran function to convert numeric field to double precision
c     number.  the string is assumed to be clean (no invalid digit
c     or character combinations from istart to the first nonspace,
c     nondigit, nonsign, and nondecimal point character).
c
      REAL c1,c2,deciml,digit
      character string*(*)
      logical sign
c
c     define ascii values of numeric field characters
      i0=ichar('0')
      i9=ichar('9')
      ineg=ichar('-')
      ipos=ichar('+')
      idot=ichar('.')
      ispc=ichar(' ')
c
      c1=0.d0
      c2=0.d0
      sign=.true.
      l=len(string)
c
c     determine the contribution to the number greater than one
      idig=0
      do 10 i=istart,l
         n=ichar(string(i:i))
         if(n.ge.i0.and.n.le.i9)then
            idig=idig+1
            c1=c1*1.d1+n-i0
         elseif(n.eq.ineg.or.n.eq.ipos.or.n.eq.ispc)then
            if(n.eq.ineg)sign=.false.
         elseif(n.eq.idot)then
            goto 20
         else
            goto 40
         endif
   10 continue
c
c     determine the contribution to the number less than than one
   20 deciml=1.d0
      do 30 j=i+1,l
         n=ichar(string(j:j))
         if(n.ge.i0.and.n.le.i9)then
            deciml=deciml/1.d1
            c2=c2+(n-i0)*deciml
         elseif(n.ne.ispc)then
            goto 40
         endif
   30 continue
c
c     put the pieces together
   40 digit=c1+c2
      if(.not.sign)digit=-digit
      return
      end
      subroutine dihed(xyz,i,j,k,l,angle)
      implicit REAL (a-h,o-z)
      dimension xyz(3,*)
*********************************************************************
*
*      dihed calculates the dihedral angle between atoms i, j, k,
*            and l.  the cartesian coordinates of these atoms
*            are in array xyz.
*
*     dihed is a modified version of a routine of the same name
*           which was written by dr. w. theil in 1973.
*
*********************************************************************
      xi1=xyz(1,i)-xyz(1,k)
      xj1=xyz(1,j)-xyz(1,k)
      xl1=xyz(1,l)-xyz(1,k)
      yi1=xyz(2,i)-xyz(2,k)
      yj1=xyz(2,j)-xyz(2,k)
      yl1=xyz(2,l)-xyz(2,k)
      zi1=xyz(3,i)-xyz(3,k)
      zj1=xyz(3,j)-xyz(3,k)
      zl1=xyz(3,l)-xyz(3,k)
c      rotate around z axis to put kj along y axis
      dist= dsqrt(xj1**2+yj1**2+zj1**2)
      cosa=zj1/dist
      if(cosa.gt.1.0d0) cosa=1.0d0
      if(cosa.lt.-1.0d0) cosa=-1.0d0
      ddd=1.0d0-cosa**2
      if(ddd.le.0.0) go to 10
      yxdist=dist* dsqrt(ddd)
      if(yxdist.gt.1.0d-6) go to 20
   10 continue
      xi2=xi1
      xl2=xl1
      yi2=yi1
      yl2=yl1
      costh=cosa
      sinth=0.d0
      go to 30
   20 cosph=yj1/yxdist
      sinph=xj1/yxdist
      xi2=xi1*cosph-yi1*sinph
      xl2=xl1*cosph-yl1*sinph
      yi2=xi1*sinph+yi1*cosph
      yj2=xj1*sinph+yj1*cosph
      yl2=xl1*sinph+yl1*cosph
c      rotate kj around the x axis so kj lies along the z axis
      costh=cosa
      sinth=yj2/dist
   30 continue
      yi3=yi2*costh-zi1*sinth
      yl3=yl2*costh-zl1*sinth
      call dang(xl2,yl3,xi2,yi3,angle)
      if (angle .lt. 0.) angle=4.0d0* dasin(1.0d00)+angle
      if (angle .ge. 6.2831853d0 ) angle=0.d0
      return
      end
      subroutine diism(xp, xparam, gp, grad, hp, heat, hs, nvar, frst)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      dimension xp(nvar), xparam(nvar), gp(nvar),
     1grad(nvar), hs(nvar*nvar)
      logical frst
************************************************************************
*                                                                      *
*     diism performs direct inversion in the iterative subspace        *
*                                                                      *
*     this involves solving for c in xparam(new) = xparam' - hg'       *
*                                                                      *
*  where xparam' = sum(c(i)xparam(i), the c coefficientes coming from  *
*                                                                      *
*                   | b   1 | . | c | = | 0 |                          *
*                   | 1   0 |   |-l |   | 1 |                          *
*                                                                      *
* where b(i,j) =grad(i)h(t)hgrad(j)  grad(i) = gradient on cycle i     *
*                              h    = inverse hessian                  *
*                                                                      *
*                          reference                                   *
*                                                                      *
*  p. csaszar, p. pulay, j. mol. struct. (theochem), 114, 31 (1984)    *
*                                                                      *
************************************************************************
************************************************************************
*                                                                      *
*     geometry optimization using the method of direct inversion in    *
*     the iterative subspace (gdiis), combined with the bfgs optimizer *
*     (a variable metric method)                                       *
*                                                                      *
*     written by peter l. cummins, university of sydney, australia     *
*                                                                      *
*                              reference                               *
*                                                                      *
*      "computational strategies for the optimization of equilibrium   *
*     geometries and transition-state structures at the semiempirical  *
*     level", peter l. cummins, jill e. gready, j. comp. chem., 10,    *
*     939-950 (1989).                                                  *
*                                                                      *
*     modified by jjps to conform to existing mopac conventions        *
*                                                                      *
************************************************************************
      common /keywrd/ keywrd
      common/iofile/mfgr,mfgw
      parameter (mreset=15, m2=(mreset+1)*(mreset+1))
      common/scrtch/ xset(mreset*maxpar),gset(mreset*maxpar), 
     + eset(mreset),dx(maxpar),gsave(maxpar),
     1 err(mreset*maxpar),b(m2),bs(m2),bst(m2)
      logical debug, print
      character*241 keywrd
      save mset
      debug=.false.
      print=(index(keywrd,' diis').ne.0)
      if (print) debug=(index(keywrd,'debug').ne.0)
      if (print)  write(mfgw,'(/,''      ***** begin gdiis ***** '')')
c
c  space simply loads the current values of xparam and gnorm into
c  the arrays xset and gset
c
      call space(mreset,mset,xparam, grad, heat, nvar, xset, gset, eset
     1, frst)
c
c     initialize some variables and constants
c
      ndiis = mset
      mplus = mset + 1
      mm = mplus * mplus
c
c     compute the approximate error vectors
c
      inv=-nvar
      do 30 i=1,mset
         inv = inv + nvar
         do 30 j=1,nvar
            s = 0.d0
            kj=(j*(j-1))/2
            do 10 k=1,j
               kj = kj+1
   10       s = s - hs(kj) * gset(inv+k)
            do 20 k=j+1,nvar
               kj = (k*(k-1))/2+j
   20       s = s - hs(kj) * gset(inv+k)
   30 err(inv+j) = s
c
c     construct the gdiis matrix
c
      do 40 i=1,mm
   40 b(i) = 1.d0
      jj=0
      inv=-nvar
      do 50 i=1,mset
         inv=inv+nvar
         jnv=-nvar
         do 50 j=1,mset
            jnv=jnv+nvar
            jj = jj + 1
            b(jj)=0.d0
            do 50 k=1,nvar
   50 b(jj) = b(jj) + err(inv+k) * err(jnv+k)
c
      do 60 i=mset-1,1,-1
         do 60 j=mset,1,-1
   60 b(i*mset+j+i) = b(i*mset+j)
      do 70 i=1,mplus
         b(mplus*i) = 1.d0
   70 b(mplus*mset+i) = 1.d0
      b(mm) = 0.d0
c
c     eliminate error vectors with the largest norm
c
   80 continue
      do 90 i=1,mm
   90 bs(i) = b(i)
      if (ndiis .eq. mset) go to 140
      do 130 ii=1,mset-ndiis
         xmax = -1.d10
         itera = 0
         do 110 i=1,mset
            xnorm = 0.d0
            inv = (i-1) * mplus
            do 100 j=1,mset
  100       xnorm = xnorm + dabs(b(inv + j))
            if (xmax.lt.xnorm .and. xnorm.ne.1.0d0) then
               xmax = xnorm
               itera = i
               ione = inv + i
            endif
  110    continue
         do 120 i=1,mplus
            inv = (i-1) * mplus
            do 120 j=1,mplus
               jnv = (j-1) * mplus
               if (j.eq.itera) b(inv + j) = 0.d0
               b(jnv + i) = b(inv + j)
  120    continue
         b(ione) = 1.0d0
  130 continue
  140 continue
c
      if (debug) then
c
c     output the gdiis matrix
c
         write(mfgw,'(/5x,'' gdiis matrix'')')
         ij = 0
         do 150 i=1,mplus
            do 150 j=1,i
               ij = ij + 1
  150    bst(ij) = b( mplus * (j-1) + i)
         call vecprt(bst,mplus)
      endif
c
c     scale diis matrix before inversion
c
      do 160 i=1,mplus
         ii = mplus * (i-1) + i
  160 gsave(i) = 1.d0 / dsqrt(1.d-20+dabs(b(ii)))
      gsave(mplus) = 1.d0
      do 170 i=1,mplus
         do 170 j=1,mplus
            ij = mplus * (i-1) + j
  170 b(ij) = b(ij) * gsave(i) * gsave(j)
c
      if (debug) then
c
c     output scaled gdiis matrix
c
         write(mfgw,'(/5x,'' gdiis matrix (scaled)'')')
         ij = 0
         do 180 i=1,mplus
            do 180 j=1,i
               ij = ij + 1
  180    bst(ij) = b( mplus * (j-1) + i)
         call vecprt(bst,mplus)
      endif
c
c     invert the gdiis matrix
c
      call minv(b,mplus,det)
c
      do 190 i=1,mplus
         do 190 j=1,mplus
            ij = mplus * (i-1) + j
  190 b(ij) = b(ij) * gsave(i) * gsave(j)
c
c     compute the intermediate interpolated parameter and gradient
c     vectors
c
      do 200 k=1,nvar
         xp(k) = 0.d0
         gp(k) = 0.d0
         do 200 i=1,mset
            ink = (i-1) * nvar + k
            xp(k) = xp(k) + b(mplus*mset+i) * xset(ink)
  200 gp(k) = gp(k) + b(mplus*mset+i) * gset(ink)
      hp=0.d0
      do 210 i=1,mset
  210 hp=hp+b(mplus*mset+i)*eset(i)
c
      do 220 k=1,nvar
  220 dx(k) = xparam(k) - xp(k)
      xnorm = dsqrt(ddot(nvar,dx,1,dx,1))
      if (print) then
         write (mfgw,'(/10x,''deviation in x '',f7.4,8x,
     +   ''determinant '', g9.3)') xnorm,det
         write(mfgw,'(10x,''gdiis coefficients'')')
         write(mfgw,'(10x,5f12.5)') (b(mplus*mset+i),i=1,mset)
      endif
c
c     the following tolerences for xnorm and det are somewhat arbitrary!
c
      thres = dmax1(10.d0**(-nvar), 1.d-25)
      if (xnorm.gt.2.d0 .or. dabs(det).lt. thres) then
         if (print) 
     +   write(mfgw,'(10x,''the diis matrix is ill conditioned''
     1, /10x,'' - probably, vectors are linearly dependent - '',
     2 /10x,''the diis step will be repeated with a smaller space'')')
         do 230 k=1,mm
  230    b(k) = bs(k)
         ndiis = ndiis - 1
         if (ndiis .gt. 0) go to 80
         if (print) write(mfgw,'(10x,''newton-raphson step taken'')')
         do 240 k=1,nvar
            xp(k) = xparam(k)
  240    gp(k) = grad(k)
c
      endif
      if (print)  write(mfgw,'(/,''      ***** end gdiis ***** '',/)')
c
      return
      end
      subroutine dijkl1 (c,n,nati,w,cij,wcij,ckl)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      dimension c(n,*), w(*)
      dimension cij(10*maxorb), wcij(10*maxorb), ckl(10*maxorb)
************************************************************************
*
*   dijkl1 is similar to ijkl.  the main differences are that
*   the array w contains the two electron integrals between
*   one atom (nati) and all the other atoms in the system.
*
*           on exit
*
*   the array xy is filled with the differentials of the
*   two-electron integrals over active-space m.o.s w.r.t. motion
*   of the atom nati.
************************************************************************
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),
     1                nlast(numatm), norbs, nelecs,nalpha,nbeta,
     2                nclose,nopen,ndumy,fract
      common /cibits/ nmos,lab,nelec, nbo(3)
      common /xyijkl/ xy(nmeci,nmeci,nmeci,nmeci)
      dimension nb(0:8)
      data nb /1,0,0,10,0,0,0,0,45/
      na=nmos
      do 110 i=1,na
         do 110 j=1,i
            ipq=0
            do 20 ii=1,numat
               if(ii.eq.nati) goto 20
               do 10 ip=nfirst(ii),nlast(ii)
                  do 10 iq=nfirst(ii),ip
                     ipq=ipq+1
                     cij(ipq)=c(ip,i)*c(iq,j)+c(ip,j)*c(iq,i)
   10          continue
   20       continue
            i77=ipq+1
            do 30 ip=nfirst(nati),nlast(nati)
               do 30 iq=nfirst(nati),ip
                  ipq=ipq+1
                  cij(ipq)=c(ip,i)*c(iq,j)+c(ip,j)*c(iq,i)
   30       continue
            do 40 ii=1,ipq
   40       wcij(ii)=0.d0
            kr=1
            js=1
            nbj=nb(nlast(nati)-nfirst(nati))
            do 50 ii=1,numat
               if (ii.eq.nati) goto 50
               nbi=nb(nlast(ii)-nfirst(ii))
               call formxy
     1(w(kr), kr, wcij(i77), wcij(js), cij(i77), nbj, cij(js), nbi)
               js=js+nbi
   50       continue
            do 100 k=1,i
               if(k.eq.i) then
                  ll=j
               else
                  ll=k
               endif
               do 100 l=1,ll
                  ipq=0
                  do 70 ii=1,numat
                     if(ii.eq.nati) goto 70
                     do 60 ip=nfirst(ii),nlast(ii)
                        do 60 iq=nfirst(ii),ip
                           ipq=ipq+1
                           ckl(ipq)=c(ip,k)*c(iq,l)+c(ip,l)*c(iq,k)
   60                continue
   70             continue
                  do 80 ip=nfirst(nati),nlast(nati)
                     do 80 iq=nfirst(nati),ip
                        ipq=ipq+1
                        ckl(ipq)=c(ip,k)*c(iq,l)+c(ip,l)*c(iq,k)
   80             continue
                  sum=0.d0
                  do 90 ii=1,ipq
   90             sum=sum+ckl(ii)*wcij(ii)
                  xy(i,j,k,l)=sum
                  xy(i,j,l,k)=sum
                  xy(j,i,k,l)=sum
                  xy(j,i,l,k)=sum
                  xy(k,l,i,j)=sum
                  xy(k,l,j,i)=sum
                  xy(l,k,i,j)=sum
                  xy(l,k,j,i)=sum
  100       continue
  110 continue
      return
      end
      subroutine dijkl2 (dc,norbs,nmos,dijkl,wijkl,nmeci)
      implicit REAL (a-h,o-z)
************************************************************************
*     relaxation of 2-electrons integrals in m.o basis.
*
*   input
*   dc(norbs,nmos) : c.i-active m.o derivatives in m.o basis, in column.
*   norbs          : total number of m.o.
*   nmos           : number of c.i-active m.o.
*   dijkl(i,j,kl)  : <i(1),j(1)|k(2),l(2)> with
*                     i              over     all    m.o.
*                     j,kl canonical over c.i-active m.o.
*   nmeci          : max. size of wijkl. (nmos <= nmeci).
*   output
*     wijkl(i,j,k,l)= d< i(1),j(1) | k(2),l(2) >
*                   = <di,j|k,l> + <i,dj|k,l> + <i,j|dk,l> + <i,j|k,dl>
*                     with i,j,k,l over all c.i-active m.o.
*     written by daniel liotard
* (note by jjps: as this code is highly efficient, no changes were made)
************************************************************************
      dimension dc(norbs,*),wijkl(nmeci,nmeci,nmeci,nmeci)
      dimension dijkl(norbs,nmos,*)
      logical lij,lkl
c
      ij=0
      do 10 i=1,nmos
         do 10 j=1,i
            ij=ij+1
            lij=i.eq.j
            kl=0
            do 10 k=1,i
               if(k.eq.i) then
                  ll=j
               else
                  ll=k
               endif
               do 10 l=1,ll
                  kl=kl+1
                  lkl=k.eq.l
                  val=  ddot(norbs,dc(1,i),1,dijkl(1,j,kl),1)
                  if(lij.and.lkl.and.j.eq.k) then
                     val=val*4.d0
                  else
                     if(lij) then
                        val=val*2.d0
                     else
                        val=val+ ddot(norbs,dc(1,j),1,dijkl(1,i,kl),1)
                     endif
                     val2= ddot(norbs,dc(1,k),1,dijkl(1,l,ij),1)
                     if(lkl) then
                        val=val+val2*2.d0
                     else
                      val=val+val2+ddot(norbs,dc(1,l),1,dijkl(1,k,ij),1)
                     endif
                  endif
                  wijkl(i,j,k,l)=val
                  wijkl(i,j,l,k)=val
                  wijkl(j,i,k,l)=val
                  wijkl(j,i,l,k)=val
                  wijkl(k,l,i,j)=val
                  wijkl(k,l,j,i)=val
                  wijkl(l,k,i,j)=val
   10 wijkl(l,k,j,i)=val
      return
      end
      subroutine dipind (dipvec)
c...............................................................
c  modification of dipole subroutine for use in the calculation
c  of the induced dipoles for polarizabilities.
c...............................................................
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      common /corec/ core(107)
      common /densty/ p(mpack),pa(mpack),pb(mpack)
      common /molmec/ htype(4),nhco(4,20),nnhco,itype
      common /cmpg/ geo(3,numatm)
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),
     1                nlast(numatm),norbs,nelecs,nalpha,nbeta,
     2                nclose,nopen,ndumy,fract
      common /numcal/ numcal
      common /keywrd/ keywrd
      common /istope/ ams(107)
      common /multip/ dd(107), qq(107), am(107), ad(107), aq(107)
      common/iofile/mfgr,mfgw
      dimension q(maxorb),q2(maxorb),dipvec(3),center(3),
     1          coord(3,numatm)
      character*241 keywrd
c
c***********************************************************************
c     dipind calculates dipole moments
c
c  on input p     = density matrix
c           q     = total atomic charges, (nuclear + electronic)
c           numat = number of atoms in molecule
c           nat   = atomic numbers of atoms
c           nfirst= start of atom orbital counters
c           coord = coordinates of atoms
c
c  output  dipole = dipole moment
c***********************************************************************
c
c     in the zdo approximation, only two terms are retained in the
c     calculation of dipole moments.
c     1. the point charge term (independent of parameterization).
c     2. the one-center hybridization term, which arises from matrix
c     elements of the form <ns/r/np>. this term is a function of
c     the slater exponents (zs,zp) and is thus dependent on parameter-
c     ization. the hybridization factors (hyf(i)) used in this sub-
c     routine are calculated from the following formulae.
c     for second row elements <2s/r/2p>
c     hyf(i)= 469.56193322*(sqrt(((zs(i)**5)*(zp(i)**5)))/
c           ((zs(i) + zp(i))**6))
c     for third row elements <3s/r/3p>
c     hyf(i)=2629.107682607*(sqrt(((zs(i)**7)*(zp(i)**7)))/
c           ((zs(i) + zp(i))**8))
c     for fourth row elements and up :
c     hyf(i)=2*(2.10716)*dd(i)
c     where dd(i) is the charge separation in atomic units
c
c
c     references:
c     j.a.pople & d.l.beveridge: approximate m.o. theory
c     s.p.mcglynn, et al: applied quantum chemistry
c
      dimension dip(4,3)
      dimension hyf(107,2)
      save icalcn, hyf, wtmol, chargd, force
      logical force, chargd
      data hyf(1,1)     / 0.0d00           /
      data   hyf(1,2) /0.0d0     /
      data   hyf(5,2) /6.520587d0/
      data   hyf(6,2) /4.253676d0/
      data   hyf(7,2) /2.947501d0/
      data   hyf(8,2) /2.139793d0/
      data   hyf(9,2) /2.2210719d0/
      data   hyf(14,2)/6.663059d0/
      data   hyf(15,2)/5.657623d0/
      data   hyf(16,2)/6.345552d0/
      data   hyf(17,2)/2.522964d0/
      data icalcn/0/
c
c  setup for dipole calculation
c
      call chrge (p,q2)
      do 10 i = 1,numat
         q(i) = core(nat(i)) - q2(i)
   10 continue
      call gmetry (geo,coord)
c
      if (icalcn.ne.numcal) then
         do 20 i=2,107
   20    hyf(i,1)= 5.0832d0*dd(i)
         wtmol=0.d0
         sum=0.d0
         do 30 i=1,numat
            wtmol=wtmol+ams(nat(i))
   30    sum=sum+q(i)
         chargd=(dabs(sum).gt.0.5d0)
         icalcn=numcal
         force=(index(keywrd,'force') +index(keywrd,'irc').ne. 0)
         ktype=1
         if(itype.eq.4)ktype=2
      endif
      if(chargd)then
c
c   need to reset ion's position so that the center of mass is at the
c   origin.
c
c$doit asis
         do 40 i=1,3
   40    center(i)=0.d0
         do 50 i=1,3
c$doit vbest
            do 50 j=1,numat
   50    center(i)=center(i)+ams(nat(j))*coord(i,j)
c$doit asis
         do 60 i=1,3
   60    center(i)=center(i)/wtmol
         do 70 i=1,3
c$doit vbest
            do 70 j=1,numat
   70    coord(i,j)=coord(i,j)-center(i)
      endif
c$doit asis
      do 80 i=1,4
c$doit asis
         do 80 j=1,3
   80 dip(i,j)=0.0d00
c$doit asis
      do 100 i=1,numat
         ni=nat(i)
         ia=nfirst(i)
         l=nlast(i)-ia
c$doit asis
         do 90 j=1,l
            k=((ia+j)*(ia+j-1))/2+ia
   90    dip(j,2)=dip(j,2)-hyf(ni,ktype)*p(k)
c$doit asis
         do 100 j=1,3
  100 dip(j,1)=dip(j,1)+4.803d00*q(i)*coord(j,i)
c$doit asis
      do 110 j=1,3
  110 dip(j,3)=dip(j,2)+dip(j,1)
c$doit asis
      do 120 j=1,3
  120 dip(4,j)=dsqrt(dip(1,j)**2+dip(2,j)**2+dip(3,j)**2)
      dipvec(1)= -dip(1,3)
      dipvec(2)= -dip(2,3)
      dipvec(3)= -dip(3,3)
c      write (mfgw,60) ((dip(i,j),i=1,4),j=1,3)
c   60 format (3(4f10.3))
      return
c
      end
      function dipmop (p,q,coord,dipvec, mode)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      common /molkst/ numat,nat(numatm),nfirst(numatm), nmidle(numatm),
     1                nlast(numatm), norbs, nelecs,nalpha,nbeta,
     2                nclose,nopen,ndumy,fract
      common /dipsto/ ux,uy,uz,ch(numatm)
      common /keywrd/ keywrd
      common /molmec/ htype(4),nhco(4,20),nnhco,itype
      common /istope/ ams(107)
      common /multip/ dd(107), qq(107), am(107), ad(107), aq(107)
      common /numcal/ numcal
      common/iofile/mfgr,mfgw
      dimension p(*),q(*),coord(3,*),dipvec(3), center(3)
      character*241 keywrd
c***********************************************************************
c     dipmop calculates dipole moments
c
c  on input p     = density matrix
c           q     = total atomic charges, (nuclear + electronic)
c           numat = number of atoms in molecule
c           nat   = atomic numbers of atoms
c           nfirst= start of atom orbital counters
c           coord = coordinates of atoms
c
c  output  dipmop = dipole moment
c***********************************************************************
c
c     in the zdo approximation, only two terms are retained in the
c     calculation of dipole moments.
c     1. the point charge term (independent of parameterization).
c     2. the one-center hybridization term, which arises from matrix
c     elements of the form <ns/r/np>. this term is a function of
c     the slater exponents (zs,zp) and is thus dependent on parameter-
c     ization. the hybridization factors (hyf(i)) used in this sub-
c     routine are calculated from the following formulae.
c     for second row elements <2s/r/2p>
c     hyf(i)= 469.56193322*(sqrt(((zs(i)**5)*(zp(i)**5)))/
c           ((zs(i) + zp(i))**6))
c     for third row elements <3s/r/3p>
c     hyf(i)=2629.107682607*(sqrt(((zs(i)**7)*(zp(i)**7)))/
c           ((zs(i) + zp(i))**8))
c     for fourth row elements and up :
c     hyf(i)=2*(2.10716)*dd(i)
c     where dd(i) is the charge separation in atomic units
c
c
c     references:
c     j.a.pople & d.l.beveridge: approximate m.o. theory
c     s.p.mcglynn, et al: applied quantum chemistry
c
      dimension dip(4,3)
      dimension hyf(107,2)
      save first, hyf, dip, wtmol, chargd, force, ktype
      logical first, force, chargd
      data hyf(1,1)     / 0.0d00           /
      data   hyf(1,2) /0.0d0     /
      data   hyf(5,2) /6.520587d0/
      data   hyf(6,2) /4.253676d0/
      data   hyf(7,2) /2.947501d0/
      data   hyf(8,2) /2.139793d0/
      data   hyf(9,2) /2.2210719d0/
      data   hyf(14,2)/6.663059d0/
      data   hyf(15,2)/5.657623d0/
      data   hyf(16,2)/6.345552d0/
      data   hyf(17,2)/2.522964d0/
      save icalcn
      data icalcn/0/
      first=(icalcn.ne.numcal)
      icalcn=numcal
      if (first) then
         do 10 i=2,107
   10    hyf(i,1)= 5.0832d0*dd(i)
         wtmol=0.d0
         sum=0.d0
         do 20 i=1,numat
            wtmol=wtmol+ams(nat(i))
   20    sum=sum+q(i)
         chargd=(dabs(sum).gt.0.5d0)
         force=(index(keywrd,'force') +index(keywrd,'irc').ne. 0)
         ktype=1
         if(itype.eq.4)ktype=2
      endif
      if(.not.force.and.chargd)then
c
c   need to reset ion's position so that the center of mass is at the
c   origin.
c
         do 30 i=1,3
   30    center(i)=0.d0
         do 40 i=1,3
            do 40 j=1,numat
   40    center(i)=center(i)+ams(nat(j))*coord(i,j)
         do 50 i=1,3
   50    center(i)=center(i)/wtmol
         do 60 i=1,3
            do 60 j=1,numat
   60    coord(i,j)=coord(i,j)-center(i)
      endif
      do 70 i=1,4
         do 70 j=1,3
   70 dip(i,j)=0.0d00
      do 90 i=1,numat
         ni=nat(i)
         ia=nfirst(i)
         l=nlast(i)-ia
         do 80 j=1,l
            k=((ia+j)*(ia+j-1))/2+ia
   80    dip(j,2)=dip(j,2)-hyf(ni,ktype)*p(k)
         do 90 j=1,3
   90 dip(j,1)=dip(j,1)+4.803d00*q(i)*coord(j,i)
      do 100 j=1,3
  100 dip(j,3)=dip(j,2)+dip(j,1)
      do 110 j=1,3
  110 dip(4,j)=dsqrt(dip(1,j)**2+dip(2,j)**2+dip(3,j)**2)
      if( force) then
         dipvec(1)=dip(1,3)
         dipvec(2)=dip(2,3)
         dipvec(3)=dip(3,3)
      endif
      if(mode.eq.1)write (mfgw,130) ((dip(i,j),i=1,4),j=1,3)
c     store dipole moment components in ux,uy,uz for use in
c     assigning charges determined from the esp. bhb
      ux=dip(1,3)
      uy=dip(2,3)
      uz=dip(3,3)
c
c     store charges q in array ch for use in assigning symmetry to
c     charges. bhb
      do 120 i=1,numat
  120 ch(i)=q(i)
      dipmop = dip(4,3)
      return
c
  130 format (' dipole',11x,'x         y         z       total',/,
     1' point-chg.',4f10.3/,' hybrid',4x,4f10.3/,' sum',7x,4f10.3)
c
      end
      function dist2m(a,b)
c
c     determine distances between neighboring atoms
c
      implicit REAL (a-h,o-z)
      dimension a(3)
      dimension b(3)
      dist2m = (a(1)-b(1))**2 + (a(2)-b(2))**2 + (a(3)-b(3))**2
      return
      end
      subroutine dofs(eref,mono3,n,dd,m,bottom,top)
      implicit REAL (a-h,o-z)
      common/iofile/mfgr,mfgw
      dimension eref(mono3,n), dd(m)
************************************************************************
*                                                                      *
* dofs forms a normalised, slightly smoothed density of states for a   *
*      1-d density of states                                           *
*  on input eref = reference energy levels                             *
*           p    = population of energy levels (=1 for energy d.o.s.   *
*                  or atomic orbital population for partial d.o.s.)    *
*           n    = number of energy levels supplied                    *
*           m    = size of d.o.s. vector                               *
*           d    = array to hold d.o.s.                                *
*           bottom = bottom of d.o.s. vector                           *
*           top    = top of d.o.s. vector                              *
*                                                                      *
*   on output d = density of states.  this analyses is independent of n*
*                 roughness will occur if n < ca. 30.                  *
*                                                                      *
************************************************************************
c
c  first, empty the density-of-states (dos) bins
c
      do 10 i=1,500
   10 dd(i)=0.d0
c
c   spread out the energies over the energy spectrum, top to bottom
c
      range=(m+1)/(top-bottom)
      do 20 j=1,mono3
         do 20 i=1,n
            x=eref(j,i)
            if(x.lt.bottom.or.x.gt.top) x=-1.d7
   20 eref(j,i)=(x-bottom)*range
      do 40 ii=1,mono3
         do 40 i=2,n
            b=eref(ii,i-1)
            if(b.lt.1) goto 40
            a=eref(ii,i)
            if(a.lt.1) goto 40
            if(b .gt. a) then
               x=b
               b=a
               a=x
            endif
            j=b
            k=a
c
c if j equals k the interval falls within one bin
c
            if(j.eq.k) then
               dd(k)=dd(k)+1.d0
            else
               spread=1.d0/(a-b+1.d-12)
               partj=(j+1-b)*spread
               partk=(a-k)*spread
               dd(j)=dd(j)+partj
               dd(k)=dd(k)+partk
c
c if k equals j+1 the interval straddles two bins
c
               if(k .ne. j+1) then
c
c if k is greater than j+1 the interval covers more than two bins
c
                  j=j+1
                  k=k-1
                  do 30 l=j,k
   30             dd(l)=dd(l)+spread
               endif
            endif
   40 continue
      x=m/((n-1)*(top-bottom))
      do 50  i=1,m
   50 dd(i)=dd(i)*x
      write(mfgw,'(a)')' normalized density of states'
c
c  the first 'bin' has lower bound at bottom and upper bound
c  at bottom+range, therefore the first 'bin' is for bottom+0.5*range
c  the last 'bin' has bounds top-range and top,
c  therefor the last 'bin' is for top-0.5*range
      range=m/(top-bottom)
      do 60 i=1,m
   60 write(mfgw,'(f9.2,f12.6)')bottom+(i-0.5d0)/range,dd(i)
      return
      end
      subroutine drc(startv, startk)
      implicit REAL (a-h,o-z)
_IF(ipsc,tools)
      logical oroot
_ENDIF
      dimension startv(*), startk(*)
************************************************************************
*                                                                      *
*    drc is designed to follow a reaction path from the transition     *
*    state.  two modes are supported, first: gas phase:- as the system *
*    moves from the t/s the momentum of the atoms is stored and the    *
*    position of the atoms is related to the old position by (a) the   *
*    current velocity of the atom, and (b) the forces acting on that   *
*    atom.  the second mode is condensed phase, in which the atoms move*
*    in response to the forces acting on them. i.e. infinitely damped  *
*                                                                      *
************************************************************************
INCLUDE(common/sizes)
INCLUDE(../m4/common/utilc)
      common /keywrd/ keywrd
      common /timdmp/ tleft, tdump
      common /densty/ p(mpack),pa(mpack),pb(mpack)
      common /gradnt/ grad(maxpar),gnorm
      common /numcal/ numcal
      common /geosym/ ndep,locpar(maxpar),idepfn(maxpar),locdep(maxpar)
      common /cmpg/ geo(3,numatm)
      common /atmass/ atmass(numatm)
      common /geovar/ nvar, loc(2,maxpar), idumy, xparam(maxpar)
      common /geokst/ natoms,labels(numatm),
     1                na(numatm),nb(numatm),nc(numatm)
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),
     1                nlast(numatm), norbs, nelecs,nalpha,nbeta,
     2                nclose,nopen,ndumy,xract
      common /drccom/ mcoprt(2,maxpar), ncoprt, prtmax
      common/iofile/mfgr,mfgw
      character keywrd*241, getmop*80
      dimension velref(maxpar), velo0(maxpar), velo1(maxpar),
     1velo2(maxpar), velo3(maxpar), gerror(maxpar),
     2coord(3,numatm), grold2(maxpar), past10(10),
     3grold(maxpar), parold(maxpar), georef(3,numatm),
     4 sqrtms(maxpar)
      logical int, addk, letot, let, velred,prtmax, ircdrc
      data velo0/maxpar*0.d0/, int/.true./
      data addk/.true./
      tnow=secmop()
      oldtim=secmop()
      delold=10.d0
      gtot=0.d0
      open(unit=7,status='scratch')
      if(index(keywrd,' prec').ne.0)then
         accu=0.25d0
      else
         accu=1.d0
      endif
      gnlim=1.d0
      past10(5)=100.d0
      i=index(keywrd,'gnorm')
      if(i.ne.0)gnlim=reada(keywrd,i)
      velred=(index(keywrd,'velo').ne.0)
      if(ddot(3*numat,startv,1,startv,1).gt.0.001d0)then
c
c     print out initial velocities
c
         write(mfgw,'(a)')' initial velocity in drc'
         write(mfgw,'(3f13.5)')(startv(i),i=1,numat*3)
      endif
      let=(index(keywrd,' geo-ok').ne.0.or.velred)
      if(index(keywrd,' sym').ne.0)then
         write(mfgw,*)
     +  '  symmetry specified, but cannot be used in drc'
         ndep=0
      endif
c
c      convert to cartesian coordinates, if not already done.
c
      if(index(keywrd,' xyz').eq.0)then
         na(1)=0
         call gmetry(geo,coord)
         l=0
c
         do 10 i=1,numat
            labels(i)=nat(i)
            sum=dsqrt(atmass(nat(i)))
            sqrtms(l+1)=sum
            sqrtms(l+2)=sum
            sqrtms(l+3)=sum
            l=l+3
   10    continue
         do 30 j=1,3
            do 20 i=1,numat
               geo(j,i)=coord(j,i)
               coord(j,i)=0.0d0
   20       continue
   30    continue
c
         na(1)=99
      endif
c
c  transfer coordinates to xparam and loc
c
      if(index(keywrd,' drc').ne.0)then
         prtmax=(loc(1,1).eq.1)
         if(prtmax)then
            j=1
         else
            j=0
         endif
         nvar=nvar-j
         do 40 i=1,nvar
            mcoprt(1,i)=loc(1,i+j)
   40    mcoprt(2,i)=loc(2,i+j)
         if(loc(1,1).eq.0)nvar=0
         ncoprt=nvar
      else
         ncoprt=0
      endif
      l=0
      do 50 i=1,numat
         loc(1,l+1)=i
         loc(2,l+1)=1
         georef(1,i)=geo(1,i)
         xparam(l+1)=geo(1,i)
c
         loc(1,l+2)=i
         loc(2,l+2)=2
         georef(2,i)=geo(2,i)
         xparam(l+2)=geo(2,i)
c
         loc(1,l+3)=i
         loc(2,l+3)=3
         georef(3,i)=geo(3,i)
         xparam(l+3)=geo(3,i)
c
         l=l+3
   50 continue
      nvar=numat*3
c
c determine damping factor
c
      ircdrc=(index(keywrd,'irc=').ne.0)
      if(index(keywrd,'drc=').ne.0) then
         half=reada(keywrd,index(keywrd,'drc='))
         write(mfgw,'(//10x,
     +   '' damping factor for kinetic energy ='',f12.6)')half
      elseif (index(keywrd,'drc').eq.0) then
         half=0.d0
      else
         half=1.d6
      endif
c
c  letot is true if corrections are not to be made part way into
c        the calculation
c
c  usage of letot:
c (1) while letot is false, no damping will be done
c (2) when letot is turned true,
c     if an irc, then etot is reset so the error is zero.
c     if a  drc, excess kinetic energy used to start the run is removed.
c
      letot=(index(keywrd,'irc=').eq.0 .and. .not. let)
      half=dsign(dmax1(0.000001d0,dabs(half)),half)
c
c determine excess kinetic energy
c
      iskin=0
      if(index(keywrd,'kine').ne.0) then
         iskin=1
         addonk=reada(keywrd,index(keywrd,'kine'))
         write(mfgw,
     + '(//10x,'' excess kinetic energy entered into system ='',f12.6)')
     +  addonk
      else
         addonk=0.d0
      endif
c
c   loop over time-intervals of deltat second
c
      deltat=1.d-16
      quadr=1.d0
      totime=0.d0
      once=0.d0
      etot=0.d0
      escf=0.d0
      const=1.d0
      if( index(keywrd,'restart').ne.0.and.index(keywrd,'irc=').eq.0)
     1then
c
c  restart from a previous run
c
_IF(ipsc,tools)
       if(oroot()) then
_ENDIF
         open(unit=9,file=getmop(3),status='unknown',
     +form='formatted')
         rewind 9
         open(unit=10,file=getmop(4),status='unknown',
     +form='unformatted')
         rewind 10
         read(9,'(a80)')alpha
         read(9,'(3f19.13)')(xparam(i),i=1,nvar)
         read(9,'(a80)')alpha
         read(9,'(3f19.3)')(velo0(i),i=1,nvar)
         read(9,'(a80)')alpha
         read(9,*)(grad(i),i=1,nvar)
         read(9,*)(grold(i),i=1,nvar)
         read(9,*)(grold2(i),i=1,nvar)
         read(9,*)etot,escf,ekin,delold,deltat,dlold2,iloop,
     1gnorm,letot,elost1,gtot
         write(mfgw,'(//10x,''calculation restarted, current'',
     1'' kinetic energy='',f10.5,//)')ekin
_IF(ipsc,tools)
      else
       write(mfgw,*)' restarts not implemented in drc'
       call pend
      endif
_ENDIF
         goto 100
      else
c                         not a restart
         iloop=1
         if(index(keywrd,'irc=').ne.0.or.velred)then
c
c  get hold of velocity vector
c
            if(index(keywrd,'irc=').ne.0)then
               k=reada(keywrd,index(keywrd,'irc='))
            else
               k=1
            endif
            if(k.lt.0)then
               k=-k
               one=-1.d0
            else
               one=1.d0
            endif
            kl=(k-1)*nvar
            summ=0.d0
            velo1(1)=0
            velo1(2)=0
            velo1(3)=0
            summas=0.d0
            i=0
            do 60 ii=1,numat
               ams=atmass(ii)
               summas=summas+ams
               velo0(i+1)=startv(kl+i+1)*one
               velref(i+1)=velo0(i+1)
               velo1(1)=velo1(1)+velo0(i+1)*ams
c
               velo0(i+2)=startv(kl+i+2)*one
               velref(i+2)=velo0(i+2)
               velo1(2)=velo1(2)+velo0(i+2)*ams
c
               velo0(i+3)=startv(kl+i+3)*one
               velref(i+3)=velo0(i+3)
               velo1(3)=velo1(3)+velo0(i+3)*ams
c
               i=i+3
   60       continue
c$doit asis
            do 70 i=1,3
   70       velo1(i)=-velo1(i)/summas
            i=0
c$doit asis
            do 80 ii=1,numat
               ams=atmass(ii)
c$doit asis
               do 80 i1=1,3
                  i=i+1
                  if(addonk.gt.1.d-5.or..not.velred)velo0(i)=velo0(i)+ve
     1lo1(i1)
   80       summ=summ+velo0(i)**2*ams
            if(addonk.lt.1.d-5.and.velred)addonk=0.5d0*summ/4.184d10
            if(addonk.lt.1.d-5.and..not.velred)then
               if(dabs(half).gt.1.d-3.and.startk(k).gt.105.d0)then
               write(mfgw,'(a,f10.3,a,/,a)')' by default, one quantum of
     1 energy,'//' equivalent to',startk(k),' cm(-1)',
     2' will be used to start the drc'
c
c    2.8585086d-3 converts cm(-1) into kcal/mole
c
                  addonk=startk(k)*2.8585086d-3
               write(mfgw,'(a,f7.2,a)')' this represents an energy of',a
     1ddonk,' kcals/mole'
               elseif(dabs(half).gt.1.d-3)then
               write(mfgw,'(a,f9.2,a)')' the vibrational frequency (',st
     1artk(k),'cm(-1)) is too small',' for one quantum to be used'
                  write(mfgw,'(a)')
     1' instead 0.3kcal/mole will be used to start the irc'
                  addonk=0.3d0
               else
                  addonk=0.3d0
               endif
            endif
c
c   at this point addonk is in kcal/mole
c   normalize so that total k.e. = one quantum (default) (drc only)
c                              or 0.3kcal/mole (irc only)
c                              or addonk if kinetic=nn supplied
c
            if(summ.lt.1.d-4) then
               write(mfgw,'(a)')' system is apparently not moving!'
               return
            endif
c
c  addonk is excess kinetic energy.  if the calculation is an irc,
c  this energy must be removed after a short 'time'.
c
c  make an ad-hoc correction: if addonk is non-zero and half is larger
c  than 0.1, modify addonk to reflect errors due to start-up.
c
            if(half.gt.0.1d0.and.half.lt.10000.d0)
     1addonk=addonk*(1.d0+0.06972d0/half)
c
c  make an ad-hoc correction: if addonk is non-zero and half is less
c  than -0.1, modify addonk to reflect errors due to start-up.
c
            if(half.lt.-0.1d0.and.half.gt.-10000.d0)
     1addonk=addonk*(1.d0+0.06886d0/half)
            summ=dsqrt(addonk/(0.5d0*summ/4.184d10))
            addk=.false.
            if(summ.gt.1.d-10)then
               do  90 i=1,nvar
   90          velo0(i)=velo0(i)*summ
c
c  if it is a drc, destroy addonk.  the kinetic energy used will come
c  from the velocity only.
c
               if(half.gt.1.d-3)addonk=0.d0
            endif
         endif
      endif
  100 continue
      iupper=iloop+4999
      ilp=iloop
      one=0.d0
      if(index(keywrd,'restart').ne.0.and.index(keywrd,'irc=').eq.0)
     1one=1.d0
      do 190 iloop=ilp,iupper
c
c  movement of atoms will be proportional to the average velocities
c  of the atoms before and after time interval
c
c
c  rapid change in gradient implies small step size for deltat
c
c   kinetic energy = 1/2 * m * v * v
c                  = 0.5 / (4.184d10) * m * v * v
c   new velocity = old velocity + gradient * time / mass
c                = kcal/angstrom*second/(atomic weight)
c                =4.184*10**10(ergs)*10**8(per cm)*deltat(seconds)
c   new position = old position - average velocity * time interval
c
c
c   establish reference total energy
c
         error=(etot-(ekin+escf))
         if(iloop.gt.2)then
            quadr = 1.d0+error/(ekin*const+0.001d0)*0.5d0
            quadr = dmin1(1.3d0,dmax1(0.8d0,quadr))
         else
            quadr=1.d0
         endif
         if((let.or.ekin.gt.0.2).and.addk)then
c
c   dump in excess kinetic energy
c
            etot=etot+addonk
            addk=.false.
            addonk=0.d0
         endif
         ekold=ekin
c
c  calculate the duration of the next step.
c  step size is that required to produce a constant change in geometry
c
c
c  if damping is used, calculate the new total energy and
c  the ratio for reducing the kinetic energy
c
         const=dmax1(1.d-36,0.5d0**(deltat*1.d15/half))
         const=dsqrt(const)
         velvec=0.d0
         ekin=0.d0
         delta1=delold+dlold2
         elost=0.d0
         do 110 i=1,nvar
c
c   calculate components of velocity as
c   v = v(0) + v'*t + v"*t*t
c   we need all three terms, v(0), v' and v"
c
            velo1(i) = 1.d0/atmass(loc(1,i))*grad(i)
            if(iloop.gt.3) then
               velo3(i) = 2.d0/atmass(loc(1,i))*
     1(delta1*(grold(i)-grad(i))-delold*(grold2(i)-grad(i)))/
     2(delta1*(delold**2*1.d30)-delold*(delta1**2*1.d30))
               velo2(i)=1.d0/atmass(loc(1,i))*
     1(grad(i)-grold(i)-0.5d0*velo3(i)*(1.d30*delold**2))/(delold*1.d15)
            else
               velo2(i) = 1.d0/atmass(loc(1,i))*
     1                 (grad(i)-grold(i))/(1.d15*delold)
               velo3(i)=0.d0
            endif
c
c  move atoms through distance equal to velocity * delta-time, note
c  velocity changes from start to finish, therefore average.
c
            parold(i)=xparam(i)
            xparam(i)=xparam(i)
     1             -1.d8*(deltat*velo0(i)*one
     2             +0.5d0*deltat**2*velo1(i)
     3             +0.16666d0*(deltat**2*1.d15)*deltat*velo2(i)
     4             +0.0416666d0*deltat**2*(1.d30*deltat**2)*velo3(i))
c
c   correct errors due to cubic components in energy gradient,
c   also to add on excess energy, if necessary.
c
            velvec=velvec+velo0(i)**2
c
c   modify velocity in light of current energy gradients.
c
c   velocity = old velocity + (delta-t / atomic mass) * current gradient
c                           + 1/2 *(delta-t * delta-t /atomic mass) *
c                             (slope of gradient)
c              slope of gradient = (grad(i)-grold(i))/delold
c
c
c   this expression is accurate to second order in time.
c
            velo0(i) = velo0(i) + deltat*velo1(i) + 0.5d0*deltat**2*velo
     12(i)*1.d15           + 0.166666d0*deltat*(1.d30*deltat**2)*velo3(
     2i)
            if(let.or.gnorm.gt.3.d0)then
               let=.true.
               elost=elost+velo0(i)**2*atmass(loc(1,i))*(1-const**2)
               velo0(i)=velo0(i)*const*quadr
            endif
c
c  calculate kinetic energy (in 2*ergs at this point)
c
            ekin=ekin+velo0(i)**2*atmass(loc(1,i))
  110    continue
         one=1.d0
         if(let.or.gnorm.gt.3.d0)then
            if(.not.letot) then
               if(dabs(half).lt.1.d-3)then
c
c  it is an irc, so reset the total energy
c
                  etot=escf+elost1
                  addonk=0.d0
                  elost1=0.d0
                  elost=0.d0
               elseif(iskin.eq.0)then
c
c  it is a drc and kinetic not used, so remove extra kinetic energy
c
                  etot=etot-addonk
               endif
            endif
            letot=.true.
         endif
c
c  convert energy into kcal/mole
c
         ekin=0.5d0*ekin/4.184d10
c
c  if it is a damped drc, modify etot to reflect loss of kinetic energy
c
         if(letot.and.dabs(half).gt.0.00001d0)
     1etot=etot-ekin/const**2+ekin
         elost1=elost1+0.5d0*elost/4.184d10
c
c store old gradients for delta - velocity calculation
c
         do 120 i=1,nvar
            grold2(i)=grold(i)
            grold(i)=grad(i)
  120    grad(i)=0.d0
c
c   calculate energy and gradients
c
         scfold=escf
         call compfg(xparam,.true.,escf,.true.,grad,.true.)
         if(iloop.gt.2)then
            gnorm=0.d0
            do 140 i=1,nvar,3
            sum=dsqrt(ddot(3,grad(i),1,grad(i),1)/
     1               (ddot(3,velo0(i),1,velo0(i),1)+1.d-20))
               do 130 j=i,i+2
  130          gerror(j)=gerror(j)+grad(j)+velo0(j)*sum
  140       continue
            gnorm=dsqrt(ddot(nvar,gerror,1,gerror,1))
            gtot=gnorm
         endif
         gnorm=dsqrt(ddot(nvar,grad,1,grad,1))
c
c   convert gradients into ergs/cm
c
         do 150 i=1,nvar
  150    grad(i)=grad(i)*4.184d18
c
c   special treatment for first point - set "old" gradients equal to
c   current gradients.
c
         if(iloop.eq.1) then
            do 160 i=1,nvar
  160       grold(i)=grad(i)
         endif
         dlold2=delold
         delold=deltat
         sum=0.d0
         do 170 i=1,nvar
  170    sum=sum + ((grad(i)-grold(i))/4.184d18)**2
         if(dabs(half).lt.0.001d0)then
            deltat= deltat*
     1      dmin1(2.d0, (5.d-5*accu/(dabs(escf+elost1-etold)+1.d-20)))
     +         **0.25d0
            etold=escf+elost1
            if(iloop.gt.5.and.scfold-escf.lt.-1.d-3 .or.
     1      iloop.gt.30.and.scfold-escf.lt.0.d0)  then
               write(mfgw,'(//,'' irc calculation complete '')')
               return
            endif
         else
            deltat= deltat*dmin1(1.05d0, 10.d0*accu/(sum+1.d-4))
            deltat=dmin1(deltat,3.d-15*accu)
            past10(10)=gnorm
            sum=0.d0
            do 180 i=1,9
               sum=sum+dabs(past10(i)-past10(i+1))
  180       past10(i)=past10(i+1)
            if(sum.lt.gnlim)then
            write(mfgw,'(//,a)')' gradient constant and small -- assume'
     1//' all motion stopped'
               return
            endif
            deltat=dmin1(deltat,2.d-15)
************************************************************************
*
*         testing code - remove before final version assembled
c#          (iloop/400)*400.eq.iloop)deltat=-deltat
*
************************************************************************
         endif
         deltat=dmax1(1.d-16,deltat)
         if(dabs(half).lt.0.00001d0)then
c
c   for the irc:
c
c escf   = potential energy
c elost1 = energy lost (in drc, this would have been the kinetic energy)
c etot   = computed total energy = starting potential energy
c
c   in drcout  'total' = escf + elost1
c              'error' = escf + elost1 - etot
c
            call prtdrc(escf,deltat,xparam,georef,
     1elost1,gtot,etot,velo0,nvar)
         else
c
c   for the drc:
c
c escf   = potential energy
c ekin   = current kinetic energy
c etot   = computed total energy = starting potential energy -
c          kinetic energy lost through damping, if present.
c
c   in drcout  'total' = escf + ekin
c              'error' = escf + ekin - etot
c
            call prtdrc(escf,deltat,xparam,georef,
     1ekin,dummy,etot,velo0,nvar)
         endif
         tnow=secmop()
         tcycle=tnow-oldtim
         oldtim=tnow
         tleft=tleft-tcycle
         if (iloop.eq.iupper.or.tleft.lt.3*tcycle) then
_IF(ipsc,tools)
          if(oroot().and.odumpm) then
_ELSE
          if(odumpm) then
_ENDIF
  46        open(unit=9,file=getmop(3),status='new',
     +form='formatted',err=45)
            goto 47
  45        open(unit=9,file=getmop(3),status='old')
            close(9,status='delete')
            goto 46
  47        continue
            rewind 9
            open(unit=10,file=getmop(4),status='unknown',
     +form='unformatted')
            rewind 10
            write(9,'(a)')' cartesian geometry parameters in angstroms'
            write(9,'(3f19.13)')(xparam(i),i=1,nvar)
            write(9,'(a)')' velocity for each cartesian coordinate, in c
     1m/sec'
            write(9,'(3f19.3)')(velo0(i),i=1,nvar)
            write(9,'(a)')' first, second, and third-order gradients, et
     1c'
            write(9,*)(grad(i),i=1,nvar)
            write(9,*)(grold(i),i=1,nvar)
            write(9,*)(grold2(i),i=1,nvar)
            i=iloop+1
            write(9,*)etot,escf,ekin,delold,deltat,dlold2,i,
     1gnorm,letot,elost1,gtot
            escf=-1.d9
            call prtdrc(escf,deltat,xparam,georef,
     1ekin,elost,etot,velo0,nvar)
            linear=(norbs*(norbs+1))/2
            write(10)(pa(i),i=1,linear)
            if(nalpha.ne.0)write(10)(pb(i),i=1,linear)
            write(mfgw,
     +   '(//10x,'' running out of time, restart file written'')')
         write(mfgw,'(a)')' geometry and velocity are in restart file'
     1//' in ascii'
       endif
            return
         endif
  190 continue
      end
      subroutine drcout(xyz3,geo3,vel3,nvar,time,escf3,ekin3,
     1gtot3,etot3,xtot3,iloop,charge,fract,text1,text2,ii,jloop)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      common/iofile/mfgr,mfgw
      character text1*3,text2*2
      dimension xyz3(3,nvar), vel3(3,nvar), escf3(3), ekin3(3)
      dimension xyz(3,numatm), vel(3,numatm), charge(numatm),
     1 geo3(3,numatm), etot3(3), gtot3(3), xtot3(3)
*************************************************************
*                                                           *
*    drcout prints the geometry, etc. for a drc at a        *
*    position determined by fract.                          *
*    on input xyz3  = quadratic expression for the geometry *
*             vel3  = quadratic expression for the velocity *
*             escf3 = quadratic expression for the p.e.     *
*             ekin3 = quadratic expression for the k.e.     *
*                                                           *
*************************************************************
      common /keywrd/ keywrd
      common /geokst/ natoms,labels(numatm),
     1                na(numatm),nb(numatm),nc(numatm)
      common /elemts/ elemnt(107)
      common /geovar/ iivar, loc(2,maxpar), idumy, xparam(maxpar)
      common /titles/ koment,title
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),
     1                nlast(numatm), norbs, nelecs,nalpha,nbeta,
     2                nclose,nopen,ndumy,xract
      common /numcal/ numcal
      dimension  iel1(3), gg(3)
      character keywrd*241,koment*81,title*81, alpha*2, elemnt*2
      save prtkey, prtkom, prtitl, i, drc
      integer prtkom, prtitl, prtkey
      logical large, drc
      save icalcn
      data icalcn/0/
      if (icalcn.ne.numcal) then
         icalcn=numcal
         if( index(keywrd,'restart').eq.0.or.index(keywrd,'irc=').ne.0)
     1then
            jloop=0
         endif
         do 10 i=80,1,-1
   10    if(keywrd(i:i).ne.' ')goto 20
         i=1
   20    prtkey=i
         do 30 i=80,1,-1
   30    if(koment(i:i).ne.' ')goto 40
         i=1
   40    prtkom=i
         do 50 i=80,1,-1
   50    if(title(i:i).ne.' ')goto 60
         i=1
   60    prtitl=i
         drc=(index(keywrd,'drc').ne.0)
         i=index(keywrd,'large')
         iprint=10000
         if(i.ne.0)then
            iprint=1
            i=i+5
            large=(keywrd(i:i).eq.' '.or.keywrd(i+1:i+1).eq.'-')
            if(keywrd(i:i).eq.'=') iprint=dabs(reada(keywrd,i))
         endif
      endif
      if(jloop.eq.0.or.(jloop/iprint)*iprint.eq.jloop) then
         if(drc) then
            write(mfgw,'(//,'' femtoseconds  point  potential +''
     1,'' kinetic  =  total     error    ref%   movement'')')
         else
            write(mfgw,'(//,''     point   potential  +  ''
     1,''energy lost   =   total      error    ref%   movement'')')
         endif
      endif
      jloop=jloop+1
c#      fract=0.d0
      escf=escf3(1)+escf3(2)*fract+escf3(3)*fract**2
      ekin=ekin3(1)+ekin3(2)*fract+ekin3(3)*fract**2
      etot=etot3(1)+etot3(2)*fract+etot3(3)*fract**2
      gtot=gtot3(1)+gtot3(2)*fract+gtot3(3)*fract**2
      xtot=xtot3(1)+xtot3(2)*fract+xtot3(3)*fract**2
      errr=dmin1(9999.99999d0,dmax1(-999.99999d0,escf+ekin-etot))
      if(ii.ne.0)then
         if(drc) then
            write(mfgw,'(f10.3,i8,f12.5,f11.5,f11.5,
     1f10.5,'' '',i5,3x,''%'',a,a,i3)')time, iloop-2, escf, ekin,
     2 escf+ekin,errr,jloop,text1,text2,ii
            write(mfgw,'(9x,a,f9.4,a)')
     + ' movement from start =',xtot,' angstroms'
         else
            write(mfgw,'(i8,f14.5,f13.5,f17.5,
     1f10.5,'' '',i5,3x,''%'',a,a,i3)') iloop-2, escf, ekin,
     2 escf+ekin,errr,jloop,text1,text2,ii
c#      write(mfgw,'(24x,'' integrated gradient error ='',g10.3,
c#     1'' kcals/angstrom'')')gtot
         write(mfgw,'(9x,a,f9.4,a)')' movement from start =',xtot,' angs
     1troms'
         endif
      else
         if(drc) then
            if(text1.eq.' '.and.text2.eq.' ')then
               write(mfgw,'(f10.3,i8,f12.5,f11.5,f11.5,
     1f10.5,'' '',i5,3x,''%'',f8.4)')time, iloop-2, escf, ekin,
     2 escf+ekin,errr,jloop,xtot
            else
               write(mfgw,'(f10.3,i8,f12.5,f11.5,f11.5,
     1f10.5,'' '',i5,3x,''%'',a,a,i3)')time, iloop-2, escf, ekin,
     2 escf+ekin,errr,jloop,text1,text2
            endif
         else
            if(text1.eq.' '.and.text2.eq.' ')then
               write(mfgw,'(i8,f14.5,f13.5,f17.5,
     1f10.5,'' '',i5,3x,''%'',f8.4)') iloop-2, escf, ekin,
     2 escf+ekin,errr,jloop,xtot
            else
               write(mfgw,'(i8,f14.5,f13.5,f17.5,
     1f10.5,'' '',i5,3x,''%'',a,a,i3)') iloop-2, escf, ekin,
     2 escf+ekin,errr,jloop,text1,text2
            endif
         endif
      endif
      natoms=nvar/3
      l=0
      do 80 i=1,natoms
         do 70 j=1,3
            l=l+1
            vel(j,i)=vel3(1,l)+vel3(2,l)*fract+vel3(3,l)*fract**2
   70    xyz(j,i)=xyz3(1,l)+xyz3(2,l)*fract+xyz3(3,l)*fract**2
   80 continue
      if(large.and.(jloop/iprint)*iprint.eq.jloop)then
         write(mfgw,*)'                cartesian geometry           '
     1//'velocity (in cm/sec)'
         write(mfgw,*)'  atom        x          y          z'
     1      //'                x          y          z'
         do 90 i=1,numat
            ll=(i-1)*3+1
            lu=ll+2
            write(mfgw,'(i4,3x,a2,3f11.5,2x,3f11.1)')
     1i, elemnt(nat(i)),(xyz(j,i),j=1,3),(vel(j,i),j=1,3)
   90    continue
      endif
      if((jloop/iprint)*iprint.eq.jloop)then
         ivar=1
         na(1)=0
         l=0
         write(mfgw,
     + '(//10x,''final geometry obtained'',33x,''charge'')')
         write(mfgw,'(a)')
     +   keywrd(:prtkey),koment(:prtkom),title(:prtitl)
         lmax=l
         l=0
         do 120 i=1,numat
            j=i/26
            alpha(1:1)=char(ichar('a')+j)
            j=i-j*26
            alpha(2:2)=char(ichar('a')+j-1)
c$doit asis
            do 100 j=1,3
  100       iel1(j)=0
  110       continue
            if(loc(1,ivar).eq.i) then
               iel1(loc(2,ivar))=1
               ivar=ivar+1
               goto 110
            endif
            if(i.lt.4) then
               iel1(3)=0
               if(i.lt.3) then
                  iel1(2)=0
                  if(i.lt.2) then
                     iel1(1)=0
                  endif
               endif
            endif
            if(labels(i).lt.99)then
               l=l+1
               gg(1)=geo3(1,i*3-2)+geo3(2,i*3-2)*fract+geo3(3,i*3-2)*fra
     1ct**2
               gg(2)=geo3(1,i*3-1)+geo3(2,i*3-1)*fract+geo3(3,i*3-1)*fra
     1ct**2
               gg(3)=geo3(1,i*3  )+geo3(2,i*3  )*fract+geo3(3,i*3  )*fra
     1ct**2
               write(mfgw,'(2x,a2,3(f12.6,i3),i4,2i3,f13.4,i5,a)')
     1    elemnt(labels(i)),(gg(k),iel1(k),k=1,3),
     2    na(i),nb(i),nc(i),charge(l),jloop,alpha//'*'
            else
               write(mfgw,'(2x,a2,3(f12.6,i3),i4,2i3,13x,i5,a)')
     1    elemnt(labels(i)),(gg(k),iel1(k),k=1,3),
     2na(i),nb(i),nc(i),jloop,alpha//'%'
            endif
  120    continue
         na(1)=99
      endif
      return
      end
      subroutine ea08c(a,b,value,vec,m,iv,w)
      implicit REAL (a-h,o-z)
c  standard fortran 66 (a verified pfort subroutine)
      dimension a(*),b(*),value(*),vec(*),w(*)
      common/iofile/mfgr,mfgw
      data eps/1.0d-6/,a34/0.0d0/
c     this uses qr iteration to find the eigenvalues and eigenvectors
c  of the symmetric tridiagonal matrix whose diagonal elements are
c  a(i),i=1,m and off-diagonal elements are b(i),i=2,m.  the array
c  w is used for workspace and must have dimension at least 2*m.
c  we treat vec as if it had dimensions (iv,m).
      sml=eps*dfloat(m)
      call ea09c(a,b,w(m+1),m,w)
c     set vec to the identity matrix.
      do 20 i=1,m
         value(i)=a(i)
         w(i)=b(i)
         k=(i-1)*iv+1
         l=k+m-1
         do 10 j=k,l
   10    vec(j)=0.d0
         ki=k+i-1
   20 vec(ki)=1.d0
      k=0
      if(m.eq.1)return
      do 100 n3=2,m
         n2=m+2-n3
c     each qr iteration is performed of rows and columns n1 to n2
         mn2=m+n2
         root=w(mn2)
         do 80 iter=1,20
            bb=(value(n2)-value(n2-1))*0.5d0
            cc=w(n2)*w(n2)
            a22=value(n2)
            if(cc.ne.0.0d0)
     +       a22=a22+cc/(bb+dsign(1.0d0,bb)*dsqrt(bb*bb+cc))
            do 30 i=1,n2
               mi=m+i
               if(dabs(root-a22).le.dabs(w(mi)-a22))go to 30
               root=w(mi)
               mn=m+n2
               w(mi)=w(mn)
               w(mn)=root
   30       continue
            do 40 ii=2,n2
               n1=2+n2-ii
               if(dabs(w(n1)).le.
     +            (dabs(value(n1-1))+dabs(value(n1)))*sml)go to 50
   40       continue
            n1=1
   50       if(n2.eq.n1) go to 100
            n2m1=n2-1
            if(iter.ge.3)root=a22
            k=k+1
            a22=value(n1)
            a12=a22-root
            a23=w(n1+1)
            a13=a23
            do70 i=n1,n2m1
               a33=value(i+1)
               if(i.ne.n2m1)a34=w  (i+2)
               s=dsign(dsqrt(a12*a12+a13*a13),a12)
               si=a13/s
               co=a12/s
               jk=i*iv+1
               j1=jk-iv
               j2=j1+min0(m,i+k)-1
               do 60 ji=j1,j2
                  v1=vec(ji)
                  v2=vec(jk)
                  vec(ji)=v1*co+v2*si
                  vec(jk)=v2*co-v1*si
   60          jk=jk+1
               if(i.ne.n1)  w(i)=s
               a11=co*a22+si*a23
               a12=co*a23+si*a33
               a13=si*a34
               a21=co*a23-si*a22
               a22=co*a33-si*a23
               a23=co*a34
               value(i)=a11*co+a12*si
               a12=-a11*si+a12*co
               w(i+1)=a12
   70       a22=a22*co-a21*si
   80    value(n2)=a22
         write(mfgw,90)
   90    format(48h1cycle detected in subroutine ea08 -stopping now)
_IF(ipsc,tools)
         call pend
_ELSE
         stop
_ENDIF
  100 continue
c     rayleigh quotient
      do 120 j=1,m
         k=(j-1)*iv
         xx=vec(k+1)**2
         xax=xx*a(1)
         do 110 i=2,m
            ki=k+i
            xx=xx+vec(ki)**2
  110    xax=xax+vec(ki)*(2.0d0*b(i)*vec(ki-1)+a(i)*vec(ki))
  120 value(j)=xax/xx
      return
      end
      subroutine ea09c(a,b,value,m,off)
      implicit REAL (a-h,o-z)
c  standard fortran 66 (a verfied pfort subroutine)
      common/iofile/mfgr,mfgw
      dimension a(*),b(*),value(*),off(*)
      data a34/0.0d0/,eps/1.0d-6/
      sml=eps*dfloat(m)
      value(1)=a(1)
      if(m.eq.1)return
      do 10 i=2,m
         value(i)=a(i)
   10 off(i)=b(i)
c     each qr iteration is performed of rows and columns n1 to n2
      maxit=10*m
      do 80 iter=1,maxit
         do 40 n3=2,m
            n2=m+2-n3
            do 20 ii=2,n2
               n1=2+n2-ii
               if(dabs(off(n1)).le.
     +          (dabs(value(n1-1))+dabs(value(n1)))*sml)go to 30
   20       continue
            n1=1
   30       if(n2.ne.n1) go to 50
   40    continue
         return
c     root  is the eigenvalue of the bottom 2*2 matrix that is nearest
c     to the last matrix element and is used to accelerate the
c     convergence
   50    bb=(value(n2)-value(n2-1))*0.5d0
         cc=off(n2)*off(n2)
         sbb=1.0d0
         if(bb.lt.0.0d0)sbb=-1.0d0
         root=value(n2)+cc/(bb+sbb*dsqrt(bb*bb+cc))
         n2m1=n2-1
         a22=value(n1)
         a12=a22-root
         a23=off(n1+1)
         a13=a23
         do 70 i=n1,n2m1
            a33=value(i+1)
            if(i.ne.n2m1)a34=off(i+2)
            s=dsqrt(a12*a12+a13*a13)
            si=a13/s
            co=a12/s
            if(i.ne.n1)off(i)=s
            a11=co*a22+si*a23
            a12=co*a23+si*a33
            a13=si*a34
            a21=co*a23-si*a22
            a22=co*a33-si*a23
            a23=co*a34
            value(i)=a11*co+a12*si
            a12=-a11*si+a12*co
            off(i+1)=a12
   70    a22=a22*co-a21*si
   80 value(n2)=a22
      write(mfgw,90)
   90 format(39h1looping detected in ea09-stopping now )
_IF(ipsc,tools)
      call pend
_ELSE
      stop
_ENDIF
      end
      subroutine ec08c(a,b,value,vec,n,iv,w)
c
c to find the eigenvalues and vectors of a tri-diagonal
c  hermitian matrix.
      REAL  value(*),w(*),pck(2),one,zero,vec(*)
      COMPLEX      a(*),b(*),dn,upck
      equivalence (pck(1),upck)
c  we treat vec as if it is defined as complex vec(iv,n)
c  in the calling program.
      data one, zero/1.0d0,0.0d0/
      iv2=iv+iv
      n2=n+n
      il=iv2*(n-1)+1
      w(1)=a(1)
c
c  the hermitian form is transformed into a real form
      if(n-1)80,80,10
   10 do 20 i=2,n
         w(i)=a(i)
   20 w(i+n)=cdabs(b(i))
c
c  find the eigenvalues and vectors of the real form
      call ea08c(w,w(n+1),value,vec,n,iv2,w(n2+1))
c
c the vectors in vec at this point are real,we now expand them
c into vec as though they were complex.
      do 50 i=1,il,iv2
         do 40 j=1,n
            k=n-j
            l=k+k
   40    vec(i+l)=vec(i+k)
   50 vec(i+1)=zero
      if(n.le.1)go to 80
      dn=one
      k=1
c
c transform vectors of real form to those of complex form.
      do 70 i=4,n2,2
         k=k+1
         upck=one
         if(w(k+n).ne.zero)upck=dn*conjg(b(k))/w(k+n)
         i1=il-1+i
         do 60 j=i,i1,iv2
            vec(j)=vec(j-1)*pck(2)
   60    vec(j-1)=vec(j-1)*pck(1)
   70 dn=upck
   80 return
      end
      subroutine ef(xparam, nvar, funct)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      dimension xparam(maxpar)
**********************************************************************
*
*   baker is a quasi newton raphson optimization routine based on
*         jon bakers algorithm (j.comp.chem. 7, 385).
*
*  on entry xparam = values of parameters to be optimised.
*           nvar   = number of parameters to be optimised.
*
*  on exit  xparam = optimised parameters.
*           funct  = heat of formation in kcal/mol.
*
*                    implemented in mopac august 1990 by jjps
*
**********************************************************************
c
c   the baker routine is controled by the following keywords :
c   ef,ts           : search for minimum or transition structure
c   cycles          : maximum number of iterations in optimization
c   recalc=n        : number of cycles between hessian calculation
c   dmax=n.n        : maximum stepsize in ang or rad
c   iupd=0,1,2      : hessian updating ; none, powell, bfgs
c   hess=0,1,2,3    : start hessian ; diagonal, calculate,
c                     read from disk, read from input.
c                     note that calculation of selective rows (coloumns)
c                     of the hessian combined with diagonal guess is
c                     controled by setting optimization parameters = 2.
c                     if any opt parameters = 2, then above hess option
c                     is overridden.
c   mode=n          : follow the n'th lowest hessian mode toward ts
c   nonr            : do not use newton-raphson step if formd fails and
c                     max gradient is less than rcut.
c   eiginv          : use hessian eigenvalue reversion rather than
c                     diagonal shift if formd fails and nonr or gnorm
c                     is larger than rcut.
c   oride           : use whatever lamda(s) formd produces, even if they
c                     are 'unacceptable'.
c   gnorm=n.n       : exit when largest gradient is less than n.n
c   prnt=0-5        : 0 : print summery every cycle
c                     1 : + geometry and ts mode
c                     2 : + gradients
c                     3 : + hessian eigenvalues and -vectors
c                     4 : + hessian matrix
c                     5 : maximum printing = debug printing
c
c   defaults :
c   prnt     : 0
c   cycles   : 100
c   dmax     : 0.20
c   recalc   : 999999
c   iupd     : 2 for minimum search, 1 for ts search
c   hess     : 0 for minimum search, 1 for ts search
c   mode     : 1, only used in ts search
c   gnorm    : 0.4 or 0.01 if "precise" is specified
c   nonr     : false
c   eiginv   : false
c   oride    : false
c
c   hints and comments :
c   normally the default options are sufficient. nonr, eiginv and
c      oride options are special and should rarely be touched.
c   convergence criteria is the same as for "sigma" optimization,
c      namely that all gradients must be below 0.4 or 0.01 if
c      "precise" is specified. results obtained without the "precise"
c      option turned on may be unreliable due to accumulated errors
c      from various parts of the program (see e.g. j.comp.chem. 9,x)
c      but can be used in preliminary stages. only results from
c      precise runs should ever be published!
c      with the precise keyword geometries are usually converged to
c      0.0001 in bond length, 0.01 in bond angles and 0.1 in torsional
c      angles. energies are converged to at least 0.001 kcal/mol.
c   convergence can be monitored in two ways : the gradient norm should
c      go toward zero, and the lamda values should also go to zero.
c   hessian and geometry will be saved on disk (and can be restarted) :
c      1) after hessian calculation (partly or whole)
c      2) in an optimization every x min. cpu used (machine dependent)
c      3) before termination, either due to convergence, time or cycles
c   if hess=2 then the geometry is taken from the input while the hessia
c      is read from disk. upon restart both geometry and hessian is
c      automatically picked up from disk.
c   ts search requires hess=1, 2 or 3, it cannot work with hess=0
c   hess=1 for bakermin is recommended for difficult cases (e.g. cyclic)
c   hess=3 will read the hessian from input, mostly used for testing.
c      to read it in, place the word 'hessian' somewhere in the input
c      file in format (a7), followed by the hessian elements in
c      format (8f10.2).
c   the routine (especially ts search) works best in internal coordinate
c   most common error from baker is "unable to determine lamda in
c      formd". this will often happens if :
c      1) symmetry constrained variables are marked for optimization
c      2) variable determined by symmetry is marked for optimization
c      3) more variables than internal degrees of freedom specified
c      4) too large step size has been chosen, updating goes haywire
c      5) bad hessian is used as start hessian
c   even when these reasons have been eliminated, the fail occurs quite
c      frequently in the ***** enviroment, and usually if soft modes
c      such as methyl rotations are present. some preliminary patches
c      for circumventing these failures have been implemented in this
c      version. if the structure is close to optimized (max grad.lt.rcut
c      = 10), then simply take the newton-raphson step, unless nonr is
c      turned on. if max grad.gt.rcut or nonr is on, then use either
c      a hessian shift or a hessian eigenvalue inversion.
c      the default, and only option for minimum searches, is to
c      increase the hessian diagonal with lowest hessian eigenvalue
c      (second lowest eigenvalue if ts search) + 2*eigmin.
c      this should always work for a min search, but may go wrong in a
c      ts search. if this happens one can try to turn on the eiginv
c      option. this will reverse the sign of all negative eigenvalues
c      other than the ts mode being followed. again there is no garanti
c      that this is will lead to a 'better' geometry.
c      finally an override switch is implemented. if keyword oride is
c      used then whatever lamda's formd produces will be used,
c      even if they are 'unacceptable', as discussed by simons.
c   these patches are as mentioned still experimental, but have
c      been found to work in most cases.
c   increasing dmax can lead to faster convergence but can also make
c      the optimization go bad very fast. furthermore the hessian
c      updating deteriorate when using large stepsizes. reducing the
c      stepsize to 0.10 or 0.05 is recommended when encountering
c      convergence problems.
c   recalc=n calculates the hessian every n steps in the optimization.
c      for small n this is costly but is also very effective in
c      terms of convergence. recalc=10 and dmax=0.10 can be useful
c      for difficult cases. in extreme cases recalc=1 and dmax=0.05
c      will always find a stationary point, if it exist.
c   if reading in gnorm=n.n notice that it is max gradient threshold
c      that is being modified, not gradient norm. ignore the message
c      about "flepo exit when...".
c   iupd should very rarely be touched. iupd=1 can be used in minimum
c      searches if the the message "hereditary positive definiteness
c      endangered. update skipped this cycle" occurs every cycle for
c      10-20 iterations. never use iupd=2 for ts search!
c
c   **** notice that very little error checking is done.
c   **** only runs requesting incompatible options are terminated.
c   **** a minimum knowledge of the theory behind the routine
c   **** is recommended to get the optimum usage out of it.
c
      common /mesage/ iflepo,iscf
      common /geovar/ ndum,loc(2,maxpar), idumy, xaram(maxpar)
      common /cmpg/ geo(3,numatm)
      common /geosym/ ndep,locpar(maxpar),idepfn(maxpar),locdep(maxpar)
      common /istope/ ams(107)
      common /last/ last
      common /keywrd/ keywrd
      common /timem/ time0
      common /gradnt/ grad(maxpar),gnfina
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),
     1                nlast(numatm), norbs, nelecs,nalpha,nbeta,
     2                nclose,nopen,ndumy,fract
      common /numcal/ numcal
      common /timdmp/ tleft, tdump
      common /sigma2/ gnext1(maxpar), gmin1(maxpar)
      common /nllcom/ hess(maxpar,maxpar),bmat(maxpar,maxpar),
     1pmat(maxpar**2)
      common /scrach/ pvec
      common /scftyp/ emin, limscf
      common /fmatrx/oldf(maxpar),d(maxpar),vmode(maxpar),
     1u(maxpar,maxpar),dd,mode,nstep,negreq,iprnt
      common/iofile/mfgr,mfgw
      dimension ipow(9), eigval(maxpar),tvec(maxpar),svec(maxpar),
     1fx(maxpar),hessc(maxhes),uc(maxpar**2), pvec(maxpar*maxpar)
      logical restrt,scf1,fail,hsshft,eiginv,nr,oride
      logical aigeo, limscf, log
      character keywrd*241
      character heswrd*7,wrd*7
      equivalence(ipow(1),ihess), (uc,u)
      data heswrd   /'hessian'/
      save
*************
*     save icalcn,restrt,scf1,log,ldump,aigeo,oride
*     save ipow,ntime,iloop,xinc,imin,iupd,igthes,its,ireclc
*     save dmax,tol2,hsshft,nr,eiginv,time1,time2
*************
      data  icalcn,zzero,one,two    /0,0.d0,1.d0,2.d0/
      data eigmin,rcut /1.d-1,1.d+01/
c     dghsx is hessian diagonal for hess=0. for stretching, angle,
c     dihedral.  the values given below are 'optimum' for cyclohexanone
      dghss=2500.d0
      dghsa= 900.d0
      dghsd=1000.d0
c     get all initialization data
      if(icalcn.ne.numcal) then
         nvar=iabs(nvar)
         ldump=0
         icalcn=numcal
         aigeo=.false.
         restrt=(index(keywrd,'restart') .ne. 0)
         log    = index(keywrd,'nolog').eq.0
         scf1=(index(keywrd,'1scf') .ne. 0)
         oride=(index(keywrd,'oride') .ne. 0)
         nstep=0
         ihess=0
         mode =0
         last=0
         ntime=0
         iloop=1
         xinc=0.00529167d0
         imin=index(keywrd,' ef')
         if(imin.ne.0) then
            igthes=0
            iupd  =2
            negreq=0
         endif
         limscf=.true.
         its=index(keywrd,' ts')
         if(its.ne.0) then
            igthes=1
            iupd  =1
            negreq=1
         endif
         i=index(keywrd,' debug')*index(keywrd,' baker')
         iprnt=0
         if(i.ne.0) iprnt=2
         ireclc=999999
         i=index(keywrd,' recalc=')
         if(i.ne.0) ireclc=reada(keywrd,i)
         i=index(keywrd,' iupd=')
         if(i.ne.0) iupd=reada(keywrd,i)
         i=index(keywrd,' mode=')
         if(i.ne.0) mode=reada(keywrd,i)
         dmax=0.2
         i=index(keywrd,' dmax=')
         if(i.ne.0) dmax=reada(keywrd,i)
         tol2=4.d-1
         if(index(keywrd,' prec') .ne. 0) tol2=1.d-2
         i=index(keywrd,' gnorm=')
         if(i.ne.0) tol2=reada(keywrd,i)
         if(index(keywrd,' let').eq.0.and.tol2.lt.0.01d0)then
            write(mfgw,'(/,a)')
     +   '  gnorm has been set too low, reset to 0.01'
            tol2=0.01d0
         endif
         hsshft=.true.
         nr=.true.
         if(index(keywrd,'nonr') .ne. 0)nr=.false.
         eiginv=.false.
         eiginv=(index(keywrd,'eiginv') .ne. 0)
         if(eiginv) then
            hsshft=.false.
            if(iprnt.eq.2)then
               write(mfgw,*)' '
               write(mfgw,*)'    hessian eigenvalue inversion turned on'
            endif
         endif
         i=index(keywrd,' hess=')
         if(i.ne.0) igthes=reada(keywrd,i)
         time1=time0
         time2=time1
c   done with all initializing stuff.
c   check that options requested are resonable
         if(nvar.gt.(3*numatm-6))write(mfgw,10)
   10    format(/,'*** warning! more variables than degrees of freedom',
     1/)
         if((its.ne.0).and.(iupd.eq.2))then
            write(mfgw,*)' ts search and bfgs update will not work'
_IF(ipsc,tools)
            call pend
_ELSE
            stop
_ENDIF
         endif
         if((its.ne.0).and.(igthes.eq.0))then
         write(mfgw,*)' ts search require better than diagonal hessian'
_IF(ipsc,tools)
            call pend
_ELSE
            stop
_ENDIF
         endif
         if((imin.ne.0).and.(eiginv))then
            write(mfgw,*)' min search and eiginv will not work'
_IF(ipsc,tools)
            call pend
_ELSE
            stop
_ENDIF
         endif
         if((igthes.lt.-1).or.(igthes.gt.3))then
            write(mfgw,*)' unrecognized hess option',igthes
_IF(ipsc,tools)
            call pend
_ELSE
            stop
_ENDIF
         endif
         if(igthes.eq.2) goto 90
         if (restrt) then
c
c   restore data. i indicates (hessian restart or optimization
c   restart). if i .gt. 0 then hessian restart and i is last
c   step calculated in the hessian. if i .le. 0 then j (nstep)
c   in an optimization has been done.
c
            ipow(9)=0
            call bkrsav(tt0,hess,funct,grad,xparam,pmat,i,j,bmat,ipow)
            k=tt0/1000000.d0
            time0=time0-tt0+k*1000000.d0
      if (scf1) then
         gnfina=dsqrt(ddot(nvar,grad,1,grad,1))
         iflepo=1
         return
      endif
            if (i .gt. 0) then
               iloop=i
               igthes=4
               nstep=j
            write(mfgw,'(10x,''restarting hessian at point'',i4)')iloop
               if(nstep.ne.0)write(mfgw,
     +  '(10x,''in optimization step'',i4)')nstep
            else
               nstep=j
               write(mfgw,
     +  '(//10x,''restarting optimization at step'',i4)')nstep
               do 20 i=1,nvar
   20          grad(i)=zzero
               call compfg(xparam, .true., funct, .true., grad, .true.)
               goto 230
            endif
         else
c   not a restart, we need to get the gradients
            do 30 i=1,nvar
   30       grad(i)=zzero
            call compfg(xparam, .true., funct, .true., grad, .true.)
         endif
      endif
      if(its.eq.0)then
c     check that geometry is not already optimized
         rmx=zzero
         do 40 i=1,nvar
            if (dabs(grad(i)).gt.rmx) rmx=dabs(grad(i))
   40    continue
         if (rmx.lt.tol2) then
            iflepo=2
            last=1
            return
         endif
      endif
c     we now have the gradients for the current geometry,
c     get the hessian. depending on igthes we get it from :
c
c     -1 : diagonal matrix, dghsx*i, but rows and coloumns of
c          hessian calculated according to variables marked '2'
c      0 : diagonal matrix, dghsx*i (default for min-search)
c      1 : calculate it numerically (default for ts-search)
c      2 : read in from ftn009
c      3 : read it in from input file (ftn005)
c      4 : read in from ftn009 (during restart, partly or whole,
c          already done at this point)
c
      if (iloop .le. 0) goto 230
c     if iloop is .le.0 this is an optimization restart
c     and hessian should already be available
      if ((igthes.eq.0).or.(igthes.eq.-1)) then
         if(iprnt.eq.2)then
            if (igthes.eq.-1)write(mfgw,50)
            if (igthes.eq.0) write(mfgw,60)
         endif
   50    format(/,10x,'hessian partly calculated',/)
   60    format(/,10x,'diagonal matrix used as start hessian',/)
         do 70 i=1,nvar
            do 70 j=1,nvar
               hess(i,j)=zzero
   70    continue
         ij=1
         do 80 j=1,numatm
            do 80 i=1,3
               if (loc(2,ij).eq.i.and.loc(1,ij).eq.j)then
                  if (i.eq.1)hess(ij,ij)=dghss
                  if (i.eq.2)hess(ij,ij)=dghsa
                  if (i.eq.3)hess(ij,ij)=dghsd
                  ij=ij+1
               endif
   80    continue
         ij=ij-1
         if(ij.ne.nvar)write(*,*)'error in igthes=-1,ij,nvar',ij,nvar
      endif
c
   90 if (igthes.eq.2) then
         write(mfgw,100)
  100    format(/,10x,'hessian read from disk',/)
         ipow(9)=0
c        use dummy array for call except for hessian
         call bkrsav(tdm,hess,fdmy,gnext1,gmin1,pmat,iidum,j,bmat,ipow)
      endif
      if (igthes .eq.3) then
         write(mfgw,110)
  110    format(/,10x,'hessian read from input',/)
         rewind 8
  120    read(8,150,end=630,err=630)wrd
         if (wrd .eq. heswrd) goto 140
         goto 120
c 130    format(1x,a7)
  140    do 160 i=1,nvar
  150       format(a7)
            read(8,170,end=160,err=630)(hess(i,j),j=1,nvar)
  160    continue
  170    format(8f10.2)
      endif
  180 if((igthes.eq.1).or.(igthes.eq.4))then
c       if igthes is .eq. 4, then this is a hessian restart.
c       use gnext1 and dummy for calls to compfg during hessian
c       calculation
         if (igthes.eq.1)write(mfgw,190)
  190    format(/,10x,'hessian calculated numerically',/)
         tstore=time1
         do 210 i=iloop,nvar
            xparam(i)=xparam(i) + xinc
            call compfg(xparam, .true., dummy, .true., gnext1, .true.)
            if(iprnt.ge.5)write(mfgw,'(i3,12(8f9.4,/3x))')
     1    i,(gnext1(if),if=1,nvar)
            xparam(i)=xparam(i) - xinc
            do 200 j=1,nvar
  200       hess(i,j)= (gnext1(j)-grad(j))/xinc
            time2=secmop()
            tstep=time2-time1
            tleft=tleft-tstep
            time1=time2
            if( tleft .lt. tstep*two) then
c
c  store partial hessian patrix
c  store gradients for geometry and iloop as positive
            write(mfgw,'(a)')' not enough time to complete hessian'
            write(mfgw,'(a,i4)')' stopping in hessian at coordinate:',i
               ipow(9)=1
               tt0=secmop()-time0
               call bkrsav(tt0,hess,funct,grad,xparam,pmat,i,nstep,bmat,
     1ipow)
               return
            endif
  210    continue
         time1=tstore
      endif
c
c     symmetrize hessian
      do 220 i=1,nvar
         do 220 j=1,i-1
            hess(i,j)=(hess(i,j)+hess(j,i))/two
            hess(j,i)=hess(i,j)
  220 continue
  230 continue
c     start of main loop
c     we now have gradients and a hessian. if this is the first
c     time through don't update the hessian. for later loops also
c     check if we need to recalculate the hessian
      time2=secmop()
      tstep=time2-time1
      tleft=tleft-tstep
      time1=time2
      iflepo=0
  240 continue
      if (ihess.ge.ireclc.and.iflepo.ne.15) then
         iloop=1
         ihess=0
         igthes=1
         goto 180
      else
         if(iflepo.eq.15)goto 270
         if(iprnt.ge.2) then
         write(mfgw,'('' xparam '')')
         write(mfgw,'(5(2i3,f10.4))')(loc(1,i),loc(2,i),xparam(i),
     +   i=1,nvar)
         write(mfgw,'('' gradients'')')
         write(mfgw,'(3x,8f9.3)')(grad(i),i=1,nvar)
         endif
c
c        print results in cycle
         gnfina=dsqrt(ddot(nvar,grad,1,grad,1))
         if(ldump.eq.0)then
            write(mfgw,250)nstep+1,dmin1(tstep,9999.99d0),
     1dmin1(tleft,9999999.9d0),dmin1(gnfina,999999.999d0),funct
            if(log)write(11,250)nstep+1,dmin1(tstep,9999.99d0),
     1dmin1(tleft,9999999.9d0),dmin1(gnfina,999999.999d0),funct
  250       format(' cycle:',i4,' time:',f7.2,' time left:',f9.1,
     1' grad.:',f10.3,' heat:',g13.7)
         else
            write(mfgw,260)dmin1(tleft,9999999.9d0),
     1dmin1(gnfina,999999.999d0),funct
            if(log)write(11,260)dmin1(tleft,9999999.9d0),
     1dmin1(gnfina,999999.999d0),funct
  260       format(' restart file written,   time left:',f9.1,
     1' grad.:',f10.3,' heat:',g13.7)
         endif
c
c        test for convergence
c
         rmx=dsqrt(ddot(nvar,grad,1,grad,1))
         if (rmx.lt.tol2)goto 580
  270    continue
         ihess=ihess+1
         nstep=nstep+1
         if (ihess.gt.1) call mophes(svec,tvec,nvar,iupd)
      endif
c
      nhsinc=0
      ij=0
      do 290 i=1,nvar
         do 290 j=1,i
            ij=ij+1
            hessc(ij)=hess(j,i)
  290 continue
      call hqrii(hessc,nvar,nvar,eigval,uc)
      do 300 i=nvar,1,-1
      do 300 j=nvar,1,-1
  300 u(j,i)=uc(j+(i-1)*nvar)
      if (iprnt.ge.3) then
         if (iprnt.ge.4) then
            write(mfgw,*)' '
            write(mfgw,*)'              hessian matrix'
            low=1
            nup=8
  310       nup=min0(nup,nvar)
            write(mfgw,330) (i,i=low,nup)
            do 320 i=1,nvar
               write(mfgw,340) i,(hess(i,j),j=low,nup)
  320       continue
            nup=nup+8
            low=low+8
            if(low.lt.nvar) goto 310
  330       format(/,3x,8i9)
  340       format(1x,i3,8f9.1)
  350       format(/,4x,8f9.1,/)
  360       format(1x,i3,8f9.4)
         endif
         write(mfgw,*)' '
         write(mfgw,*)'              hessian eigenvalues and -vectors'
         low=1
         nup=8
  370    nup=min0(nup,nvar)
         write(mfgw,330) (i,i=low,nup)
         write(mfgw,350) (eigval(i),i=low,nup)
         do 380 i=1,nvar
            write(mfgw,360) i,(u(i,j),j=low,nup)
  380    continue
         nup=nup+8
         low=low+8
         if(low.lt.nvar) goto 370
      endif
      do 390 i=1,nvar
         if (dabs(eigval(i)).lt.eigmin)then
            if (eigval(i).lt.zzero)eigval(i)=-eigmin
            if (eigval(i).gt.zzero)eigval(i)=eigmin
            write(mfgw,400)i,eigval(i)
         endif
  390 continue
  400 format(5x,'warning! eigenvalue',i3,' too small, replaced by',
     1f7.3)
      neg=0
      do 410 i=1,nvar
         if (eigval(i) .lt. zzero)neg=neg+1
  410 continue
      if (rmx.lt.tol2)goto 580
      if (ihess.eq.1.and.iprnt.eq.2)write(mfgw,420)neg
  420 format(/,10x,'hessian has',i3,' negative eigenvalue(s)',/)
      do 430 i=1,nvar
         fx(i)=ddot(nvar,u(1,i),1,grad,1)
  430 continue
c  take the p-rfo step for a ts search and
c  the simple rfo step for a minimum search
c
      if(iprnt.ge.5.and.neg.eq.negreq.and.negreq.eq.1) 
     +  write(mfgw,690)
      if(iprnt.ge.5.and.neg.eq.negreq.and.negreq.eq.0) 
     +  write(mfgw,700)
      if(iprnt.ge.5.and.neg.ne.negreq.and.negreq.eq.1) 
     + write(mfgw,710)
      if(iprnt.ge.5.and.neg.ne.negreq.and.negreq.eq.0) 
     + write(mfgw,720)
  440 call mopfd(eigval,fx,nvar,fail,oride)
c     if fail is true then no acceptable lamda value could be found.
c     if gnorm is .lt. rcut and nr .eq. true, then take simpel nr-step.
c     if gnorm is .gt. rcut or nr .eq. false, then modify hessian.
c     if hsshft is on, then increase hessian diagonal elements with
c     eigval(1) + 2*eigmin for min search, or eigval(1+mode) + 2*eigmin
c     for ts search. then call formd again.
c     if eiginv is on, then reverse the sign of all negative eigenvalues
c     in the hessian other than the ts mode being followed, and call
c     formd again. if no acceptable lamda can be found after hessian
c     has been modified, we are out of luck...
c
      if (fail) then
         if (iflepo.eq.7) return
         if (nr.and.(rmx.lt.rcut)) then
            write(mfgw,450)rcut
  450       format(5x,'max gradient is less than rcut =',f5.1,
     1             ' taking simple nr-step')
            do 460 i=1,nvar
               d(i)=zzero
  460       continue
            do 480 i=1,nvar
               temp=-fx(i)/eigval(i)
               do 470 j=1,nvar
                  d(j)=d(j)+temp*u(j,i)
  470          continue
  480       continue
            fail=.false.
            goto 530
         endif
         if (hsshft) then
            nhsinc=nhsinc+1
            if (nhsinc.gt.1) then
               write(mfgw,640)
               write(mfgw,660)
               goto 620
            endif
            if (imin.ne.0)temp=two*eigmin+dabs(eigval(1))
            if (its .ne.0) then
               if(mode.eq.0)temp=two*eigmin+dabs(eigval(2))
               if(mode.ne.0)temp=two*eigmin+dabs(eigval(mode+1))
            endif
            do 490 i=1,nvar
               hess(i,i)=hess(i,i)+temp
               eigval(i)=eigval(i)+temp
  490       continue
            write(mfgw,500)temp
  500       format(5x,'hessian diagonal increased by',f8.1)
            fail=.false.
            goto 440
         endif
         if (eiginv) then
            nneg=0
            do 520 i=1,nvar
               if ((mode.eq.0).and.(i.eq.1)) goto 520
               if ((mode.ne.0).and.(i.eq.mode)) goto 520
               if (eigval(i).lt.zzero) then
                  nneg=nneg+1
                  eigval(i)=-eigval(i)
                  write(mfgw,510)eigval(i)
  510             format(5x,'hessian eigenvalue reversed, new value =',f
     18.1)
               endif
  520       continue
            if (nneg.gt.0) then
               fail=.false.
               goto 440
            else
               write(mfgw,650)
               write(mfgw,660)
               goto 620
            endif
         endif
      endif
c
c  we now have a new step in d
c  check that the stepsize does not exceed dmax
c  if so, scale
c
  530 skal=one
      dd=ddot(nvar,d,1,d,1)
      dd=dsqrt(dd)
c
      if(dd.gt.dmax) then
         skal=dmax/dd
         do 540 i=1,nvar
            d(i)=d(i)*skal
  540    continue
         dd=dmax
         if(iprnt.ge.2)write(mfgw,550)skal
  550    format(5x,'calculated step size too large, scaled with',f9.5)
      endif
c
      if(iprnt.ge.2)write(mfgw,560)dd
  560 format(5x,'stepsize used is',f9.5)
      if(iprnt.ge.2) then
         write(mfgw,'('' calculated step'')')
         write(mfgw,'(3x,8f9.5)')(d(i),i=1,nvar)
      endif
c
c  form new xparam and geo, save current gradients
c
      do 570 i=1,nvar
         xparam(i)=xparam(i)+d(i)
         oldf(i)=grad(i)
         k=loc(1,i)
         l=loc(2,i)
         geo(l,k)=xparam(i)
  570 continue
      if(ndep.ne.0) call mopsym()
c     check steps and enough time for another pass
      time2=secmop()
      tstep=time2-time1
      tleft=tleft-tstep
      time1=time2
      if (tstep.lt.zzero)tstep=zzero
      if (tleft .lt. tstep*two) goto 620
c     in user unfriendly enviroment, save results every 1 cpu hrs
      ittest=aint((time2-time0)/tdump)
      if (ittest.gt.ntime) then
         ldump=1
         ntime=max0(ittest,(ntime+1))
         ipow(9)=2
         tt0=secmop()-time0
         call bkrsav(tt0,hess,funct,grad,xparam,pmat,-nstep,nstep,bmat,i
     1pow)
      else
         ldump=0
      endif
c     get gradient for new geometry and return for another cycle
      call compfg(xparam, .true., funct, .true., grad, .true.)
      goto 240
  580 continue
      iflepo=15
c
c  check: has eigval been set, if not then go back and set it.
c
      if(ddot(nvar,eigval,1,eigval,1).lt.1.d-15)goto 240
      if (neg.ne.negreq) then
         iflepo=16
         write(mfgw,590)
         write(mfgw,600)(eigval(i),i=1,5)
  590    format(/,5x,'warning! hessian does not have the required ',
     1'structure',/)
  600    format(5x,'lowest 5 eigenvalues of hessian',3x,5f8.2)
      endif
      last=1
      if(iprnt.ge.2)write(mfgw,610)rmx,tol2
  610 format(/,5x,'maximum gradient =',f9.5,'  is less than cutoff =',
     1f9.5,//)
c     call compfg to calculate energy for fixing mo-vector bug
      call compfg(xparam, .true., funct, .true., grad, .false.)
      return
  620 continue
c     we ran out of time, or formd fail. dump results
      if (tleft .lt. tstep*two) then
         write(mfgw,680)
      endif
      ipow(9)=1
      tt0=secmop()-time0
      call bkrsav(tt0,hess,funct,grad,xparam,pmat,-nstep,nstep,bmat,i
     1pow)
_IF(ipsc,tools)
      call pend
_ELSE
      stop
_ENDIF
  630 continue
      write(mfgw,*)'     error during read of hessian from input'
_IF(ipsc,tools)
      call pend
_ELSE
      stop
_ENDIF
  640 format(5x,'hessian diagonal increased twice without step',/,5x,
     1'still no acceptable lamda value. terminating')
  650 format(5x,'all non-ts modes have positive eigenvalues',/,5x,
     1'yet formd cannot find acceptable lamda. terminating')
  660 format(5x,'ef optimization failed.... sorry....')
c 670 format(/,5x,'excess number of optimization cycles')
  680 format(/,5x,'not enough time for another cycle')
  690 format(5x,'ts search. taking p-rfo step')
  700 format(5x,'minimum search. taking simple rfo step')
  710 format(5x,'hessian does not have the desired local structure'/
     1       5x,'taking p-rfo step')
  720 format(5x,'hessian does not have the desired local structure'/
     1       5x,'taking simple rfo step')
      end
      subroutine elesp
      implicit REAL (a-h,o-z)
c***********************************************************************
c     elesp loads the sto-6g basis set onto the atoms, perfoms the
c     deorthogonalization of the coefficients and evaluates the
c     electronic contribution to the esp. it was written by b.h.besler
c     and k.m.merz in feb. 1989 at ucsf.
c
c***********************************************************************
      character*241 keywrd
      character getmop*80
      REAL norm,ovl
      logical potwrt,sto3g,sybcnt
_IF(ipsc,tools)
      logical oroot
_ENDIF
INCLUDE(common/sizes)
      common/espf/ al((numatm+4)**2),a(numatm,numatm),b(numatm),
     1q(numatm+4),cespm(maxorb,maxorb)
      common /densty/ p(mpack),pa(mpack),pb(mpack)
      common /potesp/ xc,yc,zc,espnuc,espele,nesp
      common /abc/    co(3,numatm),ian(numatm),natom
      common /work1/
     +    potpt(3,mesp), es(mesp), esp(mesp), work1d(2*mesp)
      common /sto6g/  allc(6,5,2),allz(6,5,2)
      common /vector/ c(morb2*2+maxorb*2)
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),
     1                nlast(numatm), norbs, nelecs,nalpha,nbeta,
     2                nclose,nopen,ndumy,fract
      common /keywrd/ keywrd
      common /espc/  cc(maxpr),cen(maxpr,3),iam(maxpr,2),ind(maxpr),
     1                ex(maxpr),espi(maxorb,maxorb),
     2                fv(0:8,821),fac(0:7),
     3                dex(-1:96),tf(0:2),temp(maxpr),itemp(maxpr),
     4                ovl(maxorb,maxorb),fc(maxpr*6)
      common /corec/ tore(107)
      common /expont/ zs(107),zp(107),zd(107)
*
*  end of mindo/3 common blocks
*
      common /indx/   indc(maxorb)
      dimension cespm2(maxorb,maxorb)
      dimension cespml(maxorb*maxorb),cesp(maxorb*maxorb)
      data bohr/0.529167d0/
      pi=4.d0*datan(1.d0)
c
c     put sto-6g basis set on atom centers
c
      do 10 i=-1,10
         dex(i)=dex2(i)
   10 continue
      do 20   i=0,7
         fac(i)=1.d0/fac(i)
   20 continue
      do 30 m=0,8
         k=1
         fv(m,1)=1.d0/(2.d0*m+1.d0)
         do 30 t=0.05d0,41.d0,0.05d0
            k=k+1
            call fsub(m,t,fval)
            fv(m,k)=fval
   30 continue
c
c     load basis functions into arrays
c
      sto3g=(index(keywrd,'sto3g') .ne. 0)
      if(sto3g) then
         icd=3
         call setup3
      else
         icd=6
         call setupg
      endif
      nc=0
      npr=0
      do 80 i=1,natom
         if (ian(i) .le. 2) then
            do 40 j=1,icd
               cc(npr+j)=allc(j,1,1)
               ex(npr+j)=allz(j,1,1)*zs(1)**2
               cen(npr+j,1)=co(1,i)/bohr
               cen(npr+j,2)=co(2,i)/bohr
               cen(npr+j,3)=co(3,i)/bohr
               iam(npr+j,1)=0
               iam(npr+j,2)=0
               fc(npr+j)=i
   40       continue
            nc=nc+1
            npr=npr+icd
         else
c        determine principal quantum number(nqn)
c        of orbitals to be used
c
            nqn=2
            if(ian(i) .gt. 10 .and. ian(i) .le. 18) nqn=3
            if(ian(i) .gt. 18 .and. ian(i) .le. 36) nqn=4
            if(ian(i) .gt. 36 .and. ian(i) .le. 54) nqn=5
c
            do 50 j=1,icd
               cc(npr+j)=allc(j,nqn,1)
               ex(npr+j)=allz(j,nqn,1)*zs(ian(i))**2
               cen(npr+j,1)=co(1,i)/bohr
               cen(npr+j,2)=co(2,i)/bohr
               cen(npr+j,3)=co(3,i)/bohr
               iam(npr+j,1)=0
               iam(npr+j,2)=0
   50       continue
            nc=nc+1
            npr=npr+icd
            do 70 k=1,3
               do 60  j=1,icd
                  cc(npr+j)=allc(j,nqn,2)
                  ex(npr+j)=allz(j,nqn,2)*zp(ian(i))**2
                  cen(npr+j,1)=co(1,i)/bohr
                  cen(npr+j,2)=co(2,i)/bohr
                  cen(npr+j,3)=co(3,i)/bohr
                  iam(npr+j,1)=1
                  iam(npr+j,2)=k
   60          continue
               nc=nc+1
               npr=npr+icd
   70       continue
         endif
   80 continue
c
c     calculate normalization constants and include
c     them in the contraction coefficients
c
      do 90 i=1,npr
         norm=(2.d0*ex(i)/pi)**0.75d0*(4.d0*ex(i))**(iam(i,1)/2.d0)/
     1   dsqrt(dex(2*iam(i,1)-1))
         cc(i)=cc(i)*norm
   90 continue
      ipr=0
c
c     perform sort of primitives by angular momentum
c
      is=0
      ip=0
      ipc=0
      isc=0
      j=0
      do 100 i=1,npr
         if (iam(i,1) .eq. 0) then
            is=is+1
            ind(is)=i
         endif
  100 continue
      ip=is
      do 110 i=1,npr
         if (iam(i,1) .eq. 1 .and. iam(i,2) .eq. 1) then
            ip=ip+1
            ind(ip)=i
         endif
  110 continue
      do 120 i=1,npr
         if (iam(i,1) .eq. 1 .and. iam(i,2) .eq. 2) then
            ip=ip+1
            ind(ip)=i
         endif
  120 continue
      do 130 i=1,npr
         if (iam(i,1) .eq. 1 .and. iam(i,2) .eq. 3) then
            ip=ip+1
            ind(ip)=i
         endif
  130 continue
      do 140 i=1,nc
         in=i*icd-icd+1
         if (iam(in,1) .eq. 0) then
            isc=isc+1
            indc(isc)=i
         endif
  140 continue
      ipc=isc
      do 150 i=1,nc
         in=i*icd-icd+1
         if (iam(in,1) .eq. 1 .and. iam(in,2) .eq. 1) then
            ipc=ipc+1
            indc(ipc)=i
         endif
  150 continue
      do 160 i=1,nc
         in=i*icd-icd+1
         if (iam(in,1) .eq. 1 .and. iam(in,2) .eq. 2) then
            ipc=ipc+1
            indc(ipc)=i
         endif
  160 continue
      do 170 i=1,nc
         in=i*icd-icd+1
         if (iam(in,1) .eq. 1 .and. iam(in,2) .eq. 3) then
            ipc=ipc+1
            indc(ipc)=i
         endif
  170 continue
      do 180 i=1,npr
         temp(i)=cc(ind(i))
  180 continue
      do 190 i=1,npr
         cc(i)=temp(i)
  190 continue
      do 200 i=1,npr
         temp(i)=ex(ind(i))
  200 continue
      do 210 i=1,npr
         ex(i)=temp(i)
  210 continue
      do 220 i=1,npr
         temp(i)=cen(ind(i),1)
  220 continue
      do 230 i=1,npr
         cen(i,1)=temp(i)
  230 continue
      do 240 i=1,npr
         temp(i)=cen(ind(i),2)
  240 continue
      do 250 i=1,npr
         cen(i,2)=temp(i)
  250 continue
      do 260 i=1,npr
         temp(i)=cen(ind(i),3)
  260 continue
      do 270 i=1,npr
         cen(i,3)=temp(i)
  270 continue
      do 280 i=1,npr
         itemp(i)=iam(ind(i),1)
  280 continue
      do 290 i=1,npr
         iam(i,1)=itemp(i)
  290 continue
      do 300 i=1,npr
         itemp(i)=iam(ind(i),2)
  300 continue
      do 310 i=1,npr
         iam(i,2)=itemp(i)
  310 continue
c     calculate overlap matrix of sto-6g functions
c
      do 320 j=1,nc
         call ovlp(j,1,is,ip,npr,nc,icd)
  320 continue
c
      do 330 j=1,nc
         do 330 k=1,nc
            cespm2(indc(j),indc(k))=ovl(j,k)
  330 continue
      do 340 j=1,nc
         do 340 k=1,nc
            ovl(j,k)=cespm2(j,k)
  340 continue
      l=0
      do 350 i=1,nc
         do 350 j=1,i
            l=l+1
            cesp(l)=ovl(i,j)
  350 continue
c
c     deorthogonalize the coefficients and reform the density matrix
c
      call rsp(cesp,nc,1,temp,cespml)
      do 360 i=1,nc
         do 360 j=1,i
            sum=0.d0
            do 360 k=1,nc
               sum=sum+cespml(i+(k-1)*nc)/dsqrt(temp(k))*
     +                 cespml(j+(k-1)*nc)
               cesp(i+(j-1)*nc)=sum
               cesp(j+(i-1)*nc)=sum
  360 continue
      call mult(c,cesp,cespml,nc)
      call densit(cespml,nc,nc,nclose,nopen,fract,cesp,2)
c
c     now calculate the electronic contribution to the electrostatic pot
c
      l=0
      do 370 i=1,nc
         do 370 j=1,i
            l=l+1
            cespm(i,j)=cesp(l)
            cespm(j,i)=cesp(l)
  370 continue
      ipx=(npr-is)/3
      ipe=is+ipx
      do 380 i=1,nesp
         es(i)=0.d0
  380 continue
      call naicas(isc,is,ip,npr,nc,ipe,ipx,icd)
      call naicap(isc,is,ip,npr,nc,ipe,ipx,icd)
c     calculate total esp and form arrays for espfit
c     skip arrays for espfit if sybcnt called
      sybcnt = (index(keywrd,'sybcnt') .ne. 0)
      do 400 i=1,nesp
         esp(i)=0.d0
         do 390 j=1,natom
            ra=dsqrt((co(1,j)-potpt(1,i))**2+
     +               (co(2,j)-potpt(2,i))**2+
     +               (co(3,j)-potpt(3,i))**2)
            esp(i)=esp(i)+tore(ian(j))/(ra/bohr)
  390    continue
         esp(i)=esp(i)-es(i)
         if(sybcnt) then
            continue
         endif
         do 400  j=1,natom
            rij=dsqrt((co(1,j)-potpt(1,i))**2+
     +                (co(2,j)-potpt(2,i))**2+
     +                (co(3,j)-potpt(3,i))**2)/bohr
            b(j)=b(j)+esp(i)*1.d0/rij
  400 continue
c
c     if requested write out electric potential data to
c     unit 21
c
      potwrt=((index(keywrd,'potwrt') .ne. 0) .or.
     1(index(keywrd,'sybcnt') .ne. 0))
_IF(ipsc,tools)
      if(potwrt.and.oroot() ) then
_ELSE
      if(potwrt) then
_ENDIF
         open(21,file=getmop(10),status='unknown')
         write(21,'(i5)') nesp
         do 410 i=1,nesp
c  410    write(21,420) esp(i),potpt(1,i)/bohr,potpt(2,i)/bohr,
c     1potpt(3,i)/bohr
  410    write(21,420) esp(i),potpt(1,i),potpt(2,i),
     1potpt(3,i)
      endif
  420 format(1x,4e16.7)
      return
      end
      function emsiab(ialpha,ibeta,eiga,xy,nmos)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      dimension xy(nmeci,nmeci,nmeci,nmeci), eiga(nmeci),
     1ialpha(nmos), ibeta(nmos)
************************************************************************
*
*  calculates the energy of a microstate defined by ialpha and ibeta
*
************************************************************************
      x=0.0d0
      do 20 i=1,nmos
         if (ialpha(i).ne.0)then
            x=x+eiga(i)
            do 10  j=1,nmos
               x=x+((xy(i,i,j,j)-xy(i,j,i,j))*ialpha(j)*0.5d0 +
     1        (xy(i,i,j,j)            )*ibeta(j))
   10       continue
         endif
   20 continue
      do 40 i=1,nmos
         if (ibeta(i).ne.0) then
            x=x+eiga(i)
            do 30 j=1,i
   30       x=x+(xy(i,i,j,j)-xy(i,j,i,j))*ibeta(j)
         endif
   40 continue
      emsiab=x
      return
      end
      subroutine enpart(uhf,h,alpha,beta,p,q,coord)
c----------------------------------------------------------*
c
c     new sub. enpart,  modified by tsuneo hirano 1986/6/3/
c
c---------------------------------------------------------*
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      common/iofile/mfgr,mfgw
      parameter (natms2 = (numatm*(numatm+1))/2)
      common /elemts/ elemnt(107)
      dimension h(*), alpha(*), beta(*), p(*), q(*), coord(3,*)
c--- defined here, and to be used for enpart-print only ---*
      dimension ex(natms2,3), emat(numatm,numatm)
c--- end of dimension definition ----------------- by th --*
      logical uhf, mindo3, am1
      character*241 keywrd
      character*2 elemnt
c***********************************************************************
c
c *** energy partitioning within the umindo/3 and umndo scheme
c     routine written by s.olivella, barcelona nov. 1979.
c     extended to am1 and pm3 by jjps.
c
c   on input uhf     = .true. if a u.h.f. calculation.
c            h       = one-electron matrix.
c            alpha   = alpha electron density.
c            beta    = beta electron density.
c            p       = total electron density.
c            q       = atom electron densities.
c
c    nothing is changed on exit.
c
c***********************************************************************
      common /cmpone/ uss(107), upp(107), udd(107)
      common /corec/ core(107)
      common /ideas/ fn1(107,10),fn2(107,10),fn3(107,10)
      common /alpha3/ alp3(153)
      common /twoel3/ f03(107)
      common /alpha/ alp(107)
      common /twoele/ gss(107),gsp(107),gpp(107),gp2(107),hsp(107)
     1                ,gsd(107),gpd(107),gdd(107)
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm)
     1               ,nlast(numatm),norbs,nelecs,
     2                nalpha,nbeta,nclose,nopen,ndumy,fract
      common /wmatrc/ w(n2elec*2)
      common /keywrd/ keywrd
      parameter (mdumy=maxpar*maxpar-numatm*3-natms2*4)
      common /scrach/ ea(numatm,2),eat(numatm), e(natms2,4),
     1xdumy(mdumy)
      mindo3=(index(keywrd,'mindo').ne.0)
c@ --------------------------*
c@    clear emat(i,i)
      do 10 i=1,numat
   10 emat(i,i)=0.0d0
c@ --------------------------*
c *** recalculate the density matrices in the uhf scheme
c
      linear=norbs*(norbs+1)/2
      if( .not. uhf) then
         do 20 i=1,linear
   20    beta(i)=alpha(i)
      endif
c
c *** one-center energies
      k=0
      do 40 i=1,numat
         ia=nfirst(i)
         ib=nlast(i)
         ni=nat(i)
         ea(i,1)=0.0d0
         do 30 j=ia,ib
            k=k+j
            t=upp(ni)
            if(j.eq.ia) t=uss(ni)
   30    ea(i,1)=ea(i,1)+p(k)*t
         iss=(ia*(ia+1))/2
         ea(i,2)=0.5d0*gss(ni)*p(iss)*p(iss)
     1  -0.5d0*gss(ni)*(alpha(iss)*alpha(iss)+beta(iss)*beta(iss))
         if(ia.eq.ib) go to 40
         ia1=ia+1
         ia2=ia+2
         ixx=ia1*ia2/2
         iyy=ia2*ib/2
         izz=(ib*(ib+1))/2
         ixy=ia1+ia2*ia1/2
         ixz=ia1+ib*ia2/2
         iyz=ia2+ib*ia2/2
         isx=ia+ia1*ia/2
         isy=ia+ia2*ia1/2
         isz=ia+ib*ia2/2
         ss1=p(ixx)*p(ixx)+p(iyy)*p(iyy)+p(izz)*p(izz)
         ss2=p(iss)*(p(ixx)+p(iyy)+p(izz))
         ss3=p(ixx)*p(iyy)+p(ixx)*p(izz)+p(iyy)*p(izz)
         ss4=p(isx)*p(isx)+p(isy)*p(isy)+p(isz)*p(isz)
         ss5=p(ixy)*p(ixy)+p(ixz)*p(ixz)+p(iyz)*p(iyz)
         tt1=alpha(ixx)*alpha(ixx)+alpha(iyy)*alpha(iyy)
     1+alpha(izz)*alpha(izz)+beta(ixx)*beta(ixx)
     2+beta(iyy)*beta(iyy)+beta(izz)*beta(izz)
         tt2=alpha(iss)*(alpha(ixx)+alpha(iyy)+alpha(izz))
     1   +beta(iss)*(beta(ixx)+beta(iyy)+beta(izz))
         tt3=alpha(ixx)*alpha(iyy)+alpha(ixx)*alpha(izz)
     1+alpha(iyy)*alpha(izz)+beta(ixx)*beta(iyy)
     2+beta(ixx)*beta(izz)+beta(iyy)*beta(izz)
         tt4=alpha(isx)*alpha(isx)+alpha(isy)*alpha(isy)
     1+alpha(isz)*alpha(isz)+beta(isx)*beta(isx)
     2+beta(isy)*beta(isy)+beta(isz)*beta(isz)
         tt5=alpha(ixy)*alpha(ixy)+alpha(ixz)*alpha(ixz)
     1+alpha(iyz)*alpha(iyz)+beta(ixy)*beta(ixy)
     2+beta(ixz)*beta(ixz)+beta(iyz)*beta(iyz)
         ea(i,2)=ea(i,2)+0.5d0*gpp(ni)*ss1+gsp(ni)*ss2
     1+gp2(ni)*ss3+hsp(ni)*ss4*2.0d0+0.5d0*(gpp(ni)-gp2(ni))*ss5*2.0d0
     2                -0.5d0*gpp(ni)*tt1-gsp(ni)*tt4-gp2(ni)*tt5-
     3        hsp(ni)*(tt2+tt4)-0.5d0*(gpp(ni)-gp2(ni))*(tt3+tt5)
   40 continue
      am1=(index(keywrd,'am1')+index(keywrd,'pm3').ne.0)
      if(mindo3) then
      write(mfgw,'(///,10x,''total energy partitioning in mindo/3'')')
      elseif( index(keywrd,'pm3').ne.0 ) then
      write(mfgw,'(///,10x,''total energy partitioning in pm3'')')
      elseif( index(keywrd,'am1').ne.0 ) then
      write(mfgw,'(///,10x,''total energy partitioning in am1'')')
      else
      write(mfgw,'(///,10x,''total energy partitioning in mndo'')')
      endif
      write(mfgw,'(/10x,''all energies are in electron volts'')')
      kl=0
   50 k=kl+1
      kl=kl+10
      kl=min0(kl,numat)
      do 60 i=k,kl
   60 eat(i)=ea(i,1)+ea(i,2)
      if(numat.gt.kl) go to 50
      eau=0.0d0
      eae=0.0d0
      do 80 i=1,numat
         eau=eau+ea(i,1)
   80 eae=eae+ea(i,2)
      tone=eau+eae
c *** two-center energies
c     resonance (e(n,1)) terms
      n=1
      do 100 ii=2,numat
         e(n,1)=0.0d0
         ia=nfirst(ii)
         ib=nlast(ii)
         iminus=ii-1
         oneii=1.d0
         if(nat(ii).eq.102)oneii=0.d0
         do 90 jj=1,iminus
            n=n+1
            ja=nfirst(jj)
            jb=nlast(jj)
            onejj=1.d0
            if(nat(jj).eq.102)onejj=0.d0
            e(n,1)=0.0d0
            do 90 i=ia,ib
               ka=(i*(i-1))/2
               do 90 k=ja,jb
                  ik=ka+k
   90    e(n,1)=e(n,1)+2.0d0*p(ik)*h(ik)*oneii*onejj
  100 n=n+1
c
c     the code that follows applies only to mndo
c
      if(.not.mindo3) then
c     core-core repulsion (e(n,2)) and core-elec. attraction (e(n,3)).
         n=1
         kk=0
         do 180 ii=2,numat
            e(n,2)=0.0d0
            e(n,3)=0.0d0
            ia=nfirst(ii)
            ib=nlast(ii)
            ni=nat(ii)
            iss=(ia*(ia+1))/2
            iminus=ii-1
            do 170 jj=1,iminus
               n=n+1
               ja=nfirst(jj)
               jb=nlast(jj)
               nj=nat(jj)
               jss=(ja*(ja+1))/2
               kk=kk+1
               g=w(kk)
               r=dsqrt((coord(1,ii)-coord(1,jj))**2+
     +                 (coord(2,ii)-coord(2,jj))**2+  
     +                 (coord(3,ii)-coord(3,jj))**2)
               scale=1.0d0+dexp(-alp(ni)*r)+dexp(-alp(nj)*r)
               nt=ni+nj
               if(nt.lt.8.or.nt.gt.9) go to 110
               if(ni.eq.7.or.ni.eq.8) 
     +          scale=scale+(r-1.0d0)*dexp(-alp(ni)*r)
               if(nj.eq.7.or.nj.eq.8) 
     +          scale=scale+(r-1.0d0)*dexp(-alp(nj)*r)
  110          e(n,2)=core(ni)*core(nj)*g*scale
               if( am1 )then
                  scale=0.0d0
                  do 120 ig=1,10
                     if(dabs(fn1(ni,ig)).gt.0.d0)
     1scale=scale +core(ni)*core(nj)/r*
     2fn1(ni,ig)*dexp(-fn2(ni,ig)*(r-fn3(ni,ig))**2)
                     if(dabs(fn1(nj,ig)).gt.0.d0)
     1scale=scale +core(ni)*core(nj)/r*
     2fn1(nj,ig)*dexp(-fn2(nj,ig)*(r-fn3(nj,ig))**2)
  120             continue
                  e(n,2)=e(n,2)+scale
               endif
               e(n,3)=-(p(iss)*core(nj)+p(jss)*core(ni))*g
               if(nj.lt.3) go to 140
               kinc=9
               jap1=ja+1
               do 130 k=jap1,jb
                  kc=(k*(k-1))/2
                  do 130 l=ja,k
                     kl=kc+l
                     bb=2.0d0
                     if(k.eq.l) bb=1.0d0
                     kk=kk+1
  130          e(n,3)=e(n,3)-p(kl)*core(ni)*bb*w(kk)
               go to 150
  140          kinc=0
  150          if(ni.lt.3) go to 170
               iap1=ia+1
               do 160 i=iap1,ib
                  ka=(i*(i-1))/2
                  do 160 j=ia,i
                     ij=ka+j
                     aa=2.0d0
                     if(i.eq.j) aa=1.0d0
                     kk=kk+1
                     e(n,3)=e(n,3)-p(ij)*core(nj)*aa*w(kk)
  160          kk=kk+kinc
  170       continue
  180    n=n+1
c     coulomb (e(n,4)) and exchange (ex(n)) terms
         n=1
         kk=0
         do 200 ii=2,numat
            e(n,4)=0.0d0
            ex(n,1)=0.0d0
            ia=nfirst(ii)
            ib=nlast(ii)
            iminus=ii-1
            do 190 jj=1,iminus
               ja=nfirst(jj)
               jb=nlast(jj)
               n=n+1
               e(n,4)=0.0d0
               ex(n,1)=0.0d0
               do 190 i=ia,ib
                  ka=(i*(i-1))/2
                  do 190 j=ia,i
                     kb=(j*(j-1))/2
                     ij=ka+j
                     aa=2.0d0
                     if(i.eq.j) aa=1.0d0
                     pij=p(ij)
                     do 190 k=ja,jb
                        kc=(k*(k-1))/2
                        ik=ka+k
                        jk=kb+k
                        do 190 l=ja,k
                           il=ka+l
                           jl=kb+l
                           kl=kc+l
                           bb=2.0d0
                           if(k.eq.l) bb=1.0d0
                           kk=kk+1
                           g=w(kk)
                           e(n,4)=e(n,4)+aa*bb*g*pij*p(kl)
  190       ex(n,1) = ex(n,1)
     1    -0.5d0*aa*bb*g*(alpha(ik)*alpha(jl)+alpha(il)*alpha(jk)+
     2    beta(ik)*beta(jl)+beta(il)*beta(jk))
  200    n=n+1
      else
         n=1
         do 260 i=2,numat
            e(n,2)=0.0d0
            e(n,3)=0.0d0
            e(n,4)=0.0d0
            ex(n,1)=0.0d0
            ia=nfirst(i)
            ib=nlast(i)
            ni=nat(i)
            iminus=i-1
            do 250 j=1,iminus
               n=n+1
               ja=nfirst(j)
               jb=nlast(j)
               nj=nat(j)
               rij=(coord(1,i)-coord(1,j))**2+
     +             (coord(2,i)-coord(2,j))**2+
     +             (coord(3,i)-coord(3,j))**2
               gij=14.399d0/dsqrt(rij+
     +             (7.1995d0/f03(ni)+7.1995d0/f03(nj))**2)
               pab2=0.0d0
               ij=max0(ni,nj)
               nbond=(ij*(ij-1))/2+ni+nj-ij
               rij=dsqrt(rij)
               if(nbond.eq.22 .or. nbond .eq. 29) go to 210
               go to 220
  210          scale=alp3(nbond)*dexp(-rij)
               go to 230
  220          scale=dexp(-alp3(nbond)*rij)
  230          continue
               e(n,2)=core(ni)*core(nj)*gij+
     1     dabs(core(ni)*core(nj)*(14.399d0/rij-gij)*scale)
               e(n,3)=(-q(i)*core(nj)-q(j)*core(ni))*gij
               e(n,4)=q(i)*q(j)*gij
               do 240 k=ia,ib
                  kk=(k*(k-1))/2
                  do 240 l=ja,jb
                     lk=kk+l
  240          pab2=pab2+alpha(lk)*alpha(lk)+beta(lk)*beta(lk)
  250       ex(n,1) = -pab2*gij
  260    n=n+1
      endif
      numat1=(numat*(numat+1))/2
      do 270 i=1,4
  270 e(numat1,i)=0.0d0
      do 280 i=1,3
  280 ex(numat1,i)=0.0d0
c@ --------------------------*
c-----print out one and two center energies
c
c     e(i,1):     resonance energy
c     e(i,2):     nuclear-nuclear repulsion energy
c     e(i,3):     electron-nuclear attraction energy
c     e(i,4):     electron-electron repulsion energy
c     ex(i,1):    exchange  energy
c     ex(i,2):    exchange + resonance energy
c#      write(6,'(//,''       one and two center energies (ev) '')')
c
c#      write(6,'(/,''  [resonance term] (ev)'')')
c#      call vecprt(e,numat)
c
c#      write(6,'(/,''  [exchange term] (ev)'')')
c#      call vecprt(ex,numat)
c
c#      write(6,'(/,''  [resonance + exchange] (ev)'')')
      do 290 n=1,numat1
  290 ex(n,2) =e(n,1) + ex(n,1)
c
c   add in monocentric exchange and coulombic term
c
      do 300 i=1,numat
  300 ex((i*(i+1))/2,2)=ea(i,2)
c#      call vecprt(ex(1,2),numat)
c
c#      write(6,'(/,''  [electron - electron repulsion] (ev)'')')
c#      call vecprt(e(1,4),numat)
c
c#      write(6,'(/,''  [electron-nuclear attraction] (ev)'')')
      do 310 i=1,numat
  310 e((i*(i+1))/2,3)=ea(i,1)
c#      call vecprt(e(1,3),numat)
c
c#      write(6,'(/,''  [nuclear-nuclear repulsion] (ev)'')')
c#      call vecprt(e(1,2),numat)
c
      do 320 n=1,numat1
  320 ex(n,3) =e(n,4) + e(n,3) + e(n,2)
c     print out of total coulomb term
c#      write(6,'(/,''  [total coulomb term (e-e, e-n, and n-n)] (ev)'')
c#      call vecprt(ex(1,3),numat)
c     print out of two-center sum(off-diagonal) +
c                  one-center sum(diagonal).
c#      write(6,'(/,''  [two-center sum (off-diagonal), and  '',
c#     1''one-center sum (diagonal)] (ev)'')')
c#      do 340 n=1,numat1
c#  340 ex(n,3)=ex(n,3)+ex(n,2)
c#      call vecprt(ex(1,3),numat)
      write(mfgw,'(/,8(10x,a,/))')
     1'  one-center terms',' ',
     2'e-e:  electron-electron repulsion',
     3'e-n:  electron-nuclear attraction'
      write(mfgw,'(/,''   atom     e-e       e-n    (e-e + e-n)'')')
      do 330 i=1,numat
         j=(i*(i+1))/2
         write(mfgw,'(2x,a2,i3,1x,2f10.4,f10.4)')
     1elemnt(nat(i)),i, ex(j,2), e(j,3), ex(j,2)+e(j,3)
  330 continue
      write(mfgw,'(/,8(10x,a,/))')
     1'    two-center terms',' ',
     2'j:   resonance energy          e-e: electron-electron repulsion',
     3'k:   exchange energy           e-n: electron-nuclear attraction',
     4'                               n-n: nuclear-nuclear repulsion',
     5'c:   coulombic interaction = e-e + e-n + n-n',
     6'ee:  total of electronic and nuclear energies'
      write(mfgw,'(/,''   atom          j        k       e-'',
     1''e       e-n      n-n      c        ee'')')
      write(mfgw,'(''   pair'')')
      ij=0
      do 340 i=1,numat
         do 340 j=1,i
            ij=ij+1
            if(i.ne.j) then
            write(mfgw,'(1x,a2,i3,1x,a2,i3,1x,2f9.4,f9.4,f10.4,f9.4,f8.4
     1,f9.4)')elemnt(nat(i)),i,elemnt(nat(j)),j, e(ij,1), ex(ij,1),
     2e(ij,4), e(ij,3), e(ij,2), ex(ij,3), ex(ij,2)+ex(ij,3)
            else
               if(i.lt.6.or.i.eq.numat)then
                  write(mfgw,*)
               else
               write(mfgw,'(/,''   atom          j        k       e-'',
     1''e       e-n      n-n      c        ee'')')
               write(mfgw,'(''   pair'')')
               endif
            endif
  340 continue
c
c     ++++   totals   ++++
c
      eabr=0.0d0
      eabx=0.0d0
      eabee=0.0d0
      eaben=0.0d0
      eabnn=0.0d0
      do 350 i=1,numat
  350 e((i*(i+1))/2,3)=0.d0
      do 360 i=1,numat1
         eabr=eabr+e(i,1)
         eabx=eabx+ex(i,1)
         eabee=eabee+e(i,4)
         eaben=eaben+e(i,3)
         eabnn=eabnn+e(i,2)
  360 continue
      eabrx=eabr+eabx
      eabe=eabee+eaben+eabnn
      ttwo=eabrx+eabe
      et=tone+ttwo
c@ ***************************************************************
      write(mfgw,370)
  370 format(///,'***  summary of energy partition  ***')
      write(mfgw,380)
  380 format(1h ,'---------------------------------------')
      write(mfgw,'(''     one-center terms'')')
      write(mfgw,390) eau
  390 format(/,' electron-nuclear  (one-electron) ',f17.4,' ev')
      write(mfgw,400) eae
  400 format(' electron-electron (two-electron) ',f17.4,' ev')
      write(mfgw,410) tone
  410 format(/,' total of one-center terms        ',18x,f15.4,' ev')
      write(mfgw,380)
      write(mfgw,'(''     two-center terms'')')
      write(mfgw,420) eabr
  420 format(/,' resonance energy',8x,f15.4,' ev')
      write(mfgw,430) eabx
  430 format(' exchange energy ',8x,f15.4,' ev')
      write(mfgw,440) eabrx
  440 format(/,' exchange + resonance energy:       ',f15.4,' ev')
      write(mfgw,450) eabee
  450 format(/,' electron-electron repulsion',f12.4,' ev')
      write(mfgw,460) eaben
  460 format(  ' electron-nuclear attraction',f12.4,' ev')
      write(mfgw,470) eabnn
  470 format(  ' nuclear-nuclear repulsion  ',f12.4,' ev')
      write(mfgw,480) eabe
  480 format(/,' total electrostatic interaction    ',f15.4,' ev',/)
      write(mfgw,490) ttwo
  490 format(' grand total of two-center terms   ',17x,f15.4,' ev')
      write(mfgw,380)
      write(mfgw,500) et
  500 format(' etot (eone + etwo)   ',30x,f15.4,' ev'//)
      return
      end
      subroutine epseta(eps,eta)
      implicit REAL (a-h,o-z)
c
c     compute and return eta, the smallest representable number,
c     and eps is the smallest number for which 1+eps.ne.1.
c
c
      eta = 1.d0
   10 if((eta/2.d0).eq.0.d0) goto 20
      if(eta.lt.1.d-38) goto 20
      eta = eta / 2.d0
      goto 10
   20 eps = 1.d0
   30 if((1.d0+(eps/2.d0)).eq.1.d0) goto 40
      if(eps.lt.1.d-17) goto 40
      eps = eps / 2.d0
      goto 30
   40 return
      end
      subroutine esp
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
c***********************************************************************
c
c     this is a driver routine for electrostatic potential generation
c     written by k.m.merz feb. 1989 at ucsf
c
c***********************************************************************
      common/iofile/mfgr,mfgw
      common /keywrd/ keywrd
      character*241 keywrd
c
c     set standard parameters for the surface generation
c
      if(index(keywrd,'scale=') .ne. 0)then
         scale = reada(keywrd,index(keywrd,'scale='))
      else
         scale = 1.4d0
      endif
c
      if(index(keywrd,'den=') .ne. 0)then
         den = reada(keywrd,index(keywrd,'den='))
      else
         den = 1.0d0
      endif
c
      if(index(keywrd,'scincr=') .ne. 0)then
         scincr = reada(keywrd,index(keywrd,'scincr='))
      else
         scincr = 0.20d0
      endif
c
      if(index(keywrd,'nsurf=') .ne. 0)then
         n = reada(keywrd,index(keywrd,'nsurf='))
      else
         n = 4
      endif
c
      time1=secmop()
c
c     now calculate the surface points
c
      if(index(keywrd,'williams') .ne. 0) then
         call pdgrid
      elseif(index(keywrd,'sybcnt') .ne. 0) then
         call sybgrid
      else
         do 10 i = 1,n
            call surfac(scale,den,i)
            scale = scale + scincr
   10    continue
      endif
c
c     next calculate the esp at the points calculated by surfac
c
      call potcal
c
c     end of calculation
c
      time1=secmop()-time1
      write(mfgw,20) 'time to calculate esp:',time1,' seconds'
   20 format(/9x,a,f8.2,a)
      return
      end
      block data espblo
      implicit REAL (a-h, o-z)
INCLUDE(common/sizes)
      common /espc/  cc(maxpr),cen(maxpr,3),iam(maxpr,2),ind(maxpr),
     1                ex(maxpr),espi(maxorb,maxorb),
     2                fv(0:8,821),fac(0:7),
     3                dex(-1:96),tf(0:2),temp(maxpr),itemp(maxpr),
     4                ovl(maxorb,maxorb),fc(maxpr*6)
      data tf/33.d0,37.d0,41.d0/
      data fac/1.d0,1.d0,2.d0,6.d0,24.d0,120.d0,720.d0,5040.d0/
      end
      subroutine espfit(idip,natom,nesp,iz,esp,potpt,co,
     1dx,dy,dz,rms,rrms)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
c***********************************************************************
c
c     this routine fits the electrostatic potential to a monopole
c     expansion. fitting to the dipole monent can also be done.
c     this routine was written by b.h.besler and k.m.merz
c     in feb. 1989 at ucsf.
c
c     on input:  idip = flag to indicate if the dipole is fit
c                natom = number of atoms
c                nesp = number of esp points
c                iz = molecular charge
c                esp = total esp at the points
c                potpt = esp points
c                co = coordinates
c                dx = x component of the dipole
c                dy = y component of the dipole
c                dz = z component of the dipole
c
c     on output: q = esp charges
c                rms = root mean square fit
c                rrms = relative root mean square fit
c
c     for more details see: besler,merz,kollman j. comput. chem.
c     (in press)
c***********************************************************************
      common/espf/ al((numatm+4)**2),a(numatm,numatm),b(numatm),
     1q(numatm+4),qsc(numatm+4),cf, espfd(maxorb**2-numatm-5)
      dimension co(3,*),esp(*),potpt(3,*)
      bohr = 0.529167d00
c     conversion factor for debye to atomic units
      cf=5.2917715d-11*1.601917d-19/3.33564d-30
c
c     the following sets up the linear equation a*q=b
c     set up the a(j,k) array
c
      do 20  k=1,natom
         do 10  j=1,natom
            do 10  i=1,nesp
             rik=dsqrt((co(1,k)-potpt(1,i))**2+(co(2,k)-potpt(2,i))**2
     1      +(co(3,k)-potpt(3,i))**2)/bohr
             rij=dsqrt((co(1,j)-potpt(1,i))**2+(co(2,j)-potpt(2,i))**2
     1      +(co(3,j)-potpt(3,i))**2)/bohr
               a(j,k)=a(j,k)+1.d0/rik*1.d0/rij
   10    continue
         a(natom+1,k)=1.d0
         a(k,natom+1)=1.d0
         a(natom+1,natom+1)=0.d0
         if(idip .eq. 1) then
            a(natom+2,k)=co(1,k)/bohr
            a(k,natom+2)=co(1,k)/bohr
            a(natom+2,natom+2)=0.d0
            a(natom+3,k)=co(2,k)/bohr
            a(k,natom+3)=co(2,k)/bohr
            a(natom+3,natom+3)=0.d0
            a(natom+4,k)=co(3,k)/bohr
            a(k,natom+4)=co(3,k)/bohr
            a(natom+4,natom+4)=0.d0
         endif
   20 continue
      b(natom+1)=dfloat(iz)
      b(natom+2)=dx/cf
      b(natom+3)=dy/cf
      b(natom+4)=dz/cf
c
c     insert charge and dipolar (if desired) constraints
c
      if(idip .eq. 1) then
         l=0
         do 30 i=1,natom+4
            do 30 j=1,natom+4
               l=l+1
   30    al(l)=a(i,j)
      else
         l=0
         do 40 i=1,natom+1
            do 40 j=1,natom+1
               l=l+1
   40    al(l)=a(i,j)
      endif
      if (idip .eq. 1) then
         call osinv(al,natom+4,det)
      else
         call osinv(al,natom+1,det)
      endif
      if(idip .eq. 1) then
         l=0
         do 50 i=1,natom+4
            do 50 j=1,natom+4
               l=l+1
   50    a(i,j)=al(l)
      else
         l=0
         do 60 i=1,natom+1
            do 60 j=1,natom+1
               l=l+1
   60    a(i,j)=al(l)
      endif
c
c     solve for the charges
c
      if(idip .eq. 1) then
         do 70 i=1,natom+4
            do 70 j=1,natom+4
               q(i)=q(i)+a(i,j)*b(j)
   70    continue
      else
         do 80 i=1,natom+1
            do 80 j=1,natom+1
               q(i)=q(i)+a(i,j)*b(j)
   80    continue
      endif
c
c     calculate root mean square fits and relative root mean square fits
c
      ctot=0.0d0
      do 100 i=1,nesp
         espc=0.d0
         do 90 j=1,natom
            rij=dsqrt((co(1,j)-potpt(1,i))**2+(co(2,j)-potpt(2,i))**2
     1      +(co(3,j)-potpt(3,i))**2)/bohr
   90    espc=espc+q(j)/rij
         rms=rms+(espc-esp(i))**2
  100 rrms=rrms+esp(i)**2
      rms=dsqrt(rms/nesp)
      rrms=rms/dsqrt(rrms/nesp)
      rms=rms*627.51d0
      return
      end
      subroutine ffhpol (heat0,atpol,dipvec)
      implicit REAL (a-h,o-z)
      character*1 axis(3)
      logical large,poldip,debug
INCLUDE(common/sizes)
c***********************************************************************
c  subroutine for the finite field calculation of electric response
c  properties (dipole moment, polarizability, and 1st and 2nd
c  hyperpolarizability.
c
c  henry a. kurtz, department of chemistry
c                  memphis state university
c                  memphis, tn   38152
c
c***********************************************************************
      common /corec/ core(107)
      common /cmpg/ geo(3,numatm)
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),
     1                nlast(numatm),nors,nelecs,nalpha,nbeta,
     2                nclose,nopen,ndumy,fract
      common /coord/ coord(3,numatm)
      common/iofile/mfgr,mfgw
      common /keywrd/ keywrd
      common /cmpfd/ efield(3)
      common /euler/ tvec(3,3),idtvec
      character*241 keywrd
c
c
c     dipe4 and dipdp hold the calculated dipole moments
c
c     apole4 and apoldp hold the polarizability tensor as
c                                a packed array xx,xy,yy,xz,yz,zz
c
c     betae4 and betaep hold the first hyperpolarizability
c                                1. xxx
c                                2. yyy     6. yxx
c                                3. zzz     7. yzz
c                                4. xyy     8. zxx
c                                5. xzz     9. zyy
c
      dimension heate(3,2),dipvec(3),
     1          dipe4(3),apole4(6),betae4(9),gamme4(6),
     2          dipdp(3),apoldp(6),betadp(9),gammdp(6),
     3          dip1p(3),dip1m(3),dip2p(3),dip2m(3)
      dimension iptbd(6)
      data iptbd /5,7,4,9,6,8/
      data axis/'x','y','z'/
c energy: a.u. to kcal/mole
      autokc = 23.061d+00*27.2107d+00
c length: a.u. to angstrom
      autoa  = 0.529177d+00
c dipole: a.u. to debye
      autodb = 2.541563d+00
c electric field: a.u. to volt/meter
      autovm = 51.4257d+00
      nbdip = 1
      ngdip = 4
      nbcnt = 4
      ngcnt = 4
c
      large = (index(keywrd,'large').ne.0)
      debug = (index(keywrd,'debug').ne.0)
c
c  field strength in a.u.
c
      efval=0.001d0
      idip=1
c modification for variable field strength
      if(index(keywrd,'polar=').ne.0)
     1efval=reada(keywrd,index(keywrd,'polar='))
      write (mfgw,10) efval
   10 format (//' applied electric field magnitude: ',f15.5)
      poldip = .false.
      if (idip.ne.0) poldip = .true.
      sfe = 1.d00/efval
      write (mfgw,20) 6.74834d0*atpol
   20 format (//' atomic contribution to the polarizability: ',f15.6,/,
     1          '  (it is only applied to the e4 result)')
c.......................................................................
c  calculate the polarizability and hyperpolarizabilities along
c  the three principle axes.  (these axes depend on your arbitrary
c  orientation and may not be the true principle axes.)
c.......................................................................
      do 150 id = 1,3
         if (debug) then
            write (mfgw,30) axis(id)
   30       format (//,' ****** field in ',a1,' direction *****',/)
         endif
c
c zero the field
c
         do 40 i = 1,3
            efield(i) = 0.0d00
   40    continue
         hnuc = 0.0d00
         do 50 i = 1,numat
            hnuc = hnuc + efval*geo(id,i)*core(nat(i))*autovm
   50    continue
         hnuc = hnuc*23.061d00
c +e(id)
         efield(id) = efval
         call compfg(geo,.true.,heat1p,.true.,grad,.false.)
         call dipind (dip1p)
         diip = dip1p(id)
c -e(id)
         efield(id) = -efval
         call compfg(geo,.true.,heat1m,.true.,grad,.false.)
         call dipind (dip1m)
         diim = dip1m(id)
c +2e(id)
         efield(id) = 2.0d00*efval
         call compfg(geo,.true.,heat2p,.true.,grad,.false.)
         call dipind (dip2p)
c -2e(id)
         efield(id) = -2.0d00*efval
         call compfg(geo,.true.,heat2m,.true.,grad,.false.)
         call dipind (dip2m)
c
c  correct for electric field - nuclear interactions
c
         heat1p = heat1p + hnuc
         heate(id,1) = heat1p
         heat1m = heat1m - hnuc
         heate(id,2) = heat1m
         heat2p = heat2p + hnuc*2.d00
         heat2m = heat2m - hnuc*2.d00
c
         if (debug) then
            write (mfgw,60)
   60       format (' fields of: ',5x,'f',21x,'2f')
            write (mfgw,70) heat1p,heat2p,heat1m,heat2m,
     1                dip1p(id),dip2p(id),dip1m(id),dip2m(id)
   70       format ('  energy:'/,
     1           '   + ',2(f20.10,3x),/,'   - ',2(f20.10,3x),/,
     2           '  dipole:'/,
     3           '   + ',2(f20.10,3x),/,'   - ',2(f20.10,3x))
         endif
c
c dipole
c
         eterm = (1.0d00/12.d00)*(heat2p - heat2m)
     1        - (2.0d00/3.0d00)*(heat1p - heat1m)
         dipe4(id) = eterm*sfe/autokc
c
c alpha
c
         ivl = (id*(id+1))/2
         eterm = 2.5d00*heat0 - (4.d00/3.d00)*(heat1p + heat1m)
     1        + (1.d00/12.0d00)*(heat2p + heat2m)
         apole4(ivl) = eterm*sfe*sfe/autokc + atpol*6.74834d0
c
c beta
c
         eterm = (heat1p - heat1m) - 0.5d00*(heat2p - heat2m)
         betae4(id) = eterm*sfe*sfe*sfe/autokc
c
c gamma
c
         eterm = 4.0d00*(heat1p + heat1m) - (heat2p + heat2m)
     1        - 6.0d00*heat0
         gamme4(id) = eterm*sfe*sfe*sfe*sfe/autokc
c
c dipole calculations
c
         dmu = (2.0d00/3.0d00)*(dip1p(id) + dip1m(id))
     1      - (1.d00/6.0d00)*(dip2p(id) + dip2m(id))
         dipdp(id) = dmu/autodb
         ae = (2.0d00/3.0d00)*(dip1p(id) - dip1m(id))
     1     - (1.0d00/12.d00)*(dip2p(id) - dip2m(id))
         apoldp(ivl) = ae*sfe/autodb
         be = (1.d00/3.0d00)*(dip2p(id) + dip2m(id)
     1                     - dip1p(id) - dip1m(id))
         betadp(id) = be*sfe*sfe/autodb
         ge = 0.5d00*(dip2p(id) - dip2m(id))
     1     - (dip1p(id) - dip1m(id))
         gammdp(id) = ge*sfe*sfe*sfe/autodb
         do 80 kd = 1,3
            if (kd.lt.id) then
               kvl = (id*(id-1))/2 + kd
               aki = (2.0d00/3.0d00)*(dip1p(kd) - dip1m(kd))
     1         - (1.0d00/12.0d00)*(dip2p(kd) - dip2m(kd))
               apoldp(kvl) = aki*sfe/autodb
            endif
            if (kd.ne.id) then
               bkii = (1.0d00/3.0d00)*(dip2p(kd) + dip2m(kd)
     1                           - dip1p(kd) - dip1m(kd))
               nbd = iptbd(nbdip)
               betadp(nbd) = bkii*sfe*sfe/autodb
               nbdip = nbdip + 1
            endif
   80    continue
c.......................................................................
c
c  now calculate the off axis results.
c
c.......................................................................
         idm1 = id - 1
         do 140 jd = 1,idm1
            hnucj = 0.0d00
            do 90 i = 1,numat
               hnucj = hnucj + efval*geo(jd,i)*core(nat(i))*
     +                         51.4257d0
   90       continue
            hnucj = hnucj*23.061d0
            do 100 i = 1,3
               efield(i) = 0.0d00
  100       continue
c
c diagonal fields with components equal to efval
c
            efield(id) = efval
            efield(jd) = efval
            call compfg(geo,.true.,hpp,.true.,grad,.false.)
            call dipind (dip1p)
            dpp = dip1p(id)
            efield(jd) = -efval
            call compfg(geo,.true.,hpm,.true.,grad,.false.)
            call dipind (dip1p)
            dpm = dip1p(id)
            efield(id) = -efval
            call compfg(geo,.true.,hmm,.true.,grad,.false.)
            call dipind (dip1p)
            dmm = dip1p(id)
            efield(jd) = efval
            call compfg(geo,.true.,hmp,.true.,grad,.false.)
            call dipind (dip1p)
            dmp = dip1p(id)
            hpp = hpp + hnuc + hnucj
            hpm = hpm + hnuc - hnucj
            hmm = hmm - hnuc - hnucj
            hmp = hmp - hnuc + hnucj
            if (debug) then
               write (mfgw,110)
  110          format (/,' ',12x,'+,+',15x,'+,-',15x,'-,+',15x,'-,-')
               write (mfgw,120) hpp,hpm,hmp,hmm
  120          format ('  e ',4f15.6)
            endif
c
c  diagonal fields with components equal to 2*efval
c
            efield(id) = efval*2.d00
            efield(jd) = efval*2.d00
            call compfg(geo,.true.,h2pp,.true.,grad,.false.)
            efield(jd) = -efval*2.d00
            call compfg(geo,.true.,h2pm,.true.,grad,.false.)
            efield(id) = -efval*2.d00
            call compfg(geo,.true.,h2mm,.true.,grad,.false.)
            efield(jd) = efval*2.d00
            call compfg(geo,.true.,h2mp,.true.,grad,.false.)
            h2pp = h2pp + 2.0d00*(hnuc + hnucj)
            h2pm = h2pm + 2.0d00*(hnuc - hnucj)
            h2mm = h2mm - 2.0d00*(hnuc + hnucj)
            h2mp = h2mp - 2.0d00*(hnuc - hnucj)
            if (debug) then
               write (mfgw,130) h2pp,h2pm,h2mp,h2mm
  130          format (' 2e ',4f15.6)
            endif
c
            aterm = (1.0d00/48.0d00)*(h2pp - h2pm - h2mp + h2mm)
     1          - (1.0d00/3.0d00)*(hpp - hpm - hmp + hmm)
            aij = aterm*sfe*sfe/autokc
            ivl = (id*(id-1))/2 + jd
            apole4(ivl) = aij
            bterm = 0.5d00*(hmm - hpp + hpm - hmp)
     1          + heate(jd,1) - heate(jd,2)
            bjii = bterm*sfe*sfe*sfe/autokc
            betae4(nbcnt) = bjii
            nbcnt = nbcnt + 1
            bterm = 0.5d00*(hmm - hpp + hmp - hpm)
     1          + heate(id,1) - heate(id,2)
            bijj = bterm*sfe*sfe*sfe/autokc
            betae4(nbcnt) = bijj
            nbcnt = nbcnt + 1
c
            gterm = -(hpp + hmm + hpm + hmp) - 4.0d00*heat0
     1           + 2.0d00*(heate(id,1) + heate(id,2))
     2           + 2.0d00*(heate(jd,1) + heate(jd,2))
            giijj = gterm*sfe*sfe*sfe*sfe/autokc
            gamme4(ngcnt) = giijj
            gdip = 0.5d00*(dpp - dmp + dpm - dmm) - (diip - diim)
            gammdp(ngcnt) = gdip*sfe*sfe*sfe/autodb
            ngcnt = ngcnt + 1
  140    continue
c
  150 continue
c-----------------------------------------------------------------------
c  summarize the results
c-----------------------------------------------------------------------
      write (mfgw,160)
  160 format (//,' ',30('*'),' dipole ',30('*'),//)
      dipe4t = dsqrt(dipe4(1)*dipe4(1) + dipe4(2)*dipe4(2)
     1              + dipe4(3)*dipe4(3))
      dipe4d = dipe4t*autodb
      dipdpt = dsqrt(dipdp(1)*dipdp(1) + dipdp(2)*dipdp(2)
     1              + dipdp(3)*dipdp(3))
      dipdpd = dipdpt*autodb
      write (mfgw,170)
  170 format (21x,'e4',13x,'dip',/)
      write (mfgw,180) 'x',dipe4(1),dipdp(1)
      write (mfgw,180) 'y',dipe4(2),dipdp(2)
      write (mfgw,180) 'z',dipe4(3),dipdp(3)
  180 format (5x,a1,7x,2f15.6)
      write (mfgw,190) dipe4t,dipdpt,
     1               dipe4d,dipdpd
  190 format (//' magnitude:  ',2f15.6,'  (a.u.)',/,
     1          ' ',12x,2f15.6,'  (debye)')
c
c find eigenvalues and eigenvectors of polarization matrix.
c
      write (mfgw,200)
  200 format (//,' ',22('*'),' polarizability (alpha)',21('*'),//)
      avgpe4 = (apole4(1)+apole4(3)+apole4(6))/3.0d00
      avga3 = avgpe4*0.14818d00
      avgesu = avgpe4*0.296352d-24
      avgpdp = (apoldp(1)+apoldp(3)+apoldp(6))/3.0d00
      avga3d = avgpdp*0.14818d00
      avgesd = avgpdp*0.296352d-24
      write (mfgw,210)
  210 format ('  component',12x,'e4',13x,'dip',/)
      write (mfgw,220) 'xx',apole4(1),apoldp(1),
     1              'yy',apole4(3),apoldp(3),
     2              'zz',apole4(6),apoldp(6),
     3              'xy',apole4(2),apoldp(2),
     4              'xz',apole4(4),apoldp(4),
     5              'yz',apole4(5),apoldp(5)
  220 format (' ',5x,a4,5x,2f15.6)
      write (mfgw,230) avgpe4,avgpdp,avga3,avga3d,avgesu,avgesd
  230 format (//,' average polarizability:',8x,'e4',13x,'dip',/,
     1           ' ',24x,2f15.6,'  a.u.',/,
     2           ' ',24x,2f15.6,'  ang.**3',/,
     3           ' ',24x,2(1pd15.6),'  esu')
c
c  calculate "experimental" hyperpolarizabilities
c
c   8.65710d-33 is a.u. to e.s.u. conversion
      write (mfgw,240)
  240 format (//,' ',30('*'),' second-order (beta)',25('*'),//)
      bx4 = 0.6d00*(betae4(1) + betae4(4) + betae4(6))
      by4 = 0.6d00*(betae4(2) + betae4(5) + betae4(8))
      bz4 = 0.6d00*(betae4(3) + betae4(7) + betae4(9))
      b4mu = (bx4*dipe4(1) + by4*dipe4(2) + bz4*dipe4(3))/dipe4t
      b4esu = b4mu*8.65710d-03
      bxd = 0.6d00*(betadp(1) + betadp(4) + betadp(6))
      byd = 0.6d00*(betadp(2) + betadp(5) + betadp(8))
      bzd = 0.6d00*(betadp(3) + betadp(7) + betadp(9))
      bdmu = (bxd*dipdp(1) + byd*dipdp(2) + bzd*dipdp(3))/dipdpt
      bdesu = bdmu*8.65710d-03
c
      write(mfgw,'(29x,a2,25x,a6)')'1x','(1/2)x'
      write (mfgw,250)
  250 format ('  component',2(12x,'e4',10x,'dip',2x),/)
      write (mfgw,260) 
     +  'xxx',betae4(1),betadp(1),betae4(1)/2,betadp(1)/2
      write (mfgw,260) 
     +   'xyy',betae4(4),betadp(4),betae4(4)/2,betadp(4)/2
      write (mfgw,260) 
     +   'xzz',betae4(6),betadp(6),betae4(6)/2,betadp(6)/2
      write (mfgw,260) 
     +    'yyy',betae4(2),betadp(2),betae4(2)/2,betadp(2)/2
      write (mfgw,260) 
     +     'yxx',betae4(5),betadp(5),betae4(5)/2,betadp(5)/2
      write (mfgw,260) 
     +      'yzz',betae4(8),betadp(8),betae4(8)/2,betadp(8)/2
      write (mfgw,260) 
     +       'zzz',betae4(3),betadp(3),betae4(3)/2,betadp(3)/2
      write (mfgw,260) 
     +       'zxx',betae4(7),betadp(7),betae4(7)/2,betadp(7)/2
      write (mfgw,260) 
     +       'zyy',betae4(9),betadp(9),betae4(9)/2,betadp(9)/2
  260 format (' ',5x,a4,2(5x,2f12.3))
      write (mfgw,270)
  270 format (//,' vector components given by:',/,
     1          '      bi = (2/5)*(bi11+bi22+bi33)'/)
      write (mfgw,280) 'bx',bx4,bxd,bx4/2,bxd/2
      write (mfgw,280) 'by',by4,byd,by4/2,byd/2
      write (mfgw,280) 'bz',bz4,bzd,bz4/2,bzd/2
  280 format (' ',6x,a2,2(6x,2f12.3))
      write (mfgw,290)
  290 format (//'  value of beta along the dipole moment:'/)
      write (mfgw,300) 
     +    b4mu,bdmu,b4mu/2,bdmu/2,b4esu,bdesu,b4esu/2,bdesu/2
  300 format (' ',4x,'b(au)',2(5x,2f12.3,2x),/,
     1        ' ',4x,'b(esu)',4x,2f12.3,7x,2f12.3,' (x10-30)')
c
      write (mfgw,310)
  310 format (//' ',24('*'),' third-order (gamma)',24('*'),//)
      gamval = (gamme4(1) + gamme4(2) + gamme4(3))
      gamval = gamval + 2.0d00*(gamme4(4) + gamme4(5) + gamme4(6))
      gamval = gamval/5.0d00
c  5.05116d-40 is the a.u. to e.s.u. conversion
      gamesu = gamval*5.05116d-04
      gamdip = (gammdp(1) + gammdp(2) + gammdp(3))
      gamdip = gamdip + 2.0d00*(gammdp(4) + gammdp(5) + gammdp(6))
      gamdip = gamdip/5.0d00
      gamdes = gamdip*5.05116d-04
      write(mfgw,'(23x,a2,25x,a6)')'1x','(1/6)x'
      write (mfgw,320)
  320 format (' ',17x,'e4',8x,'dip',16x,'e4',8x,'dip',/)
      write (mfgw,330) 
     +   'xxxx',gamme4(1),gammdp(1),gamme4(1)/6,gammdp(1)/6
      write (mfgw,330) 
     +   'yyyy',gamme4(2),gammdp(2),gamme4(2)/6,gammdp(2)/6
      write (mfgw,330) 
     +    'zzzz',gamme4(3),gammdp(3),gamme4(3)/6,gammdp(3)/6
      write (mfgw,330) 
     +     'xxyy',gamme4(4),gammdp(4),gamme4(4)/6,gammdp(4)/6
      write (mfgw,330) 
     +     'xxzz',gamme4(5),gammdp(5),gamme4(5)/6,gammdp(5)/6
      write (mfgw,330) 
     +     'yyzz',gamme4(6),gammdp(6),gamme4(6)/6,gammdp(6)/6
  330 format (5x,a4,2f12.3,5x,2f12.3)
      write (mfgw,340)
  340 format (//' average gamma given by:',/,
     1 '    (1/5)*[gxxx + gyyy + gzzz + 2.0*(gxxyy + gxxzz + gyyzz)]')
      write(mfgw,'(/,20x,a2,22x,a6)')'1x','(1/6)x'
      write (mfgw,350) gamval,gamdip,gamval/6,gamdip/6,
     1              gamesu,gamdes,gamesu/6,gamdes/6
  350 format (/' <gamma> ',1pd12.5,1pd12.5,5x,1pd12.5,1pd12.5,'  a.u.'/,
     1       ' ',8x,1pd12.5,1pd12.5,5x,1pd12.5,1pd12.5,'  esu (x10-36)')
c
      return
      end
      subroutine flepo (xparam,nvar,funct1)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      dimension xparam(*)
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),
     1                nlast(numatm), norbs, nelecs,nalpha,nbeta,
     2                nclose,nopen,ndumy,fract
      common /keywrd/ keywrd
      common /numscf/ nscf
      common /last/ last
      common /gravec/ cosine
      common /path/ latom,lparam,react(200)
      common /gradnt/ grad(maxpar),gnorm
      common /mesage/ iflepo,iscf
      common /timem/ time0
      common /fmatrx/ hesinv(maxpar**2+maxpar*3+1), idumy(4)
      common /scftyp/ emin, limscf
      common /timdmp/ tleft, tdump
      common /numcal/ numcal
      common/iofile/mfgr,mfgw
      character*241 keywrd
c
c
c     *
c     this routine attempts to minimize a real-valued function of
c     the n-component real vector xparam according to the
c     bfgs formula. relevant references are
c
c     broyden, c.g., journal of the institute for mathematics and
c                     applications, vol. 6 pp 222-231, 1970.
c     fletcher, r., computer journal, vol. 13, pp 317-322, 1970.
c
c     goldfarb, d. mathematics of computation, vol. 24, pp 23-26, 1970.
c
c     shanno, d.f. mathematics of computation, vol. 24, pp 647-656
c                    1970.
c
c   see also summary in
c
c    head, j.d.; and zerner, m.c., chemical physics letters, vol. 122,
c          264 (1985).
c    shanno, d.f., j. of optimization theory and applications
c          vol.46, no 1 pp 87-94 1985.
c     *
c     the function can also be minimized using the
c     davidon-fletcher-powell algorithm (computer journal, vol. 6,
c     p. 163).
c
c     the user must supply the subroutine
c     compfg(xparam,.true.,funct,.true.,grad,lgrad)
c     which computes function values  funct at given values for the
c     variables xparam, and the gradient grad if lgrad=.true.
c     the minimization proceeds by a sequence of one-dimensional
c     minimizations.  these are carried out without gradient computation
c     by the subroutine linmin, which solves the subproblem of
c     minimizing the function funct along the line xparam+alpha*pvect,
c     where xparam
c     is the vector of current variable values,  alpha is a scalar
c     variable, and  pvect  is a search-direction vector provided by the
c     bfgs or davidon-fletcher-powell algorithm.  each iteration step ca
c     out by flepo proceeds by letting linmin find a value for alpha
c     which minimizes  funct  along  xparam+alpha*pvect, by
c     updating the vector  xparam  by the amount alpha*pvect, and
c     finally by generating a new vector  pvect.  under
c     certain restrictions (powell, j.inst.maths.applics.(1971),
c     v.7,21-36)  a sequence of funct values converging to some
c     local minimum value and a sequence of
c     xparam vectors converging to the corresponding minimum point
c     are produced.
c                          convergence tests.
c
c     herberts test: the estimated distance from the current point
c                    point to the minimum is less than tolera.
c
c                    "herberts test satisfied - geometry optimized"
c
c     gradient test: the gradient norm has become less than tolerg
c                    times the square root of the number of variables.
c
c                    "test on gradient satisfied".
c
c     xparam test:  the relative change in xparam, measured by its norm,
c                   over any two successive iteration steps drops below
c                   tolerx.
c
c                    "test on xparam satisfied".
c
c     function test: the calculated value of the heat of formation
c                    between any two cycles is within tolerf of
c                    each other.
c
c                    "heat of formation test satisfied"
c
c     for the gradient, function, and xparam tests a further condition,
c     that no individual component of the gradient is greater
c     than tolerg, must be satisfied, in which case the
c     calculation exits with the message
c
c                     "peters test satisfied"
c
c     will be printed, and funct and xparam will contain the last
c     function value cum variable values reached.
c
c
c     the broyden-fletcher-goldfarb-shanno and davidon-fletcher-powell
c     algorithms choose search directions
c     on the basis of local properties of the function.  a matrix  h,
c     which in flepo is preset with the identity, is maintained and
c     updated at each iteration step.  the matrix describes a local
c     metric on the surface of function values above the point xparam.
c     the search-direction vector  pvect  is simply a transformation
c     of the gradient  grad  by the matrix h.
c
      dimension xvar(maxpar), gvar(maxpar), xd(maxpar), gd(maxpar),
     1glast(maxpar), xlast(maxpar), gg(maxpar), pvect(maxpar)
      dimension mdfp(9),xdfp(9), xtemp(maxpar), gtemp(maxpar)
      save
*******
*     save  icalcn
*     save  rst, tdel, sfact, dell, einc, igg1, del
*     save  restrt, geook, dfp, const
*     save  saddle, minprt, rootv, print, delhof, tolerf, tolerg
*     save  tolerx, drop, frepf, ihdim, cncadd, absmin, itry1, itry2
*     save  okf, jcyc, lnstop, irepet, alpha, pnorm, jnrst, cycmx
*     save  cos, ncount, resfil, mdfp, tx1, tx2, tlast
*     save  time, totime
*******
*     save iprt, thiel, log, ldiis, nrst, tolrg, lgrad
*     save xvar, gvar, xd, gd, glast, xlast, gg, pvect
*     save xtemp, gtemp
*******
      logical okf, print,  time, restrt, minprt, saddle, geook, log
     1        ,reset, resfil, lgrad, dfp, ldiis, thiel, diisok, frst,
     2         limscf
      equivalence (mdfp(1),jcyc  ),(mdfp(2),jnrst),(mdfp(3),ncount),
     1            (mdfp(4),lnstop),(xdfp(1),alpha),(xdfp(2),cos   ),
     2            (xdfp(3),pnorm ),(xdfp(4),drop ),(xdfp(5),del   ),
     3            (xdfp(6),frepf ),(xdfp(7),cycmx),(xdfp(8),totime)
      data icalcn /0/
c
c   start of once-only section
c
      emin=0.d0
      if (icalcn.ne.numcal) then
c
c   the following constants should be set by the user.
c
         rst   = 0.05d0
         iprt  = mfgw
         tdel  = 0.06d0
         nrst  = 30
         sfact = 1.5d0
         dell  = 0.01d0
         einc  = 0.3d0
         igg1  = 3
         del=dell
c
c    these constants should be set by the program.
c
         restrt = index(keywrd,'restar').ne.0
         thiel  = index(keywrd,'nothie').eq.0
         geook  = index(keywrd,'geo-ok').ne.0
         log    = index(keywrd,'nolog').eq.0
         ldiis  = index(keywrd,'nodiis').eq.0
         saddle = index(keywrd,'saddle').ne.0
         minprt = .not.saddle
         time   = index(keywrd,'time').ne.0
         const=1.d0
c
c      the davidon-fletcher-powell method is not recommended
c      but can be invoked by using the keyword 'dfp'
c
         dfp=index(keywrd,'dfp').ne.0
c
c  order of precision:   'gnorm' takes precedence over 'force', which
c                        takes precedence over 'precise'.
         tolerg=1.0d0
         if(index(keywrd,'prec') .ne. 0) tolerg=0.2d0
         if (index(keywrd,'force') .ne. 0) tolerg = 0.1d0
c
c      read in the gradient-norm limit, if specified
c
         if(index(keywrd,'gnorm=').ne.0) then
            rootv=1.d0
            const=1.d-20
            tolerg=reada(keywrd,index(keywrd,'gnorm='))
            if(index(keywrd,' let').eq.0.and.tolerg.lt.1.d-2)then
            write(mfgw,'(/,a)')'  gnorm has been set too low, reset to 0
     1.01'
               tolerg=1.d-2
            endif
         else
            rootv=dsqrt(nvar+1.d-5)
         endif
         tolerx = 0.0001d0*const
         delhof = 0.0010d0*const
         tolerf = 0.002d0*const
         tolrg  = tolerg
c
c  minor book-keeping
c
         tlast=tleft
         tx2=secmop()
         tleft=tleft-tx2+time0
         print  = (index(keywrd,'flepo').ne.0)
c
c   the following constants should be set to some arbitary large value.
c
         drop  = 1.d15
         frepf = 1.d15
c
c     and finally, the following constants are calculated.
c
         ihdim=(nvar*(nvar+1))/2
         cncadd=1.0d00/rootv
         if (cncadd.gt.0.15d00) cncadd=0.15d00
         icalcn=numcal
         if (restrt) then
            jnrst=1
            mdfp(9)=0
            call dfpsav(totime,xparam,gd,xlast,funct1,mdfp,xdfp)
            i=totime/1000000.d0
            totime=totime-i*1000000.d0
            time0=time0-totime
            nscf=mdfp(5)
            write(iprt,'(//10x,''total time used so far:'',
     1    f13.2,'' seconds'')')totime
            if(index(keywrd,'1scf') .ne. 0) then
               last=1
               lgrad= index(keywrd,'grad').ne.0
               call compfg (xparam,.true.,funct1,.true.,grad,lgrad)
               iflepo=13
               emin=0.d0
               return
            endif
         endif
c
c   end of once-only setup
c
      endif
c
c     first, we initialize the variables.
c
      diisok=.false.
      ireset=0
      absmin=1.d6
      frst=.true.
      itry1=0
      itry2=0
      jcyc=0
      lnstop=1
      irepet=1
      limscf=.true.
      alpha = 1.0d00
      pnorm=1.0d00
      jnrst=0
      cycmx=0.d0
      cos=0.0d00
      totime=0.d0
      ncount=1
      if( saddle) then
*
*   we don't need high precision during a saddle-point calculation.
*
         if(nvar.gt.0)gnorm=
     +      dsqrt(ddot(nvar,grad,1,grad,1))-3.d0
         if(gnorm.gt.10.d0)gnorm =10.d0
         if(gnorm.gt.1.d0) tolerg=tolrg*gnorm
         write(iprt,'('' gradient criterion in flepo ='',f12.5)')tole
     1rg
      endif
      if(nvar.eq.1) then
         pvect(1)=0.01d0
         alpha=1.d0
         goto 300
      endif
      totime=0.d0
c
c calculate the value of the function -> funct1, and gradients -> grad.
c normal set-up of funct1 and grad, done once only.
c
      call compfg (xparam,.true.,funct1,.true.,grad,.true.)
      call dcopy(nvar,grad,1,gd,1)
      if (nvar.ne.0) then
         gnorm=dsqrt(ddot(nvar,grad,1,grad,1))
         gnormr=gnorm
         if (lnstop.ne.1.and.cos.gt.rst.and.(jnrst.lt.nrst.or..not.dfp)
     1     .and.restrt)then
            call dcopy(nvar,gd,1,glast,1)
         else
            call dcopy(nvar,grad,1,glast,1)
         endif
         glnorm=gnorm
      endif
      if(gnorm.lt.tolerg.or.nvar.eq.0) then
         iflepo=2
         if(restrt) then
            call compfg (xparam,.true.,funct1,.true.,grad,.true.)
         else
            call compfg (xparam,.true.,funct1,.true.,grad,.false.)
         endif
         emin=0.d0
         return
      endif
      tx1 =  secmop()
      tleft=tleft-tx1+tx2
c     *
c     start of each iteration cycle ...
c     *
c
      reset=.false.
      gnorm=dsqrt(ddot(nvar,grad,1,grad,1))
      if(gnormr.lt.1.d-10)gnormr=gnorm
      goto 30
   10 continue
      if(cos .lt. rst) then
         do 20 i=1,nvar
   20    gd(i)=0.5d0
      endif
   30 continue
      jcyc=jcyc+1
      jnrst=jnrst+1
      i80=0
   40 continue
      if (i80.eq.1.or.
     1lnstop.eq.1.or.cos.le.rst.or.(jnrst.ge.nrst.and.dfp))then
c
c...this contains patches to fix the recently discussed problem
c...that can occur with flepo optimisation in ampac/mopac
c...between the "cnew........" lines
c
c     *
c     restart section
c     *
c
cnew..............................
  89  continue   
cnew..............................
         reset=.true.
         do 50 i=1,nvar
c
c  make the first step a weak function of the gradient
c
            step=dabs(grad(i))*0.0002d0
            step=dmax1(0.01d0,dmin1(0.04d0,step))
c#         xd(i)=xparam(i)-sign(step,grad(i))
            xd(i)=xparam(i)-dsign(del,grad(i))
   50    continue
c#      write(6,'(10f8.3)')(xd(i)-xparam(i),i=1,nvar)
c
c this call of compfg is used to calculate the second-order matrix in h
c if the new point happens to improve the result, then it is kept.
c otherwise it is scrapped, but still the second-order matrix is o.k.
c
c#      write(6,*)' reset hessian'
         call compfg (xd,.true.,funct2,.true.,gd,.true.)
         if(.not. geook .and. dsqrt(ddot(nvar,gd,1,gd,1))/
     +   gnorm.gt.10.0d0.and.gnorm.gt.20.0d0.and.jcyc.gt.2)then
c
c  the geometry is badly specified in that minor changes in internal
c  coordinates lead to large changes in cartesian coordinates, and these
c  large changes are between pairs of atoms that are chemically bonded
c  together.
            write(iprt,'('' gradients of old geometry, gnorm='',f13.6)')
     1              gnorm
            write(iprt,'(6f12.6)')(grad(i),i=1,nvar)
            gdnorm=dsqrt(ddot(nvar,gd,1,gd,1))
            write(iprt,'('' gradients of new geometry, gnorm='',f13.6)')
     1              gdnorm
            write(iprt,'(6f12.6)')(gd(i),i=1,nvar)
cnew..............................
            del=del/10.0d0
c...you may wish to play with thresh.
            thresh=0.00005d0
            if(del.ge.thresh)then
            go to 89
            else
cnew..............................
            write(iprt,'(///20x,''calculation abandoned at this point!''
     1)')
            write(iprt,'(//10x,'' small changes in internal coordinates
     1are   '',/10x,'' causing a large change in the distance between'',
     2/   10x,'' chemically-bound atoms. the geometry optimization'',/
     3   10x,'' procedure would likely produce incorrect results'')')
            call geout(1)
_IF(ipsc,tools)
            call pend
_ELSE
            stop
_ENDIF
cnew..............................
         endif
cnew..............................
         endif
         ncount=ncount+1
         do 60 i=1,ihdim
   60    hesinv(i)=0.0d00
         ii=0
         do 90 i=1,nvar
            ii=ii+i
            deltag=grad(i)-gd(i)
            deltax=xparam(i)-xd(i)
            if (dabs(deltag).lt.1.d-12) go to 70
            ggd=dabs(grad(i))
            if (funct2.lt.funct1) ggd=dabs(gd(i))
            hesinv(ii)=deltax/deltag
            if (hesinv(ii).lt.0.0d00.and.ggd.lt.1.d-12) go to 70
            if (hesinv(ii).lt.0.0d00) hesinv(ii)=tdel/ggd
            go to 80
   70       hesinv(ii)=0.01d00
   80       continue
            if (ggd.lt.1.d-12) ggd=1.d-12
            pmstep=dabs(0.1d0/ggd)
            if (hesinv(ii).gt.pmstep) hesinv(ii)=pmstep
   90    continue
         jnrst=0
         if(jcyc.lt.2)cosine=1.d0
         if(funct2 .ge. funct1) then
            if(print)write (iprt,100) funct1,funct2
  100       format (' function value=',f13.7,
     1           '  will not be replaced by value=',f13.7,/10x,
     2           'calculated by restart procedure',/)
            cosine=1.d0
         else
            if( print ) write (iprt,110) funct1,funct2
  110       format (' function value=',f13.7,
     1           ' is being replaced by value=',f13.7,/10x,
     2           ' found in restart procedure',/,6x,'the corresponding'
     3           ' x values and gradients are also being replaced',/)
            funct1=funct2
            call dcopy(nvar,xd,1,xparam,1)
            call dcopy(nvar,gd,1,grad  ,1)
            gnorm=dsqrt(ddot(nvar,grad,1,grad,1))
            if(gnormr.lt.1.d-10)gnormr=gnorm
         endif
      else
c
c     *
c     update variable-metric matrix
c     *
c
         do 120 i=1,nvar
            xvar(i)=xparam(i)-xlast(i)
  120    gvar(i)=grad(i)-glast(i)
         call supdot(gg,hesinv,gvar,nvar,1)
         yhy=ddot(nvar,gg,1,gvar,1)
         sy =ddot(nvar,xvar,1,gvar,1)
         k=0
c
c    update according to davidon-fletcher-powell
c
         if(dfp)then
            do 130 i=1,nvar
               xvari=xvar(i)/sy
               ggi=gg(i)/yhy
               do 130 j=1,i
                  k=k+1
  130       hesinv(k)=hesinv(k)+xvar(j)*xvari-gg(j)*ggi
c
c     update using the bfgs formalism
c
         else
            yhy=1.0d0 + yhy/sy
            do 140 i=1,nvar
               xvari=xvar(i)/sy
               ggi=gg(i)/sy
               do 140 j=1,i
                  k=k+1
  140       hesinv(k)=hesinv(k)-gg(j)*xvari-xvar(j)*ggi + yhy*xvar(j)*xv
     1ari
         endif
      endif
c#      do 191 i=1,ihdim
c#  191 htemp(i)=hesinv(i)
c#      call hqrii(htemp, nvar, nvar, xtemp, vects)
c#      j=0
c#      do 193 i=1,nvar
c#      if(xtemp(i).lt.0.0d0)then
c#      j=j+1
c#      xtemp(i)=0.00002d0
c#      endif
c#  193 continue
c#      if(j.ne.0)then
c#      do 194 i=1,ihdim
c#  194 htemp(i)=hesinv(i)
c#      call hrefm(nvar,vects,xtemp,hesinv)
c#      write(6,*)' original hessian'
c#      call vecprt(htemp,nvar)
c#      write(6,*)' reformed hessian'
c#      call vecprt(hesinv,nvar)
c#      endif
c#      write(6,*)' eigenvalues of hessian matrix'
c#      write(6,'(1x,5g12.6)')(6.951d-3/xtemp(i),i=1,nvar)
c
c     *
c     establish new search direction
c     *
      pnlast=pnorm
c#      call vecprt(hesinv,nvar)
      call supdot(pvect,hesinv,grad,nvar,1)
      pnorm=dsqrt(ddot(nvar,pvect,1,pvect,1))
      if(pnorm.gt.1.5d0*pnlast)then
c
c  trim pvect back
c
         do 150 i=1,nvar
  150    pvect(i)=pvect(i)*1.5d0*pnlast/pnorm
         pnorm=1.5d0*pnlast
      endif
      dott=-ddot(nvar,pvect,1,grad,1)
      do 160 i=1,nvar
  160 pvect(i)=-pvect(i)
      cos=-dott/(pnorm*gnorm)
      if (jnrst.eq.0) go to 190
      if (cos.le.cncadd.and.drop.gt.1.0d00) go to 170
      if (cos.le.rst) go to 170
      go to 190
  170 continue
c#      k=0
c#      do 222 i=1,nvar
c#      do 223 j=1,i-1
c#      k=k+1
c#  223 hesinv(k)=hesinv(k)*0.75d0
c#      k=k+1
c#  222 hesinv(k)=hesinv(k)+0.005d0
c#      goto 241
      pnorm=pnlast
      if( print )write (iprt,180) cos
  180 format (//,5x, 'since cos=',f9.3,5x,'the program will go to re',
     1'start section',/)
      i80=1
      go to 40
  190 continue
      if ( print ) write (iprt,200) jcyc,funct1
  200 format (1h , 'at the beginning of cycle',i5, '  the function va
     1lue is ',f13.6/, '  the current point is ...')
      if(print)write (iprt,210) gnorm,cos
  210 format ( '  gradient norm = ',f10.4/,'  angle cosine =',f10.4)
      if( print )then
         write (mfgw,220)
  220    format ('  the current point is ...')
         nto6=(nvar-1)/6+1
         iinc1=-5
         do 270 i=1,nto6
            write (mfgw,'(/)')
            iinc1=iinc1+6
            iinc2=min0(iinc1+5,nvar)
            write (mfgw,230) (j,j=iinc1,iinc2)
            write (mfgw,240) (xparam(j),j=iinc1,iinc2)
            write (mfgw,250) (grad(j),j=iinc1,iinc2)
            write (mfgw,260) (pvect(j),j=iinc1,iinc2)
  230       format (1h ,3x,  1hi,9x,i3,9(8x,i3))
  240       format (1h ,1x, 'xparam(i)',1x,f9.4,2x,9(f9.4,2x))
  250       format (1h ,1x, 'grad  (i)',f10.4,1x,9(f10.4,1x))
  260       format (1h ,1x, 'pvect (i)',2x,f10.6,1x,9(f10.6,1x))
  270    continue
      endif
      lnstop=0
      alpha=alpha*pnlast/pnorm
      call dcopy(nvar,grad,  1,glast,1)
      call dcopy(nvar,xparam,1,xlast,1)
      glnorm=gnorm
      if (jnrst.eq.0) alpha=1.0d00
      drop=dabs(alpha*dott)
      if(print)write (iprt,280) drop
  280 format (1h , 13h -alpha.p.g =,f18.6,/)
      if (jnrst.ne.0.and.drop.lt.delhof)then
c
c   herbert's test: the predicted drop in energy is less than delhof
c   if passed, call compfg to get a good set of eigenvectors, then exit
c
         if(minprt)write (iprt,290)
  290    format(//,10x,'herberts test satisfied - geometry optimized')
c
c   flepo is ending properly. this is immediately before the return.
c
         last=1
         call compfg (xparam,.true.,funct,.true.,grad,.false.)
         iflepo=3
         time0=time0-totime
         emin=0.d0
         return
      endif
      beta =alpha
      smval=funct1
      dropn=-dabs(drop/alpha)
c
c    update geometry using the g-diis procedure
c
      if(diisok) then
         okf=.true.
         ic=1
      else
         okf=.false.
         ic=2
      endif
  300 call linmin(xparam,alpha,pvect,nvar,funct1,okf,ic,dropn)
      if(nvar.eq.1)then
         write(mfgw,
     +    '('' only one variable, therefore energy a minimum'')')
         last=1
         lgrad=(index(keywrd,'grad').ne.0)
         call compfg (xparam,.true.,funct,.true.,grad,lgrad)
         iflepo=14
         emin=0.d0
         return
      endif
c   we want accurate derivatives at this point
c
c   linmin does not generate any derivatives, therefore compfg must be
c   called to end the line search
c
c  if the derivatives are to be calculated using full scf's, then check
c  whether to do full scf's (criterion from flepo: grad is null).
c
      if(ireset.gt.10.or.gnorm.lt.40.d0.and.gnorm/gnormr.lt.0.33d0)then
         ireset=0
         gnormr=0.d0
         do 310 i=1,nvar
  310    grad(i)=0.d0
      endif
      ireset=ireset+1
c
c
c     restore to standard value before computing the gradient
      reset=.false.
      if(thiel)then
         call compfg (xparam, ic.ne.1,  scrap, .true. ,grad,.true.)
      else
         call compfg (xparam, .true.,  funct1, .true. ,grad,.true.)
      endif
      if(ldiis) then
c
c  update geometry and gradient after making a step using linmin
c
         do 320 i=1,nvar
            xtemp(i)=xparam(i)
  320    gtemp(i)=grad(i)
         call diism(xtemp, xparam, gtemp, grad, hdiis, funct1,hesinv,
     1   nvar, frst)
         if(hdiis.lt.funct1.and.
     +   dsqrt(ddot(nvar,gtemp,1,gtemp,1)) .lt. 
     +   dsqrt(ddot(nvar,grad,1,grad,1)))then
            do 330 i=1,nvar
               xparam(i)=xtemp(i)
  330       grad(i)=gtemp(i)
            diisok=.true.
         else
            diisok=.false.
         endif
      endif
      gnorm=dsqrt(ddot(nvar,grad,1,grad,1))
      if(gnormr.lt.1.d-10)gnormr=gnorm
      ncount=ncount+1
      if ( .not. okf) then
         lnstop = 1
         if(minprt)write (iprt,'(/,20x, ''no point lower in energy '',
     1    ''than the starting point '',/,20x,''could be found '',
     2    ''in the line minimization'')')
         funct1=smval
         alpha=beta
         call dcopy(nvar,glast,1,grad  ,1)
         call dcopy(nvar,xlast,1,xparam,1)
         if (jnrst.eq.0)then
            write (iprt,340)
  340       format (1h ,//,20x, 'since cos was just reset,the search',
     1        ' is being ended')
c
c           flepo is ending badly. this is immediately before the return
c
            last=1
            call compfg (xparam, .true., funct, .true. ,grad,.true.)
            iflepo=4
            time0=time0-totime
            emin=0.d0
            return
         endif
         if(print)write (iprt,350)
  350    format (1h ,20x, 'cos will be reset and another '
     1    ,'attempt made')
         cos=0.0d00
         go to 470
      endif
      xn=dsqrt(ddot(nvar,xparam,1,xparam,1))
      tx=dabs(alpha*pnorm)
      if (xn.ne.0.0d00) tx=tx/xn
      tf=dabs(smval-funct1)
      if(absmin-smval.lt.1.d-7)then
         itry1=itry1+1
         if(itry1.gt.10)then
            write(mfgw,
     + '(//,'' heat of formation is essentially stationary'')')
            goto 460
         endif
      else
         itry1=0
         absmin=smval
      endif
      iout=0
      if (print) write (mfgw,360) 
     +  ncount,cos,tx*xn,alpha,-drop,-tf,gnorm
  360 format (/,'           number of counts =',i6,
     1'         cos    =',f11.4,/,
     2        '  absolute  change in x     =',f13.6,
     3'  alpha  =',f11.4,/,
     4        '  predicted change in f     =  ',g11.4,
     5'  actual =  ',g11.4,/,
     6        '  gradient norm             =  ',g11.4,//)
      if (tx.le.tolerx) then
         if(minprt) write (iprt,370)
  370    format (' test on x satisfied')
         goto 400
      endif
      if (tf.le.tolerf) then
c#         write(6,*)tf,tolerf
         if(minprt) write (iprt,380)
  380    format (' heat of formation test satisfied')
         goto 400
      endif
      if (gnorm.le.tolerg*rootv) then
         if(minprt) write (iprt,390)
  390    format (' test on gradient satisfied')
         goto 400
      endif
      go to 470
  400 do 440 i=1,nvar
         if (dabs(grad(i)).gt.tolerg)then
            irepet=irepet+1
            if (irepet.gt.1) go to 410
            frepf=funct1
            cos=0.0d00
  410       if(minprt) write (iprt,420)tolerg
  420       format (20x,'however, a component of gradient is ',
     1     'larger than',f6.2 ,/)
            if (dabs(funct1-frepf).gt.einc) irepet=0
            if (irepet.gt.igg1) then
               write (iprt,430)igg1,einc
  430          format (10x,' there have been',i2,' attempts to reduce th
     1e ',' gradient.',/10x,' during these attempts the energy dropped',
     2' by less than',f4.1,' kcal/mole',/
     310x,' further calculation is not justified at this time.',/
     410x,' to continue, start again with the word "precise"' )
               last=1
               call compfg (xparam,.true.,funct,.true.,grad,.false.)
               iflepo=8
               time0=time0-totime
               emin=0.d0
               return
            else
               goto 470
            endif
         endif
  440 continue
      if(minprt) write (iprt,450)
  450 format ( 23h peters test satisfied )
  460 last=1
      call compfg (xparam,.true.,funct,.true.,grad,.false.)
      iflepo=6
      time0=time0-totime
      emin=0.d0
      return
c
c   all tests have failed, we need to do another cycle.
c
  470 continue
      bsmvf=dabs(smval-funct1)
      if (bsmvf.gt.10.d00) cos = 0.0d00
      del=0.002d00
      if (bsmvf.gt.1.0d00) del=dell/2.0d00
      if (bsmvf.gt.5.0d00) del=dell
      tx2 = secmop()
      tcycle=tx2-tx1
      tx1=tx2
c
c end of iteration loop, everything is still o.k. so go to
c next iteration, if there is enough time left.
c
      if(tcycle.lt.100000.d0)cycmx=dmax1(cycmx,tcycle)
      tleft=tleft-tcycle
      if(tleft.lt.0)tleft=-0.1d0
      if(tcycle.gt.1.d5)tcycle=0.d0
      if(tlast-tleft.gt.tdump)then
         totim=totime   +   secmop()-time0
         tlast=tleft
         mdfp(9)=2
         resfil=.true.
         mdfp(5)=nscf
         call dfpsav(totim,xparam,gd,xlast,funct1,mdfp,xdfp)
      endif
      if(resfil)then
         if(minprt) write(mfgw,480)dmin1(tleft,9999999.9d0),
     1dmin1(gnorm,999999.999d0),funct1
  480    format(' restart file written,   time left:',f9.1,
     1' grad.:',f10.3,' heat:',g13.7)
         resfil=.false.
      else
         if(minprt) write(mfgw,490)jcyc,dmin1(tcycle,9999.99d0),
     1dmin1(tleft,9999999.9d0),dmin1(gnorm,999999.999d0),funct1
         if(log) write(11,490)jcyc,dmin1(tcycle,9999.99d0),
     1dmin1(tleft,9999999.9d0),dmin1(gnorm,999999.999d0),funct1
  490    format(' cycle:',i4,' time:',f7.2,' time left:',f9.1,
     1' grad.:',f10.3,' heat:',g13.7)
      endif
      if (tleft.gt.sfact*cycmx) go to 10
      write(iprt,500)
  500 format (20x, 42hthere is not enough time for another cycle,/,30x,
     118hnow going to final)
      totim=totime   +   secmop()-time0
      mdfp(9)=1
      mdfp(5)=nscf
      call dfpsav(totim,xparam,gd,xlast,funct1,mdfp,xdfp)
      iflepo=-1
      return
c
c
      end
      function fm06as(n,a,ia,b,ib)
      implicit COMPLEX      (a-h,o-z)
      COMPLEX      a(*), b(*)
*******************************************************
*
*    fm06as - a function routine to compute the value of the
*      inner product, or dot product, of two single precision
*      complex*16      vectors, accumulating the intermediate products
*      double precision.  the elements of each vector can be
*      stored in any fixed displacement from neighbouring
*      elements.
*
*    computes: sum(j=1,n) a((j-1)*ia+1)*b((j-1)*ib+1)
*
*          w = fm06as(n,a,ia,b,ib)
*
*    n   integer scalar; (user:*); length of the vectors a and b.
*        if n <= 0 the inner product value is defined to be zero.
*    a   complex*8 array((n-1)*iabs(ia)+1); (user:*); the array
*        containing the 1st vector.  the fortran convention of storing
*        real and imaginary parts in adjacent words is assumed.
*    ia  integer scalar; (user:*); the subscript displacement of
*        an element in the array a to its neighbour, i.e. the vector
*        elements are in a(1), a(ia+1), a(2*ia+1),...
*        if ia < 0 the elements are assumed to be stored in
*        a(1-(n-1)*ia), a(1-(n-2)*ia),..., a(1-ia), a(1).
*    b   complex*8 array((n-1)*iabs(ia)+1); (user:*); the array
*        containing the second vector.  treat like a.
*    ib  integer scalar; (user:*); the subscript displacement of
*        an element in b to its neighbour. treat like ia.
*    fm06as  complex*16   function; (*:fm06as); the inner product value.
*        it is returned double precision, the real*8  part in flt pnt
*        reg 0 and the imaginary part in flt pnt reg 2.
*
*    this routine is written in fortran.
*
*--------------------------------------------------------*
      sum=(0.0d0,0.0d0)
      do 10 i=1,n
   10 sum=sum+a((i-1)*ia+1)*b((i-1)*ib+1)
      fm06as=sum
      return
      end
      function fm06bs(n,a,ia,b,ib)
      implicit COMPLEX      (a-h,o-z)
      COMPLEX      a(*), b(*)
*******************************************************
*
*    fm06bs - a function routine to compute the value of the
*      inner product, or dot product, of a single  precision
*      complex*16      vectors, accumulating the intermediate products
*      double precision.  the elements of each vector can be
*      stored in any fixed displacement from neighbouring
*      elements.
*
*    computes: sum(j=1,n) a((j-1)*ia+1)*b((j-1)*ib+1)
*
*          w = fm06bs(n,a,ia,b,ib)
*
*    n   integer scalar; (user:*); length of the vectors a and b.
*        if n <= 0 the inner product value is defined to be zero.
*    a   complex*8 array((n-1)*iabs(ia)+1); (user:*); the array
*        containing the 1st vector.  the fortran convention of storing
*        real and imaginary parts in adjacent words is assumed.
*    ia  integer scalar; (user:*); the subscript displacement of
*        an element in the array a to its neighbour, i.e. the vector
*        elements are in a(1), a(ia+1), a(2*ia+1),...
*        if ia < 0 the elements are assumed to be stored in
*        a(1-(n-1)*ia), a(1-(n-2)*ia),..., a(1-ia), a(1).
*    b   complex*8 array((n-1)*iabs(ia)+1); (user:*); the array
*        containing the second vector.  treat like a.
*    ib  integer scalar; (user:*); the subscript displacement of
*        an element in b to its neighbour. treat like ia.
*    fm06bs  complex  function; (*:fm06bs); the inner product value.
*        it is returned double precision, the real*8  part in flt pnt
*        reg 0 and the imaginary part in flt pnt reg 2.
*
*    this routine is written in fortran.
*
*--------------------------------------------------------*
      sum=(0.0d0,0.0d0)
      do 10 i=1,n
   10 sum=sum+a((i-1)*ia+1)*conjg(b((i-1)*ib+1))
      fm06bs=sum
      return
      end
      subroutine fmat(fmatrx, nreal, tscf, tder, deldip, heat)
      implicit REAL (a-h,o-z)
_IF(ipsc,tools)
      logical oipsci
_ENDIF
INCLUDE(common/sizes)
      dimension fmatrx(*), deldip(3,*)
***********************************************************************
*
*  value calculates the second-order of the energy with
*        respect to the cartesian coordinates i and j and places it
*        in fmatrx
*
*  on input natoms  = number of atoms in the system.
*           xparam  = internal coordinates of molecule stored linearly
*
*  variables used
*           coordl  = array of cartesian coordinates, stored linearly.
*           i       = index of cartesian coordinate.
*           j       = index of cartesian coordinate.
*
*  on output fmatrx = second derivative of the energy with respect to
*                    cartesian coordinates i and j.
***********************************************************************
      common /keywrd/ keywrd
      common /geokst/ natoms,labels(numatm),
     1                na(numatm),nb(numatm),nc(numatm)
      common /geovar/ nvar,loc(2,maxpar),idumy, dumy(maxpar)
      common /densty/ p(mpack),pdumy(2,mpack)
      common /timdmp/ tleft, tdump
      common /atmass/ atmass(numatm)
      common /timem/ time0
      common/iofile/mfgr,mfgw
_IF(ipsc,tools)
      common/nodinf/mpid,minode,mihost,dim,nnodes
_ENDIF
      common /corec/ core(107)
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),
     1                nlast(numatm), norbs, nelecs,nalpha,nbeta,
     2                nclose,nopen,ndumy,fract
      common /coord/ coord(3,numatm)
      common /nllcom/ evecs(maxpar*maxpar),bmat(maxpar,maxpar*2)
      dimension cold(maxpar), grad(maxpar),
     1grold(maxpar), coordl(maxpar), q(numatm), del2(3), g2old(maxpar)
     2, eigs(maxpar), g2rad(maxpar),
     3 fconst(maxpar)
_IF(ipsc,tools)
      common /junk/ gdumy(maxpar*(maxpar+1)/2)
_ENDIF
      character*241 keywrd
      save  space, dott, zero, nine, fact
      logical debug, restrt, prnt, resfil, analyt, precis, big, log
      character space*1, dott*1, zero*1, nine*1
      equivalence (coord(1,1),coordl(1))
      data space,dott,zero,nine /' ','.','0','9'/
      data fact/6.95125d-3/
c
c    fact is the conversion factor from kcal/mole to ergs
c
c set up constants and flags
      na(1)=99
c
c  set up the variables in xparam andloc,these are in cartesian coordina
c
      numat=0
c$doit asis
      do 10 i=1,natoms
         if(labels(i).ne.99.and.labels(i).ne.107) then
            numat=numat+1
            labels(numat)=labels(i)
         endif
   10 continue
      natoms=numat
c
c   this is a quick, if clumsy, way to calculate numat, and to remove
c   the dummy atoms from the array labels.
c
      nvar=numat*3
      do 20 i=1,numat
         loc(1,(i-1)*3+1)=i
         loc(2,(i-1)*3+1)=1
c
         loc(1,(i-1)*3+2)=i
         loc(2,(i-1)*3+2)=2
c
         loc(1,(i-1)*3+3)=i
         loc(2,(i-1)*3+3)=3
   20 continue
      lin=(nvar*(nvar+1))/2
      do 30 i=1,lin
   30 fmatrx(i)=0.d0
      prnt   =(index(keywrd,'irc=') .eq. 0)
      log    =(index(keywrd,'nolog') .eq. 0)
      precis =(index(keywrd,'prec') .ne. 0)
      analyt =(index(keywrd,'analyt') .ne. 0)
      restrt =(index(keywrd,'restart') .ne. 0)
      if(index(keywrd,'nllsq') .ne. 0) restrt=.false.
      debug =(index(keywrd,'fmat') .ne. 0)
      big    =(index(keywrd,'large') .ne. 0 .and. debug)
      if(prnt)
     +   write(mfgw,'(//4x,''first derivatives will be used in the''
     1,'' calculation of second derivatives'')')
      tlast=tleft
      resfil=.false.
      if(restrt) then
         do 40 i=1,nvar
   40    cold(i)=coordl(i)
         istart = 0
         i=0
         call forsav(totime,deldip,istart,i,fmatrx, coord, nvar,heat,
     1                evecs,jstart,fconst)
         kountf=(istart*(istart+1))/2
         istart=istart+1
         jstart=jstart+1
         time2 = secmop()
      else
         kountf=0
         totime=0.d0
         if (tscf.gt.0.d0)tleft=tleft-tscf-tder
         istart=1
      endif
c calculate fmatrx
      if(istart.gt.1) then
         estime=(nvar-istart+1)*totime/(istart-1.d0)
      else
         estime=nvar*(tscf+tder)*2.d0
         if (precis) estime=estime*2.d0
      endif
      if(tscf.gt.0)
     1write(mfgw,
     +  '(/10x,''estimated time to complete calculation =''
     2,f9.2,'' seconds'')')estime
      if(restrt) then
         if(istart.le.nvar)
     1    write(mfgw,
     +   '(/10x,''starting again at line'',18x,i4)')istart
         write(mfgw,
     +   '(/10x,''time used up to restart ='',f22.2)')totime
      endif
      lu=kountf
      time1 = secmop()
      numat=nvar/3
      do 50 i=1,nvar
   50 eigs(i)=0.d0
_IF(ipsc,tools)
c *** MPP ***
_IF(ipsc)
      call gsync
_ELSE
      call synch(11111)
_ENDIF
      iflop = iipsci()
c *** MPP ***
_ENDIF
      do 120 i=istart,nvar
         time2 = secmop()
         delta=1.d0/120.d0
_IF(ipsc,tools)
c *** MPP ***
         if(oipsci()) go to 120
c *** MPP ***
_ENDIF
         if(precis)then
c
c   determine a good step size
c
            g2old(1)=100.d0
            coordl(i)=coordl(i)+delta
            call compfg(coordl, .true., escf, .true., g2old, .true.)
            coordl(i)=coordl(i)-delta
            delta=delta*10.d0/dsqrt(ddot(nvar,g2old,1,g2old,1))
c
c   constrain delta to a 'reasonable' value
c
            delta=dmin1(0.05d0,dmax1(0.005d0,delta))
            if(debug)write(mfgw,
     +   '(a,i3,a,f12.5)')' step:',i,' delta :',delt
     1a
            g2old(1)=100.d0
            coordl(i)=coordl(i)+delta
            call compfg(coordl, .true., escf, .true., g2old, .true.)
            if(debug)write(mfgw,
     +     '(a,f12.5)')' gnorm +1.0*delta',
     +       dsqrt(ddot(nvar,g2old,1,g2old,1))
            coordl(i)=coordl(i)-delta*2.d0
            g2rad(1)=100.d0
            call compfg(coordl, .true., heataa, .true., g2rad, .true.)
            coordl(i)=coordl(i)+delta
            if(debug)write(mfgw,'(a,f12.5)')' gnorm -1.0*delta',
     1            dsqrt(ddot(nvar,g2rad,1,g2rad,1))
         else
            if(debug)
     +       write(mfgw,'(a,i3,a,f12.5)')' step:',i,' delta :',delt
     1a
         endif
         coordl(i)=coordl(i)+0.5d0*delta
         grold(1)=100.d0
         call compfg(coordl, .true., escf, .true., grold, .true.)
         if(debug)write(mfgw,'(a,f12.5)')' gnorm +0.5*delta',
     1              dsqrt(ddot(nvar,grold,1,grold,1))
         call chrge(p,q)
         do 60 ii=1,numat
   60    q(ii)=core(labels(ii))-q(ii)
         sum = dipmop(p,q,coordl,deldip(1,i),0)
         coordl(i)=coordl(i)-delta
         grad(1)=100.d0
         call compfg(coordl, .true., heataa, .true., grad, .true.)
         if(debug)write(mfgw,'(a,f12.5)')' gnorm -0.5*delta',
     1              dsqrt(ddot(nvar,grad,1,grad,1))
         call chrge(p,q)
         do 70 ii=1,numat
   70    q(ii)=core(labels(ii))-q(ii)
         sum = dipmop(p,q,coordl,del2,0)
         coordl(i)=coordl(i)+delta*0.5d0
         deldip(1,i)=(deldip(1,i)-del2(1))*0.5d0/delta
         deldip(2,i)=(deldip(2,i)-del2(2))*0.5d0/delta
         deldip(3,i)=(deldip(3,i)-del2(3))*0.5d0/delta
c        ll=lu+1
         ll=i*(i-1)/2 +1
         lu=ll+i-1
         l=0
         if(precis)then
            do 80 kountf=ll,lu
               l=l+1
c
c       g2old = x + 1.0*delta
c       grold = x + 0.5*delta
c       grad  = x - 0.5*delta
c       g2rad = x - 1.0*delta
c
               dumy(l)= (8.d0*(grold(l)-grad(l))-(g2old(l)-g2rad(l)))
     1          /delta*fact/24.d0
               eigs(l)=(2.d0*(grold(l)-grad(l))-(g2old(l)-g2rad(l)))
     1          /delta**3*fact/56.d0
c
c  correct for 4'th order contamination
c
c#             corr=min(abs(dumy(l)),abs(eigs(l))*0.0001d0)
c#             dumy(l)=dumy(l)-sign(corr,dumy(l))
               fmatrx(kountf)=fmatrx(kountf)+dumy(l)
   80       continue
            l=l-1
            do 90 k=i,nvar
               l=l+1
               kk=(k*(k-1))/2+i
               dumy(l)=(8.d0*(grold(l)-grad(l))-(g2old(l)-g2rad(l)))
     1          /delta*fact/24.d0
               eigs(l)=(2.d0*(grold(l)-grad(l))-(g2old(l)-g2rad(l)))
     1          /delta**3*fact/56.d0
c
c  correct for 4'th order contamination
c
c#             corr=min(abs(dumy(l)),abs(eigs(l))*0.0001d0)
c#             dumy(l)=dumy(l)-sign(corr,dumy(l))
               fmatrx(kk)=fmatrx(kk)+dumy(l)
   90       continue
         else
            do 100 kountf=ll,lu
               l=l+1
               dumy(l)=((grold(l)-grad(l)))*0.25d0/delta*fact
               fmatrx(kountf)=fmatrx(kountf)+dumy(l)
  100       continue
            l=l-1
            do 110 k=i,nvar
               l=l+1
               kk=(k*(k-1))/2+i
               dumy(l)=((grold(l)-grad(l)))*0.25d0/delta*fact
               fmatrx(kk)=fmatrx(kk)+dumy(l)
  110       continue
         endif
         if(big)then
         write(mfgw,'(a)')' contributions to f-matrix'
         write(mfgw,'(a)')' element  +1.0*delta  +0.5*delta  -0.5*del'
     1//'ta  -1.0*delta   2''nd order 4th order'
         write(mfgw,'(i7,6f12.6)')(l,g2old(l),grold(l),grad(l),g2rad(l),
     1dumy(l),eigs(l),l=1,nvar)
         endif
         time3 = secmop()
         tstep=time3-time2
         tleft= dmax1(0.1d0,tleft-tstep)
         if(tstep.gt.1.d6)tstep=tstep-1.d6
         totime= totime+tstep
         if(resfil)then
         write(mfgw,'('' step:'',i4,'' restart file written, integral ='
     1',f10.2,'' time left:'',f10.2)')i,totime,tleft
         if(log)write(11,'('' step:'',i4,'' restart file written, '',
     +''integral ='',f10.2,'' time left:'',f10.2)')i,totime,tleft
            resfil=.false.
         else
         write(mfgw,'('' step:'',i4,'' time ='',f9.2,'' secs, integral =
     1'',f10.2,'' time left:'',f10.2)')i,tstep,totime,tleft
        if(log) write(11,'('' step:'',i4,'' time ='',f9.2,'' secs, '',
     +''integral ='',f10.2,'' time left:'',f10.2)')i,tstep,totime,tleft
         endif
         estim = totime/i
         if(tlast-tleft.gt.tdump)then
            tlast=tleft
            resfil=.true.
            jstart=1
            ii=i
            call forsav(totime,deldip,ii,nvar,fmatrx, coord,nvar,heat,
     1                evecs,jstart,fconst)
         endif
         if(i.ne.nvar.and.tleft-10.d0 .lt. estim) then
         write(mfgw,'(//10x,''- - - - - - - time up - - - - - - -'',//)'
     1)
            write(mfgw,'(/10x,'' point reached ='',i4)')i
            write(mfgw,'(/10x,'' restart using key-word "restart"'')')
            write(mfgw,'(10x,''estimated time for the next step ='',f8.2,
     1'' seconds'')')estim
            jstart=1
            ii=i
            call forsav(totime,deldip,ii,nvar,fmatrx, coord,nvar,heat,
     1                evecs,jstart,fconst)
            write(mfgw,'(//10x,''force matrix written to disk'')')
            nreal=-1
            return
         endif
  120 continue
_IF(ipsc,tools)
_IF(ipsc)
      call gsync
c *** MPP ***
       call gdsum(fmatrx,lin,gdumy)
c *** MPP ***
_ELSE
      call synch(22222)
c *** MPP ***
      call dgop(200,fmatrx,lin,'+',gdumy)
c *** MPP ***
_ENDIF
_ENDIF
      do 130 i=1,natoms
         if(atmass(i).lt.1.d-20.and.labels(i).lt.99)then
            call forsav(totime,deldip,nvar,nvar,fmatrx, coord,nvar,heat,
     1                evecs,iloop,fconst)
         write(mfgw,'(a)')' at least one atom has a zero mass. a restart
     1'
         write(mfgw,'(a)')' file has been written and the job stopped'
_IF(ipsc,tools)
            call pend
_ELSE
            stop
_ENDIF
         endif
  130 continue
      if(istart.le.nvar .and. index(keywrd,'isot') .ne. 0)
     1call forsav(totime,deldip,nvar,nvar,fmatrx, coord,nvar,heat,
     2                evecs,iloop,fconst)
      return
      end
      subroutine fock1(f, ptot, pa, pb)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      dimension f(*), ptot(*), pa(*), pb(*)
c *********************************************************************
c
c *** compute the remaining contributions to the one-centre elements.
c
c *********************************************************************
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),
     1                nlast(numatm), norbs, nelecs,nalpha,nbeta,
     2                nclose,nopen,ndumy,fract
      common /cmpga/ fn1(107),fn2(107)
      common /molorb/ uspd(maxorb),dumy(maxorb)
      common /twoele/ gss(107),gsp(107),gpp(107),gp2(107),hsp(107)
     1                ,gsd(107),gpd(107),gdd(107)
      dimension qtot(numatm), qa(numatm), qb(numatm)
      common /keywrd/ keywrd
      character*241 keywrd
      call chrge(ptot,qtot)
      call chrge(pa,qa)
      do 10 i=1,numat
   10 qb(i)=qtot(i)-qa(i)
      do 100 ii=1,numat
         ia=nfirst(ii)
         ib=nmidle(ii)
         ic=nlast(ii)
         ni=nat(ii)
         dtpop=0.d0
         dapop=0.d0
         ptpop=0.d0
         papop=0.d0
         goto (100,40,30,30,30,20,20,20,20,20)ic-ia+2
   20    dtpop=ptot((ic*(ic+1))/2)+ptot(((ic-1)*(ic))/2)
     1        +ptot(((ic-2)*(ic-1))/2)+ptot(((ic-3)*(ic-2))/2)
     2        +ptot(((ic-4)*(ic-3))/2)
         dapop=pa((ic*(ic+1))/2)+pa(((ic-1)*(ic))/2)
     1        +pa(((ic-2)*(ic-1))/2)+pa(((ic-3)*(ic-2))/2)
     2        +pa(((ic-4)*(ic-3))/2)
   30    ptpop=ptot((ib*(ib+1))/2)+ptot(((ib-1)*(ib))/2)
     1        +ptot(((ib-2)*(ib-1))/2)
         papop=pa((ib*(ib+1))/2)+pa(((ib-1)*(ib))/2)
     1        +pa(((ib-2)*(ib-1))/2)
   40    dbpop=dtpop-dapop
         pbpop=ptpop-papop
         if(ni.eq.1)then
            sum=0.d0
         else
            sum2=0.d0
            sum1=0.d0
            do 60 i=ia,ib
               im1=i-1
               do 50 j=ia,im1
   50          sum1=sum1+ptot(j+(i*(i-1))/2)**2
   60       sum2=sum2+ptot((i*(i+1))/2)**2
            sum=sum1*2.d0+sum2
            sum=dsqrt(sum)-qtot(ii)*0.5d0
         endif
         sum=sum*fn1(ni)
c
c     f(s,s)
c
         ka=(ia*(ia+1))/2
         f(ka)=f(ka)+pb(ka)*gss(ni)+ptpop*gsp(ni)
     1         -papop*hsp(ni) + dtpop*gsd(ni)
         if (ni.lt.3) go to 100
         iplus=ia+1
         l=ka
         do 70 j=iplus,ib
            m=l+ia
            l=l+j
c
c     f(p,p)
c
            f(l)=f(l)+ptot(ka)*gsp(ni)-pa(ka)*hsp(ni)+
     1      pb(l)*gpp(ni)+(ptpop-ptot(l))*gp2(ni)
     2      -0.5d0*(papop-pa(l))*(gpp(ni)-gp2(ni))
     3      +dtpop*gpd(ni)
c
c     f(s,p)
c
   70    f(m)=f(m)+2.d0*ptot(m)*hsp(ni)-pa(m)*(hsp(ni)+gsp(ni))
c
c     f(p,p*)
c
         iminus=ib-1
         do 80 j=iplus,iminus
            icc=j+1
            do 80 l=icc,ib
               m=(l*(l-1))/2+j
   80    f(m)=f(m)+ptot(m)*(gpp(ni)-gp2(ni))
     1      -0.5d0*pa  (m)*(gpp(ni)+gp2(ni))
         do 90 j=ib+1,ic
            m=(j*(j+1))/2
   90    f(m)=f(m)+ptot(ka)*gsd(ni)
     1         +ptpop*gpd(ni)
     2         +(dtpop-pa(m))*gdd(ni)
  100 continue
      return
      end
      subroutine fock2(f, ptot, p, w, wj, wk, numat, nfirst,
     1nmidle, nlast)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      dimension f(*), ptot(*), wj(*), wk(*), nfirst(*), nmidle(*),
     1          nlast(*), p(*), w(*)
      REAL  wj,wk
      logical lid
c***********************************************************************
c
c fock2 forms the two-electron two-center repulsion part of the fock
c matrix
c on input  ptot = total density matrix.
c           p    = alpha or beta density matrix.
c           w    = two-electron integral matrix.
c
c  on output f   = partial fock matrix
c***********************************************************************
      common /euler/ tvec(3,3), id
      common /molmec/ htype(4),nhco(4,20),nnhco,itype
      common /numcal/ numcal
      common /keywrd/ keywrd
      common /work4/ ptot2(numatm,16)
      common /work5/ ifact(maxorb),i1fact(maxorb), jindex(256), 
     + kindex(256), ijperm(10), llperm(10),
     + pk(16), pja(16), pjb(16), mmperm(10), jjndex(256), ione, lid
      character*241 keywrd
      save icalcn
      data icalcn/0/
      if(icalcn.ne.numcal) then
         icalcn=numcal
c
c   set up array of lower half triangle indices (pascal's triangle)
c
         do 10 i=1,maxorb
            ifact(i)=(i*(i-1))/2
   10    i1fact(i)=ifact(i)+i
c
c   set up gather-scatter type arrays for use with two-electron
c   integrals.  jindex are the indices of the j-integrals for atom i
c   integrals.  jjndex are the indices of the j-integrals for atom j
c               kindex are the indices of the k-integrals
c
         m=0
         do 20 i=1,4
            do 20 j=1,4
               ij=min0(i,j)
               ji=i+j-ij
               do 20 k=1,4
                  ik=min0(i,k)
                  ki=i+k-ik
                  do 20 l=1,4
                     m=m+1
                     kl=min0(k,l)
                     lk=k+l-kl
                     jl=min0(j,l)
                     lj=j+l-jl
                     kindex(m)= ifact(lj) +jl + 10*( ifact(ki) +ik) -10
   20    jindex(m)=(ifact(ji) + ij)*10 + ifact(lk) + kl - 10
         l=0
         do 30 i=1,4
            i1=(i-1)*4
            do 30 j=1,i
               i1=i1+1
               l=l+1
               ijperm(l)=i1
               mmperm(l)=ijperm(l)-16
               llperm(l)=(i1-1)*16
   30    continue
         l=0
         do 40 i=1,10
            m=mmperm(i)
            l=llperm(i)
            do 40 k=1,16
               l=l+1
               m=m+16
   40    jjndex(l)=jindex(m)
         lid=(id.eq.0)
         ione=1
         if(id.ne.0)ione=0
c
c      end of initialization
c
      endif
      if(itype.eq.4) goto 200
c
c     start of mndo, am1, or pm3 option
c
      kk=0
      l=0
      do 60 i=1,numat
         ia=nfirst(i)
         ib=nlast(i)
         m=0
         do 50 j=ia,ib
            do 50 k=ia,ib
               m=m+1
               jk=min0(j,k)
               kj=k+j-jk
               jk=jk+(kj*(kj-1))/2
               ptot2(i,m)=ptot(jk)
   50    continue
   60 continue
      do 190 ii=1,numat
         ia=nfirst(ii)
         ib=nlast(ii)
c
c  if numat=2 then we are in a derivative or in a molecule calculation
c
         if(numat.ne.2)then
            iminus=ii-ione
         else
            iminus=ii-1
         endif
         do 180 jj=1,iminus
            ja=nfirst(jj)
            jb=nlast(jj)
            jc=nmidle(jj)
            if(lid) then
               drep=w(kk+1)
               if(ib-ia.ge.3.and.jb-ja.ge.3)then
c
c                         heavy-atom  - heavy-atom
c
c   extract coulomb terms
c
                  do 70 i=1,16
                     pja(i)=ptot2(ii,i)
   70             pjb(i)=ptot2(jj,i)
c
c  coulomb terms
c
                  call jab(ia,ja,llperm,jindex, jjndex, pja,pjb,w(kk+1),
     1f)
c
c  exchange terms
c
c
c  extract intersection of atoms ii and jj in the spin density matrix
c
                  l=0
                  do 80 i=ia,ib
                     i1=ifact(i)+ja
                     do 80 j=i1,i1+3
                        l=l+1
   80             pk(l)=p(j)
                  call kab(ia,ja, pk, w(kk+1), kindex, f)
                  kk=kk+100
               elseif(ib-ia.ge.3.and.ja.eq.jb)then
c
c                         light-atom  - heavy-atom
c
c
c   coulomb terms
c
                  sumdia=0.d0
                  sumoff=0.d0
                  ll=i1fact(ja)
                  k=0
                  do 100 i=0,3
                     j1=ifact(ia+i)+ia-1
                     do 90 j=0,i-1
                        k=k+1
                        j1=j1+1
                        f(j1)=f(j1)+ptot(ll)*w(kk+k)
   90                sumoff=sumoff+ptot(j1)*w(kk+k)
                     j1=j1+1
                     k=k+1
                     f(j1)=f(j1)+ptot(ll)*w(kk+k)
  100             sumdia=sumdia+ptot(j1)*w(kk+k)
                  f(ll)=f(ll)+sumoff*2.d0+sumdia
c
c  exchange terms
c
c
c  extract intersection of atoms ii and jj in the spin density matrix
c
                  k=0
                  do 120 i=ia,ib
                     i1=ifact(i)+ja
                     sum=0.d0
                     do 110 j=ia,ib
                        k=k+1
                        j1=ifact(j)+ja
  110                sum=sum+p(j1)*w(kk+jindex(k))
  120             f(i1)=f(i1)-sum
                  kk=kk+10
               elseif(jb-ja.ge.3.and.ia.eq.ib)then
c
c                         heavy-atom - light-atom
c
c
c   coulomb terms
c
                  sumdia=0.d0
                  sumoff=0.d0
                  ll=i1fact(ia)
                  k=0
                  do 140 i=0,3
                     j1=ifact(ja+i)+ja-1
                     do 130 j=0,i-1
                        k=k+1
                        j1=j1+1
                        f(j1)=f(j1)+ptot(ll)*w(kk+k)
  130                sumoff=sumoff+ptot(j1)*w(kk+k)
                     j1=j1+1
                     k=k+1
                     f(j1)=f(j1)+ptot(ll)*w(kk+k)
  140             sumdia=sumdia+ptot(j1)*w(kk+k)
                  f(ll)=f(ll)+sumoff*2.d0+sumdia
c
c  exchange terms
c
c
c  extract intersection of atoms ii and jj in the spin density matrix
c
                  k=ifact(ia)+ja
                  j=0
                  do 160 i=k,k+3
                     sum=0.d0
                     do 150 l=k,k+3
                        j=j+1
  150                sum=sum+p(l)*w(kk+jindex(j))
  160             f(i)=f(i)-sum
                  kk=kk+10
               elseif(jb.eq.ja.and.ia.eq.ib)then
c
c                         light-atom - light-atom
c
                  i1=i1fact(ia)
                  j1=i1fact(ja)
                  ij=i1+ja-ia
                  f(i1)=f(i1)+ptot(j1)*w(kk+1)
                  f(j1)=f(j1)+ptot(i1)*w(kk+1)
                  f(ij)=f(ij)-p   (ij)*w(kk+1)
                  kk=kk+1
               endif
            else
               drep=wj(kk+1)
               do 170 i=ia,ib
                  ka=ifact(i)
                  do 170 j=ia,i
                     kb=ifact(j)
                     ij=ka+j
                     aa=2.0d00
                     if (i.eq.j) aa=1.0d00
                     do 170 k=ja,jc
                        kc=ifact(k)
                        if(i.ge.k) then
                           ik=ka+k
                        else
                           ik=0
                        endif
                        if(j.ge.k) then
                           jk=kb+k
                        else
                           jk=0
                        endif
                        do 170 l=ja,k
                           if(i.ge.l) then
                              il=ka+l
                           else
                              il=0
                           endif
                           if(j.ge.l) then
                              jl=kb+l
                           else
                              jl=0
                           endif
                           kl=kc+l
                           bb=2.0d00
                           if (k.eq.l) bb=1.0d00
                           kk=kk+1
                           aj=wj(kk)
                           ak=wk(kk)
c
c     a  is the repulsion integral (i,j/k,l) where orbitals i and j are
c     on atom ii, and orbitals k and l are on atom jj.
c     aa and bb are correction factors since
c     (i,j/k,l)=(j,i/k,l)=(i,j/l,k)=(j,i/l,k)
c     ij is the location of the matrix elements between atomic orbitals
c     i and j.  similarly for ik etc.
c
c this forms the two-electron two-center repulsion part of the fock
c matrix.  the code here is hard to follow, and impossible to modify!,
c but it works,
                           if(kl.le.ij)then
                              if(i.eq.k.and.aa+bb.lt.2.1d0)then
                                 bb=bb*0.5d0
                                 aa=aa*0.5d0
                                 f(ij)=f(ij)+bb*aj*ptot(kl)
                                 f(kl)=f(kl)+aa*aj*ptot(ij)
                              else
                                 f(ij)=f(ij)+bb*aj*ptot(kl)
                                 f(kl)=f(kl)+aa*aj*ptot(ij)
                                 a=ak*aa*bb*0.25d0
                                 f(ik)=f(ik)-a*p(jl)
                                 f(il)=f(il)-a*p(jk)
                                 f(jk)=f(jk)-a*p(il)
                                 f(jl)=f(jl)-a*p(ik)
                              endif
                           endif
  170          continue
            endif
  180    continue
  190 continue
      return
c
c                    start of mindo/3 option
c
  200 kr=0
      do 230 ii=1,numat
         ia=nfirst(ii)
         ib=nlast(ii)
         im1=ii-ione
         do 220 jj=1,im1
            kr=kr+1
            if(lid)then
               elrep=w(kr)
               elexc=elrep
            else
               elrep=wj(kr)
               elexc=wk(kr)
            endif
            ja=nfirst(jj)
            jb=nlast(jj)
            do 210 i=ia,ib
               ka=ifact(i)
               kk=ka+i
               do 210 k=ja,jb
                  ll=i1fact(k)
                  ik=ka+k
                  f(kk)=f(kk)+ptot(ll)*elrep
                  f(ll)=f(ll)+ptot(kk)*elrep
  210       f(ik)=f(ik)-p(ik)*elexc
  220    continue
  230 continue
      return
      end
      subroutine force
      implicit REAL (a-h,o-z)
      logical oprint
INCLUDE(common/sizes)
      common/prints/oprint(60)
      common /geovar/ nvar,loc(2,maxpar),idumy,dumy(maxpar)
      common /geosym/ ndep,locpar(maxpar),idepfn(maxpar),
     1                     locdep(maxpar)
      common /geokst/ natoms,labels(numatm),
     1na(numatm),nb(numatm),nc(numatm)
      common /fmatrx/ fmatrx(maxpar**2+maxpar*3+1),idumy2(4)
      common /keywrd/ keywrd
      common /gradnt/ grad(maxpar),gnorm
      parameter (ipadd=2*morb2+2*maxorb-maxpar-maxpar*maxpar)
      common /vector/ cnorml(maxpar*maxpar),freq(maxpar),dummy(ipadd)
      common /elemts/ elemnt(107)
      common /last/ last
      common /mesage/ iflepo,iscf
      common /simbol/ simbol(maxpar)
      common /cmpg/ geo(3,numatm)
      common /coord/ coord(3,numatm)
      common/iofile/mfgr,mfgw
***********************************************************************
*
*   force calculates the force constants for the molecule, and the
*         vibrational frequencies.  isotopic substitution is allowed.
*
***********************************************************************
      common /euler/ tvec(3,3), id
      common /scftyp/ emin, limscf
      common /scrach/ store(maxpar**2)
      dimension xparam(maxpar), gr(3,numatm),
     1deldip(3,maxpar), trdip(3,maxpar),locold(2,maxpar)
     2,redmas(maxpar), shift(6), dipt(maxpar), travel(maxpar)
     3, rot(3,3), georef(3,maxpar)
      character keywrd*241, keys(241)*1, elemnt*2, simbol*10
      logical restrt, linear, debug, bartel, prnt, large, limscf
      equivalence (grad(1), gr(1,1)), (keywrd,keys(1))
c
c test geometry to see if it is optimized
      time2=-1.d9
      call gmetry(geo,coord)
      nvaold=nvar
      do 10 i=1,nvar
         locold(1,i)=loc(1,i)
   10 locold(2,i)=loc(2,i)
      nvar=0
      ndeold=ndep
      ndep=0
      numat=0
      if(labels(1) .ne. 99) numat=1
      do 30 i=2,natoms
         if(labels(i).eq.99) goto 30
         if(i.eq.2)ilim=1
         if(i.eq.3)ilim=2
         if(i.gt.3)ilim=3
c
c  is it a polymer?
c
         if(labels(i).eq.107) then
            ilim=1
         else
            numat=numat+1
         endif
c$doit asis
         do 20 j=1,ilim
            nvar=nvar+1
            loc(1,nvar)=i
            loc(2,nvar)=j
   20    xparam(nvar)=geo(j,i)
   30 continue
c
c   if a restart, then tscf and tder will be faulty, therefore set to -1
c
      tscf=-1.d0
      tder=-1.d0
      prnt=(index(keywrd,'rc=') .eq. 0)
      debug=(index(keywrd,'dforce') .ne. 0)
      large=(index(keywrd,'large') .ne. 0)
      bartel=(index(keywrd,'nllsq') .ne. 0)
      restrt=(index(keywrd,'restart') .ne. 0)
      time1=secmop()
      if (restrt) then
c
c   check to see if calculation is in nllsq or force.
c
         if(bartel)goto 50
c
c   calculation is in force
c
         goto 80
      endif
      call compfg( xparam, .true., escf, .true., grad, .false.)
      if(prnt)write(mfgw,'(//10x,''heat of formation ='',f12.6,
     1'' kcals/mole'')')escf
      time2=secmop()
      tscf=time2-time1
      call compfg( xparam, .true., escf1, .false., grad, .true.)
      time3=secmop()
      tder=time3-time2
      if(prnt)
     +  write(mfgw,'(//10x,''internal coordinate derivatives'',//3x,
     1''number  atom'',2x,''bond'',9x,''  angle'',10x,''dihedral'',/)')
      l=0
      iu=0
      do 40 i=1,natoms
         if(labels(i).eq.99) goto 40
         l=l+1
         il=iu+1
         if(i .eq. 1) iu=il-1
         if(i .eq. 2) iu=il
         if(i .eq. 3) iu=il+1
         if(i .gt. 3) iu=il+2
         if(labels(i).eq.107)iu=il
         if(prnt)write(mfgw,'(i6,4x,a2,f13.6,2f13.6)')
     1l,elemnt(labels(i)),(grad(j),j=il,iu)
   40 continue
c   test sum of gradients
      gnorm=dsqrt(ddot(nvar,grad,1,grad,1))
      if(prnt)write(mfgw,'(//10x,''gradient norm ='',f10.5)') gnorm
      if(gnorm.lt.10.d0) goto 70
      if(index(keywrd,' let ') .ne. 0) then
      write(mfgw,'(///1x,''** gradient is very large, but since "let"'',
     1'' is used, calculation will continue'')')
         goto 80
      endif
      write(mfgw,'(///1x,''** gradient is too large to allow '',
     1    ''force matrix to be calculated, (limit=10) **'',//)')
   50 continue
      do 60 i=1,nvar
   60 simbol(i)='---'
      write(mfgw,'(//10x,'' geometry will be optimized first'')')
      if(bartel) then
         write(mfgw,'(15x,''using nllsq'')')
         call nllsq(xparam,nvar)
      else
         write(mfgw,'(15x,''using flepo'')')
         call flepo(xparam,nvar,escf)
c
c  did flepo use all the time allowed?
c
         if(iflepo.eq.-1) return
      endif
      limscf=.false.
      call compfg( xparam, .true., escf, .true., grad, .true.)
      call writmo(time1,escf)
      write(mfgw,'(//10x,''gradient norm ='',f10.7)') gnorm
      call gmetry(geo,coord)
   70 continue
      do 8 i=1,3
      do 8 j=1,natoms
   8  georef(i,j)=geo(i,j)
c
c now to calculate the force matrix
c
c check out symmetry
   80 continue
c
c   need to ensure that mopxyz will work correctly before call
c   to drc.
c
      l=0
      do 90 i=1,natoms
         if(labels(i).ne.99)then
            l=l+1
            labels(l)=labels(i)
         endif
   90 continue
      natoms=numat
      call mopxyz(coord,numat,na,nb,nc,1.d0,geo)
      call gmetry(geo,coord)
      if(index(keywrd,'thermo').ne.0 .and.gnorm.gt.1.d0) then
         write(mfgw,'(//30x,''**** warning ****'',//
     110x,'' gradient is very large for a thermo calculation'',/
     210x,'' results are likely to be inaccurate if there are'')')
      write(mfgw,'(10x,'' any low-lying vibrations (less than about ''
     1,''400cm-1)'')')
      write(mfgw,'(10x,'' gradient norm should be less than about '',
     1''0.2 for thermo'',/10x,'' to give accurate results'')')
      endif
      if(tscf.gt.0.d0) then
      write(mfgw,'(//10x,''time for scf calculation ='',f8.2)')tscf
      write(mfgw,'(//10x,''time for derivatives     ='',f8.2)')tder
      endif
      if(ndep.gt.0) then
      write(mfgw,'(//10x,''symmetry was specified, but '',
     1''cannot be used here'')')
         ndep=0
      endif
      if(prnt.and. .not. oprint(28) )
     +   call axis(coord,numat,a,b,c,wtmol,2,rot)
      nvib=3*numat-6
      if(dabs(c).lt.1.d-20)nvib=nvib+1
      if(id.ne.0)nvib=3*numat-3
      if(prnt.and. .not. oprint(28) ) then
      write(mfgw,'(/9x,''orientation of molecule in force calculation'')
     1')
      write(mfgw,'(/,4x,''no.'',7x,''atom'',9x,''x'',
     19x,''y'',9x,''z'',/)')
      endif
      l=0
      do 100 i=1,natoms
         if(labels(i) .eq. 99) goto 100
         l=l+1
         if(prnt.and. .not. oprint(28) )
     +   write(mfgw,'(i6,7x,i3,4x,3f10.4)')
     1    l,labels(i),(coord(j,l),j=1,3)
  100 continue
       timed = secmop()
       write(mfgw,350) timed
  350  format(/' commence 2nd derivative calc. at ', f10.2,' seconds'/)
      call fmat(fmatrx, nvib, tscf, tder, deldip,escf)
       timed = secmop()
       write(mfgw,360) timed
  360  format(/' 2nd derivative calc. complete at ', f10.2,' seconds'/)
      na(1)=0
      do 18 i=1,3
      do 18 j=1,natoms
   18  geo(i,j)=georef(i,j)
      if(nvib.lt.0)then
      ndep=ndeold
      nvar=0
      return
      endif
c
c   the force matrix is printed as an atom-atom matrix rather than
c   as a 3n*3n matrix, as the 3n matrix is very confusing!
c
      ij=0
      iu=0
      do 130 i=1,numat
         il=iu+1
         iu=il+2
         im1=i-1
         ju=0
         do 120 j=1,im1
            jl=ju+1
            ju=jl+2
            sum=0.d0
c$doit asis
            do 110 ii=il,iu
c$doit asis
               do 110 jj=jl,ju
  110       sum=sum+fmatrx((ii*(ii-1))/2+jj)**2
            ij=ij+1
  120    store(ij)=dsqrt(sum)
         ij=ij+1
  130 store(ij)=dsqrt(
     1fmatrx(((il+0)*(il+1))/2)**2+
     2fmatrx(((il+1)*(il+2))/2)**2+
     3fmatrx(((il+2)*(il+3))/2)**2+2.d0*(
     4fmatrx(((il+1)*(il+2))/2-1)**2+
     5fmatrx(((il+2)*(il+3))/2-2)**2+
     6fmatrx(((il+2)*(il+3))/2-1)**2))
      if(debug) then
      write(mfgw,'(//10x,'' full force matrix, invoked by "dforce"'')')
         i=-nvar
         call vecprt(fmatrx,i)
      endif
      if(prnt.and. .not. oprint(28) )then
      write(mfgw,'(//10x,'' force matrix in millidynes/angstrom'')')
         call vecprt(store,numat)
      endif
      l=(nvar*(nvar+1))/2
      do 140 i=1,l
  140 store(i)=fmatrx(i)
      if(prnt) call axis(coord,numat,a,b,c,sum,0,rot)
      if(prnt)write(mfgw,'(//10x,''heat of formation ='',f12.6,
     1'' kcals/mole'')')escf
      if(large)then
         call mopfr(store,numat,0,shift)
         call rsp(store,nvar,nvar,freq,cnorml)
         do 150 i=nvib+1,nvar
            j=(freq(i)+50.d0)*0.01d0
  150    freq(i)=freq(i)-j*100
         if(prnt)then
         write(mfgw,'(//10x,''trivial vibrations, should be zero'')')
         write(mfgw,'(/, f9.4,''=tx'',f9.4,''=ty'',f9.4,''=tz'',
     1             f9.4,''=rx'',f9.4,''=ry'',f9.4,''=rz'')')
     2(freq(i),i=nvib+1,nvar)
         write(mfgw,'(//10x,''force constants in millidynes/angstrom''
     1,'' (= 10**5 dynes/cm)'',/)')
            write(mfgw,'(8f10.5)')(freq(i),i=1,nvib)
c convert to weighted fmat
            write(mfgw,'(//10x,'' associated eigenvectors'')')
            i=-nvar
            call mopmat(cnorml,freq,nvib,i,nvar)
         endif
      endif
      call freqcy(fmatrx,freq,cnorml,redmas,travel,.true.)
c
c  calculate zero point energy
c
c
c  these constants taken from handbook of chemistry and physics 62nd ed.
c   n avogadro's number = 6.022045*10**23
c   h planck's constant = 6.626176*10**(-34)jhz
c   c speed of light    = 2.99792458*10**10 cm/sec
c   const=0.5*n*h*c/(1000*4.184)
      const=1.4295718d-3
      sum=0.d0
      do 160 i=1,nvar
  160 sum=sum+freq(i)
      sum=sum*const
      if(prnt)
     1write(mfgw,'(//10x,'' zero point energy''
     2, f12.3,'' kilocalories per mole'')')sum
      summ=0.d0
      do 210 i=1,nvar
         sum1=1.d-20
c$doit vbest
         do 170 j=1,nvar
  170    sum1=sum1+cnorml(j+(i-1)*nvar)**2
         sum1=1.d0/dsqrt(sum1)
c$doit asis
         do 180 k=1,3
  180    grad(k)=0.d0
c$doit asis
         do 200 k=1,3
            sum=0.d0
c$doit vbest
            do 190 j=1,nvar
  190       sum=sum+cnorml(j+(i-1)*nvar)*deldip(k,j)
            summ=summ+dabs(sum)
  200    trdip(k,i)=sum*sum1
         dipt(i)=dsqrt(trdip(1,i)**2+trdip(2,i)**2+trdip(3,i)**2)
  210 continue
      if(prnt)then
      write(mfgw,'(//3x,'' the last'',i2,'' vibrations are the'',
     1'' translation and rotation modes'')')nvar-nvib
      write(mfgw,'(3x,'' the first three of these being translations'',
     1'' in x, y, and z, respectively'')')
      endif
      if(oprint(28)) then
         nto6=nvar/6
         nrem6=nvar-nto6*6
         iinc1=-5
         if (nto6.lt.1) go to 2230
         do 2220 i=1,nto6
            write (mfgw,'(/)')
            iinc1=iinc1+6
            iinc2=iinc1+5
         write (mfgw,'(3x,''i'',10i10)') (j,j=iinc1,iinc2)
         write (mfgw,'('' freq(i)'',6f10.4,/)') 
     +      (freq(j),j=iinc1,iinc2)
2220    continue
2230    continue
         if (nrem6.lt.1) go to 2240
         write (mfgw,'(/)')
         iinc1=iinc1+6
         iinc2=iinc1+(nrem6-1)
      write (mfgw,'(3x,''i'',10i10)') (j,j=iinc1,iinc2)
      write (mfgw,'('' freq(i)'',6f10.4)') (freq(j),j=iinc1,iinc2)
2240    continue
      endif
      if(prnt.and.large)then
      write(mfgw,'(//10x,'' frequencies, reduced masses and '',
     1''vibrational dipoles''/)')
         nto6=nvar/6
         nrem6=nvar-nto6*6
         iinc1=-5
         if (nto6.lt.1) go to 230
         do 220 i=1,nto6
            write (mfgw,'(/)')
            iinc1=iinc1+6
            iinc2=iinc1+5
         write (mfgw,'(3x,''i'',10i10)') (j,j=iinc1,iinc2)
         write (mfgw,'('' freq(i)'',6f10.4,/)') 
     +      (freq(j),j=iinc1,iinc2)
         write (mfgw,'('' mass(i)'',6f10.5,/)') (redmas(j),j=iinc1,iinc2
     1)
         write (mfgw,'('' dipx(i)'',6f10.5)') (trdip(1,j),j=iinc1,iinc2)
         write (mfgw,'('' dipy(i)'',6f10.5)') (trdip(2,j),j=iinc1,iinc2)
         write (mfgw,'('' dipz(i)'',6f10.5,/)') (trdip(3,j),j=iinc1,iinc
     12)
         write (mfgw,'('' dipt(i)'',6f10.5)')
     1   (dipt(j),j=iinc1,iinc2)
  220    continue
  230    continue
         if (nrem6.lt.1) go to 240
         write (mfgw,'(/)')
         iinc1=iinc1+6
         iinc2=iinc1+(nrem6-1)
      write (mfgw,'(3x,''i'',10i10)') (j,j=iinc1,iinc2)
      write (mfgw,'('' freq(i)'',6f10.4)') (freq(j),j=iinc1,iinc2)
      write (mfgw,'(/,'' mass(i)'',6f10.5)') (redmas(j),j=iinc1,iinc2)
      write (mfgw,'(/,'' dipx(i)'',6f10.5)') (trdip(1,j),j=iinc1,iinc2)
      write (mfgw,'('' dipy(i)'',6f10.5)') (trdip(2,j),j=iinc1,iinc2)
      write (mfgw,'('' dipz(i)'',6f10.5)') (trdip(3,j),j=iinc1,iinc2)
      write (mfgw,'(/,'' dipt(i)'',6f10.5)')
     1   (dipt(j),j=iinc1,iinc2)
  240    continue
      endif
      if(prnt.and. .not. oprint(28) )then
         write(mfgw,'(//10x,'' normal coordinate analysis'')')
         i=-nvar
         call mopmat(cnorml,freq,nvar,i,nvar)
      endif
c
c   carry out irc if requested.
c
      if(index(keywrd,'irc')+index(keywrd,'drc').ne.0)then
         do 250 i=1,nvar
            loc(1,i)=0
  250    loc(2,i)=0
         nvar=nvaold
         do 260 i=1,nvar
            loc(1,i)=locold(1,i)
  260    loc(2,i)=locold(2,i)
         call mopxyz(coord,numat,na,nb,nc,1.d0,geo)
         last=1
         call drc(cnorml,freq)
      na(1)=0
      ndep=ndeold
      nvar=0
      do 28 i=1,3
      do 28 j=1,natoms
   28  geo(i,j)=georef(i,j)
         return
      endif
      call freqcy(fmatrx,freq,cnorml,deldip,deldip,.false.)
      if( .not. oprint(28) )
     +write(mfgw,'(//10x,'' mass-weighted coordinate analysis'')')
      i=-nvar
      if( .not. oprint(28) ) then
       call mopmat(cnorml,freq,nvar,i,nvar)
       call anavib(coord,freq,dipt,nvar,cnorml,store,
     1fmatrx,travel,redmas)
      endif
      if(index(keywrd,'thermo').ne.0) then
         call gmetry(geo,coord)
         i=index(keywrd,' rot')
         if(i.ne.0) then
            sym=reada(keywrd,i)
         else
            sym=1
         endif
         linear=(dabs(a*b*c) .lt. 1.d-10)
         i=index(keywrd,' trans')
c
c   "i" is going to mark the beginning of the genuine vibrations.
c
         if(i.ne.0)then
            i=index(keywrd,' trans=')
            if(i.ne.0)then
               i=1+reada(keywrd,i)
               j=nvib-i+1
            write(mfgw,'(//1x,''the lowest'',i3,'' vibrations are not'',
     1/,'' to be used in the thermo calculation'')')i-1
            else
               write(mfgw,'(//10x,''system is a transition state'')')
               i=2
               j=nvib-1
            endif
         else
            write(mfgw,'(//10x,''system is a ground state'')')
            i=1
            j=nvib
         endif
         call moptho(a,b,c,linear,sym,wtmol,freq(i),j,escf)
      endif
      na(1)=0
      nvar=0
      ndep=ndeold
      do 38 i=1,3
      do 38 j=1,natoms
   38  geo(i,j)=georef(i,j)
      return
      end
      subroutine formxy(w,kr,wca,wcb,ca,na,cb,nb)
      implicit REAL (a-h,o-z)
      dimension w(100), wca(na), wcb(nb), ca(na), cb(nb)
c***********************************************************************
c
c    each of the na elements of wca will add on the nb electrostatic
c    terms from atom b in cb
c
c    each of the nb elements of wcb will add on the na electrostatic
c    terms from atom a in ca
c
c    both sums will involve the na*nb terms in array w.  once used,
c    w will be incremented by na*nb.
c
c na=1 if atom 'a' is a hydrogen, na=10 if atom 'a' is not a hydrogen
c nb=1 if atom 'b' is a hydrogen, nb=10 if atom 'b' is not a hydrogen
c
c***********************************************************************
      common /keywrd/ keywrd
      common /numcal/ numcal
      logical mindo3
      character keywrd*241
      save icalcn,mindo3
      data icalcn/0/
      if(icalcn.ne.numcal)then
         icalcn=numcal
         mindo3=(index(keywrd,'mindo').ne.0)
      endif
      if(mindo3)then
         w1=w(1)*0.25d0
c
c   calculate the total number of electrons on atoms a and b
c
         pa=ca(1)
         pb=cb(1)
         if(na.gt.1.and.nb.gt.1)then
            pwa=(pa+ca(3)+ca(6)+ca(10))*w1
            pwb=(pb+cb(3)+cb(6)+cb(10))*w1
            wca(1)=wca(1)+pwb
            wca(3)=wca(3)+pwb
            wca(6)=wca(6)+pwb
            wca(10)=wca(10)+pwb
            wcb(1)=wcb(1)+pwa
            wcb(3)=wcb(3)+pwa
            wcb(6)=wcb(6)+pwa
            wcb(10)=wcb(10)+pwa
         elseif(na.gt.1)then
            pwb=pb*w1
            wca(1)=wca(1)+pwb
            wca(3)=wca(3)+pwb
            wca(6)=wca(6)+pwb
            wca(10)=wca(10)+pwb
            wcb(1)=wcb(1)+(pa+ca(3)+ca(6)+ca(10))*w1
         elseif(nb.gt.1)then
            pwa=pa*w1
            wca(1)=wca(1)+(pb+cb(3)+cb(6)+cb(10))*w1
            wcb(1)=wcb(1)+pwa
            wcb(3)=wcb(3)+pwa
            wcb(6)=wcb(6)+pwa
            wcb(10)=wcb(10)+pwa
         else
            wca(1)=wca(1)+pb*w1
            wcb(1)=wcb(1)+pa*w1
         endif
         kr=kr+1
         return
      endif
      if(na.gt.1.and.nb.gt.1)then
c
c   both atoms 'a' and 'b' are heavy atoms
c
c
c  this commented-out code runs slower on a scalar machine than the
c  explicit code actually used here.  the code commented out is provided
c  for users who want to vectorize the code
c
c#         ijp=0
c#         do 3 ii=1,4
c#         do 4 jj=1,ii
c#         ij=ijp*10
c#         ijp=ijp+1
c#         kl=-10+ijp
c#         sum1=0.d0
c#         sum2=0.d0
c#         ji=0
c#         do 10 i=1,4
c#            do 10 j=1,i
c#               ji=ji+1
c#               ij=ij+1
c#               kl=kl+10
c#               fact=1.d0
c#               if(i.eq.j)fact=0.5d0
c#               sum1=sum1+cb(ji)*w(ij)*fact
c#   10    sum2=sum2+ca(ji)*w(kl)*fact
c#      if(ii.eq.jj)then
c#      sum1=sum1*0.5d0
c#      sum2=sum2*0.5d0
c#      endif
c#      wca(ijp)=wca(ijp)+sum1
c#      wcb(ijp)=wcb(ijp)+sum2
c#   4  continue
c#   3  continue
c
c   start of explicit code
c
         wca(1)=wca(1)+
     10.25d0*(cb(1)*w(1) + cb(3)*w(3) + cb(6)*w(6) + cb(10)*w(10)) +
     20.5d0*( cb(2)*w(2) + cb(4)*w(4) + cb(5)*w(5) +
     3        cb(7)*w(7) + cb(8)*w(8) + cb(9)*w(9))
         wca(2)=wca(2)+
     10.5d0*(cb(1)*w(11) + cb(3)*w(13) + cb(6)*w(16) + cb(10)*w(20)) +
     2cb(2)*w(12) + cb(4)*w(14) + cb(5)*w(15) +
     3cb(7)*w(17) + cb(8)*w(18) + cb(9)*w(19)
         wca(3)=wca(3)+
     10.25d0*(cb(1)*w(21) + cb(3)*w(23) + cb(6)*w(26) + cb(10)*w(30)) +
     20.5d0*(cb(2)*w(22) + cb(4)*w(24) + cb(5)*w(25) +
     3       cb(7)*w(27) + cb(8)*w(28) + cb(9)*w(29))
         wca(4)=wca(4)+
     10.5d0*(cb(1)*w(31) + cb(3)*w(33) + cb(6)*w(36) + cb(10)*w(40)) +
     2cb(2)*w(32) + cb(4)*w(34) + cb(5)*w(35) +
     3cb(7)*w(37) + cb(8)*w(38) + cb(9)*w(39)
         wca(5)=wca(5)+
     10.5d0*(cb(1)*w(41) + cb(3)*w(43) + cb(6)*w(46) + cb(10)*w(50)) +
     2cb(2)*w(42) + cb(4)*w(44) + cb(5)*w(45) +
     3cb(7)*w(47) + cb(8)*w(48) + cb(9)*w(49)
         wca(6)=wca(6)+
     10.25d0*(cb(1)*w(51) + cb(3)*w(53) + cb(6)*w(56) + cb(10)*w(60)) +
     20.5d0*(cb(2)*w(52) + cb(4)*w(54) + cb(5)*w(55) +
     3       cb(7)*w(57) + cb(8)*w(58) + cb(9)*w(59))
         wca(7)=wca(7)+
     10.5d0*(cb(1)*w(61) + cb(3)*w(63) + cb(6)*w(66) + cb(10)*w(70)) +
     2cb(2)*w(62) + cb(4)*w(64) + cb(5)*w(65) +
     3cb(7)*w(67) + cb(8)*w(68) + cb(9)*w(69)
         wca(8)=wca(8)+
     10.5d0*(cb(1)*w(71) + cb(3)*w(73) + cb(6)*w(76) + cb(10)*w(80)) +
     2cb(2)*w(72) + cb(4)*w(74) + cb(5)*w(75) +
     3cb(7)*w(77) + cb(8)*w(78) + cb(9)*w(79)
         wca(9)=wca(9)+
     10.5d0*(cb(1)*w(81) + cb(3)*w(83) + cb(6)*w(86) + cb(10)*w(90)) +
     2cb(2)*w(82) + cb(4)*w(84) + cb(5)*w(85) +
     3cb(7)*w(87) + cb(8)*w(88) + cb(9)*w(89)
         wca(10)=wca(10)+
     10.25d0*(cb(1)*w(91) + cb(3)*w(93) + cb(6)*w(96) + cb(10)*w(100)) +
     20.5d0*(cb(2)*w(92) + cb(4)*w(94) + cb(5)*w(95) +
     3       cb(7)*w(97) + cb(8)*w(98) + cb(9)*w(99))
         wcb(1)=wcb(1)+
     10.25d0*(ca(1)*w(1) + ca(3)*w(21) + ca(6)*w(51) + ca(10)*w(91)) +
     20.5d0*(ca(2)*w(11) + ca(4)*w(31) + ca(5)*w(41) +
     3       ca(7)*w(61) + ca(8)*w(71) + ca(9)*w(81))
         wcb(2)=wcb(2)+
     10.5d0*(ca(1)*w(2) + ca(3)*w(22) + ca(6)*w(52) + ca(10)*w(92)) +
     2ca(2)*w(12) + ca(4)*w(32) + ca(5)*w(42) +
     3ca(7)*w(62) + ca(8)*w(72) + ca(9)*w(82)
         wcb(3)=wcb(3)+
     10.25d0*(ca(1)*w(3) + ca(3)*w(23) + ca(6)*w(53) + ca(10)*w(93)) +
     20.5d0*(ca(2)*w(13) + ca(4)*w(33) + ca(5)*w(43) +
     3       ca(7)*w(63) + ca(8)*w(73) + ca(9)*w(83))
         wcb(4)=wcb(4)+
     10.5d0*(ca(1)*w(4) + ca(3)*w(24) + ca(6)*w(54) + ca(10)*w(94)) +
     2ca(2)*w(14) + ca(4)*w(34) + ca(5)*w(44) +
     3ca(7)*w(64) + ca(8)*w(74) + ca(9)*w(84)
         wcb(5)=wcb(5)+
     10.5d0*(ca(1)*w(5) + ca(3)*w(25) + ca(6)*w(55) + ca(10)*w(95)) +
     2ca(2)*w(15) + ca(4)*w(35) + ca(5)*w(45) +
     3ca(7)*w(65) + ca(8)*w(75) + ca(9)*w(85)
         wcb(6)=wcb(6)+
     10.25d0*(ca(1)*w(6) + ca(3)*w(26) + ca(6)*w(56) + ca(10)*w(96)) +
     20.5d0*(ca(2)*w(16) + ca(4)*w(36) + ca(5)*w(46) +
     3       ca(7)*w(66) + ca(8)*w(76) + ca(9)*w(86))
         wcb(7)=wcb(7)+
     10.5d0*(ca(1)*w(7) + ca(3)*w(27) + ca(6)*w(57) + ca(10)*w(97)) +
     2ca(2)*w(17) + ca(4)*w(37) + ca(5)*w(47) +
     3ca(7)*w(67) + ca(8)*w(77) + ca(9)*w(87)
         wcb(8)=wcb(8)+
     10.5d0*(ca(1)*w(8) + ca(3)*w(28) + ca(6)*w(58) + ca(10)*w(98)) +
     2ca(2)*w(18) + ca(4)*w(38) + ca(5)*w(48) +
     3ca(7)*w(68) + ca(8)*w(78) + ca(9)*w(88)
         wcb(9)=wcb(9)+
     10.5d0*(ca(1)*w(9) + ca(3)*w(29) + ca(6)*w(59) + ca(10)*w(99)) +
     2ca(2)*w(19) + ca(4)*w(39) + ca(5)*w(49) +
     3ca(7)*w(69) + ca(8)*w(79) + ca(9)*w(89)
         wcb(10)=wcb(10)+
     10.25d0*(ca(1)*w(10) + ca(3)*w(30) + ca(6)*w(60) + ca(10)*w(100)) +
     20.5d0*(ca(2)*w(20) + ca(4)*w(40) + ca(5)*w(50) +
     3       ca(7)*w(70) + ca(8)*w(80) + ca(9)*w(90))
c
c   end of explicit code
c
      elseif(na.gt.1)then
c
c   atom 'a' is not a hydrogen, atom 'b' is a hydrogen
c
         sum=0.d0
         ij=0
         do 20 i=1,4
            do 10 j=1,i-1
               ij=ij+1
               sum=sum+ca(ij)*w(ij)
   10       wca(ij)=wca(ij)+cb(1)*w(ij)*0.5d0
            ij=ij+1
            sum=sum+ca(ij)*w(ij)*0.5d0
   20    wca(ij)=wca(ij)+cb(1)*w(ij)*0.25d0
         wcb(1) =wcb(1)+sum*0.5d0
      elseif(nb.gt.1)then
c
         sum=0.d0
         ij=0
         do 40 i=1,4
            do 30 j=1,i-1
               ij=ij+1
               sum=sum+cb(ij)*w(ij)
   30       wcb(ij)=wcb(ij)+ca(1)*w(ij)*0.5d0
            ij=ij+1
            sum=sum+cb(ij)*w(ij)*0.5d0
   40    wcb(ij)=wcb(ij)+ca(1)*w(ij)*0.25d0
         wca(1) =wca(1)+sum*0.5d0
      elseif(nb.gt.1)then
c
c   atom 'a' is a hydrogen, atom 'b' is not a hydrogen
c
      else
c
c   both atoms 'a' and 'b' are hydrogens
c
         wcb(1)=wcb(1)+ca(1)*w(1)*0.25d0
         wca(1)=wca(1)+cb(1)*w(1)*0.25d0
      endif
      kr=kr+na*nb
      return
      end
      subroutine forsav(time,deldip,ipt,n3,fmatrx, coord,nvar,refh,
     1                  evecs,jstart,fconst)
      implicit REAL (a-h,o-z)
_IF(ipsc,tools)
      logical oroot
_ENDIF
INCLUDE(common/sizes)
INCLUDE(../m4/common/utilc)
      dimension fmatrx(*), deldip(3,*), coord(*), evecs(*), fconst(*)
************************************************************************
*
*  forsav saves and restores data used in the force calculation.
*
* on input time = total time elapsed since the start of the calculation.
*          ipt  = line of force matrix reached, if in write mode,
*               = 0 if in read mode.
*        fmatrx = force matrix
************************************************************************
      common /densty/ p(mpack), pa(mpack), pb(mpack)
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),
     1                nlast(numatm), norbs, nelecs,nalpha,nbeta,
     2                nclose,nopen,ndumy,fract
      common/iofile/mfgr,mfgw
      character*80 getmop
_IF(ipsc,tools)
      if(oroot().and.odumpm) then
_ELSE
      if(odumpm) then
_ENDIF
      open(unit=9,file=getmop(3)
     +              ,status='unknown',form='unformatted')
      rewind 9
      open(unit=10,file=getmop(4)
     +              ,status='unknown',form='unformatted')
      rewind 10
      endif
      ir=9
      iw=9
      if( ipt .eq. 0 ) then
c
c   read in force data
c
_IF(ipsc,tools)
      if( oroot()) then
_ENDIF
         read(ir,end=20,err=20)time,ipt,refh
         linear=(nvar*(nvar+1))/2
         read(ir)(coord(i),i=1,nvar)
         read(ir,end=10,err=10)(fmatrx(i),i=1,linear)
         read(ir)((deldip(j,i),j=1,3),i=1,ipt)
         n33=nvar*nvar
         read(ir)(evecs(i),i=1,n33)
         read(ir)jstart,(fconst(i),i=1,nvar)
_IF(ipsc,tools)
       else
         write(mfgw,*)' restart not implemented in forsav'
         go to 21
       endif
_ENDIF
         return
      else
c
c    write force data
c
_IF(ipsc,tools)
        if(oroot().and.odumpm) then
_ELSE
        if(odumpm) then
_ENDIF
         rewind iw
         if(time.gt.1.d6)time=time-1.d6
         write(iw)time,ipt,refh
         linear=(nvar*(nvar+1))/2
         write(iw)(coord(i),i=1,nvar)
         write(iw)(fmatrx(i),i=1,linear)
         write(iw)((deldip(j,i),j=1,3),i=1,ipt)
         n33=nvar*nvar
         write(ir)(evecs(i),i=1,n33)
         write(ir)jstart,(fconst(i),i=1,nvar)
         linear=(norbs*(norbs+1))/2
         write(10)(pa(i),i=1,linear)
         if(nalpha.ne.0)write(10)(pb(i),i=1,linear)
         close(9)
         close(10)
        endif
      endif
      return
   10 write(mfgw,
     +  '(10x,''insufficient data on disk files for a force '',
     1''calculation'',/10x,''restart. perhaps this started of as a '',
     2''force calculation '')')
      write(mfgw,
     +  '(10x,''but the geometry had to be optimized first, '',
     1''in which case '',/10x,''remove the key-word "force".'')')
_IF(ipsc,tools)
         call pend
_ELSE
         stop
_ENDIF
   20 write(mfgw,'(//10x,''no restart file exists!'')')
   21 continue
_IF(ipsc,tools)
        call pend
_ELSE
        stop
_ENDIF
      end
      subroutine freqcy(fmatrx,freq,cnorml,redmas,travel,eorc)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      dimension fmatrx(*), redmas(*), freq(*), cnorml(*), travel(*)
      logical eorc
*********************************************************************
*
*  frce calculates the force constants and vibrational frequencies
*       for a molecule.  it uses the isotopic masses to weight the
*       force matrix
*
* on input   fmatrx   =  force matrix, of size numat*3*(numat*3+1)/2.
*
*********************************************************************
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),
     1                nlast(numatm), norbs, nelecs,nalpha,nbeta,
     2                nclose,nopen,ndumy,fract
      common /nllcom/ fmat2d(2*maxpar**2), vec(maxpar**2)
      common /atmass/ atmass(numatm)
      common /keywrd/ keywrd
      common /scrach/ oldf(maxpar**2)
      character keywrd*241
      dimension wtmass(maxpar), shift(6), sec(maxpar**2)
      equivalence (sec,oldf)
      save fact
      data fact/6.023d23/
c
c    conversion factor for speed of light and 2 pi.
c
      c2pi=1.d0/(2.998d10*3.141592653598d0*2.d0)
c now to calculate the vibrational frequencies
c
c   find conversion constants for mass weighted system
      n3=3*numat
      l=0
      do 10 i=1,numat
         weight=1.4142136d0/dsqrt(atmass(i))
         wtmass(l+1)=weight
         wtmass(l+2)=weight
         wtmass(l+3)=weight
         l=l+3
   10 wtmass(l)=weight
c    convert to mass weighted fmatrx
      linear=0
      do 20 i=1,n3
         do 20 j=1,i
            linear=linear+1
            oldf(linear)=  fmatrx(linear)*1.d5
   20 fmatrx(linear)=fmatrx(linear)*wtmass(i)*wtmass(j)
c
c    1.d5 is to convert from millidynes/angstrom to dynes/cm.
c
c    diagonalize
      i=index(keywrd,' k=')
      if(i.ne.0)then
c
c  go into brillouin zone mode
c
         step=reada(keywrd,i)
         mono3=reada(keywrd(i:),index(keywrd(i:),','))*3
         call brlzon(fmatrx, fmat2d, n3, sec, vec, alband, mono3, step,1
     1)
         return
      endif
      call mopfr(fmatrx,numat,1,shift)
      call rsp(fmatrx,n3,n3,freq,cnorml)
      do 30 i=1,n3
         j=(freq(i)+50.d0)*0.01d0
   30 freq(i)=freq(i)-dfloat(j*100)
      do 40 i=1,n3
   40 freq(i)=freq(i)*1.d5
c
c    calculate reduced masses, store in redmas
c
      do 80 i=1,n3
         ii=(i-1)*n3
         sum=0.d0
         do 70 j=1,n3
            jii=j+ii
            jj=(j*(j-1))/2
            do 50 k=1,j
   50       sum=sum+cnorml(jii)*oldf(jj+k)*cnorml(k+ii)
            do 60 k=j+1,n3
   60       sum=sum+cnorml(jii)*oldf((k*(k-1))/2+j)*cnorml(k+ii)
   70    continue
         sum1=sum*2.d0
         if(dabs(freq(i)).gt.dabs(sum)*1.d-20) then
            sum=1.d0*sum/freq(i)
         else
            sum=0.d0
         endif
         freq(i)=dsign(dsqrt(fact*dabs(freq(i)))*c2pi,freq(i))
         if(dabs(freq(i)).lt.dabs(sum1)*1.d+20) then
            sum1=dsqrt(dabs(freq(i)/(sum1*1.d-5)))
         else
            sum1=0.d0
         endif
         if(sum.lt.0.d0.or.sum.gt.100)sum=0.d0
c
c 0.0063024=sqrt(2*a*b*c/n) where
c         a=1.196d8 = conversion of cm**(-1) to (ergs = dyne.angstroms)
c         b=1000.0  = millidynes to dynes
c         c=1.d8    = centimeters to angstroms
c         n=6.02205d23 = avogadro's number
         travel(i)=sum1*0.0063024d0
         if(travel(i).gt.1.d0)travel(i)=0.d0
c#      write(6,*)travel(i)
   80 redmas(i)=sum
      if(eorc) then
c
c    convert normal vectors to cartesian coordinates
c    (deleted) and normalize so that the total movement is 1.0 angstrom.
c
         ij=0
         do 110 i=1,n3
            sum=0.d0
            j=0
            do 90 jj=1,numat
               sum1=0.d0
               cnorml(ij+1)=cnorml(ij+1)*wtmass(j+1)
               sum1=sum1+cnorml(ij+1)**2
c
               cnorml(ij+2)=cnorml(ij+2)*wtmass(j+2)
               sum1=sum1+cnorml(ij+2)**2
c
               cnorml(ij+3)=cnorml(ij+3)*wtmass(j+3)
               sum1=sum1+cnorml(ij+3)**2
c
               j=j+3
               ij=ij+3
   90       sum=sum+dsqrt(sum1)
            sum=1.d0/dsqrt(sum)
            ij=ij-n3
            do 100 j=1,n3
               ij=ij+1
  100       cnorml(ij)=cnorml(ij)*sum
  110    continue
c
c          return hessian in millidynes/angstrom in fmatrx
c
         do 120 i=1,linear
  120    fmatrx(i)=oldf(i)*1.d-5
      else
c
c  return hessian as mass-weighted fmatrix
         linear=0
c
         do 130 i=1,n3
            do 130 j=1,i
               linear=linear+1
  130    fmatrx(linear)=oldf(linear)*1.d-5*wtmass(i)*wtmass(j)
      endif
      return
      end
      subroutine fsub(n,x,fval)
      implicit REAL (a-h,o-z)
c***********************************************************************
c
c     calculate the fm(t). kindly supplied by rus pitzer and cleaned up
c     by k.m.merz in feb. 1989 at ucsf.
c
c     on input:  n = index
c                x = exponent
c     on output: fval = value of the function
c
c     for more details see: obara and saika j. chem. phys. 1986,84,3963
c***********************************************************************
      dimension ff(21),term(200)
      data a0, a1s2, pie4, a1
     1   /0.0d0,0.5d0,0.7853981633974483096156608d0,1.0d0/
      data xsw /24.0d0/
      e=a1s2*dexp(-x)
      fac0=n
      fac0=fac0+a1s2
      if(x.gt.xsw) go to 50
c
c     use power series
c
   10 fac=fac0
      term0=e/fac
      sum=term0
      ku=(x-fac0)
      if(ku.lt.1) go to 30
c
c     sum increasing terms forwards
c
      do 20 k=1,ku
         fac=fac+a1
         term0=term0*x/fac
         sum=sum+term0
   20 continue
   30 i=1
      fac=fac+a1
      term(1)=term0*x/fac
      suma=sum+term(1)
      if(sum.eq.suma) go to 90
   40 i=i+1
      fac=fac+a1
      term(i)=term(i-1)*x/fac
      sum1=suma
      suma=suma+term(i)
      if(sum1-suma) 40,90,40
c
c     use asymptotic series
c
   50 sum=dsqrt(pie4/x)
      if(n.eq.0) go to 70
      fac=-a1s2
      do 60 k=1,n
         fac=fac+a1
         sum=sum*fac/x
   60 continue
   70 i=1
      term(1)=-e/x
      suma=sum+term(1)
      if(sum.eq.suma) go to 90
      fac=fac0
      ku=(x+fac0-a1)
      do 80 i=2,ku
         fac=fac-a1
         term(i)=term(i-1)*fac/x
         sum1=suma
         suma=suma+term(i)
         if(sum1.eq.suma) go to 90
   80 continue
c
c     xsw set too low. use power series.
c
      go to 10
c
c     sum decreasing terms backwards
c
   90 sum1=a0
      do 100 k=1,i
         sum1=sum1+term(i+1-k)
  100 continue
      ff(n+1)=sum+sum1
c
c     use recurrence relation
c
      if(n.eq.0) goto 120
      do 110 k=1,n
         fac0=fac0-a1
         ff(n+1-k)=(e+x*ff(n+2-k))/fac0
  110 continue
  120 fval=ff(n+1)
      return
      end
      subroutine genunm(u,n)
c****************************************************************
c
c     generate unit vectors over sphere. used by surfac only.
c
c****************************************************************
      implicit REAL (a-h,o-z)
      dimension u(3,n)
      pi=4.d0*datan(1.d0)
      nequat = dsqrt(n * pi)
      nvert = nequat/2
      nu = 0
      do 20 i = 1,nvert+1
         fi = (pi * (i-1)) / nvert
         z = dcos(fi)
         xy = dsin(fi)
         nhor = nequat * xy
         if (nhor .lt. 1) nhor = 1
         do 10 j = 1,nhor
            fj = (2.d0 * pi * (j-1)) / nhor
            x = dcos(fj) * xy
            y = dsin(fj) * xy
            if (nu .ge. n) go to 30
            nu = nu + 1
            u(1,nu) = x
            u(2,nu) = y
            u(3,nu) = z
   10    continue
   20 continue
   30 continue
      n = nu
      return
      end
      subroutine geout(mode1)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
**********************************************************************
*
*   geout prints the current geometry.  it can be called any time,
*         from any point in the program and does not affect anything.
*
**********************************************************************
      common /cmpg/ geo(3,numatm)
      common /geokst/ natoms,labels(numatm),
     1na(numatm),nb(numatm),nc(numatm)
      common /geovar/ nvar,loc(2,maxpar),idumy,xparam(maxpar)
      common /path/ latom,lparam,react(200)
      common /densty/ p(mpack),pa(mpack),pb(mpack)
      common /corec/ core(107)
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),
     1                nlast(numatm), norbs, nelecs,nalpha,nbeta,
     2                nclose,nopen,ndumy,fract
      common /keywrd/ keywrd
      common /titles/ koment,title
      common /atomtx/ ltxt, txtatm(numatm)
      common /geosym/ ndep,locpar(maxpar),idepfn(maxpar),
     1                     locdep(maxpar)
      common /elemts/ elemnt(107)
      common/iofile/mfgr,mfgw
      dimension coord(3,numatm), q2(numatm), loctmp(2,maxpar)
      character q(3)*2, elemnt*2, flag1*2, flag0*2, flagn*2, txtatm*8
      character keywrd*241, koment*81, title*81, blank*80, ltxt*1
      logical cart
      mode=mode1
      if(mode.eq.1)then
         flag1=' *'
         flag0='  '
         flagn=' +'
         iprt=mfgw
      else
         flag1=' 1'
         flag0=' 0'
         flagn='-1'
         iprt=iabs(mode)
      endif
c
c *** output the parameter data.
c
      cart=.false.
      if(na(1).ne.0) then
         cart=.true.
         call mopxyz(geo,natoms,na,nb,nc,1.d0,coord)
         loctmp(1,1)=2
         loctmp(2,1)=1
         loctmp(1,2)=3
         loctmp(2,2)=1
         loctmp(1,3)=3
         loctmp(2,3)=2
         nvartm=0
         do 10 i=4,natoms
            nvartm=nvartm+3
            do 10 j=1,3
               loctmp(1,nvartm+j)=i
   10    loctmp(2,nvartm+j)=j
         nvartm=nvartm+3
      else
         do 20 i=1,nvar
            loctmp(1,i)=loc(1,i)
   20    loctmp(2,i)=loc(2,i)
         nvartm=nvar
         do 30 j=1,3
c$dout vbest
            do 30 i=1,natoms
   30    coord(j,i)=geo(j,i)
      endif
      degree=57.29577951d00
      maxtxt=ichar(ltxt)
      blank=' '
      if(mode.eq.1)then
         write (mfgw,40)blank(:max0(2,maxtxt-4)),
     1               blank(:max0(4,maxtxt-2)),
     2               blank(:max0(18,maxtxt+12))
   40    format (/4x,'atom',3x,'chemical',a ,'bond length',4x,'bond angl
     1e',4x ,' twist angle',/3x,'number',2x,'symbol', a,'(angstroms)',5
     2x,'(degrees)',5x,' (degrees)',/4x,'(i)',a,'na:i',10x,'nb:na:i',5
     3x,' nc:nb:na:i',5x,'na',3x,'nb',3x,'nc',/)
      else
         if(mode.gt.0)call wrttxt(iprt)
      endif
      if(mode.ne.1)then
         call chrge(p,q2)
         do 50 i=1,numat
            l=nat(i)
   50    q2(i)=core(l) - q2(i)
      endif
      n=1
      ia=loctmp(1,1)
      ii=0
      do 80 i=1,natoms
         do 60 j=1,3
            q(j)=flag0
            if (ia.ne.i) go to 60
            if (j.ne.loctmp(2,n).or.n.gt.nvartm) go to 60
            q(j)=flag1
            n=n+1
            ia=loctmp(1,n)
   60    continue
         w = coord(2,i) * degree
         x = coord(3,i) * degree
c
c  constrain angle to domain 0 - 180 degrees
c
         w=w - aint(w/360.d0)*360.d0
         if(w.lt.0)w=w+360.d0
         if(w .gt. 180.d0) then
            x=x+180.d0
            w=360.d0-w
         endif
c
c  constrain dihedral to domain -180 - 180 degrees
c
         x=x - aint(x/360.d0+dsign(0.5d0-1.d-9,x)-1.d-9)*360.d0
         if (latom.ne.i) go to 70
         j=lparam
         q(j)=flagn
   70    continue
         blank=elemnt(labels(i))//txtatm(i)//'  '
         if(mode.ne.1)then
            j=max0(4,maxtxt+2)
            k=max0(0,8-j)
         else
            j=max0(9,maxtxt+3)
         endif
         if(labels(i).ne.0)then
            if(mode.ne.1)then
               if(labels(i).ne.99.and.labels(i).ne.107)then
                  ii=ii+1
                  write (iprt,'(1x,a,f11.7,1x,a2,f14.6,1x,a2,f14.6,1x,
     1a2,3i5,a,f7.4)') blank(:j),coord(1,i),q(1),w,q(2),x,q(3),
     2na(i),nb(i),nc(i),blank(20:20+k),q2(ii)
               else
                  write (iprt,'(1x,a,f11.7,1x,a2,f14.6,1x,a2,f14.6,1x,
     1a2,3i5)') blank(:j),coord(1,i),q(1),w,q(2),x,q(3),
     2na(i),nb(i),nc(i)
               endif
            elseif(i.gt.3)then
            write (mfgw,'(3x,i4 ,5x,a,f9.5,1x,a2,f14.5,1x,a2,f11.5,1x,
     1a2,i4,2i5)') i,blank(:j),coord(1,i),q(1),w,q(2),x,q(3),
     2na(i),nb(i),nc(i)
            elseif(i.eq.3)then
            write (mfgw,'(''      3'',5x,a,f9.5,1x,a2,f14.5,1x,a2,13x,
     12i5)') blank(:j),coord(1,3),q(1),w,q(2),na(3),nb(3)
            elseif(i.eq.2)then
            write (mfgw,'(''      2'',5x,a,f9.5,1x,a2,30x,i5)')
     1 blank(:j),coord(1,2),q(1),na(2)
            else
            write (mfgw,'(''      1'',5x,a)') blank(:j)
            endif
         endif
   80 continue
      if(cart) na(1)=99
      if(mode.eq.1) return
      write (iprt,*)
      if(ndep.eq.0) return
c
c   output symmetry data.
c
      i=1
   90 j=i
  100 if(j.eq.ndep) goto 110
      if(locpar(j).eq.locpar(j+1).and.idepfn(j).eq.idepfn(j+1)
     1.and.j-i.lt.15)then
         j=j+1
         goto 100
      else
         write(iprt,'(i4,i3,i5,15i4)')
     1locpar(i),idepfn(i),(locdep(k),k=i,j)
      endif
      i=j+1
      goto 90
  110 continue
      write(iprt,'(i4,i3,i5,15i4)')
     1locpar(i),idepfn(i),(locdep(k),k=i,j)
      return
      end
      subroutine geoutg(iprt,style)
      implicit REAL (a-h,o-z)
      logical style
INCLUDE(common/sizes)
      common /geokst/ natoms,labels(numatm),
     1                na(numatm),nb(numatm),nc(numatm)
      common /geovar/ nvar,loc(2,maxpar),idumy,dumy(maxpar)
      common /simbol/ simbol(maxpar)
      common /geosym/ ndep,locpar(maxpar),idepfn(maxpar),locdep(maxpar)
      common /atomtx/ ltxt, txtatm(numatm)
      common /cmpg/ geo(3,numatm)
************************************************************************
*
*   geoutg writes out the geometry in gaussian-8x (style = .false.)
*   or gamess-uk style (style=.true)
*
************************************************************************
      dimension igeo(3,numatm)
      character line(3,numatm)*15, type(3)*1, optdat(maxpar)*14
      character txtatm*8, blank*80, elemnt(107)*2, simbol*10, ltxt*1
      data elemnt/' h','he',
     1 'li','be',' b',' c',' n',' o',' f','ne',
     2 'na','mg','al','si',' p',' s','cl','ar',
     3 ' k','ca','sc','ti',' v','cr','mn','fe','co','ni','cu',
     4 'zn','ga','ge','as','se','br','kr',
     5 'rb','sr',' y','zr','nb','mo','tc','ru','rh','pd','ag',
     6 'cd','in','sn','sb','te',' i','xe',
     7 'cs','ba','la','ce','pr','nd','pm','sm','eu','gd','tb','dy',
     8 'ho','er','tm','yb','lu','hf','ta',' w','re','os','ir','pt',
     9 'au','hg','tl','pb','bi','po','at','rn',
     1 'fr','ra','ac','th','pa',' u','np','pu','am','cm','bk','cf','xx',
     2 'fm','md','cb','++',' +','--',' -','tv'/
      data type/'r','a','d'/
      do 10 i=1,natoms
         do 10 j=1,3
   10 igeo(j,i)=-1
      do 20 i=1,nvar
   20 igeo(loc(2,i),loc(1,i))=-2
      do 30 i=1,ndep
         if(idepfn(i).eq.14)then
            igeo(3,locdep(i))=-locpar(i)
         else
            if(idepfn(i).gt.3) goto 30
            igeo(idepfn(i),locdep(i))=locpar(i)
         endif
   30 continue
      open(unit=21,status='scratch')
      degree=90.d0/dasin(1.d0)
      maxtxt=ichar(ltxt)
      nopt=0
           if(style) write (iprt,'(a)')'zmatrix angstrom'
      do 50 i=1,natoms
         do 40 j=1,3
            line(j,i)=' '
            if(igeo(j,i).eq.-1)then
               rewind 21
               if(j.ne.1)then
                  write(21,'(f12.6)')geo(j,i)*degree
               else
                  write(21,'(f12.6)')geo(j,i)
               endif
               rewind 21
               read(21,'(a)')line(j,i)
            elseif(igeo(j,i).eq.-2)then
               nopt=nopt+1
               if(simbol(nopt).ne.'---')then
               if(simbol(nopt)(1:1).eq.'-') then
                 line(j,i)(4:)=simbol(nopt)(2:)
               else
                 line(j,i)(4:)=simbol(nopt)
               endif
               else
                  nbi=nb(i)
                  nci=nc(i)
                  if(j.ne.3)nci=0
                  if(j.eq.1)nbi=0
                  call xxx(type(j),i,na(i),nbi,nci,line(j,i)(4:))
               endif
               optdat(nopt)=line(j,i)
            elseif(igeo(j,i).lt.0)then
               line(3,i)=line(3,-igeo(j,i))
               line(3,i)(3:3)='-'
            else
               line(j,i)=line(j,igeo(j,i))
            endif
   40    continue
         blank=elemnt(labels(i))//txtatm(i)//'  '
         if(labels(i).eq.99)blank(1:1)=' '
         j=max0(4,maxtxt+2)
         if(i.eq.1)then
            write(iprt,'(1x,a,i4,a,i4,a,i4,a,i4)')blank(:j)
         elseif(i.eq.2)then
            write(iprt,'(1x,a,i4,a,i4,a,i4,a,i4)')blank(:j),na(i),line(1
     1,i)
         elseif(i.eq.3)then
            write(iprt,'(1x,a,i4,a,i4,a,i4,a,i4)')blank(:j),
     1na(i),line(1,i),nb(i), line(2,i)
         else
            l=0
            write(iprt,'(1x,a,i4,a,i4,a,i4,a,i4)')blank(:j),
     1na(i),line(1,i),nb(i), line(2,i), nc(i), line(3,i), l
         endif
   50 continue
      if (style) then
       write(iprt,'(a)')'variables'
      else
       write(iprt,*)
      endif
      do 70 l=1,3
         do 60 i=1,nopt
            if(loc(2,i).eq.l)then
               if(loc(2,i).ne.1)then
                  write(iprt,'(a,f12.6)')optdat(i),geo(loc(2,i),loc(1,i)
     1)*degree
               else
                  write(iprt,'(a,f12.6)')optdat(i),geo(loc(2,i),loc(1,i)
     1)
               endif
            endif
   60    continue
   70 continue
      if (style) write(iprt,'(a)')'end'
      end
_IFN(ipsc,tools)
      subroutine getdat(gamess)
      implicit REAL (a-h,o-z)
      logical gamess
      common / readme / ird
      common/iofile/iread,iwrite
      character line*80
************************************************************************
*
*   getdat reads all the data in on channel iread, and writes 
*   it to scratch channel 99.  this way the input data-set is 
*   freed up as soon as  the job starts.
*
************************************************************************
      data i,iiread/0,0/
      save i,iiread
c
      ird = 99
      open(unit=ird,form='formatted',status='scratch')
c
c  close unit 5 in case it was already pre-assigned.
c
c     close (5)
c     open(unit=ird,form='formatted',status='scratch')
c     rewind 5
      rewind ird
c  10 read(5,'(a80)',end=20,err=20)line
      rewind iread
   10 read(iread,'(a80)',end=20,err=20)line
      iiread = iiread + 1
      if(index(line,'mopac').eq.0) go to 10
c  30 read(5,'(a80)',end=20,err=20)line
   30 read(iread,'(a80)',end=20,err=20)line
      if(index(line(1:10),'gamess').eq.0) go to 35
      gamess = .true.
      rewind iread
      do 37 loop = 1,iiread+1
   37 read(iread,'(a80)')line
      goto 20
c   re-position gamess input file
   35 iiread = iiread + 1
      i=i+1
       call lcase(line(1:80))
      write(ird,'(a80)')line
      goto 30
   20 rewind ird
      if(i.lt.3)then
         write(6,'(a)')' input file missing or empty'
         call caserr('input file missing or empty')
      endif
c     close (2)
      return
      end
_ELSE
_IF(ipsc)
      subroutine getdat(gamess)
      implicit REAL (a-h,o-z)
      logical gamess,oroot
      common/nodinf/mpid,minode,mihost,dim,nnodes
      common / readme / ird
      common/iofile/iread,iwrite
      character line*80
************************************************************************
*
*   getdat reads all the data in on channel iread, and writes 
*   it to scratch channel 99.  this way the input data-set is 
*   freed up as soon as  the job starts.
*
************************************************************************
      data i,iiread/0,0/
      save i,iiread
c
      ird = 99
      if(oroot()) then
      print *,' just opened datain  for node ',minode
      open(unit=ird,form='formatted',status='unknown',file='datain')
      rewind ird
   30 read(5,'(a80)',end=20,err=20)line
      i=i+1
      write(ird,'(a80)')line
      goto 30
   20 rewind ird
      if(i.lt.3)then
         write(6,'(a)')' input file missing or empty'
         call caserr('input file missing or empty')
      endif
      endif
c
      call gsync
c
      if(.not.oroot()) then
        open(unit=ird,iostat=ioerr,form='formatted',access='sequential',
     * status='unknown',file='datain')
        if(ioerr.ne.0) call caserr(
     + 'error opening  data input file')
        print *,' just opened datain  for node ',minode
        rewind ird
      endif
c
      call gsync
      return
      end
_ELSE
      subroutine getdat(gamess)
      implicit REAL  (a-h,p-w),integer   (i-n),logical    (o)
      implicit character *8 (z),character *1 (x)
      implicit character *4 (y)
      logical gamess
      common/nodinf/mpid,minode,mihost,ldim,nnodes
      common / readme / ird
      common/iofile/iread,iwrite
      character *10 chpid
      character *80 rec80,ginput
      integer pid,getpid
      dimension ibuff(80)
************************************************************************
*
*   getdat reads all the data in on channel iread, and writes 
*   it to scratch channel 99.  this way the input data-set is 
*   freed up as soon as  the job starts.
*
************************************************************************
      data irec/0/
      save irec
c
      ird = 99
c
c --- write a copy of the input to unit ird
c
      pid=getpid()
      write(chpid,'(i10)')pid
      do 1020 i=1,10
      if(chpid(i:i).ne.' ') then
      length=i
      go to 1030
      endif
1020  continue
1030  ginput='mopac_input.'//chpid(length:10)
      open(unit=ird,form='formatted',file=ginput,status='unknown')
c
      call synch(22222)
c
c broadcast input file
c
 1060 continue
      if(oroot())then
         read(iread,1080,end=1091) rec80
         do 10 i=1,nnodes-1
            call chtoi(ibuff(1),rec80)
            call snd(150,ibuff,80*4,i,0)
 10      continue
      else
         call rcv(150,ibuff,80*4,il,0,if,0)
         if(ibuff(1).eq.0)goto 1090
         call itoch(ibuff(1),rec80)
      endif
      write(ird,1080)rec80
      irec = irec + 1
      go to 1060
1080  format(a80)
 1091 continue
      ibuff(1)=0
      do 11 i=1,nnodes-1
         call snd(150,ibuff,80*4,i,0)
 11   continue
 1090 continue
      if(irec.lt.3)then
         write(6,'(a)')' input file missing or empty'
         call caserr('input file missing or empty')
      endif
      call synch(33333)
      rewind ird
      return
      end
_ENDIF
_ENDIF
      subroutine getgeg(iread,labels,geo,lopt,na,nb,nc,ams,natoms,int)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      dimension geo(3,*),na(*),nb(*),nc(*),ams(*), lopt(3,*)
     1,labels(*)
      common /geosym/ ndep, locpar(maxpar), idepfn(maxpar),
     1                locdep(maxpar)
      common /simbol/ simbol(maxpar)
      common /atmass/ atmass(numatm)
      common /atomtx/ ltxt, txtatm(numatm)
      common /geovar/ nvar, loc(2,maxpar), idumy, xparam(maxpar)
      common/iofile/mfgr,mfgw
      dimension istart(20), lgeo(3,100)
      character line*80, tgeo(3,100)*12, txtatm*8, string*80, simbol*10
      logical leadsp, int
      character elemnt(107)*2, ltxt*1
      data (elemnt(i),i=1,107)/' h','he',
     1 'li','be',' b',' c',' n',' o',' f','ne',
     2 'na','mg','al','si',' p',' s','cl','ar',
     3 'k ','ca','sc','ti',' v','cr','mn','fe','co','ni','cu',
     4 'zn','ga','ge','as','se','br','kr',
     5 'rb','sr',' y','zr','nb','mo','tc','ru','rh','pd','ag',
     6 'cd','in','sn','sb','te',' i','xe',
     7 'cs','ba','la','ce','pr','nd','pm','sm','eu','gd','tb','dy',
     8 'ho','er','tm','yb','lu','hf','ta',' w','re','os','ir','pt',
     9 'au','hg','tl','pb','bi','po','at','rn',
     1 'fr','ra','ac','th','pa','u','np','pu','am','cm','bk','cf','xx',
     2 'fm','md','cb','++',' +','--',' -','tv'/
      nerr=0
      int=.true.
      numat=0
      na(1)=0
      nb(1)=0
      nc(1)=0
      nb(2)=0
      nc(2)=0
      nc(3)=0
      maxtxt=0
      do 60 natoms=1,100
         read(iread,'(a)',end=70,err=70)line
         if(line.eq.' ')goto 70
c
c   see if text is associated with this element
c
         i=index(line,'(')
         if(i.ne.0)then
c
c  yes, element is labelled.
c
            k=index(line,')')
            txtatm(natoms)=line(i:k)
            maxtxt=max0(maxtxt,k-i+1)
            string=line(1:i-1)//line(k+1:)
            line=string
         else
            txtatm(natoms)=' '
         endif
************************************************************************
         do 10 i=1,80
            iline=ichar(line(i:i))
            if(iline.ge.ichar('a').and.iline.le.ichar('z')) then
               line(i:i)=char(iline+ichar('a')-ichar('a'))
            endif
   10    continue
************************************************************************
         nvalue=0
         leadsp=.true.
         do 20 i=1,80
            if (leadsp.and.line(i:i).ne.' ') then
               nvalue=nvalue+1
               istart(nvalue)=i
            end if
            leadsp=(line(i:i).eq.' ')
   20    continue
         do 30 j=1,107
   30    if(index(' '//line(istart(1):istart(1)+2),elemnt(j)//' ').ne.0)
     1 goto 40
         if(index(' '//line(istart(1):istart(1)+2),' x').ne.0) then
            j=99
            goto 40
         endif
         write(mfgw,'(2a)')' element not recognized: ',
     1line(istart(1):istart(1)+2)
         nerr=nerr+1
   40    labels(natoms)=j
         if(j.ne.99)then
            numat=numat+1
            atmass(numat)=reada(line(1:max0(istart(2)-1,1)),istart(1))
            if(atmass(numat).gt.1.d-15)then
               write(mfgw,'('' for atom'',i4,''  isotopic mass:''
     1    ,f15.5)')natoms, atmass(numat)
            else
               atmass(numat)=ams(j)
            endif
c#         write(6,*)natoms,numat,atmass(numat)
         endif
         tgeo(1,natoms)=' '
         tgeo(2,natoms)=' '
         tgeo(3,natoms)=' '
         if(natoms.eq.1) goto 50
         na(natoms)=reada(line,istart(2))
         call getval(line(istart(3):),geo(1,natoms),tgeo(1,natoms))
         if(natoms.eq.2) goto 50
         nb(natoms)=reada(line,istart(4))
         call getval(line(istart(5):),geo(2,natoms),tgeo(2,natoms))
         if(natoms.eq.3) goto 50
         nc(natoms)=reada(line,istart(6))
         call getval(line(istart(7):),geo(3,natoms),tgeo(3,natoms))
   50    continue
   60 continue
   70 natoms=natoms-1
      do 80 i=1,natoms
         do 80 j=1,3
   80 lgeo(j,i)=-1
      ivar=-1
      nvar=0
      ndep=0
      kerr=0
   90 read(iread,'(a)',end=180,err=180)line
      if(line.eq.' ')then
         if(ivar.eq.-1)then
            merr=0
            do 110 i=1,natoms
               do 100 j=1,3
  100          if(geo(j,i).lt.-998)merr=merr+1
  110       continue
c
c  if all symbols are defined, then do not read 'fixed' symbols
c
            if(merr.eq.0) goto 180
            ivar=nvar
            goto 90
         else
            goto 180
         endif
      endif
************************************************************************
      do 120 i=1,80
         iline=ichar(line(i:i))
         if(iline.ge.ichar('a').and.iline.le.ichar('z')) then
            line(i:i)=char(iline+ichar('a')-ichar('a'))
         endif
  120 continue
************************************************************************
      do 130 i=1,80
  130 if(line(i:i).ne.' ')goto 140
  140 do 150 l=i,i+12
  150 if(line(l:l).eq.' ')goto 160
  160 sum=reada(line,l)
      n=0
      lerr=0
      do 170 j=1,natoms
         do 170 k=1,3
            if(tgeo(k,j).eq.line(i:l) .or.
     1tgeo(k,j)(2:).eq.line(i:l).and.tgeo(k,j)(1:1).eq.'-')then
               if(lgeo(k,j).ne.-1)lerr=1
               lgeo(k,j)=lgeo(k,j)+1
               n=n+1
               geo(k,j)=sum
               if(n.eq.1)then
                  nvar=nvar+1
                  loc(1,nvar)=j
                  loc(2,nvar)=k
                  xparam(nvar)=sum
                  simbol(nvar)=tgeo(k,j)
                  if(simbol(nvar)(1:1).eq.'-')then
      write(mfgw,'(a)')' negative symbolics must be preceeded by '
     +//' the positive equivalent'
               write(mfgw,'(a)')' faulty symbolic:  '//simbol(nvar)
_IF(ipsc,tools)
                 call pend
_ELSE
                 stop
_ENDIF
               endif
               endif
               if(n.gt.1)then
                  ndep=ndep+1
                  locpar(ndep)=loc(1,nvar)
                  idepfn(ndep)=loc(2,nvar)
                  if(tgeo(k,j)(1:1).eq.'-')then
                     idepfn(ndep)=14
                     if(loc(2,nvar).ne.3) then
                        kerr=kerr+1
                     write(mfgw,'(2a)')' only dihedral symbolics can be'
     1//' preceeded by a "-" sign'
                     endif
                  endif
                  locdep(ndep)=j
               endif
            endif
  170 continue
      kerr=kerr+lerr
      if(lerr.eq.1)then
      write(mfgw,'(2a)')' the following symbol has been defined more'//
     1' than once:',line(i:l)
         nerr=nerr+1
      endif
      if(n.eq.0)then
      write(mfgw,'(2a)')' the following symbolic was not used:',line(i:l
     1)
         nerr=nerr+1
      endif
      goto 90
  180 continue
      merr=0
      do 200 i=1,natoms
         do 190 j=1,3
  190    if(geo(j,i).lt.-998)merr=merr+1
c#     write(6,'(2x,a,3f12.6,3i4)')elemnt(labels(i)),
c#     1(geo(j,i),j=1,3), na(i), nb(i), nc(i)
  200 continue
      if(merr.ne.0)write(mfgw,'(i4,a)')merr, 
     +  ' geometry variables were not'//' defined'
      if(merr+kerr+nerr.ne.0)then
         write(mfgw,'(a,i3,a)')
     1' the geometry data-set contained',merr+kerr+nerr,' errors'
_IF(ipsc,tools)
         call pend
_ELSE
         stop
_ENDIF
      endif
c
c  sort parameters to be optimized into increasing order of atoms
c
      if(ivar.ne.-1)nvar=ivar
      do 230 i=1,nvar
         j=100000
         do 210 l=i,nvar
            if(j.gt.loc(1,l)*4+loc(2,l))then
               k=l
               j=loc(1,l)*4+loc(2,l)
            endif
  210    continue
         string(1:10)=simbol(i)
         simbol(i)=simbol(k)
         simbol(k)=string
         sum=xparam(i)
         xparam(i)=xparam(k)
         xparam(k)=sum
         do 220 j=1,2
            l=loc(j,i)
            loc(j,i)=loc(j,k)
  220    loc(j,k)=l
  230 continue
c#      if(nvar.ne.0)
c#     + write(mfgw,'(//,''    parameters to be optimized'')')
      degree=dasin(1.d0)/90
      do 240 i=1,nvar
c#      write(6,'(2i6,f12.6)')loc(1,i),loc(2,i),xparam(i)
  240 if(loc(2,i).ne.1)xparam(i)=xparam(i)*degree
c#      if(ndep.ne.0)write(6,'(//,''   symmetry functions  '')')
c#      do 28 i=1,ndep
c#   28 write(6,'(3i6)')locpar(i),idepfn(i),locdep(i)
      ltxt=char(maxtxt)
      return
      end
      subroutine getgeo(iread,labels,geo,lopt,na,nb,nc,ams,natoms,int)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      dimension geo(3,*),na(*),nb(*),nc(*),ams(*), lopt(3,*)
     1,labels(*)
      logical int
************************************************************************
*
*   getgeo reads in the geometry. the element is specified by it's
*          chemical symbol, or, optionally, by it's atomic number.
*
*  on input   iread  = channel number for read, normally 5
*             ams    = default atomic masses.
*
* on output labels = atomic numbers of all atoms, including dummies.
*           geo    = internal coordinates, in angstroms, and degrees.
*           lopt   = integer array, a '1' means optimize this parameter,
*                    '0' means do not optimize, and a '-1' labels the
*                    reaction coordinate.
*           na     = integer array of atoms (see data input)
*           nb     = integer array of atoms (see data input)
*           nc     = integer array of atoms (see data input)
*           atmass = atomic masses of atoms.
************************************************************************
      common /path/ idum(2),react(3,66), dumm1,dumm2
      common /simbol/ simbol(maxpar)
      common /atmass/ atmass(numatm)
      common /atomtx/ ltxt, txtatm(numatm)
      common /keywrd/ keywrd
      common/iofile/mfgr,mfgw
      dimension istart(40), xyz(3,numatm), value(4), abc(3,numatm)
      logical leadsp, ircdrc
      character keywrd*241, txtatm*8, simbol*10, ltxt*1
      character elemnt(107)*2, line*80, space*1, nine*1,zero*1,
     1tab*1, comma*1, string*80, ele*2, turn*1
      save elemnt, comma, space, nine, zero
      data (elemnt(i),i=1,107)/'h','he',
     1 'li','be','b','c','n','o','f','ne',
     2 'na','mg','al','si','p','s','cl','ar',
     3 'k','ca','sc','ti','v','cr','mn','fe','co','ni','cu',
     4 'zn','ga','ge','as','se','br','kr',
     5 'rb','sr','y','zr','nb','mo','tc','ru','rh','pd','ag',
     6 'cd','in','sn','sb','te','i','xe',
     7 'cs','ba','la','ce','pr','nd','pm','sm','eu','gd','tb','dy',
     8 'ho','er','tm','yb','lu','hf','ta','w','re','os','ir','pt',
     9 'au','hg','tl','pb','bi','po','at','rn',
     1 'fr','ra','ac','th','pa','u','np','pu','am','cm','bk','cf','xx',
     2 'fm','md','cb','++','+','--','-','tv'/
      data comma,space,nine,zero/',',' ','9','0'/
      tab=char(9)
      ircdrc=(index(keywrd,'irc')+index(keywrd,'drc') .ne.0)
      ilowa = ichar('a')
      ilowz = ichar('z')
      icapa = ichar('a')
      icapz = ichar('z')
      maxtxt=0
      natoms=0
      numat=0
      iserr=0
      do 10 i=1,maxpar
   10 simbol(i)= '---'
   20 read(iread,'(a)',end=130,err=230)line
      if(line.eq.' ') go to 130
      natoms=natoms+1
c
c   see if text is associated with this element
c
      i=index(line,'(')
      if(i.ne.0)then
c
c  yes, element is labelled.
c
         k=index(line,')')
         txtatm(natoms)=line(i:k)
         maxtxt=max0(maxtxt,k-i+1)
         string=line(1:i-1)//line(k+1:)
         line=string
      else
         txtatm(natoms)=' '
      endif
*   clean the input data
************************************************************************
      do 30 i=1,80
         iline=ichar(line(i:i))
         if(iline.ge.ilowa.and.iline.le.ilowz) then
            line(i:i)=char(iline+icapa-ilowa)
         endif
   30 continue
************************************************************************
      icomma=ichar(comma)
      itab=ichar(tab)
      do 40 i=1,80
         khar=ichar(line(i:i))
         if(khar.eq.icomma.or.khar.eq.itab)line(i:i)=space
   40 continue
*
*   initialize istart to interpret blanks as zero's
      do 50 i=1,10
   50 istart(i)=80
*
* find initial digit of all numbers, check for leading spaces followed
*     by a character and store in istart
      leadsp=.true.
      nvalue=0
      do 60 i=1,80
         if (leadsp.and.line(i:i).ne.space) then
            nvalue=nvalue+1
            istart(nvalue)=i
         end if
         leadsp=(line(i:i).eq.space)
   60 continue
*
* establish the element's name and isotope, check for errors or e.o.data
*
      weight=0.d0
      string=line(istart(1):istart(2)-1)
      if( string(1:1) .ge. zero .and. string(1:1) .le. nine) then
*  atomic number used: no isotope allowed
         label=reada(string,1)
         if (label.eq.0) go to 120
         if (label.lt.0.or.label.gt.107) then
            write(mfgw,'(''  illegal atomic number'')')
            go to 240
         end if
         go to 80
      end if
*  atomic symbol used
      real=dabs(reada(string,1))
      if (real.lt.1.d-15) then
*   no isotope
         ele=string(1:2)
      else
         weight=real
         if( string(2:2) .ge. zero .and. string(2:2) .le. nine) then
            ele=string(1:1)
         else
            ele=string(1:2)
         end if
      end if
*   check for error in atomic symbol
      if(ele(1:1).eq.'-'.and.ele(2:2).ne.'-')ele(2:2)=' '
      do 70 i=1,107
         if(ele.eq.elemnt(i)) then
            label=i
            go to 80
         end if
   70 continue
      if(ele(1:1).eq.'x')then
         label=99
         goto 80
      endif
      write(mfgw,'(''  unrecognized element name: ('',a,'')'')')ele
      goto 240
*
* all o.k.
*
   80 if (label.ne.99) numat=numat+1
      if(weight.ne.0.d0)then
         write(mfgw,'('' for atom'',i4,''  isotopic mass:''
     1    ,f15.5)')natoms, weight
         atmass(numat)=weight
      else
         if(label .ne. 99)  atmass(numat)=ams(label)
      endif
      if(natoms.gt.numatm)then
      write(mfgw,'(//10x,''****  max. number of atoms allowed:'',i4)')
     1numatm
_IF(ipsc,tools)
         call pend
_ELSE
         stop
_ENDIF
      endif
      labels(natoms)   =label
      geo(1,natoms)    =reada(line,istart(2))
      geo(2,natoms)    =reada(line,istart(4))
      geo(3,natoms)    =reada(line,istart(6))
      if(ircdrc)then
         turn=line(istart(3):istart(3))
         if(turn.eq.'t')then
            lopt(1,natoms)=1
         if(natoms.eq.1)write(mfgw,'(a)')' in drc monitor potential ener
     1gy'//' turning points'
         else
            lopt(1,natoms)=0
         endif
         turn=line(istart(5):istart(5))
         if(turn.eq.'t')then
            lopt(2,natoms)=1
         else
            lopt(2,natoms)=0
         endif
         turn=line(istart(7):istart(7))
         if(turn.eq.'t')then
            lopt(3,natoms)=1
         else
            lopt(3,natoms)=0
         endif
      else
         lopt(1,natoms)   =reada(line,istart(3))
         lopt(2,natoms)   =reada(line,istart(5))
         lopt(3,natoms)   =reada(line,istart(7))
         do 90 i=3,7,2
            if(ichar(line(istart(i):istart(i))).ge.icapa.and.
     1ichar(line(istart(i):istart(i))).le.icapz)iserr=1
   90    continue
      endif
      na(natoms)       =reada(line,istart(8))
      nb(natoms)       =reada(line,istart(9))
      nc(natoms)       =reada(line,istart(10))
c
c  special case of users forgetting to add dihedral data for atom 3
c
      if(natoms.eq.3)then
         if(lopt(3,3).eq.2)then
            na(3)=1
            nb(3)=2
            geo(3,3)=0.d0
            lopt(3,3)=0
         elseif(lopt(3,3).eq.1.and.dabs(geo(3,3)-2.d0).lt.1.d-4)then
            na(3)=2
            nb(3)=1
            geo(3,3)=0.d0
            lopt(3,3)=0
         endif
      endif
      if(lopt(1,natoms).gt.1.or.lopt(2,natoms).gt.1.or.
     1lopt(3,natoms).gt.1)iserr=1
      if(iserr.eq.1) then
c
c  must be gaussian geometry input
c
         do 110 i=2,natoms
            do 110 k=1,3
               j=geo(k,i)+0.4d0
               if(dabs(geo(k,i)-j).gt.1.d-5)then
c
c   geometry cannot be gaussian
c
               write(mfgw,'(a)')' geometry is faulty.  geometry read in
     1is'
                  const=3.141592653598d0/180.d0
                  do 100 l=1,natoms
                     geo(2,l)=geo(2,l)*const
  100             geo(3,l)=geo(3,l)*const
                  call geout(6)
_IF(ipsc,tools)
                  call pend
_ELSE
                  stop
_ENDIF
               endif
  110    continue
         natoms=-1
         return
      endif
      goto 20
*
* all data read in, clean up and return
*
  120 natoms=natoms-1
  130 na(2)=1
      ltxt=char(maxtxt)
      if(natoms.gt.3)then
         int=(na(4).ne.0)
      else
         if(geo(2,3).lt.10.and.natoms.eq.3)
     1write(mfgw,
     + '(//10x,'' warning: internal coordinates are assumed -'',/
     210x,'' for three-atom systems '',//)')
         int=.true.
      endif
      if(int)geo(2,2)=0
c
c     read in velocity vector, if present
c
      if(index(keywrd,'velo').gt.0)then
         if(int)then
         write(mfgw,'(a)')' coordinates must be cartesian when velocity'
     1//' vector is used.'
_IF(ipsc,tools)
            call pend
_ELSE
            stop
_ENDIF
         endif
c#      write(mfgw,'(/10x,a)')'initial velocity vector for drc'
         do 150 i=1,natoms
            read(5,'(a)') line
            call nuchar(line,value,ndmy)
            if(ndmy.ne.3)then
               write(mfgw,'(/10x,a)')
     1'  there must be exactly three velocity data per line'
_IF(ipsc,tools)
               call pend
_ELSE
               stop
_ENDIF
            endif
            do 140 j=1,3
  140       react(j,i+2)=value(j)
c#      write(6,'(2x,a2,2x,3f13.5)')elemnt(labels(i)),(value(j),j=1,3)
  150    continue
         do 160 i=1,3
            do 160 j=1,2
  160    react(i,j)=geo(i,j+1)-geo(i,1)
c
c  now to rotate velocity vector to suit internal coordinate definition
c
c
c   rotate around the 1-2 x-axis to as to eliminate react(3,2)
c   (put atom 2 in x-y plane)
         sa=react(3,1)/dsqrt(react(2,1)**2+react(3,1)**2+1.d-20)
         ca=dsign(dsqrt(1.d0-sa**2),react(2,1))
c#      labels(natoms+1)=1
c#      labels(natoms+2)=1
c#      write(6,*)' first rotation, about 1-2 x-axis'
         do 170 i=1,natoms+2
            temp1= react(2,i)*ca+react(3,i)*sa
            temp2=-react(2,i)*sa+react(3,i)*ca
            react(2,i)=temp1
            react(3,i)=temp2
c#      write(6,'(2x,a2,2x,3f13.5)')elemnt(labels(i)),(react(j,i),j=1,3)
  170    continue
c   rotate around the 1-2 z-axis to as to eliminate react(2,2)
c   (put atom 2 on x axis)
         ca=react(1,1)/dsqrt(react(2,1)**2+react(1,1)**2+1.d-20)
         sa=dsign(dsqrt(1.d0-ca**2),react(2,1))
c#      write(6,*)' second rotation, about 1-2 z-axis'
         do 180 i=1,natoms+2
            temp1= react(1,i)*ca+react(2,i)*sa
            temp2=-react(1,i)*sa+react(2,i)*ca
            react(1,i)=temp1
            react(2,i)=temp2
c#      write(6,'(2x,a2,2x,3f13.5)')elemnt(labels(i)),(react(j,i),j=1,3)
  180    continue
c   rotate around the 2-3 x-axis to as to eliminate react(3,3)
c   (put atom 3 on x-y plane)
         sa=react(3,2)/dsqrt(react(2,2)**2+react(3,2)**2+1.d-20)
         ca=dsign(dsqrt(1.d0-sa**2),react(2,2))
c#      write(6,*)' third rotation, about 2-3 x-axis'
         do 190 i=1,natoms+2
            temp1= react(2,i)*ca+react(3,i)*sa
            temp2=-react(2,i)*sa+react(3,i)*ca
            react(2,i)=temp1
            react(3,i)=temp2
c#      write(6,'(2x,a2,2x,3f13.5)')elemnt(labels(i)),(react(j,i),j=1,3)
  190    continue
c
c  strip off first two coordinates; these were the coordinate axis
c  definitions
c
         do 200 i=1,natoms
            do 200 j=1,3
  200    react(j,i)=react(j,i+2)
      endif
      if(  .not. int ) then
         do 210 i=1,natoms
            do 210 j=1,3
  210    xyz(j,i)=geo(j,i)
c geometry fix added by s.green - 15.3.91
         do 211 i=1,natoms
            do 211 j=1,3
  211    abc(j,i) = geo(j,i)
         degree=90.d0/dasin(1.d0)
         call mopxyz(xyz,natoms,na,nb,nc,degree,geo)
c geometry fix added by s.green - 15.3.91
c         if(index(keywrd,'fix') .ne. 0) then
c            do 212 i=1,natoms
c               geo(1,i)=abc(1,i)
c               geo(2,i)=abc(2,i) / 0.01745329252d00
c               geo(3,i)=abc(3,i) / 0.01745329252d00
c  212       continue
c         endif
         if(index(keywrd,' xyz').eq.0)then
c
c  unconditionally set flags for internal coordinates
c
            do 220 i=1,3
               do 220 j=i,3
  220       lopt(j,i)=0
         endif
         if(dabs(geo(2,3)-180.d0).lt.1.d-4.or.dabs(geo(2,3)).lt.1.d-4)
     1then
         write(mfgw,'(a)')' due to program bug, the first three atoms mu
     1st not lie in a straight line.'
_IF(ipsc,tools)
            call pend
_ELSE
            stop
_ENDIF
         endif
      elseif (.not.ircdrc) then
         lopt(2,2)=0
         if(lopt(1,1)+lopt(2,1)+lopt(3,1)+lopt(3,2)+
     1        lopt(3,3) .gt. 0)then
            lopt(1,1)=0
            lopt(2,1)=0
            lopt(3,1)=0
            lopt(3,2)=0
            lopt(3,3)=0
         write(mfgw,'(//10x,'' an unoptimizable geometric parameter has'
     1',/10x,'' been marked for optimization. this is a non-fatal ''
     2,''error'')')
         endif
      endif
      if(na(3).eq.0) then
         nb(3)=1
         na(3)=2
      endif
      return
* error conditions
  230 if(iread.eq.5) then
      write(mfgw,'( '' error during read at atom number '', i3 )')natoms
      else
         natoms=0
         return
      endif
  240 j=natoms-1
      write(mfgw,'('' data currently read in are '')')
      do 250 k=1,j
  250 write(mfgw,260)labels(k),(geo(jj,k),lopt(jj,k),jj=1,3),
     1na(k),nb(k),nc(k)
  260 format(i4,2x,3(f10.5,2x,i2,2x),3(i2,1x))
_IF(ipsc,tools)
      call pend
_ELSE
      stop
_ENDIF
      end
      function getmop(in)
c
c    this function is designed for use on a unix system.
c    gtnv will consult the environment
c    for the current alias of the character string contained in
c    'namein'.  the alias, if it exists, or the original name in namein
c    will be returned.
c
      character*(80) nameout, zdef1(60), zdef2(60),getmop
      data zdef1/
     *'fort.1', 'fort.2','restart','density','logfile','archive',
     *'DENSITY', 'sybyl', 'fort.9', 'fort.10','fort.11',
     *'fort.12','fort.13','fort.14','fort.16','fort.16','fort.17',
     *'fort.18','fort.19','fort.20','fort.21','fort.22','fort.23',
     *'fort.24','fort.25','fort.26','fort.27','fort.28','fort.29',
     *'fort.30','fort.31','fort.32','fort.33','fort.34','fort.35',
     *'fort.36','fort.37','fort.38','fort.39',
     *'fort.40','fort.41','fort.42','fort.43','fort.44','fort.45',
     *'fort.46','fort.47','fort.48','fort.49','fort.50','fort.51',
     *'fort.52','fort.53','fort.54','fort.55','fort.56','fort.57',
     *'fort.58','fort.59','fort.60'/
      data zdef2/
     *'ftn001','ftn002','restart','density','logfile','archive',
     *'DENSITY','sybyl','ftn009','ftn010','ftn011',
     *'ftn012','ftn013','ftn014','ftn015','ftn016','ftn017','ftn018',
     *'ftn019','ftn020','ftn021','ftn022','ftn023','ftn024','ftn025',
     *'ftn026','ftn027','ftn028','ftn029','ftn030','ftn031',
     *'ftn032','ftn033','ftn034','ftn035','ftn036','ftn037','ftn038',
     *'ftn039',
     *'ftn040','ftn041','ftn042','ftn043','ftn044','ftn045',
     *'ftn046','ftn047','ftn048','ftn049','ftn050','ftn051',
     *'ftn052','ftn053','ftn054','ftn055','ftn056','ftn057',
     *'ftn058','ftn059','ftn060'/
      nameout = ' '
      iunit = in
      call gtnv(zdef1(iunit),nameout)
      if(nameout.eq.' ')  then
       call gtnv(zdef2(iunit),nameout)
       if (nameout .eq. ' ') nameout = zdef1(iunit)
      endif
      do 10 loop = len(nameout), 1, -1
        if(nameout(loop:loop).ne.' ') goto 20
 10   continue
 20   getmop = nameout
      return
      end
      subroutine gtsymm
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      common / readme / ird
      common/iofile/mfgr,mfgw
      common /geosym/ ndep, locpar(maxpar), idepfn(maxpar),
     1                locdep(maxpar)
c***********************************************************************
c
c   gtsymm reads in the symmetry dependence relationships.
c
c   on exit     ndep    = number of symmetry relations.
c               locpar  = array of reference function indices.
c               idepfn  = array of reference atom locations.
c               locdep  = array of dependent atom locations.
c
c***********************************************************************
c
c     locdep is the atom whose coordinates depend on the coordinates of
c     locpar.
c     locpar is the atom whose coordinates are used to calculate those
c     of locdep
c     idepfn points to the particular function to be used (see nddo)
c
c***********************************************************************
      dimension ivalue(40),value(40)
      character  text(18)*60, line*80
      save text
      data text/
     1' bond length    is set equal to the reference bond length   ',
     2' bond angle     is set equal to the reference bond angle    ',
     3' dihedral angle is set equal to the reference dihedral angle',
     4' dihedral angle varies as  90 degrees - reference dihedral  ',
     5' dihedral angle varies as  90 degrees + reference dihedral  ',
     6' dihedral angle varies as 120 degrees - reference dihedral  ',
     7' dihedral angle varies as 120 degrees + reference dihedral  ',
     8' dihedral angle varies as 180 degrees - reference dihedral  ',
     9' dihedral angle varies as 180 degrees + reference dihedral  ',
     1' dihedral angle varies as 240 degrees - reference dihedral  ',
     2' dihedral angle varies as 240 degrees + reference dihedral  ',
     3' dihedral angle varies as 270 degrees - reference dihedral  ',
     4' dihedral angle varies as 270 degrees - reference dihedral  ',
     5' dihedral angle varies as - reference dihedral              ',
     6' bond length varies as half the reference bond length       ',
     7' bond angle varies as half the reference bond angle         ',
     8' bond angle varies as 180 degrees - reference bond angle    ',
     9' the user has to supply this function in depvar             '/
c
c title output
      write (mfgw,10)
   10 format (///5x,25hparameter dependence data//
     1'        reference atom      function no.    dependent atom(s)')
c
c input symmetry : function, referance parameter, and dependent atoms
c
      ndep=0
   20 read(ird,'(a)',end=70) line
      call nuchar(line,value,nvalue)
c   integer values
      do 30 i=1,nvalue
   30 ivalue(i)=value(i)
c   fill the locdep array
      if(nvalue.eq.0.or.ivalue(3).eq.0) go to 70
      do 40 i=3,nvalue
         if(ivalue(i).eq.0) goto 50
         ndep=ndep+1
         locdep(ndep)=ivalue(i)
         locpar(ndep)=ivalue(1)
         idepfn(ndep)=ivalue(2)
   40 continue
   50 ll=i-1
      write(mfgw,60)ivalue(1),ivalue(2),(ivalue(j),j=3,ll)
   60 format(i13,i19,i14,11i3,10(/,43x,12i3))
      go to 20
c
c clean up
   70 continue
      write(mfgw,80)
   80 format(/10x,'   descriptions of the functions used',/)
      do 120 j=1,18
         do 90 i=1,ndep
            if(idepfn(i).eq.j) goto 100
   90    continue
         goto 120
  100    write(mfgw,110)j,text(j)
  110    format(i4,5x,a)
  120 continue
      return
      end
      subroutine gettxt
      common / readme / ird
      common /keywrd/ keywrd
      common /titles/ koment,title
      common/iofile/mfgr,mfgw
      dimension is(3)
      character keywrd*241, koment*81, title*81, ch*1, ch2*1, filen*50
     +,getmop*80, oldkey*80
      is(1)=161
      is(2)=81
      is(3)=1
      keywrd=' '
      koment='    null  '
      title ='    null  '
      read(ird,'(a)',end=100,err=90)keywrd(:80)
      oldkey=keywrd
      call upcase(keywrd(1:80))
      if(index(keywrd,'setup').ne.0)then
         i=index(keywrd,'setup=')
         if(i.ne.0)then
            j=index(keywrd(i:),' ')
            filen=oldkey(i+6:i+j-1)
         else
            filen='setup'
         endif
         open(unit=4,file=getmop(12),
     +        status='unknown',form='formatted')
         rewind 4
         read(4,'(a)',end=40,err=40)keywrd(81:160)
         call upcase(keywrd(81:160))
         read(4,'(a)',end=10,err=10)keywrd(161:240)
         call upcase(keywrd(161:240))
   10    continue
         read(ird,'(a)',end=100,err=90)koment,title
      elseif(index(keywrd(1:80),' +') .ne.0)then
c
c  read second keyword line
c
         read(ird,'(a)',end=100,err=90)keywrd(81:160)
         oldkey=keywrd(81:160)
         call upcase(keywrd(81:160))
         if(index(keywrd(81:160),'setup').ne.0)then
            i=index(keywrd,'setup=')
            if(i.ne.0)then
               j=index(keywrd(i:),' ')
               filen=oldkey(i-74:i+j-80)
            else
               filen='setup'
            endif
            open(unit=4,file=getmop(12)
     +          ,status='unknown',form='formatted')
            rewind 4
            read(4,'(a)',end=20,err=20)keywrd(161:240)
            call upcase(keywrd(161:240))
   20       continue
         elseif(index(keywrd(81:160),' +') .ne.0)then
c
c  read third keyword line
c
            read(ird,'(a)',end=100,err=90)keywrd(161:240)
            call upcase(keywrd(161:240))
         endif
c
c  read title line
c
         read(ird,'(a)',end=100,err=90)koment,title
      elseif(index(keywrd(:80),'&').ne.0)then
         read(ird,'(a)',end=100,err=90)keywrd(81:160)
         oldkey=keywrd(81:160)
         call upcase(keywrd(81:160))
         if(index(keywrd(81:160),'setup').ne.0)then
            i=index(keywrd,'setup=')
            if(i.ne.0)then
               j=index(keywrd(i:),' ')
               filen=oldkey(i-74:i+j-80)
c               write(*,*)' <'//filen//'>'
c               stop
c               call pend
            else
               filen='setup'
            endif
            open(unit=4,file=getmop(12),
     +           status='unknown',form='formatted')
            rewind 4
            read(4,'(a)',end=30,err=30)keywrd(161:240)
            call upcase(keywrd(161:240))
            read(ird,'(a)',end=100,err=90)title
   30       continue
         elseif(index(keywrd(81:160),'&').ne.0)then
            read(ird,'(a)',end=100,err=90)keywrd(161:240)
         else
            read(ird,'(a)',end=100,err=90)title
         endif
      else
         read(ird,'(a)',end=100,err=90)koment,title
      endif
      goto 50
   40 write(mfgw,'(a)')' setup file missing or corrupt'
   50 do 80 j=1,3
         if(keywrd(is(j):is(j)) .ne. ' ') then
            ch=keywrd(is(j):is(j))
            keywrd(is(j):is(j))=' '
            do 60 i=is(j)+1,239
               ch2=keywrd(i:i)
               keywrd(i:i)=ch
               ch=ch2
               if(keywrd(i+1:i+2) .eq. '  ') then
                  keywrd(i+1:i+1)=ch
                  goto 70
               endif
   60       continue
         write(mfgw,'(a,i2,a)')' line',j,' of keywords does not have eno
     1ugh'
         write(mfgw,'(a)')' spaces for parsing.  please correct line.'
_IF(ipsc,tools)
            call pend
_ELSE
            stop
_ENDIF
   70       continue
         endif
   80 continue
      return
   90 write(mfgw,'(a)')' error in read of first three lines'
  100 continue
_IF(ipsc,tools)
         call pend
_ELSE
         stop
_ENDIF
      end
      subroutine getval(line,x,t)
      implicit REAL (a-h,o-z)
      character line*80, t*12, ch1*1, ch2*1
      ch1=line(1:1)
      ch2=line(2:2)
      if((ichar(ch1).lt.ichar('a').or.ichar(ch1).gt.ichar('z')) .and.
     1(ichar(ch2).lt.ichar('a').or.ichar(ch2).gt.ichar('z')))then
c
c   is a number
c
         x=reada(line,1)
         t=' '
      else
         i=index(line,' ')
         t=line(:i)
         x=-999.d0
      endif
      return
      end
      subroutine gmetry(geo,coord)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      common /geokst/ natoms,labels(numatm),
     1na(numatm),nb(numatm),nc(numatm)
      common /euler/ tvec(3,3), id
      common /reactn/ step, geoa(3,numatm), geovec(3,numatm),colcst
      common /geook/ igeook
      common /numcal/ numcal
      common /keywrd/ keywrd
      common/iofile/mfgr,mfgw
      dimension geo(3,*),coord(3,*)
      character *15 ndimen(4), keywrd*241
      logical geook
      save icalcn, ndimen, geook
      data icalcn/0/
      data ndimen/' molecule     ',' polymer       ',
     1'layer structure',' solid         '/
c***********************************************************************
c
c    gmetry  computes coordinates from bond-angles and lengths.
c *** it is adapted from the program written by m.j.s. dewar.
c
c     three separate options exist within gmetry. these are:
c    (a) if na(1) is equal to 99 (impossible under normal circumstances)
c        then geo is assumed to be in cartesian rather than internal
c        coordinates, and coord is then set equal to geo.
c    (b) if step is non-zero (this is the case when "saddle" is used)
c        then geo is first modified by shifting the internal coordinates
c        along a radius from geoa to place geo at adistancestepfromgeoa.
c    (c) normal conversion from internal to cartesian coordinatesisdone.
c
c  on input:
c         geo    = array of internal coordinates.
c         natoms = number of atoms, including dummies.
c         na     = array of atom labels for bond lengths.
c
c  on output:
c         coord  = array of cartesian coordinates
c
c***********************************************************************
c                                     option (b)
c     former form of next line was
c     geook=(igeook.eq.99)
c     hacked by hbb 11.3.91
c
      geook=((igeook.eq.99).or.(index(keywrd,'geo-ok').ne.0))
      if(dabs(step) .gt. 1.d-4) then
         sum=0.d0
         do 10 j=1,3
c$doit vbest
            do 10 i=1,natoms
               geovec(j,i)=geo(j,i)-geoa(j,i)
   10    sum=sum+geovec(j,i)**2
         sum=dsqrt(sum)
         error=(sum-step)/sum
      else
         error=0.d0
      endif
      do 20 j=1,3
c$doit vbest
         do 20 i=1,natoms
   20 geo(j,i)=geo(j,i)-error*geovec(j,i)
c                                     option (a)
c     geometry fix added by s.green - 15.3.91
c      if((na(1).eq.99).or.(index(keywrd, 'fix').ne.0)) then
      if((na(1).eq.99)) then
         do 30 i=1,3
c$doit vbest
            do 30 j=1,natoms
   30    coord(i,j)=geo(i,j)
         goto 100
      endif
c                                     option (c)
      coord(1,1)=0.0d00
      coord(2,1)=0.0d00
      coord(3,1)=0.0d00
      coord(1,2)=geo(1,2)
      coord(2,2)=0.0d00
      coord(3,2)=0.0d00
      if(natoms.eq.2) goto 100
      ccos=dcos(geo(2,3))
      if(na(3).eq.1)then
         coord(1,3)=coord(1,1)+geo(1,3)*ccos
      else
         coord(1,3)=coord(1,2)-geo(1,3)*ccos
      endif
      coord(2,3)=geo(1,3)*dsin(geo(2,3))
      coord(3,3)=0.0d00
      do 90 i=4,natoms
         cosa=dcos(geo(2,i))
         mb=nb(i)
         mc=na(i)
         xb=coord(1,mb)-coord(1,mc)
         yb=coord(2,mb)-coord(2,mc)
         zb=coord(3,mb)-coord(3,mc)
         rbc=xb*xb+yb*yb+zb*zb
         if(rbc.lt.1.d-16)then
c
c     two atoms are coincident.  a fatal error.
c
         write(mfgw,'(a,i4,a,i4,a)')' atoms',mb,' and',mc,' are coincide
     1nt'
         write(mfgw,'(a)')' this is a fatal error, run stopped in gmetry
     1'
_IF(ipsc,tools)
            call pend
_ELSE
            stop
_ENDIF
         else
            rbc=1.0d00/dsqrt(rbc)
         endif
         ma=nc(i)
         xa=coord(1,ma)-coord(1,mc)
         ya=coord(2,ma)-coord(2,mc)
         za=coord(3,ma)-coord(3,mc)
c
c     rotate about the z-axis to make yb=0, and xb positive.  if xyb is
c     too small, first rotate the y-axis by 90 degrees.
c
         xyb=dsqrt(xb*xb+yb*yb)
         k=-1
         if (xyb.gt.0.1d00) go to 40
         xpa=za
         za=-xa
         xa=xpa
         xpb=zb
         zb=-xb
         xb=xpb
         xyb=dsqrt(xb*xb+yb*yb)
         k=+1
c
c     rotate about the y-axis to make zb vanish
c
   40    costh=xb/xyb
         sinth=yb/xyb
         xpa=xa*costh+ya*sinth
         ypa=ya*costh-xa*sinth
         sinph=zb*rbc
         cosph=dsqrt(dabs(1.d00-sinph*sinph))
         xqa=xpa*cosph+za*sinph
         zqa=za*cosph-xpa*sinph
c
c     rotate about the x-axis to make za=0, and ya positive.
c
         yza=dsqrt(ypa**2+zqa**2)
         if(yza.lt.1.d-4)goto 60
         if(yza.lt.2.d-2 .and. .not.geook)then
         write(mfgw,'(//20x,'' calculation abandoned at this point'')')
         write(mfgw,'(//10x,'' three atoms being used to define the'',/
     110x,'' coordinates of a fourth atom, whose bond-angle is'')')
            write(mfgw,'(10x,'' not zero or 180 degreees, are '',
     1''in an almost straight'')')
         write(mfgw,'(10x,'' line.  there is a high probability that the
     1'',/10x,'' coordinates of the atom will be incorrect.'')')
         write(mfgw,'(//20x,''the faulty atom is atom number'',i4)')i
            call geout(1)
         write(mfgw,'(//20x,''cartesian coordinates up to faulty atom'')
     1')
         write(mfgw,'(//5x,''i'',12x,''x'',12x,''y'',12x,''z'')')
            do 50 j=1,i
   50    write(mfgw,'(i6,f16.5,2f13.5)')j,(coord(k,j),k=1,3)
         write(mfgw,'(//6x,'' atoms'',i3,'','',i3,'', and'',i3,
     1'' are within'',f7.4,'' angstroms of a straight line'')')
     2mc,mb,ma,yza
_IF(ipsc,tools)
            call pend
_ELSE
            stop
_ENDIF
         endif
         coskh=ypa/yza
         sinkh=zqa/yza
         goto 70
   60    continue
c
c   angle too small to be important
c
         coskh=1.d0
         sinkh=0.d0
   70    continue
c
c     coordinates :-   a=(xqa,yza,0),   b=(rbc,0,0),  c=(0,0,0)
c     none are negative.
c     the coordinates of i are evaluated in the new frame.
c
         sina=dsin(geo(2,i))
         sind=-dsin(geo(3,i))
         cosd=dcos(geo(3,i))
         xd=geo(1,i)*cosa
         yd=geo(1,i)*sina*cosd
         zd=geo(1,i)*sina*sind
c
c     transform the coordinates back to the original system.
c
         ypd=yd*coskh-zd*sinkh
         zpd=zd*coskh+yd*sinkh
         xpd=xd*cosph-zpd*sinph
         zqd=zpd*cosph+xd*sinph
         xqd=xpd*costh-ypd*sinth
         yqd=ypd*costh+xpd*sinth
         if (k.lt.1) go to 80
         xrd=-zqd
         zqd=xqd
         xqd=xrd
   80    coord(1,i)=xqd+coord(1,mc)
         coord(2,i)=yqd+coord(2,mc)
         coord(3,i)=zqd+coord(3,mc)
   90 continue
c
c *** now remove the translation vectors, if any, from the array coor
c
  100 continue
      k=natoms
  110 if(labels(k).ne.107) goto 120
      k=k-1
      goto 110
  120 k=k+1
      if(k.gt.natoms) goto 170
c
c   system is a solid, of dimension natoms+1-k
c
      l=0
      do 130 i=k,natoms
         l=l+1
         mc=na(i)
         tvec(1,l)=coord(1,i)-coord(1,mc)
         tvec(2,l)=coord(2,i)-coord(2,mc)
         tvec(3,l)=coord(3,i)-coord(3,mc)
  130 continue
      id=l
      if (icalcn.ne.numcal) then
         icalcn=numcal
         write(mfgw,140)ndimen(id+1)
  140    format(/10x,'    the system is a ',a15,/)
         if(id.eq.0) goto 170
         write(mfgw,150)
         write(mfgw,160)(i,(tvec(j,i),j=1,3),i=1,id)
  150    format(/,'                unit cell translation vectors',/
     1/,'              x              y              z')
  160    format('    t',i1,' = ',f11.7,'    ',f11.7,'    ',f11.7)
      endif
  170 continue
      j=0
      do 190 i=1,natoms
         if (labels(i).eq.99.or.labels(i).eq.107) go to 190
         j=j+1
c$doit asis
         do 180 k=1,3
  180    coord(k,j)=coord(k,i)
  190 continue
      cutoff=200.d0
      return
      end
      subroutine gover(ni,nj,xi,xj,r,sg)
************************************************************************
*                                                                      *
*   gover calculates the overlap integrals using a gaussian expansion  *
*         sto-6g by r.f. stewart, j. chem. phys., 52 431-438, 1970     *
*                                                                      *
*         on input   ni   =  atomic number of first atom               *
*                    nj   =  atomic number of second atom              *
*                    r    =  interatomic distance in angstroms         *
*         on exit    s    =  9x9 array of overlaps, in order s,px,py,  *
*                            pz                                        *
*                                                                      *
************************************************************************
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      common /natype/ nztype(107), mtype(30),ltype
      common /temp/  c(60,6), z(60,6)
      common /cmporb/ natorb(107)
      dimension s(6,6), xi(3),xj(3), sg(9,9)
      save ngauss
      data ngauss/6/
c
c    find start and end of gaussian
c
      ifa=nztype(ni)*4-3
      if(c(ifa+1,1).ne.0.d0)then
         ila=ifa+3
      else
         ila=ifa
      endif
      ifb=nztype(nj)*4-3
      if(c(ifb+1,1).ne.0.d0)then
         ilb=ifb+3
      else
         ilb=ifb
      endif
c
c  convert r into au
c
      r=r/0.529167d0
      r = r**2
      ka=0
      do 80 i=ifa,ila
         ka=ka+1
         nat=ka-1
         kb=0
         do 80 j=ifb,ilb
            kb=kb+1
            nbt=kb-1
c
c         decide is it an s-s, s-p, p-s, or p-p overlap
c
            if(nat.gt.0.and.nbt.gt.0) then
c    p-p
               is=4
               tomb=(xi(nat)-xj(nat))*(xi(nbt)
     1-xj(nbt))*3.5711928576d0
            elseif(nat.gt.0) then
c    p-s
               is=3
               tomb=(xi(nat)-xj(nat))*1.88976d0
            elseif(nbt.gt.0) then
c    s-p
               is=2
               tomb=(xi(nbt)-xj(nbt))*1.88976d0
            else
c    s-s
               is=1
            endif
            do 60 k=1,ngauss
               do 60 l=1,ngauss
                  s(k,l)=0.0d0
                  amb=z(i,k)+z(j,l)
                  apb=z(i,k)*z(j,l)
                  adb=apb/amb
c
c           check of overlap is non-zero before starting
c
                  if((adb*r).lt.90.d0) then
                     abn=1.0d0
                     go to(50,10,20,30),is
   10                abn=2.d0*tomb*z(i,k)*dsqrt(z(j,l))/amb
                     go to 50
   20                abn=-2.d0*tomb*z(j,l)*dsqrt(z(i,k))/amb
                     go to 50
   30                abn=-adb*tomb
                     if(nat.eq.nbt) abn=abn+0.5d0
                     abn=4.0d0*abn*dsqrt(apb)/amb
   50                s(k,l)=dsqrt((2.*dsqrt(apb)/amb)**3)*
     +                      dexp(-adb*r)*abn
                  endif
   60       continue
            sg(ka,kb)=0.0d0
            do 70 k=1,ngauss
               do 70 l=1,ngauss
   70       sg(ka,kb)=sg(ka,kb)+s(k,l)*c(i,k)*c(j,l)
   80 continue
      return
      end
      subroutine h1elec(ni,nj,xi,xj,smat)
      implicit REAL (a-h,o-z)
      dimension xi(3),xj(3),smat(9,9), bi(9), bj(9)
c***********************************************************************
c
c  h1elec forms the one-electron matrix between two atoms.
c
c   on input    ni   = atomic no. of first atom.
c               nj   = atomic no. of second atom.
c               xi   = coordinates of first atom.
c               xj   = coordinates of second atom.
c
c   on output   smat = matrix of one-electron interactions.
c
c***********************************************************************
      common /betas/ betas(107),betap(107),betad(107)
      common /molmec/ htype(4),nhco(4,20),nnhco,itype
      common /beta3/ beta3(153)
      common /keywrd/ keywrd
      common /euler/ tvec(3,3), id
      common /vsips/ vs(107),vp(107),vd(107)
      common /cmporb/ natorb(107)
      common /numcal/ numcal
      common /ucell/ l1l,l2l,l3l,l1u,l2u,l3u
      save sbits, xjuc
      dimension sbits(9,9), lims(3,2), xjuc(3)
      character*241 keywrd
      equivalence (l1l,lims(1,1))
      save icalcn
      data icalcn/0/
      if(ni.eq.102.or.nj.eq.102)then
         if(dsqrt((xi(1)-xj(1))**2+
     1        (xi(2)-xj(2))**2+
     2        (xi(3)-xj(3))**2) .gt.1.8)then
            do 10 i=1,9
               do 10 j=1,9
   10       smat(i,j)=0.d0
            return
         endif
      endif
      if(id.eq.0) then
         if (icalcn.ne.numcal) icalcn=numcal
         call diat(ni,nj,xi,xj,smat)
      else
         if (icalcn.ne.numcal) then
            icalcn=numcal
            do 20 i=1,id
               lims(i,1)=-1
   20       lims(i,2)= 1
            do 30 i=id+1,3
               lims(i,1)=0
   30       lims(i,2)=0
         endif
         do 40 i=1,9
            do 40 j=1,9
   40    smat(i,j)=0
         do 70 i=l1l,l1u
            do 70 j=l2l,l2u
               do 70 k=l3l,l3u
                  do 50 l=1,3
   50             xjuc(l)=xj(l)+tvec(l,1)*i+tvec(l,2)*j+tvec(l,3)*k
                  call diat(ni,nj,xi,xjuc,sbits)
                  do 60 l=1,9
                     do 60 m=1,9
   60             smat(l,m)=smat(l,m)+sbits(l,m)
   70    continue
      endif
      if(itype.ne.4) goto 80
c
c     start of mndo, am1, or pm3 option
c
      ii=max0(ni,nj)
      nbond=(ii*(ii-1))/2+ni+nj-ii
      if(nbond.gt.153)goto 90
      bi(1)=beta3(nbond)*vs(ni)
      bi(2)=beta3(nbond)*vp(ni)
      bi(3)=bi(2)
      bi(4)=bi(2)
      bj(1)=beta3(nbond)*vs(nj)
      bj(2)=beta3(nbond)*vp(nj)
      bj(3)=bj(2)
      bj(4)=bj(2)
      goto 90
   80 continue
      bi(1)=betas(ni)*0.5d0
      bi(2)=betap(ni)*0.5d0
      bi(3)=bi(2)
      bi(4)=bi(2)
      bi(5)=betad(ni)*0.5d0
      bi(6)=bi(5)
      bi(7)=bi(5)
      bi(8)=bi(5)
      bi(9)=bi(5)
      bj(1)=betas(nj)*0.5d0
      bj(2)=betap(nj)*0.5d0
      bj(3)=bj(2)
      bj(4)=bj(2)
      bj(5)=betad(nj)*0.5d0
      bj(6)=bj(5)
      bj(7)=bj(5)
      bj(8)=bj(5)
      bj(9)=bj(5)
   90 continue
      norbi=natorb(ni)
      norbj=natorb(nj)
      if(norbi.eq.9.or.norbj.eq.9) then
c
c    in the calculation of the one-electron terms the geometric mean
c    of the two beta values is being used if one of the atoms
c    contains d-orbitals.
         do 100 j=1,norbj
            do 100 i=1,norbi
  100    smat(i,j)=-2.0d0*smat(i,j)*dsqrt(bi(i)*bj(j))
      else
         do 110 j=1,norbj
            do 110 i=1,norbi
  110    smat(i,j)=smat(i,j)*(bi(i)+bj(j))
      endif
      return
      end
      subroutine haddon (w,l,m,loc,a)
      implicit REAL (a-h,o-z)
      common/iofile/mfgr,mfgw
      dimension a(3,*)
c**********************************************************************
c
c   haddon calculates the value of a symmetry-dependent variable
c
c  on input: m   = number specifying the symmetry operation
c            loc = address of reference atom
c            a   = array of internal coordinates
c  on output w   = value of dependent function
c            l   = 1 (for bond length), 2 (angle), or 3 (dihedral)
c**********************************************************************
      pi = 3.1415926536d00
      if (m.gt.18 .or. m.lt.1) then
         write(mfgw,'(///10x,''undefined symmetry function used'')')
_IF(ipsc,tools)
         call pend
_ELSE
         stop
_ENDIF
      endif
      i=loc
      go to
     1(140,160,10,20,30,40,50,60,70,80,90,100,110,120,150,170,180,190),
     2m
   10 w=a(3,i)
      go to 130
   20 w=(pi/2.0d00)-a(3,i)
      go to 130
   30 w=(pi/2.0d00)+a(3,i)
      go to 130
   40 w=(2.0d00*pi/3.0d00)-a(3,i)
      go to 130
   50 w=(2.0d00*pi/3.0d00)+a(3,i)
      go to 130
   60 w=(pi)-a(3,i)
      go to 130
   70 w=(pi)+a(3,i)
      go to 130
   80 w=(4.0d00*pi/3.0d00)-a(3,i)
      go to 130
   90 w=(4.0d00*pi/3.0d00)+a(3,i)
      go to 130
  100 w=(3.0d00*pi/2.0d00)-a(3,i)
      go to 130
  110 w=(3.0d00*pi/2.0d00)+a(3,i)
      go to 130
  120 w=-a(3,i)
  130 l=3
      return
  140 l=1
      w=a(1,i)
      return
  150 l=1
      w=a(1,i)/2.0d00
      return
  160 l=2
      w=a(2,i)
      return
  170 l=2
      w=a(2,i)/2.0d00
      return
  180 l=2
      w=pi-a(2,i)
      return
  190 call depvar (a,i,w,l)
      return
c
      end
      function helect(n,p,h,f)
      implicit REAL (a-h,o-z)
      dimension p(*), h(*), f(*)
c***********************************************************************
c
c    subroutine calculates the electronic energy of the system in ev.
c
c    on entry n = number of atomic orbitals.
c             p = density matrix, packed, lower triangle.
c             h = one-electron matrix, packed, lower triangle.
c             f = two-electron matrix, packed, lower triangle.
c    on exit
c        helect = electronic energy.
c
c    no arguments are changed.
c
c***********************************************************************
      ed=0.0d00
      ee=0.0d00
      k=0
      nn=n+1
      do 20 i=2,nn
         k=k+1
         jj=i-1
         ed=ed+p(k)*(h(k)+f(k))
         if (i.eq.nn) go to 20
         do 10 j=1,jj
            k=k+1
   10    ee=ee+p(k)*(h(k)+f(k))
   20 continue
      ee=ee+.5d00*ed
      helect=ee
      return
c
      end
      subroutine hqrii(a,n,m,e,v)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      common/iofile/mfgr,mfgw
      dimension a(*), e(n), v(n,m)
*************************************************************
*
* hqrii is a diagonalisation routine, written by yoshitaka beppu of
*       nagoya university, japan.
*       for details see 'computers & chemistry' vol.6 1982. page 000.
*
* on input    a       = matrix to be diagonalised (packed canonical)
*             n       = size of matrix to be diagonalised.
*             m       = number of eigenvectors needed.
*             e       = array of size at least n
*             v       = array of size at least nmax*m
*
* on output   e       = eigenvalues
*             v       = eigenvectors in array of size nmax*m
*
************************************************************************
      dimension w(5,maxpar)
      if(n.le.1 .or. m .le.1 .or. m .gt. n) then
         if(n.eq.1 .and. m.eq.1) then
            e(1)=a(1)
            v(1,1)=1.d0
            return
         endif
         write(mfgw,'(////10x,''in hqrii, n ='',i4,'' m ='',i4)')n,m
_IF(ipsc,tools)
         call pend
_ELSE
         stop
_ENDIF
      endif
*
* eps3 and eps are machine-precision dependent
*
      eps3=1.d-30
      zero=0.d0
      ll=(n*(n+1))/2+1
      eps=1.d-8
      iord=-1
      nm1=n-1
      if(n.eq.2) goto 90
      nm2=n-2
      krank=0
c     householder transformation
      do 80 k=1,nm2
         kp1=k+1
         krank=krank+k
         w(2,k)=a(krank)
         sum=0.d0
         jrank=krank
         do 10 j=kp1,n
            w(2,j)=a(jrank+k)
_IFN(blas)
            jrank=jrank+j
   10    sum=w(2,j)**2+sum
_ELSE
   10    jrank=jrank+j
_ENDIF
_IF(blas)
         sum=ddot(n-kp1+1,w(2,kp1),5,w(2,kp1),5)
_ENDIF
         s=dsign(dsqrt(sum),w(2,kp1))
         w(1,k)=-s
         w(2,kp1)=w(2,kp1)+s
         a(k+krank)=w(2,kp1)
         h=w(2,kp1)*s
         if(dabs(h).lt.eps3) goto 80
         summ=0.d0
         irank=krank
         do 50 i=kp1,n
_IFN(blas)
            sum=0.d0
            do 20 j=kp1,i
   20       sum=sum+a(j+irank)*w(2,j)
_ELSE
            sum=ddot(i-kp1+1,a(kp1+irank),1,w(2,kp1),5)
_ENDIF
            if(i.ge.n) goto 40
            ip1=i+1
            jrank=i*(i+3)/2
            do 30 j=ip1,n
               sum=sum+a(jrank)*w(2,j)
   30       jrank=jrank+j
   40       w(1,i)=sum/h
            irank=irank+i
_IFN(blas)
   50    summ=w(1,i)*w(2,i)+summ
_ELSE
   50    continue
         summ=summ+ddot(n-kp1+1,w(1,kp1),5,w(2,kp1),5)
_ENDIF
         u=summ*0.5d0/h
         jrank=krank
         do 70 j=kp1,n
            w(1,j)=w(2,j)*u-w(1,j)
_IFN(blas)
            do 60 i=kp1,j
   60       a(i+jrank)=w(1,i)*w(2,j)+w(1,j)*w(2,i)+a(i+jrank)
_ELSE
            call daxpy(j-kp1+1,w(2,j),w(1,kp1),5,a(kp1+jrank),1)
            call daxpy(j-kp1+1,w(1,j),w(2,kp1),5,a(kp1+jrank),1)
_ENDIF
   70    jrank=jrank+j
   80 a(krank)=h
   90 w(2,nm1)=a((nm1*(nm1+1))/2)
      w(2,n)=a((n*(n+1))/2)
      w(1,nm1)=a(nm1+(n*(n-1))/2)
      w(1,n)=0.d0
      gersch=dabs(w(2,1))+dabs(w(1,1))
      do 100 i=1,nm1
  100 gersch=dmax1(dabs(w(2,i+1))+dabs(w(1,i))+dabs(w(1,i+1)),gersch)
      del=eps*gersch
_IFN(blas)
      do 110 i=1,n
         w(3,i)=w(1,i)
         e(i)=w(2,i)
  110 v(i,m)=e(i)
_ELSE
      call dcopy(n,w(1,1),5,w(3,1),5)
      call dcopy(n,w(2,1),5,e(1),1)
      call dcopy(n,e(1),1,v(1,m),1)
_ENDIF
      if(dabs(del).lt.eps3)  goto  220
c     qr-method with origin shift
      k=n
  120 l=k
  130 if(dabs(w(3,l-1)).lt.del) goto 140
      l=l-1
      if(l.gt.1)  goto 130
  140 if(l.eq.k)  goto 170
      ww=(e(k-1)+e(k))*0.5d0
      r=e(k)-ww
      z=dsign(dsqrt(w(3,k-1)**2+r*r),r)+ww
      ee=e(l)-z
      e(l)=ee
      ff=w(3,l)
      r=dsqrt(ee*ee+ff*ff)
      j=l
      goto 160
  150 r=dsqrt(e(j)**2+w(3,j)**2)
      w(3,j-1)=s*r
      ee=e(j)*c
      ff=w(3,j)*c
  160 c=e(j)/r
      s=w(3,j)/r
      ww=e(j+1)-z
      e(j)=(ff*c+ww*s)*s+ee+z
      e(j+1)=c*ww-s*ff
      j=j+1
      if(j.lt.k) goto 150
      w(3,k-1)=e(k)*s
      e(k)=e(k)*c+z
      goto 120
  170 k=k-1
      if(k.gt.1) goto 120
*    *    *    *    *    *    *    *    *    *    *    *    *
*
*   at this point the array 'e' contains the un-ordered eigenvalues
*
*    *    *    *    *    *    *    *    *    *    *    *    *
c     straight selection sort of eigenvalues
      srter=1.d0
      if(iord.lt.0) srter=-1.d0
      j=n
  180 l=1
      ii=1
      ll=1
      do 200 i=2,j
         if((e(i)-e(l))*srter .gt. 0.d0) goto 190
         l=i
         goto 200
  190    ii=i
         ll=l
  200 continue
      if(ii.eq.ll) goto 210
      ww=e(ll)
      e(ll)=e(ii)
      e(ii)=ww
  210 j=ii-1
      if(j.ge.2) goto 180
  220 if(m.eq.0) return
***************
*  ordering of eigenvalues complete.
***************
c      inverse-iteration for eigenvectors
      fn=dfloat(n)
      eps1=1.d-5
      seps=dsqrt(eps)
      eps2=0.05d0
      rn=0.d0
      ra=eps*0.6180339887485d0
c    0.618... is the fibonacci number (-1+sqrt(5))/2.
      ig=1
_IF(blas)
      onem=-1.d0
_ENDIF
      do 450 i=1,m
         im1=i-1
_IF(blas)
         call dcopy(n,0.d0,0,w(3,1),5)
         call dcopy(n,w(1,1),5,w(4,1),5)
         call dcopy(n,v(1,m),1,w(5,1),5)
         call daxpy(n,onem,e(i),0,w(5,1),5)
_ENDIF
         do 230 j=1,n
_IFN(blas)
            w(3,j)=0.d0
            w(4,j)=w(1,j)
            w(5,j)=v(j,m)-e(i)
_ENDIF
            rn=rn+ra
            if(rn.ge.eps) rn=rn-eps
  230    v(j,i)=rn
         do 260 j=1,nm1
            if(dabs(w(5,j)).ge.dabs(w(1,j))) goto 240
            w(2,j)=-w(5,j)/w(1,j)
            w(5,j)=w(1,j)
            t=w(5,j+1)
            w(5,j+1)=w(4,j)
            w(4,j)=t
            w(3,j)=w(4,j+1)
            if(dabs(w(3,j)).lt.eps3) w(3,j)=del
            w(4,j+1)=0.d0
            goto 250
  240       if(dabs(w(5,j)).lt.eps3) w(5,j)=del
            w(2,j)=-w(1,j)/w(5,j)
  250       w(4,j+1)=w(3,j)*w(2,j)+w(4,j+1)
  260    w(5,j+1)=w(4,j)*w(2,j)+w(5,j+1)
         if(dabs(w(5,n)) .lt. eps3) w(5,n)=del
         do 320 itere=1,5
            if(itere.eq.1) goto 280
            do 270 j=1,nm1
               if(dabs(w(3,j)).lt.eps3) goto 270
               t=v(j,i)
               v(j,i)=v(j+1,i)
               v(j+1,i)=t
  270       v(j+1,i)=v(j,i)*w(2,j)+v(j+1,i)
  280       v(n,i)=v(n,i)/w(5,n)
            v(nm1,i)=(v(nm1,i)-v(n,i)*w(4,nm1))/w(5,nm1)
            vn=dmax1(dabs(v(n,i)),dabs(v(nm1,i)),1.d-20)
            if(n.eq.2) goto 300
            k=nm2
  290       v(k,i)=(v(k,i)-v(k+1,i)*w(4,k)-v(k+2,i)*w(3,k))/w(5,k)
            vn=dmax1(dabs(v(k,i)),vn,1.d-20)
            k=k-1
            if(k.ge.1) goto 290
  300       s=eps1/vn
_IFN(blas)
            do 310 j=1,n
  310       v(j,i)=v(j,i)*s
_ELSE
            call dscal(n,s,v(1,i),1)
_ENDIF
            if(itere.gt.1 .and. vn.gt.1) goto 330
  320    continue
c     transformation of eigenvectors
  330    if(n.eq.2) goto 380
         krank=nm2*(n+1)/2
         kpiv=nm2*nm1/2
         do 370 k=nm2,1,-1
            kp1=k+1
            if(dabs(a(kpiv)).le.eps3) goto 360
            sum=0.d0
            do 340 kk=kp1,n
               sum=sum+a(krank)*v(kk,i)
  340       krank=krank+kk
            s=-sum/a(kpiv)
            do 350 kk=n,kp1,-1
               krank=krank-kk
  350       v(kk,i)=a(krank)*s+v(kk,i)
  360       kpiv=kpiv-k
  370    krank=krank-kp1
  380    do 390 j=ig,i
            if(dabs(e(j)-e(i)) .lt. eps2) goto 400
  390    continue
         j=i
  400    ig=j
         if(ig .eq. i) goto 430
c     re-orthogonalisation
         do 420 k=ig,im1
_IFN(blas)
            sum=0.d0
            do 410 j=1,n
  410       sum=v(j,k)*v(j,i)+sum
_ELSE
            sum=ddot(n,v(1,k),1,v(1,i),1)
_ENDIF
            s=-sum
_IFN(blas)
            do 420 j=1,n
  420    v(j,i)=v(j,k)*s+v(j,i)
_ELSE
            call daxpy(n,s,v(1,k),1,v(1,i),1)
  420    continue
_ENDIF
c     normalisation
  430    sum=1.d-24
_IFN(blas)
         do 440 j=1,n
  440    sum=sum+v(j,i)**2
_ELSE
         sum=sum+ddot(n,v(1,i),1,v(1,i),1)
_ENDIF
         sinv=1.d0/dsqrt(sum)
_IFN(blas)
         do 450 j=1,n
  450 v(j,i)=v(j,i)*sinv
_ELSE
         call dscal(n,sinv,v(1,i),1)
  450 continue
_ENDIF
      return
      end
      subroutine interp(n,np,nq,mode,e,fp,cp,vec,fock,p,h,vecl)
      implicit REAL (a-h,o-z)
      common/iofile/mfgr,mfgw
INCLUDE(common/sizes)
      dimension fp(mpack), cp(n,n)
      dimension vec(n,n), fock(n,n),
     1          p(n,n), h(n*n), vecl(n*n)
**********************************************************************
*
* interp: an interpolation procedure for forcing scf convergance
*         original theory and fortran written by r.n. camp and
*         h.f. king, j. chem. phys. 75, 268 (1981)
**********************************************************************
*
* on input n     = number of orbitals
*          np    = number of filled levels
*          nq    = number of empty levels
*          mode  = 1, do not reset.
*          e     = energy
*          fp    = fock matrix, as lower half triangle, packed
*          cp    = eigenvectors of fock matrix of iteration -1
*                  as packed array of n*n coefficients
*
* on output cp   = best guessed set of eigenvectors
*           mode = 2 or 3 - used by calling program
**********************************************************************
      dimension theta(maxorb), ia(maxorb)
      common /keywrd/ keywrd
      common /numcal/ numcal
      common/fit/npnts,idum2,xlow,xhigh,xmin,emin,demin,x(12),f(12),
     1 df(12)
      logical debug, debug1
      character*241 keywrd
      save zero, ff, radmax, icalcn, debug1, debug, ia, eold, xold
      data icalcn/0/
      data zero,ff,radmax/0.0d0,0.9d0,1.5708d0/
      if(icalcn.ne.numcal)then
         debug=(index(keywrd,'interp').ne.0)
         debug1=(index(keywrd,'debug').ne.0.and.debug)
         icalcn=numcal
         do 10 i=1,maxorb
   10    ia(i)=(i*i-i)/2
      endif
c
c     radmax=maximum rotation angle (radians).  1.5708 = 90 degrees.
c         ff=factor for convergence test for 1d search.
c
      minpq=min0(np,nq)
      maxpq=max0(np,nq)
      np1=np+1
      np2=max0(1,np/2)
      if(mode.eq.2) go to 110
c
c     (mode=1 or 3 entry)
c     transform fock matrix to current mo basis.
c     only the off diagonal occ-virt block is computed.
c     store in fock array
c
      ii=0
      do 50 i=1,n
         i1=i+1
         do 40 j=1,nq
            dum=zero
            do 20 k=1,i
   20       dum=dum+fp(ii+k)*cp(k,j+np)
            if(i.eq.n) go to 40
            ik=ii+i+i
            do 30 k=i1,n
               dum=dum+fp(ik)*cp(k,j+np)
   30       ik=ik+k
   40    p(i,j)=dum
   50 ii=ii+i
      do 80 i=1,np
         do 70 j=1,nq
            dum=zero
            do 60 k=1,n
   60       dum=dum+cp(k,i)*p(k,j)
            fock(i,j)=dum
   70    continue
   80 continue
      if(mode.eq.3) go to 100
c
c     current point becomes old point (mode=1 entry)
c
      do 90 i=1,n
         do 90 j=1,n
   90 vec(i,j)=cp(i,j)
      eold=e
      xold=1.0d0
      mode=2
      return
c
c     (mode=3 entry)
c     fock corresponds to current point in corresponding representation.
c     vec does not hold current vectors. vec set in last mode=2 entry.
c
  100 npnts=npnts+1
      if(debug)write(mfgw,
     +    '(''   interpolated energy:'',f13.6)')e*23.061d0
      ipoint=npnts
      go to 500
c
c    (mode=2 entry) calculate theta, and u, v, w matrices.
c                   u rotates current into old mo.
c                   v rotates current into corresponding current mo.
c                   w rotates old into corresponding old mo.
c
  110 j1=1
      do 140 i=1,n
         if(i.eq.np1) j1=np1
         do 130 j=j1,n
            p(i,j)=zero
            do 120 k=1,n
  120       p(i,j)=p(i,j)+cp(k,i)*vec(k,j)
  130    continue
  140 continue
c
c     u = cp(dagger)*vec is now in p array.
c     vec is now available for temporary storage.
c
      ij=0
      do 170 i=1,np
         do 160 j=1,i
            ij=ij+1
            h(ij)=0.d0
            do 150 k=np1,n
  150       h(ij)=h(ij)+p(i,k)*p(j,k)
  160    continue
  170 continue
      call hqrii(h,np,np,theta,vecl)
      do 180 i=np,1,-1
         il=i*np-np
         do 180 j=np,1,-1
  180 vec(j,i)=vecl(j+il)
      do 200 i=1,np2
         dum=theta(np1-i)
         theta(np1-i)=theta(i)
         theta(i)=dum
         do 190 j=1,np
            dum=vec(j,np1-i)
            vec(j,np1-i)=vec(j,i)
  190    vec(j,i)=dum
  200 continue
      do 210 i=1,minpq
         theta(i)=dmax1(theta(i),zero)
         theta(i)=dmin1(theta(i),1.d0)
  210 theta(i)=dasin(dsqrt(theta(i)))
c
c     theta matrix has now been calculated, also unitary vp matrix
c     has been calculated and stored in first np columns of vec matrix.
c     now compute wq
c
      do 240 i=1,nq
         do 230 j=1,minpq
            vec(i,np+j)=zero
            do 220 k=1,np
  220       vec(i,np+j)=vec(i,np+j)+p(k,np+i)*vec(k,j)
  230    continue
  240 continue
      call schmit(vec(1,np1),nq,n)
c
c     unitary wq matrix now in last nq columns of vec matrix.
c     transpose np by np block of u stored in p
c
      do 260 i=1,np
         do 250 j=1,i
            dum=p(i,j)
            p(i,j)=p(j,i)
  250    p(j,i)=dum
  260 continue
c
c     calculate wp matrix and hold in first np columns of p
c
      do 300 i=1,np
         do 270 k=1,np
  270    h(k)=p(i,k)
         do 290 j=1,np
            p(i,j)=zero
            do 280 k=1,np
  280       p(i,j)=p(i,j)+h(k)*vec(k,j)
  290    continue
  300 continue
      call schmib(p,np,n)
c
c     calculate vq matrix and hold in last nq columns of p matrix.
c
      do 340 i=1,nq
         do 310 k=1,nq
  310    h(k)=p(np+i,np+k)
         do 330 j=np1,n
            p(i,j)=zero
            do 320 k=1,nq
  320       p(i,j)=p(i,j)+h(k)*vec(k,j)
  330    continue
  340 continue
      call schmib(p(1,np1),nq,n)
c
c     calculate (de/dx) at old point
c
      dedx=zero
      do 370 i=1,np
         do 360 j=1,nq
            dum=zero
            do 350 k=1,minpq
  350       dum=dum+theta(k)*p(i,k)*vec(j,np+k)
  360    dedx=dedx+dum*fock(i,j)
  370 continue
c
c     store old point information for spline fit
c
      deold=-4.0d0*dedx
      x(2)=xold
      f(2)=eold
      df(2)=deold
c
c     move vp out of vec array into first np columns of p matrix.
c
      do 380 i=1,np
         do 380 j=1,np
  380 p(i,j)=vec(i,j)
      k1=0
      k2=np
      do 410 j=1,n
         if(j.eq.np1) k1=np
         if(j.eq.np1) k2=nq
         do 400 i=1,n
            dum=zero
            do 390 k=1,k2
  390       dum=dum+cp(i,k1+k)*p(k,j)
  400    vec(i,j)=dum
  410 continue
c
c     corresponding current mo vectors now held in vec.
c     compute vec(dagger)*fp*vec
c     store off-diagonal block in fock array.
c
      ii=0
      do 460 i=1,n
         i1=i+1
         do 450 j=1,nq
            dum=zero
            do 430 k=1,i
  430       dum=dum+fp(ii+k)*vec(k,j+np)
            if(i.eq.n) go to 450
            ik=ii+i+i
            do 440 k=i1,n
               dum=dum+fp(ik)*vec(k,j+np)
  440       ik=ik+k
  450    p(i,j)=dum
  460 ii=ii+i
      do 490 i=1,np
         do 480 j=1,nq
            dum=zero
            do 470 k=1,n
  470       dum=dum+vec(k,i)*p(k,j)
            fock(i,j)=dum
  480    continue
  490 continue
c
c     set limits on range of 1-d search
c
      npnts=2
      ipoint=1
      xnow=zero
      xhigh=radmax/theta(1)
      xlow=-0.5d0*xhigh
c
c     calculate (de/dx) at current point and
c     store information for spline fit
c     ***** jump point for mode=3 entry *****
c
  500 dedx=zero
      do 510 k=1,minpq
  510 dedx=dedx+theta(k)*fock(k,k)
      denow=-4.0d0*dedx
      enow=e
      if(ipoint.le.12) go to 530
c 520 format(//,'excessive data pnts for spline.',/
c    1,'ipoint =',i3,'maximum is 12.')
c
c     perform 1-d search and determine exit mode.
c
  530 x(ipoint)=xnow
      f(ipoint)=enow
      df(ipoint)=denow
      call spline
      if((eold-enow).gt.ff*(eold-emin).or.ipoint.gt.10) go to 560
c
c     (mode=3 exit) recompute cp vectors at predicted minimum.
c
      xnow=xmin
      do 550 k=1,minpq
         ck=dcos(xnow*theta(k))
         sk=dsin(xnow*theta(k))
         if(debug)write(mfgw,
     +   '('' rotation angle:'',f12.4)')sk*57.29578d0
         do 540 i=1,n
            cp(i,k)   =ck*vec(i,k)-sk*vec(i,np+k)
  540    cp(i,np+k)=sk*vec(i,k)+ck*vec(i,np+k)
  550 continue
      mode=3
      return
c
c     (mode=2 exit) current vectors give satisfactory energy improvement
c     current point becomes old point for the next 1-d search.
c
  560 if(mode.eq.2) go to 580
      do 570 i=1,n
         do 570 j=1,n
  570 vec(i,j)=cp(i,j)
      mode=2
  580 rold=xold*theta(1)*57.29578d0
      rnow=xnow*theta(1)*57.29578d0
      rmin=xmin*theta(1)*57.29578d0
      if(debug)write(mfgw,600) xold,eold*23.061d0,deold,rold
     1,             xnow,enow*23.061d0,denow,rnow
     2,             xmin,emin*23.061d0,demin,rmin
      eold=enow
      if(npnts.le.200) return
      write(mfgw,610)
      do 590 k=1,npnts
  590 write(mfgw,620) k,x(k),f(k),df(k)
      write(mfgw,630)
      return
  600 format(
     1/14x,3h x ,10x,6h f(x) ,9x,7h df/dx ,21h   rotation (degrees),
     2/10h      old ,f10.5,3f15.10,
     3/10h  current ,f10.5,3f15.10,
     4/10h predicted,f10.5,3f15.10/)
  610 format(3h  k,10h     x(k) ,15h       f(k)    ,10h     df(k))
  620 format(i3,f10.5,2f15.10)
  630 format(10x)
      end
      subroutine iterm (h, w, wj, wk, ee, fulscf,rand)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      REAL  meci
_IF(ipsc,tools)
      logical oroot
_ENDIF
      common/iofile/mfgr,mfgw
      dimension h(*), w(*), wj(*), wk(*)
      common /fokmat/ f(mpack), fb(mpack)
      common /densty/ p(mpack), pa(mpack), pb(mpack)
      common /vector/ c(morb2),eigs(maxorb),cbeta(morb2),eigb(maxorb)
      common /gradnt/ dumy(maxpar),gnorm
      common /last/ last
      common /mesage/ iflepo,iiter
      common /atheat/ atheat
      common /enuclr/ enuclr
      common /citerm/ xi,xj,xk
      common /path/ latom,lparam,react(200)
      common /numcal/ numcal
      common /scftyp/ emin, limscf
      common /timem/ time0
      logical fulscf, rand, limscf
      REAL  wj, wk
c***********************************************************************
c
c     iter generates a scf field and returns the energy in "energy"
c
c the main arrays used in iter are:
c            p      only ever contains the total density matrix
c            pa     only ever contains the alpha density matrix
c            pb     only ever contains the beta density matrix
c            c      only ever contains the eigenvectors
c            h      only ever contains the one-electron matrix
c            f      starts off containing the one-electron matrix,
c                   and is used to hold the fock matrix
c            w      only ever contains the two-electron matrix
c
c the main integers constants in iter are:
c
c            linear size of packed triangle = norbs*(norbs+1)/2
c
c the main integer variables are
c            niter  number of iterations executed
c
c  principal references:
c
c   on mndo: "ground states of molecules. 38. the mndo method.
c             approximations and parameters."
c             dewar, m.j.s., thiel,w., j. am. chem. soc.,99,4899,(1977).
c   on shift: "the dynamic 'level shift' method for improving the
c             convergence of the scf procedure", a. v. mitin, j. comp.
c             chem. 9, 107-110 (1988)
c   on half-electron: "mindo/3 comparison of the generalized s.c.f.
c             coupling operator and "half-electron" methods for
c             calculating the energies and geometries of open shell
c             systems"
c             dewar, m.j.s., olivella, s., j. chem. soc. fara. ii,
c             75,829,(1979).
c   on pulay's converger: "convergance acceleration of iterative
c             sequences. the case of scf iteration", pulay, p.,
c             chem. phys. lett, 73, 393, (1980).
c   on cnvg:  it encorporates the improved iteration scheme (iis) by
c             piotr badziag & fritz solms. accepted for publishing
c             in computers & chemistry
c   on pseudodiagonalisation: "fast semiempirical calculations",
c             stewart. j.j.p., csaszar, p., pulay, p., j. comp. chem.,
c             3, 227, (1982)
c
c***********************************************************************
      dimension pold(mpack), pold2(mpack), pold3(maxorb+400)
      dimension pbold(mpack), pbold2(mpack), pbold3(maxorb+400)
************************************************************************
*                                                                      *
*   pack all the arrays used by pulay into a common block so that they *
*   can be used by the c.i. derivative, if needed                      *
*                                                                      *
************************************************************************
      common /work3/pold,pold2,pbold,pbold2
      common /work1/ ar1,ar2,ar3,ar4,br1,br2,br3,br4
      dimension  ar1(2*npulay), ar2(2*npulay), ar3(2*npulay),
     1 ar4(2*npulay)
      dimension  br1(2*npulay), br2(2*npulay), br3(2*npulay),
     1 br4(7*npulay)
      dimension escf0(10)
      common /preci/ selcon
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),
     1                nlast(numatm), norbs, nelecs,
     2                nalpha, nbeta, nclose, nopen, ndumy, fract
      common/molorb/ dummy(maxorb),pdiag(maxorb)
      common/keywrd/ keywrd
      common/numscf/ nscf
      save icalcn, debug, prtfok, prteig, prtden, prt1el, abprt
      save linear, minprt, newdg, scfcrt, prtpl, prtvec, pl
      save bshift, pltest, itrmax, na2el, na1el, nb2el,nb1el
      save ifill, camkin, ci, okpuly, uhf, scf1, oknewd, excitd, times
      save force, allcon, trans, halfe, w1, w2, random
*********
      save eps,eta,shfmax,shift,irrr,plchek,ten,timitr,capps
*********
      character keywrd*241, abprt(3)*5, getmop*80
      logical prtfok,prteig,prtden, debug, times, ci
     1,uhf, newdg, scf1, halfe, force, prt1el,prtpl, oknewd
     2,excitd, minprt, frst, bfrst, okpuly, ready, prtvec,
     3camkin, allcon, makea, makeb, incitr, capps, timitr
      data icalcn/0/, debug/.false./, prtfok/.false./
      data prteig/.false./,prtden/.false./
      data prt1el/.false./
      data abprt/'     ','alpha',' beta'/
c
c  initialize
c
      ifill=0
      ihomo=max0(1,nclose+nalpha)
      ihomob=max0(1,nclose+nbeta)
      eold=1.d2
      ready=.false.
      if (icalcn.ne.numcal) then
         call epseta(eps,eta)
c
c  ultimate scf criterion: heat of formation converged within a factor
c  of 10 of the limiting precision of the computer
c
         eps=23.061d0*eps*10.d0
         irrr=5
         shift=0.d0
         icalcn=numcal
         shfmax=20.d0
         linear=(norbs*(norbs+1))/2
c
c    debug key-words worked out
c
         debug=( index(keywrd,'debug') .ne. 0 )
         minprt=(index(keywrd,'saddle')+
     1      latom .eq.0 .or. debug)
         prteig=( index(keywrd,'eigs') .ne. 0 )
         prtpl =( index(keywrd,' pl ')  .ne.0 )
         prt1el=( index(keywrd,'1ele') .ne.0 .and. debug)
         prtden=( index(keywrd,' dens').ne.0 .and. debug)
         prtfok=( index(keywrd,'fock') .ne. 0  .and. debug)
         prtvec=( index(keywrd,'vect') .ne. 0  .and. debug)
         debug=( index(keywrd,'iter') .ne. 0 )
c
c initialize some logicals and constants
c
         newdg =.false.
         plchek=0.005d0
         pl    =1.d0
         bshift=0.d0
         shift=1.d0
*
* scfcrt is machine-precision dependent
*
         scfcrt=1.d-4
         itrmax = 200
         na2el=nclose
         na1el=nalpha+nopen
         nb2el=0
         nb1el=nbeta+nopen
c
c  use key-words to assign various constants
c
         if(index(keywrd,'fill').ne.0)
     1      ifill=-reada(keywrd,index(keywrd,'fill'))
         if(index(keywrd,'shift').ne.0)
     1      bshift=-reada(keywrd,index(keywrd,'shift'))
         if(bshift.ne.0)ten=bshift
         if(index(keywrd,'itry').ne.0)
     1      itrmax=reada(keywrd,index(keywrd,'itry'))
         camkin=(index(keywrd,'king')+index(keywrd,'camp') .ne. 0)
         ci=(index(keywrd,'micros')+index(keywrd,'c.i.') .ne. 0)
         okpuly=.false.
         okpuly=(index(keywrd,'pulay').ne.0)
         uhf=(index(keywrd,'uhf') .ne. 0)
         scf1=(index(keywrd,'1scf') .ne. 0)
         oknewd=dabs(bshift) .lt. 0.001d0
         if(camkin.and.dabs(bshift).gt.1.d-5) bshift=4.44d0
         excitd=(index(keywrd,'exci') .ne. 0)
         times=(index(keywrd,'times') .ne. 0)
         timitr=(times.and.debug)
         force=(index(keywrd,'force') .ne. 0)
         allcon=(okpuly.or.camkin)
c
c   do we need a capped atom correction?
c
         j=0
         do 10 i=1,numat
   10    if(nat(i).eq.102)j=j+1
         capps=(j.gt.0)
         iiter=1
         trans=0.1d0
         if(index(keywrd,'restart')+index(keywrd,'oldens')
     1      .ne. 0) then
_IF(ipsc,tools)
         if (oroot()) then
_ENDIF
            if(index(keywrd,'oldens').ne.0)
     1   open(unit=10,file=getmop(4),
     +        status='unknown',form='unformatted')
            rewind 10
            read(10)(pa(i),i=1,linear)
            if( uhf) then
               read(10)(pb(i),i=1,linear)
               do 20 i=1,linear
                  pold(i)=pa(i)
                  pbold(i)=pb(i)
   20          p(i)=pa(i)+pb(i)
            else
               do 30 i=1,linear
                  pb(i)=pa(i)
                  pbold(i)=pa(i)
                  pold(i)=pa(i)
   30          p(i)=pa(i)*2.d0
            endif
_IF(ipsc,tools)
          else
           write(mfgw,*)' restart not available in iter'
           call pend
          endif
_ENDIF
         else
            nscf=0
            do 40 i=1,linear
               p(i)=0.d0
               pa(i)=0.d0
   40       pb(i)=0.d0
            w1=na1el/(na1el+1.d-6+nb1el)
            w2=1.d0-w1
            if(w1.lt.1.d-6)w1=0.5d0
            if(w2.lt.1.d-6)w2=0.5d0
c
c  slightly perturb the density matrix in case the system is
c  trapped in a s**2 = 0 state.
c
            random=1.0d0
            if(uhf.and.na1el.eq.nb1el) random=1.1d0
            do 50 i=1,norbs
               j=(i*(i+1))/2
               p(j)=pdiag(i)
               pa(j)=p(j)*w1*random
               random=1.d0/random
   50       pb(j)=p(j)*w2*random
            do 60 i=1,linear
               pbold(i)=pb(i)
   60       pold(i)=pa(i)
         endif
         halfe=(nopen .ne. nclose.and.fract.ne.2.d0.and.fract.ne.0.d0)
c
c   determine the self-consistency criterion
c
         if(index(keywrd,'prec') .ne. 0)
     1                               scfcrt=scfcrt*0.01d0
         if( index(keywrd,'polar') + index(keywrd,'nllsq') +
     1 index(keywrd,'sigma') .ne. 0) scfcrt=scfcrt*0.001d0
         if(force)                   scfcrt=scfcrt*0.0001d0
         if(nopen-nclose.gt.4)       scfcrt=scfcrt*0.1d0
         scfcrt=dmax1(scfcrt,1.d-12)
         if(index(keywrd,'polar').ne.0)scfcrt=1.d-11
c
c  the user can state the scf criterion, if desired.
c
         i=index(keywrd,'scfcrt')
         if(i.ne.0) then
            scfcrt=reada(keywrd,i)
            write(mfgw,'(''  scf criterion ='',g14.4)')scfcrt
            if(scfcrt.lt.1.d-12)
     1 write(mfgw,'(//2x,'' there is a risk of infinite looping with'',
     2'' the scfcrt less than 1.d-12'')')
         else
            if(debug)write(mfgw,'(''  scf criterion ='',g14.4)')scfcrt
         endif
         if(.not.scf1)last=0
c
c   end of initialization section.
c
      elseif(force.and.nscf.gt.0.and..not.uhf)then
c
c   reset the density matrix if meci has formed an excited state.  this
c   prevents the scf getting trapped on an excited state, particularly
c   if the pulay converger is used.
c
         do 70 i=1,linear
   70    p(i)=2.d0*pa(i)
      endif
c
c   initialization operations done every time iter is called
c
      makea=.true.
      makeb=.true.
      iemin=0
      iemax=0
c
c  turn off shift if not a full scf.
c
      if(.not.fulscf) shift=0.d0
      if(newdg) newdg=(dabs(bshift).lt.0.001d0)
      if(last.eq.1) newdg=.false.
c
c   self-consistency criteria: selcon is in kcal/mol, pltest is
c   a less important test to make sure that the selcon test is not
c   passed 'by accident'
c                              if gnorm is large, make selcon bigger
c
      selcon=scfcrt
      if(.not. force .and. .not. halfe) then
         if(gnorm.gt.5.d0) selcon=scfcrt*gnorm*0.2d0
         if(gnorm.gt.200.d0) selcon=scfcrt*40.d0
      endif
      pltest=0.05d0*dsqrt(selcon)
c
c  sometimes heat goes scf but density is still fluctuating in uhf
c  in which case pay less attention to density matrix
c
      if(nalpha.ne.nbeta.and.uhf)pltest=0.001d0
      if(debug)then
         write(mfgw,'(''  selcon, pltest'',3g16.7)')selcon, pltest
      endif
      titer1=secmop()
      if(prt1el) then
         write(mfgw,
     +  '(//10x,''one-electron matrix at entrance to iter'')')
         call vecprt(h,norbs)
      endif
      iredy=1
   80 niter=0
      time1=secmop()
      frst=.true.
      if(camkin) then
         modea=1
         modeb=1
      else
         modea=0
         modeb=0
      endif
      bfrst=.true.
**********************************************************************
*                                                                    *
*                                                                    *
*                start the scf loop here                             *
*                                                                    *
*                                                                    *
**********************************************************************
      incitr=.true.
   90 incitr=(modea.ne.3.and.modeb.ne.3)
      if(incitr)niter=niter+1
      if(timitr)then
         titer=secmop()
         write(mfgw,*)
         write(mfgw,'(a,f7.2)')'     time for iteration:', titer-titer0
         titer0=titer
      endif
      if(niter.gt.itrmax-10.and..not.allcon) then
************************************************************************
*                                                                      *
*                   switch on all convergers                           *
*                                                                      *
************************************************************************
         write(mfgw,'(//,'' all convergers are now forced on'',/
     1          '' shift=10, pulay on, camp-king on'',/
     2          '' and iteration counter reset'',//)')
         allcon=.true.
         bshift=4.44d0
         iredy=-4
         eold=100.d0
         okpuly=.true.
         newdg=.false.
         camkin=(.not.halfe)
         goto 80
      endif
************************************************************************
*                                                                      *
*                        make the alpha fock matrix                    *
*                                                                      *
************************************************************************
      if(dabs(shift).gt.1.d-10.and.bshift .ne. 0.d0) then
         l=0
         if(niter.gt.1)then
            if(newdg.and..not.(halfe.or.camkin))then
c
c  shift will apply to the virtual energy levels used in the
c  pseudodiagonaliization. if diff is -ve, good, then lower the
c  homo-lumo gap by 0.1ev, otherwise increase it.
               if(diff.gt.0)then
                  shift=1.d0
c
c if the pseudodiagonalization approximation -- that the wavefunction
c is almost stable -- is invalid, turn off newdg
                  if(diff.gt.1)newdg=.false.
               else
                  shift=-0.1d0
               endif
            else
               shift=ten+eigs(ihomo+1)-eigs(ihomo)+shift
            endif
            if(diff.gt.0.d0) then
               if(shift.gt.4.d0)shfmax=4.5d0
               if(shift.gt.shfmax)shfmax=dmax1(shfmax-0.5d0,0.d0)
            endif
c
c   if system goes unstable, limit shift to the range -infinity - shfmax
c   but if system is stable, limit shift to the range -infinity - +20
c
            shift=dmax1(-20.d0,dmin1(shfmax,shift))
            if(dabs(shift-shfmax).lt.1.d-5)shfmax=shfmax+0.01d0
c
c  the camp-king and pulay converges need a constant shift.
c  if the shift is allowed to vary, these convergers will not
c  work properly.
c
            if(okpuly.or.dabs(bshift-4.44d0).lt.1.d-5)then
               shift=-8.d0
               if(newdg) shift=0
            endif
            if(uhf)then
               if(newdg.and..not.(halfe.or.camkin))then
                  shiftb=ten-tenold
               else
                  shiftb=ten+eigs(ihomob+1)-eigs(ihomob)+shiftb
               endif
               if(diff.gt.0.d0)shiftb=dmin1(4.d0,shiftb)
               shiftb=dmax1(-20.d0,dmin1(shfmax,shiftb))
               if(okpuly.or.dabs(bshift-4.44d0).lt.1.d-5)then
                  shiftb=-8.d0
                  if(newdg)shift=0
               endif
               do 100 i=ihomob+1,norbs
  100          eigb(i)=eigb(i)+shiftb
            else
            endif
         endif
         tenold=ten
         if(pl.gt.plchek)then
            shftbo=shiftb
            shfto=shift
         else
            shiftb=shftbo
            shift=shfto
         endif
         do 110 i=ihomo+1,norbs
  110    eigs(i)=eigs(i)+shift
         do 130 i=1,norbs
            do 120 j=1,i
               l=l+1
  120       f(l)=h(l)+shift*pa(l)
  130    f(l)=f(l)-shift
      elseif (i.eq.77.and.last.eq.0.and.niter.lt.2.and.fulscf)then
c
c  slightly perturb the fock matrix in case the system is
c  trapped in a metastable excited electronic state
c
         random=0.001d0
         do 140 i=1,linear
            random=-random
  140    f(i)=h(i)+random
      else
         do 150 i=1,linear
  150    f(i)=h(i)
      endif
  160 continue
      if(timitr)then
         t0=secmop()
         write(mfgw,'(a,f7.2)')' load fock mat. integral',t0-titer0
      endif
c#      call timop('before fock2')
      call fock2(f,p,pa,w, wj, wk,numat,nfirst,nmidle,nlast)
c#      call timop('after fock2')
c#      call timop('before fock1')
      call fock1(f,p,pa,pb)
c#      call timop('after fock1')
      if(timitr)then
         t0=secmop()
         tf1=tf1+t0-t1
         write(mfgw,'(2(a,f7.2))')'  fock1:',t0-t1,'integral:',t0-titer0
      endif
************************************************************************
*                                                                      *
*                        make the beta fock matrix                     *
*                                                                      *
************************************************************************
      if (uhf) then
         if(shiftb .ne. 0.d0) then
            l=0
            do 180 i=1,norbs
               do 170 j=1,i
                  l=l+1
  170          fb(l)=h(l)+shiftb*pb(l)
  180       fb(l)=fb(l)-shiftb
         elseif (rand.and.last.eq.0.and.niter.lt.2.and.fulscf)then
            random=0.001
            do 190 i=1,linear
               random=-random
  190       fb(i)=h(i)+random
         else
            do 200 i=1,linear
  200       fb(i)=h(i)
         endif
         call fock2(fb,p,pb,w, wj, wk,numat,nfirst,nmidle,nlast)
         call fock1(fb,p,pb,pa)
      endif
      if( .not. fulscf) goto 380
      if(prtfok) then
         write(mfgw,210)niter
  210    format('   fock matrix on iteration',i3)
         call vecprt (f,norbs)
      endif
c
c   code the following line in properly sometime
c   this operation is believed to give rise to a better fock matrix
c   than the conventional guess.
c
      if(irrr.eq.0)then
         do 220 i=1,norbs
  220    f((i*(i+1))/2)=f((i*(i+1))/2)*0.5d0
         irrr=2
      endif
************************************************************************
*                                                                      *
*                        calculate the energy in kcal/mole             *
*                                                                      *
************************************************************************
      if (niter .ge. itrmax) then
         if(diff.lt.1.d-3.and.pl.lt.1.d-4.and..not.force)then
         write(mfgw,'('' """""""""""""""unable to achieve self-consisten
     1ce, job continuing'')')
            goto 380
         endif
         if(minprt)write (mfgw,230)
  230    format (//10x,'"""""""""""""unable to achieve self-consistence'
     1,/)
         write (mfgw,240) diff,pl
  240    format (//,10x,'deltae= ',e12.4,5x,'deltap= ',e12.4,///)
         iflepo=9
         iiter=2
         call writmo(time0,escf)
_IF(ipsc,tools)
         call pend
_ELSE
         stop
_ENDIF
      endif
      ee=helect(norbs,pa,h,f)
      if(uhf)then
         ee=ee+helect(norbs,pb,h,fb)
      else
         ee=ee*2.d0
      endif
      if(capps)ee=ee+capcor(nat,nfirst,nlast,numat,p,h)
      if(bshift.ne.0.d0)
     1scorr=shift*(nopen-nclose)*23.061d0*0.25d0*(fract*(2.d0-fract))
      escf=(ee+enuclr)*23.061d0+atheat+scorr
      if(incitr)then
         diff=escf-eold
         if(diff.gt.0)then
            ten=ten-1.d0
         else
            ten=ten*0.975d0+0.05d0
         endif
c
c make sure self-consistency test is not more stringent than the
c computer can handle
c
         sellm1=eps*dmax1(dabs(ee),1.d0)
         sellim=dmax1(selcon,sellm1)
c
c scf test:  change in heat of formation in kcal/mol should be
c            less than sellim.  the other tests are safety measures
c
         if(.not.(niter.gt.4.and.(pl.eq.0.d0.or.pl.lt.pltest.and.
     1   dabs(diff).lt.sellim) .and. ready)) goto 270
************************************************************************
*                                                                      *
*          self-consistency test, exit mode from iterations            *
*                                                                      *
************************************************************************
  250    if (dabs(shift) .lt. 1.d-10) goto 380
         shift=0.d0
         shiftb=0.d0
         do 260 i=1,linear
  260    f(i)=h(i)
         makea=.true.
         makeb=.true.
         goto 160
  270    continue
***********************************************************************
***********************************************************************
         if(limscf.and.emin.ne.0.d0.and..not.(ci.or.halfe))then
c
c  the following tests are intended to allow a fast exit from iter
c  if the result is 'good enough' for the current step in the geometry
c  optimization
c
            if(escf.lt.emin)then
c
c  the energy is lower than the previous minimum.  now check that
c  it is consistently lower.
c
               iemax=0
               iemin=min0(5,iemin+1)
               do 280 i=2,iemin
  280          escf0(i-1)=escf0(i)
               escf0(iemin)=escf
c
c  is the difference in energy between two iterations less than 5%
c  of the energy gain for this geometry relative to the previous
c  minimum.
c
               if(iemin.gt.3)then
                  do 290 i=2,iemin
                     if(dabs(escf0(i)-escf0(i-1)).gt.
     +                  0.05d0*(emin-escf))goto 320
  290             continue
c
c is good enough -- rapid exit
c
                  if(debug) write(mfgw,*)
     1' rapid exit because energy is consistently lower'
                  goto 250
               endif
            else
c
c  the energy has risen above that of the previous minimum.
c  we need to check whether this is a fluke or is this really
c  a bad geometry.
c
               iemin=0
               iemax=min0(5,iemax+1)
               do 300 i=2,iemax
  300          escf0(i-1)=escf0(i)
               escf0(iemax)=escf
c
c  is the difference in energy between two iterations less than 5%
c  of the energy lost for this geometry relative to the previous
c  minimum.
c
               if(iemax.gt.3)then
                  do 310 i=2,iemax
                     if(dabs(escf0(i)-escf0(i-1)).gt.
     +                   0.05d0*(escf-emin))goto 320
  310             continue
c
c is good enough -- rapid exit
c
                  if(debug) write(mfgw,*)
     1' rapid exit because energy is consistently higher'
                  goto 250
               endif
            endif
         endif
  320    ready=(iredy.gt.0.and.
     +          (dabs(diff).lt.sellim*10.d0.or.pl.eq.0.d0))
         iredy=iredy+1
      endif
      if(prtpl.or.debug.and.niter.gt.itrmax-20) then
         if(dabs(escf).gt.99999.d0) escf=dsign(9999.d0,escf)
         if(dabs(diff).gt.9999.d0)diff=0.d0
         if(incitr)
     1    write(mfgw,
     +    '('' iteration'',i3,'' pls='',2e10.3,'' energy  '',
     2f14.7,'' deltae'',f13.7)')niter,pl,plb,escf,diff
      endif
      if(incitr)eold=escf
************************************************************************
*                                                                      *
*                        invoke the camp-king converger                *
*                                                                      *
************************************************************************
      if(niter.gt.2 .and. camkin .and. makea)
     1call interp(norbs,na1el,norbs-na1el, modea, escf/23.061d0,
     2f, c, ar1, ar2, ar3, ar4, ar1)
      makeb=.false.
      if(modea.eq.3)goto 340
      makeb=.true.
      if(timitr)then
      t0=secmop()
      write(mfgw,'(2(a,f7.2))')' adjust damper  integral',t0-titer0
      endif
      if( newdg ) then
************************************************************************
*                                                                      *
*                        invoke pulay's converger                      *
*                                                                      *
************************************************************************
         if(okpuly.and.makea.and.iredy.gt.1)
     1call pulay(f,pa,norbs,pold,pold2,pold3,jalp,ialp,mpack,frst,pl)
************************************************************************
*                                                                      *
*           diagonalize the alpha or rhf secular determinant           *
* where possible, use the pulay-stewart method, otherwise use beppu's  *
*                                                                      *
************************************************************************
         if (halfe.or.camkin) then
            call hqrii(f,norbs,norbs,eigs,c)
         else
c#      call timop('before diag')
            call mopd(f,c,na1el,eigs,norbs,norbs)
c#      call timop('after diag')
         endif
      else
c#      call timop('before hqrii')
         call hqrii(f,norbs,norbs,eigs,c)
c#      call timop('after hqrii')
         if(timitr)then
            t1=secmop()
         write(mfgw,'(2(a,f7.2))')'  hqrii:',t1-t0,' integral',t1-titer0
         endif
      endif
      j=1
      if(prtvec) then
         j=1
         if(uhf)j=2
         write(mfgw,'(//10x,a,
     1'' eigenvectors and eigenvalues on iteration'',i3)')
     2   abprt(j),niter
         call mopmat(c,eigs,norbs,norbs,norbs)
      else
         if (prteig) write(mfgw,330)abprt(j),niter,(eigs(i),i=1,norbs)
      endif
  330 format(10x,a,'  eigenvalues on iteration',i3,/10(6g13.6,/))
  340 if(ifill.ne.0)call mopx(c,norbs,norbs,na2el,ifill)
************************************************************************
*                                                                      *
*            calculate the alpha or rhf density matrix                 *
*                                                                      *
************************************************************************
      if(uhf)then
         call densit( c,norbs, norbs, na2el,na1el, fract, pa, 1)
         if(modea.ne.3.and..not. (newdg.and.okpuly))
     1    call cnvg(pa, pold, pold2, norbs, niter, pl)
      else
c#      call timop('before densit')
         call densit( c,norbs, norbs, na2el,na1el, fract, p, 1)
c#      call timop('after densit')
         if(modea.ne.3.and..not. (newdg.and.okpuly))then
c#      call timop('before cnvg')
            call cnvg(p, pold, pold2, norbs, niter, pl)
c#      call timop('after cnvg')
         endif
      endif
************************************************************************
*                                                                      *
*                       uhf-specific code                              *
*                                                                      *
************************************************************************
      if( uhf )then
************************************************************************
*                                                                      *
*                        invoke the camp-king converger                *
*                                                                      *
************************************************************************
         if(niter.gt.2 .and. camkin .and. makeb )
     1call interp(norbs,nb1el,norbs-nb1el, modeb, escf/23.061d0,
     2fb, cbeta, br1, br2, br3, br4, br1)
         makea=.false.
         if(modeb.eq.3) goto 350
         makea=.true.
         if( newdg ) then
************************************************************************
*                                                                      *
*                        invoke pulay's converger                      *
*                                                                      *
************************************************************************
            if( okpuly.and.makeb.and.iredy.gt.1)
     1call pulay(fb,pb,norbs,pbold,pbold2,
     2pbold3,jbet,ibet,mpack,bfrst,plb)
************************************************************************
*                                                                      *
*           diagonalize the alpha or rhf secular determinant           *
* where possible, use the pulay-stewart method, otherwise use beppu's  *
*                                                                      *
************************************************************************
            if (halfe.or.camkin) then
               call hqrii(fb,norbs,norbs,eigb,cbeta)
            else
               call mopd(fb,cbeta,nb1el,eigb,norbs,norbs)
            endif
         else
            call hqrii(fb,norbs,norbs,eigb,cbeta)
         endif
         if(prtvec) then
            write(mfgw,'(//10x,a,'' eigenvectors and eigenvalues on '',
     1''iteration'',i3)')abprt(3),niter
            call mopmat(cbeta,eigb,norbs,norbs,norbs)
         else
         if (prteig) write(mfgw,330)abprt(3),niter,(eigb(i),i=1,norbs)
         endif
************************************************************************
*                                                                      *
*                calculate the beta density matrix                     *
*                                                                      *
************************************************************************
  350    call densit( cbeta,norbs, norbs, nb2el, nb1el, fract, pb, 1)
         if( .not. (newdg.and.okpuly))
     1call cnvg(pb, pbold, pbold2, norbs, niter, plb)
      endif
************************************************************************
*                                                                      *
*                   calculate the total density matrix                 *
*                                                                      *
************************************************************************
      if(uhf) then
         do 360 i=1,linear
  360    p(i)=pa(i)+pb(i)
      else
         do 370 i=1,linear
            pa(i)=p(i)*0.5d0
  370    pb(i)=pa(i)
      endif
      if(prtden) then
         write(mfgw,'('' density matrix on iteration'',i4)')niter
         call vecprt (p,norbs)
      endif
      oknewd=(pl.lt.sellim .or. oknewd)
      newdg=(pl.lt.trans .and. oknewd .or. newdg)
      if(pl.lt.trans*0.3333d0)oknewd=.true.
      go to 90
**********************************************************************
*                                                                    *
*                                                                    *
*                      end the scf loop here                         *
*                now calculate the electronic energy                 *
*                                                                    *
*                                                                    *
**********************************************************************
*          self-consistence acheived.
*
  380 ee=helect(norbs,pa,h,f)
      if(uhf) then
         ee=ee+helect(norbs,pb,h,fb)
      else
         ee=ee*2.d0 +
     1shift*(nopen-nclose)*23.061d0*0.25d0*(fract*(2.d0-fract))
      endif
      if(capps)ee=ee+capcor(nat,nfirst,nlast,numat,p,h)
c
c   normally the eigenvalues are incorrect because the
c   pseudodiagonalization has been used.  if this
c   is the last scf, then do an exact diagonalization
      if( nscf.eq.0 .or. last.eq.1 .or. ci .or. halfe ) then
c
c  put f and fb into pold in order to not destroy f and fb
c  and do exact diagonalisations
         do 390 i=1,linear
  390    pold(i)=f(i)
         call hqrii(pold,norbs,norbs,eigs,c)
         if(uhf) then
            do 400 i=1,linear
  400       pold(i)=fb(i)
            call hqrii(pold,norbs,norbs,eigb,cbeta)
            do 410 i=1,linear
  410       pold(i)=pa(i)
         else
            do 420 i=1,linear
  420       pold(i)=p(i)
         endif
         if(ci.or.halfe) then
c#        call timop('before meci')
            sum=meci(eigs,c)
c#        call timop('after meci')
            ee=ee+sum
            if(prtpl)then
               escf=(ee+enuclr)*23.061d0 +atheat
               write(mfgw,'(27x,''after meci, energy  '',f14.7)')escf
            endif
         endif
      endif
      nscf=nscf+1
      titer2=secmop()
      if(debug)write(mfgw,'('' no. of iterations ='',i6)')niter
c            if(force)  scfcrt=1.d-5
      if(allcon.and.dabs(bshift-4.44d0).lt.1.d-7)then
         camkin=.false.
         allcon=.false.
         newdg=.false.
         bshift=-10.d0
         okpuly=.false.
      endif
      shift=1.d0
      if(emin.eq.0.d0)then
         emin=escf
      else
         emin=dmin1(emin,escf)
      endif
      return
      end
      subroutine jab(ia,ja,llperm,jindex, jjndex,pja,pjb,w, f)
      implicit REAL (a-h,o-z)
      dimension llperm(10), pja(16), pjb(16), w(*), f(*),
     1jindex(256), jjndex(256), suma(10), sumb(10)
c
c  for vector machines, remove the arrays  suma and sumb, uncomment
c  the lines marked cvector, and comment out the second whole part
c  of the subroutine
cvector                  i=0
cvector                  do 100 i5=1,4
cvector                  iia=ia+i5-1
cvector                  ija=ja+i5-1
cvector                  ioff=(iia*(iia-1))/2+ia-1
cvector                  joff=(ija*(ija-1))/2+ja-1
cvector                  do 100 i6=1,i5
cvector                  ioff=ioff+1
cvector                  joff=joff+1
cvector                        i=i+1
cvector                        l=llperm(i)
cvector                        suma=0
cvector                        sumb=0
cvector                        do 90 k=1,16
cvector                           l=l+1
cvector                           sumb=sumb+pja(k)*w(jjndex(l))
cvector   90                   suma=suma+pjb(k)*w(jindex(l))
cvector                        f(ioff)=f(ioff)+suma
cvector  100             f(joff)=f(joff)+sumb
      suma( 1)=
     1+pja( 1)*w(  1)+pja( 2)*w( 11)+pja( 3)*w( 31)+pja( 4)*w( 61)
     2+pja( 5)*w( 11)+pja( 6)*w( 21)+pja( 7)*w( 41)+pja( 8)*w( 71)
     3+pja( 9)*w( 31)+pja(10)*w( 41)+pja(11)*w( 51)+pja(12)*w( 81)
     4+pja(13)*w( 61)+pja(14)*w( 71)+pja(15)*w( 81)+pja(16)*w( 91)
      suma( 2)=
     1+pja( 1)*w(  2)+pja( 2)*w( 12)+pja( 3)*w( 32)+pja( 4)*w( 62)
     2+pja( 5)*w( 12)+pja( 6)*w( 22)+pja( 7)*w( 42)+pja( 8)*w( 72)
     3+pja( 9)*w( 32)+pja(10)*w( 42)+pja(11)*w( 52)+pja(12)*w( 82)
     4+pja(13)*w( 62)+pja(14)*w( 72)+pja(15)*w( 82)+pja(16)*w( 92)
      suma( 3)=
     1+pja( 1)*w(  3)+pja( 2)*w( 13)+pja( 3)*w( 33)+pja( 4)*w( 63)
     2+pja( 5)*w( 13)+pja( 6)*w( 23)+pja( 7)*w( 43)+pja( 8)*w( 73)
     3+pja( 9)*w( 33)+pja(10)*w( 43)+pja(11)*w( 53)+pja(12)*w( 83)
     4+pja(13)*w( 63)+pja(14)*w( 73)+pja(15)*w( 83)+pja(16)*w( 93)
      suma( 4)=
     1+pja( 1)*w(  4)+pja( 2)*w( 14)+pja( 3)*w( 34)+pja( 4)*w( 64)
     2+pja( 5)*w( 14)+pja( 6)*w( 24)+pja( 7)*w( 44)+pja( 8)*w( 74)
     3+pja( 9)*w( 34)+pja(10)*w( 44)+pja(11)*w( 54)+pja(12)*w( 84)
     4+pja(13)*w( 64)+pja(14)*w( 74)+pja(15)*w( 84)+pja(16)*w( 94)
      suma( 5)=
     1+pja( 1)*w(  5)+pja( 2)*w( 15)+pja( 3)*w( 35)+pja( 4)*w( 65)
     2+pja( 5)*w( 15)+pja( 6)*w( 25)+pja( 7)*w( 45)+pja( 8)*w( 75)
     3+pja( 9)*w( 35)+pja(10)*w( 45)+pja(11)*w( 55)+pja(12)*w( 85)
     4+pja(13)*w( 65)+pja(14)*w( 75)+pja(15)*w( 85)+pja(16)*w( 95)
      suma( 6)=
     1+pja( 1)*w(  6)+pja( 2)*w( 16)+pja( 3)*w( 36)+pja( 4)*w( 66)
     2+pja( 5)*w( 16)+pja( 6)*w( 26)+pja( 7)*w( 46)+pja( 8)*w( 76)
     3+pja( 9)*w( 36)+pja(10)*w( 46)+pja(11)*w( 56)+pja(12)*w( 86)
     4+pja(13)*w( 66)+pja(14)*w( 76)+pja(15)*w( 86)+pja(16)*w( 96)
      suma( 7)=
     1+pja( 1)*w(  7)+pja( 2)*w( 17)+pja( 3)*w( 37)+pja( 4)*w( 67)
     2+pja( 5)*w( 17)+pja( 6)*w( 27)+pja( 7)*w( 47)+pja( 8)*w( 77)
     3+pja( 9)*w( 37)+pja(10)*w( 47)+pja(11)*w( 57)+pja(12)*w( 87)
     4+pja(13)*w( 67)+pja(14)*w( 77)+pja(15)*w( 87)+pja(16)*w( 97)
      suma( 8)=
     1+pja( 1)*w(  8)+pja( 2)*w( 18)+pja( 3)*w( 38)+pja( 4)*w( 68)
     2+pja( 5)*w( 18)+pja( 6)*w( 28)+pja( 7)*w( 48)+pja( 8)*w( 78)
     3+pja( 9)*w( 38)+pja(10)*w( 48)+pja(11)*w( 58)+pja(12)*w( 88)
     4+pja(13)*w( 68)+pja(14)*w( 78)+pja(15)*w( 88)+pja(16)*w( 98)
      suma( 9)=
     1+pja( 1)*w(  9)+pja( 2)*w( 19)+pja( 3)*w( 39)+pja( 4)*w( 69)
     2+pja( 5)*w( 19)+pja( 6)*w( 29)+pja( 7)*w( 49)+pja( 8)*w( 79)
     3+pja( 9)*w( 39)+pja(10)*w( 49)+pja(11)*w( 59)+pja(12)*w( 89)
     4+pja(13)*w( 69)+pja(14)*w( 79)+pja(15)*w( 89)+pja(16)*w( 99)
      suma(10)=
     1+pja( 1)*w( 10)+pja( 2)*w( 20)+pja( 3)*w( 40)+pja( 4)*w( 70)
     2+pja( 5)*w( 20)+pja( 6)*w( 30)+pja( 7)*w( 50)+pja( 8)*w( 80)
     3+pja( 9)*w( 40)+pja(10)*w( 50)+pja(11)*w( 60)+pja(12)*w( 90)
     4+pja(13)*w( 70)+pja(14)*w( 80)+pja(15)*w( 90)+pja(16)*w(100)
      sumb( 1)=
     1+pjb( 1)*w(  1)+pjb( 2)*w(  2)+pjb( 3)*w(  4)+pjb( 4)*w(  7)
     2+pjb( 5)*w(  2)+pjb( 6)*w(  3)+pjb( 7)*w(  5)+pjb( 8)*w(  8)
     3+pjb( 9)*w(  4)+pjb(10)*w(  5)+pjb(11)*w(  6)+pjb(12)*w(  9)
     4+pjb(13)*w(  7)+pjb(14)*w(  8)+pjb(15)*w(  9)+pjb(16)*w( 10)
      sumb( 2)=
     1+pjb( 1)*w( 11)+pjb( 2)*w( 12)+pjb( 3)*w( 14)+pjb( 4)*w( 17)
     2+pjb( 5)*w( 12)+pjb( 6)*w( 13)+pjb( 7)*w( 15)+pjb( 8)*w( 18)
     3+pjb( 9)*w( 14)+pjb(10)*w( 15)+pjb(11)*w( 16)+pjb(12)*w( 19)
     4+pjb(13)*w( 17)+pjb(14)*w( 18)+pjb(15)*w( 19)+pjb(16)*w( 20)
      sumb( 3)=
     1+pjb( 1)*w( 21)+pjb( 2)*w( 22)+pjb( 3)*w( 24)+pjb( 4)*w( 27)
     2+pjb( 5)*w( 22)+pjb( 6)*w( 23)+pjb( 7)*w( 25)+pjb( 8)*w( 28)
     3+pjb( 9)*w( 24)+pjb(10)*w( 25)+pjb(11)*w( 26)+pjb(12)*w( 29)
     4+pjb(13)*w( 27)+pjb(14)*w( 28)+pjb(15)*w( 29)+pjb(16)*w( 30)
      sumb( 4)=
     1+pjb( 1)*w( 31)+pjb( 2)*w( 32)+pjb( 3)*w( 34)+pjb( 4)*w( 37)
     2+pjb( 5)*w( 32)+pjb( 6)*w( 33)+pjb( 7)*w( 35)+pjb( 8)*w( 38)
     3+pjb( 9)*w( 34)+pjb(10)*w( 35)+pjb(11)*w( 36)+pjb(12)*w( 39)
     4+pjb(13)*w( 37)+pjb(14)*w( 38)+pjb(15)*w( 39)+pjb(16)*w( 40)
      sumb( 5)=
     1+pjb( 1)*w( 41)+pjb( 2)*w( 42)+pjb( 3)*w( 44)+pjb( 4)*w( 47)
     2+pjb( 5)*w( 42)+pjb( 6)*w( 43)+pjb( 7)*w( 45)+pjb( 8)*w( 48)
     3+pjb( 9)*w( 44)+pjb(10)*w( 45)+pjb(11)*w( 46)+pjb(12)*w( 49)
     4+pjb(13)*w( 47)+pjb(14)*w( 48)+pjb(15)*w( 49)+pjb(16)*w( 50)
      sumb( 6)=
     1+pjb( 1)*w( 51)+pjb( 2)*w( 52)+pjb( 3)*w( 54)+pjb( 4)*w( 57)
     2+pjb( 5)*w( 52)+pjb( 6)*w( 53)+pjb( 7)*w( 55)+pjb( 8)*w( 58)
     3+pjb( 9)*w( 54)+pjb(10)*w( 55)+pjb(11)*w( 56)+pjb(12)*w( 59)
     4+pjb(13)*w( 57)+pjb(14)*w( 58)+pjb(15)*w( 59)+pjb(16)*w( 60)
      sumb( 7)=
     1+pjb( 1)*w( 61)+pjb( 2)*w( 62)+pjb( 3)*w( 64)+pjb( 4)*w( 67)
     2+pjb( 5)*w( 62)+pjb( 6)*w( 63)+pjb( 7)*w( 65)+pjb( 8)*w( 68)
     3+pjb( 9)*w( 64)+pjb(10)*w( 65)+pjb(11)*w( 66)+pjb(12)*w( 69)
     4+pjb(13)*w( 67)+pjb(14)*w( 68)+pjb(15)*w( 69)+pjb(16)*w( 70)
      sumb( 8)=
     1+pjb( 1)*w( 71)+pjb( 2)*w( 72)+pjb( 3)*w( 74)+pjb( 4)*w( 77)
     2+pjb( 5)*w( 72)+pjb( 6)*w( 73)+pjb( 7)*w( 75)+pjb( 8)*w( 78)
     3+pjb( 9)*w( 74)+pjb(10)*w( 75)+pjb(11)*w( 76)+pjb(12)*w( 79)
     4+pjb(13)*w( 77)+pjb(14)*w( 78)+pjb(15)*w( 79)+pjb(16)*w( 80)
      sumb( 9)=
     1+pjb( 1)*w( 81)+pjb( 2)*w( 82)+pjb( 3)*w( 84)+pjb( 4)*w( 87)
     2+pjb( 5)*w( 82)+pjb( 6)*w( 83)+pjb( 7)*w( 85)+pjb( 8)*w( 88)
     3+pjb( 9)*w( 84)+pjb(10)*w( 85)+pjb(11)*w( 86)+pjb(12)*w( 89)
     4+pjb(13)*w( 87)+pjb(14)*w( 88)+pjb(15)*w( 89)+pjb(16)*w( 90)
      sumb(10)=
     1+pjb( 1)*w( 91)+pjb( 2)*w( 92)+pjb( 3)*w( 94)+pjb( 4)*w( 97)
     2+pjb( 5)*w( 92)+pjb( 6)*w( 93)+pjb( 7)*w( 95)+pjb( 8)*w( 98)
     3+pjb( 9)*w( 94)+pjb(10)*w( 95)+pjb(11)*w( 96)+pjb(12)*w( 99)
     4+pjb(13)*w( 97)+pjb(14)*w( 98)+pjb(15)*w( 99)+pjb(16)*w(100)
      i=0
      do 10 i5=1,4
         iia=ia+i5-1
         ija=ja+i5-1
         ioff=(iia*(iia-1))/2+ia-1
         joff=(ija*(ija-1))/2+ja-1
         do 10 i6=1,i5
            ioff=ioff+1
            joff=joff+1
            i=i+1
            f(ioff)=f(ioff)+sumb(i)
   10 f(joff)=f(joff)+suma(i)
      return
      end
      subroutine jcarin (coord,xparam,step,preci,b,ncol)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
c     jacobian dcartesian/dinternal, worked out by finite difference.
c  input
c     xparam(*) : internal coordinates
c     step      : step size for finite difference method
c     preci     : .true. if 2-points finite differences to be used,
c                 .false. otherwise.
c  output
c     b(nvar,ncol) : jacobian, step time too large.
c
      common /geosym/ ndep, locpar(maxpar), idepfn(maxpar),
     1                      locdep(maxpar)
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),
     1                nlast(numatm), norbs, nelecs,nalpha,nbeta,
     2                nclose,nopen,ndumy,fract
      common /geovar/ nvar,loc(2,maxpar), idumy, yparam(maxpar)
      common /euler/ tvec(3,3),id
      common /ucell/ l1l,l2l,l3l,l1u,l2u,l3u
      common /cmpg/ geo(3,numatm)
      dimension coord(3,*),xparam(*),b(nvar,*), coold(3,numatm*27)
      logical preci
c
      ncol=3*numat
      if(id.ne.0)
     1 ncol=ncol*(l1u-l1l+1)*(l2u-l2l+1)*(l3u-l3l+1)
c
c     internal of central point
      do 10 ivar=1,nvar
   10 geo(loc(2,ivar),loc(1,ivar))=xparam(ivar)
c
      if (id.eq.0) then
c
c        molecular system
c        ----------------
         do 30 ivar=1,nvar
c        step forward
            geo(loc(2,ivar),loc(1,ivar))=xparam(ivar)+step
            if(ndep.ne.0) call mopsym()
            call gmetry (geo,coord)
            do 20 j=1,ncol
   20       b(ivar,j)=coord(j,1)
   30    geo(loc(2,ivar),loc(1,ivar))=xparam(ivar)
         if (preci) then
            do 50 ivar=1,nvar
c           step backward
               geo(loc(2,ivar),loc(1,ivar))=xparam(ivar)-step
               if(ndep.ne.0) call mopsym()
               call gmetry (geo,coord)
               do 40 j=1,ncol
   40          b(ivar,j)=b(ivar,j)-coord(j,1)
   50       geo(loc(2,ivar),loc(1,ivar))=xparam(ivar)
         else
c           central point
            if(ndep.ne.0) call mopsym()
            call gmetry (geo,coord)
            do 60 ivar=1,nvar
               do 60 j=1,ncol
   60       b(ivar,j)=b(ivar,j)-coord(j,1)
         endif
      else
c
c        solid state
c        -----------
         do 80 ivar=1,nvar
c        step forward
            geo(loc(2,ivar),loc(1,ivar))=xparam(ivar)+step
            if(ndep.ne.0) call mopsym()
            call gmetry (geo,coord)
            ij=0
            do 70 ii=1,numat
               do 70 il=l1l,l1u
                  do 70 jl=l2l,l2u
                     do 70 kl=l3l,l3u
                        do 70 ll=1,3
                           ij=ij+1
   70       b(ivar,ij)=coord(ll,ii)
     1            +tvec(ll,1)*il+tvec(ll,2)*jl+tvec(ll,3)*kl
   80    geo(loc(2,ivar),loc(1,ivar))=xparam(ivar)
         if (preci) then
            do 100 ivar=1,nvar
c           step backward
               geo(loc(2,ivar),loc(1,ivar))=xparam(ivar)-step
               if(ndep.ne.0) call mopsym()
               call gmetry (geo,coord)
               ij=0
               do 90 ii=1,numat
                  do 90 il=l1l,l1u
                     do 90 jl=l2l,l2u
                        do 90 kl=l3l,l3u
                           do 90 ll=1,3
                              ij=ij+1
   90          b(ivar,ij)=b(ivar,ij)-coord(ll,ii)
     1                -tvec(ll,1)*il-tvec(ll,2)*jl-tvec(ll,3)*kl
  100       geo(loc(2,ivar),loc(1,ivar))=xparam(ivar)
         else
c           central point
            if(ndep.ne.0) call mopsym()
            call gmetry (geo,coord)
            ij=0
            do 110 ii=1,numat
               do 110 il=l1l,l1u
                  do 110 jl=l2l,l2u
                     do 110 kl=l3l,l3u
                        ij=ij+1
                        do 110 ll=1,3
  110       coold(ll,ij)=coord(ll,ii)
     1                  +tvec(ll,1)*il+tvec(ll,2)*jl+tvec(ll,3)*kl
            do 120 ivar=1,nvar
               do 120 ij=1,ncol
  120       b(ivar,ij)=b(ivar,ij)-coold(ij,1)
         endif
      endif
      return
      end
      subroutine kab(ia,ja, pk, w, kindex, f)
      implicit REAL (a-h,o-z)
      dimension pk(*), w(*), f(*),kindex(256), sum(16)
c
c  for vector machines, remove the array sum, uncomment the lines
c  marked cvector, and comment out the second whole part of the
c  subroutine
c
cvector                  l=0
cvector                  m=0
cvector                  do 130 j1=ia,ia+3
cvector                  j=(j1*(j1-1))/2
cvector                  do 130 j2=ja,ja+3
cvector                  m=m+1
cvector                  j3=j+j2
cvector                     sum=0
cvector                     do 120 i=1,16
cvector                        l=l+1
cvector  120                sum=sum+pk(i)*w(kindex(l))
cvector  130             f(j3)=f(j3)-sum
      sum( 1)=
     1+pk( 1)*w(  1)+pk( 2)*w(  2)+pk( 3)*w(  4)+pk( 4)*w(  7)
     2+pk( 5)*w( 11)+pk( 6)*w( 12)+pk( 7)*w( 14)+pk( 8)*w( 17)
     3+pk( 9)*w( 31)+pk(10)*w( 32)+pk(11)*w( 34)+pk(12)*w( 37)
     4+pk(13)*w( 61)+pk(14)*w( 62)+pk(15)*w( 64)+pk(16)*w( 67)
      sum( 2)=
     1+pk( 1)*w(  2)+pk( 2)*w(  3)+pk( 3)*w(  5)+pk( 4)*w(  8)
     2+pk( 5)*w( 12)+pk( 6)*w( 13)+pk( 7)*w( 15)+pk( 8)*w( 18)
     3+pk( 9)*w( 32)+pk(10)*w( 33)+pk(11)*w( 35)+pk(12)*w( 38)
     4+pk(13)*w( 62)+pk(14)*w( 63)+pk(15)*w( 65)+pk(16)*w( 68)
      sum( 3)=
     1+pk( 1)*w(  4)+pk( 2)*w(  5)+pk( 3)*w(  6)+pk( 4)*w(  9)
     2+pk( 5)*w( 14)+pk( 6)*w( 15)+pk( 7)*w( 16)+pk( 8)*w( 19)
     3+pk( 9)*w( 34)+pk(10)*w( 35)+pk(11)*w( 36)+pk(12)*w( 39)
     4+pk(13)*w( 64)+pk(14)*w( 65)+pk(15)*w( 66)+pk(16)*w( 69)
      sum( 4)=
     1+pk( 1)*w(  7)+pk( 2)*w(  8)+pk( 3)*w(  9)+pk( 4)*w( 10)
     2+pk( 5)*w( 17)+pk( 6)*w( 18)+pk( 7)*w( 19)+pk( 8)*w( 20)
     3+pk( 9)*w( 37)+pk(10)*w( 38)+pk(11)*w( 39)+pk(12)*w( 40)
     4+pk(13)*w( 67)+pk(14)*w( 68)+pk(15)*w( 69)+pk(16)*w( 70)
      sum( 5)=
     1+pk( 1)*w( 11)+pk( 2)*w( 12)+pk( 3)*w( 14)+pk( 4)*w( 17)
     2+pk( 5)*w( 21)+pk( 6)*w( 22)+pk( 7)*w( 24)+pk( 8)*w( 27)
     3+pk( 9)*w( 41)+pk(10)*w( 42)+pk(11)*w( 44)+pk(12)*w( 47)
     4+pk(13)*w( 71)+pk(14)*w( 72)+pk(15)*w( 74)+pk(16)*w( 77)
      sum( 6)=
     1+pk( 1)*w( 12)+pk( 2)*w( 13)+pk( 3)*w( 15)+pk( 4)*w( 18)
     2+pk( 5)*w( 22)+pk( 6)*w( 23)+pk( 7)*w( 25)+pk( 8)*w( 28)
     3+pk( 9)*w( 42)+pk(10)*w( 43)+pk(11)*w( 45)+pk(12)*w( 48)
     4+pk(13)*w( 72)+pk(14)*w( 73)+pk(15)*w( 75)+pk(16)*w( 78)
      sum( 7)=
     1+pk( 1)*w( 14)+pk( 2)*w( 15)+pk( 3)*w( 16)+pk( 4)*w( 19)
     2+pk( 5)*w( 24)+pk( 6)*w( 25)+pk( 7)*w( 26)+pk( 8)*w( 29)
     3+pk( 9)*w( 44)+pk(10)*w( 45)+pk(11)*w( 46)+pk(12)*w( 49)
     4+pk(13)*w( 74)+pk(14)*w( 75)+pk(15)*w( 76)+pk(16)*w( 79)
      sum( 8)=
     1+pk( 1)*w( 17)+pk( 2)*w( 18)+pk( 3)*w( 19)+pk( 4)*w( 20)
     2+pk( 5)*w( 27)+pk( 6)*w( 28)+pk( 7)*w( 29)+pk( 8)*w( 30)
     3+pk( 9)*w( 47)+pk(10)*w( 48)+pk(11)*w( 49)+pk(12)*w( 50)
     4+pk(13)*w( 77)+pk(14)*w( 78)+pk(15)*w( 79)+pk(16)*w( 80)
      sum( 9)=
     1+pk( 1)*w( 31)+pk( 2)*w( 32)+pk( 3)*w( 34)+pk( 4)*w( 37)
     2+pk( 5)*w( 41)+pk( 6)*w( 42)+pk( 7)*w( 44)+pk( 8)*w( 47)
     3+pk( 9)*w( 51)+pk(10)*w( 52)+pk(11)*w( 54)+pk(12)*w( 57)
     4+pk(13)*w( 81)+pk(14)*w( 82)+pk(15)*w( 84)+pk(16)*w( 87)
      sum(10)=
     1+pk( 1)*w( 32)+pk( 2)*w( 33)+pk( 3)*w( 35)+pk( 4)*w( 38)
     2+pk( 5)*w( 42)+pk( 6)*w( 43)+pk( 7)*w( 45)+pk( 8)*w( 48)
     3+pk( 9)*w( 52)+pk(10)*w( 53)+pk(11)*w( 55)+pk(12)*w( 58)
     4+pk(13)*w( 82)+pk(14)*w( 83)+pk(15)*w( 85)+pk(16)*w( 88)
      sum(11)=
     1+pk( 1)*w( 34)+pk( 2)*w( 35)+pk( 3)*w( 36)+pk( 4)*w( 39)
     2+pk( 5)*w( 44)+pk( 6)*w( 45)+pk( 7)*w( 46)+pk( 8)*w( 49)
     3+pk( 9)*w( 54)+pk(10)*w( 55)+pk(11)*w( 56)+pk(12)*w( 59)
     4+pk(13)*w( 84)+pk(14)*w( 85)+pk(15)*w( 86)+pk(16)*w( 89)
      sum(12)=
     1+pk( 1)*w( 37)+pk( 2)*w( 38)+pk( 3)*w( 39)+pk( 4)*w( 40)
     2+pk( 5)*w( 47)+pk( 6)*w( 48)+pk( 7)*w( 49)+pk( 8)*w( 50)
     3+pk( 9)*w( 57)+pk(10)*w( 58)+pk(11)*w( 59)+pk(12)*w( 60)
     4+pk(13)*w( 87)+pk(14)*w( 88)+pk(15)*w( 89)+pk(16)*w( 90)
      sum(13)=
     1+pk( 1)*w( 61)+pk( 2)*w( 62)+pk( 3)*w( 64)+pk( 4)*w( 67)
     2+pk( 5)*w( 71)+pk( 6)*w( 72)+pk( 7)*w( 74)+pk( 8)*w( 77)
     3+pk( 9)*w( 81)+pk(10)*w( 82)+pk(11)*w( 84)+pk(12)*w( 87)
     4+pk(13)*w( 91)+pk(14)*w( 92)+pk(15)*w( 94)+pk(16)*w( 97)
      sum(14)=
     1+pk( 1)*w( 62)+pk( 2)*w( 63)+pk( 3)*w( 65)+pk( 4)*w( 68)
     2+pk( 5)*w( 72)+pk( 6)*w( 73)+pk( 7)*w( 75)+pk( 8)*w( 78)
     3+pk( 9)*w( 82)+pk(10)*w( 83)+pk(11)*w( 85)+pk(12)*w( 88)
     4+pk(13)*w( 92)+pk(14)*w( 93)+pk(15)*w( 95)+pk(16)*w( 98)
      sum(15)=
     1+pk( 1)*w( 64)+pk( 2)*w( 65)+pk( 3)*w( 66)+pk( 4)*w( 69)
     2+pk( 5)*w( 74)+pk( 6)*w( 75)+pk( 7)*w( 76)+pk( 8)*w( 79)
     3+pk( 9)*w( 84)+pk(10)*w( 85)+pk(11)*w( 86)+pk(12)*w( 89)
     4+pk(13)*w( 94)+pk(14)*w( 95)+pk(15)*w( 96)+pk(16)*w( 99)
      sum(16)=
     1+pk( 1)*w( 67)+pk( 2)*w( 68)+pk( 3)*w( 69)+pk( 4)*w( 70)
     2+pk( 5)*w( 77)+pk( 6)*w( 78)+pk( 7)*w( 79)+pk( 8)*w( 80)
     3+pk( 9)*w( 87)+pk(10)*w( 88)+pk(11)*w( 89)+pk(12)*w( 90)
     4+pk(13)*w( 97)+pk(14)*w( 98)+pk(15)*w( 99)+pk(16)*w(100)
      if(ia.gt.ja)then
         m=0
         do 10 j1=ia,ia+3
            j=(j1*(j1-1))/2
            do 10 j2=ja,ja+3
               m=m+1
               j3=j+j2
   10    f(j3)=f(j3)-sum(m)
      else
c
c   ia is less than ja, therefore use other half of triangle
c
         m=0
         do 20 j1=ia,ia+3
            do 20 j2=ja,ja+3
               m=m+1
               j3=(j2*(j2-1))/2+j1
   20    f(j3)=f(j3)-sum(m)
      endif
      return
      end
      subroutine linmin(xparam,alpha,pvect,nvar,funct,okf,ic, dott)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      dimension xparam(nvar),pvect(nvar)
      common /gravec/ cosine
      common /numcal/ numcal
      common/iofile/mfgr,mfgw
c*********************************************************************
c
c  linmin does a line minimisation.
c
c  on input:  xparam = starting coordinate of search.
c             alpha  = step size for initiating search.
c             pvect  = direction of search.
c             nvar   = number of variables in xparam.
c             funct  = initial value of the function to be minimized.
c             isok   = not important.
c             cosine = cosine of angle of current and previous gradient.
c
c  on output: xparam = coordinate of minimum of functi0n.
c             alpha  = new step size, used in next call of linmin.
c             funct  = final, minimum value of the function.
c             okf    = true if linmin improved funct, false otherwise.
c
c**********************************************************************
      common /keywrd/ keywrd
c
c  the following common is used to find out if a non-variationally
c  optimized wave-function is being used.
c
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),
     1                nlast(numatm), norbs, nelecs,nalpha,nbeta,
     2                nclose,nopen,ndumy,fract
      character keywrd*241
      dimension phi(3), vt(4), pold(maxpar)
      dimension xstor(maxpar), xparef(maxpar)
      integer left,right,center
      logical print,okf, halfe, diis
*******
      save
*******
*     save icalcn, print, halfe, xmaxm, i
*     save maxlin, angle, ymaxst, drop, delta1, delta2
*******
      data icalcn /0/
      if (icalcn.ne.numcal) then
         halfe =(index(keywrd,'c.i.') .ne. 0 .or. nclose.ne.nopen)
         if(index(keywrd,'gnorm') .ne. 0)
     1drop=drop*dmin1(reada(keywrd,index(keywrd,'gnorm')),1.d0)
         xmaxm  = 0.4d0
         delta2 = 0.001d0
         if(index(keywrd,'noth') .eq. 0) then
            delta1 = 0.5d0
         else
            delta1 = 0.1d0
         endif
         alpha  = 1.d0
         maxlin = 15
         if(nvar.eq.1)then
            pvect(1)=0.01d0
            drop=0.01d0
            alpha=1.d0
            delta1 = 0.00005d0
            delta2 = 0.00001d0
            if(index(keywrd,'prec') .ne. 0) delta1=0.0000005d0
            maxlin=30
         endif
         angle=0.8d0
         if(halfe) angle=-2.d0
         cosine=99.99d0
c
c  angle is used to decide if p is to be updated as calculation
c        proceeds.
c
         ymaxst  = 0.4d0
         print=(index(keywrd,'linmin') .ne. 0)
         icalcn=numcal
      endif
c#         write(6,'(a,f12.6)')' angle between pvect''s:',
c#     1dot(pold,pvect,nvar)/
c#     1dsqrt(dot(pold,pold,nvar)*dot(pvect,pvect,nvar)+1.d-20)
      do 10 i=1,nvar
         xparef(i)=xparam(i)
   10 pold(i)=pvect(i)
      xmaxm=0.d0
      do 20 i=1,nvar
         pabs=dabs(pvect(i))
   20 xmaxm=dmax1(xmaxm,pabs)
      xminm=xmaxm
      xmaxm=ymaxst/xmaxm
      if(nvar.eq.1)
     1call compfg(xparam, .true., funct,.true.,grad,.false.)
      fin=funct
      ssqlst=funct
      diis=ic.eq.1.and.nvar.gt.1
      phi(1)=funct
      alpha=1.d0
      vt(1)=0.0d00
      vt(2)=alpha
      if (vt(2).gt.xmaxm) vt(2)=xmaxm
      fmax=funct
      fmin=funct
      alpha=vt(2)
      do 30 i=1,nvar
   30 xparam(i)=xparef(i)+alpha*pvect(i)
      call compfg(xparam, .true., phi(2),.true.,grad,.false.)
      if(phi(2).gt.fmax) fmax=phi(2)
      if(phi(2).lt.fmin) fmin=phi(2)
      call mopexc(phi(2),sqstor,energy,estor,xparam,xstor,alpha,alfs,
     +  nvar)
      if(diis)goto 190
      if(nvar.gt.1)then
c
c   calculate a new alpha based on thiel's formula
c
         alpha=-alpha**2*dott/(2.d0*(phi(2)-ssqlst-alpha*dott))
         if(alpha.gt.2.d0)alpha=2.d0
      else
         if(phi(2).lt.phi(1))then
            alpha=2*alpha
         else
            alpha=-alpha
         endif
      endif
c#      if(print)write(6,'(3(a,f12.6))')' estimated drop:',dott*0.5d0,
c#     1'  actual: ',phi(2)-ssqlst, '  predicted alpha',alpha
      okf=okf.or.phi(2).lt.ssqlst
      if(delta1.gt.0.3d0)then
c
c  thiel's tests # 18 and 19
c
         if(okf.and.alpha.lt.2.d0)goto 190
      endif
      vt(3)=alpha
      if (vt(3).le.1.d0) then
         left=3
         center=1
         right=2
      else
         left=1
         center=2
         right=3
      endif
      do 40 i=1,nvar
   40 xparam(i)=xparef(i)+alpha*pvect(i)
      call compfg (xparam, .true., funct,.true.,grad,.false.)
      if(funct.gt.fmax) fmax=funct
      if(funct.lt.fmin) fmin=funct
      if (funct.lt.sqstor) call mopexc(funct,sqstor,energy,estor,xparam
     +  ,xstor,alpha,alfs,nvar)
      okf=(okf.or.funct.lt.fin)
      phi(3)=funct
      if (print)write (mfgw,50) vt(1),phi(1),phi(1)-fin,
     1                        vt(2),phi(2),phi(2)-fin,
     2                        vt(3),phi(3),phi(3)-fin
   50 format ( ' ---qlinmn ',/5x, 'left   ...',f17.8,2f17.11/5x,
     1 'center ...',f17.8,2f17.11,/5x, 'right  ...',f17.8,2f17.11,/)
      do 180 ictr=3,maxlin
         alpha=vt(2)-vt(3)
         beta=vt(3)-vt(1)
         gamma=vt(1)-vt(2)
         if(dabs(alpha*beta*gamma) .gt. 1.d-4)then
            alpha=-(phi(1)*alpha+phi(2)*beta+phi(3)*gamma)/(alpha*beta*g
     1amm   a)
         else
c
c   finish because two points calculated are very close together
c
            goto 190
         endif
         beta=((phi(1)-phi(2))/gamma)-alpha*(vt(1)+vt(2))
         if (alpha) 60,60,90
   60    if (phi(right).gt.phi(left)) go to 70
         alpha=3.0d00*vt(right)-2.0d00*vt(center)
         go to 80
   70    alpha=3.0d00*vt(left)-2.0d00*vt(center)
   80    s=alpha-alpold
         if (dabs(s).gt.xmaxm) s=dsign(xmaxm,s)*
     +                           (1.0d0+0.01d0*(xmaxm/s))
         alpha=s+alpold
         go to 100
   90    alpha=-beta/(2.0d00*alpha)
         s=alpha-alpold
         xxm=2.0d00*xmaxm
         if (dabs(s).gt.xxm) s=dsign(xxm,s)*(1.0d0+0.01d0*(xxm/s))
         alpha=s+alpold
  100    continue
c
c   finish if calculated point is near to point already calculated
c
         do 110 i=1,3
  110    if (dabs(alpha-vt(i)).lt.delta1*(1.d0+vt(i)).and.okf)
     +        goto 190
         do 120 i=1,nvar
  120    xparam(i)=xparef(i)+alpha*pvect(i)
         funold=funct
         call compfg (xparam, .true., funct,.true.,grad,.false.)
         if(funct.gt.fmax) fmax=funct
         if(funct.lt.fmin) fmin=funct
         if (funct.lt.sqstor) call mopexc(funct,sqstor,energy,estor,
     +  xparam,xstor,alpha,alfs,nvar)
         okf=okf .or. (funct.lt.fin)
         if (print) write(mfgw,130) vt(left),phi(left), phi(left)-fin,
     1                      vt(center),phi(center),phi(center)-fin,
     2                      vt(right),phi(right),phi(right)-fin,
     3                      alpha,funct,funct-fin
  130    format (5x,'left    ...',f17.8,2f17.11,/5x,'center  ...',
     1f17.8,2f17.11,/5x,'right   ...',f17.8,2f17.11,/5x,
     2 'new     ...',f17.8,2f17.11,/)
c
c test to exit from linmin if not dropping in value of function fast.
c
         if(dabs(funold-funct) .lt. delta2 .and. okf) goto 190
         alpold=alpha
         if ((alpha.gt.vt(right)).or.(alpha.gt.vt(center)
     1        .and.funct.lt.phi(center)).or.(alpha.gt.vt(left)
     2        .and.alpha.lt.vt(center).and.funct.gt.phi(center)))
     3         goto 140
         vt(right)=alpha
         phi(right)=funct
         go to 150
  140    vt(left)=alpha
         phi(left)=funct
  150    if (vt(center).lt.vt(right)) go to 160
         i=center
         center=right
         right=i
  160    if (vt(left).lt.vt(center)) go to 170
         i=left
         left=center
         center=i
  170    if (vt(center).lt.vt(right)) go to 180
         i=center
         center=right
         right=i
  180 continue
  190 continue
c
c  ic=1 if the last point calculated was the best point, ic=2 otherwise
c
      ic=2
      if(dabs(estor-energy).lt.1.d-12)ic=1
      call mopexc(sqstor,funct,estor,energy,xstor,xparam,alfs,alpha,
     +  nvar)
      okf = (funct.lt.ssqlst.or.diis)
      if (funct.ge.ssqlst) return
      if (alpha) 200,220,220
  200 alpha=-alpha
      do 210 i=1,nvar
  210 pvect(i)=-pvect(i)
  220 continue
      return
c
c
      end
      subroutine locmin(m,x,n,p,ssq,alf,efs,itrap,escf)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      common /nllsqi/ ncount
      common /keywrd/ contrl
      common /numcal/ numcal
      common/iofile/mfgr,mfgw
      dimension x(*), p(*), efs(*)
      dimension const(maxpar), xstor(maxpar), gstor(maxpar)
      dimension phi(3),vt(3)
      integer left,right,center
      character*241 keywrd, contrl
*****
      save
*****
*     save xmaxm, scale, first, keywrd, eps, debug, tee, ymaxst, xcrit
*     save mxcnt2, iprint, const
*****
      logical first, debug, lower
      data const/maxpar*1.d0/, first /.true./
*     save icalcn
      data icalcn/0/
************************************************************************
*
*    locmin is called by nllsq only. it is a line-search procedure for
*    locating a minimum in the function space of compfg.  see nllsq
*    for more details
*
************************************************************************
      if (icalcn.ne.numcal) then
         icalcn=numcal
         xmaxm=1.d9
         scale=1.d0
         keywrd=contrl
c
c the above line is to try to prevent overflow in nllsq
c
         eps=1.d-5
         debug=(index(keywrd,'linmin') .ne. 0)
         tee=1.d-2
         ymaxst=0.005d0
         xcrit=0.0002d0
         mxcnt2=30
         iprint=0
         if(debug)iprint=-1
      endif
      xmaxm=1.d-11
      do 10 i=1,n
   10 xmaxm=dmax1(xmaxm,dabs(p(i)))
      xminm=xmaxm*scale
      xmaxm=ymaxst/xmaxm/scale
      fin = ssq
      lower = .false.
      t=alf
      phi(1) = ssq
      vt(1) = 0.0d0
      vt(2) = t/4.0d0
      if(vt(2).gt.xmaxm) vt(2)=xmaxm
      t = vt(2)
      do 20 i=1,n
   20 x(i) = x(i)+t*p(i)*const(i)*scale
      call compfg(x,.true.,escf,.true.,efs,.true.)
      phi(2)=ddot(n,efs,1,efs,1)
      call mopexc(phi(2),sqstor,energy,estor,x,xstor,t,alfs,n)
      do 30 i=1,m
   30 gstor(i)=efs(i)
      if (phi(1) .le. phi(2)) then
         vt(3) = -vt(2)
         left = 3
         center = 1
         right = 2
      else
         vt(3)=2.0d0*vt(2)
         left = 1
         center = 2
         right = 3
      endif
      tlast = vt(3)
      t = tlast-t
      do 40 i=1,n
   40 x(i) = x(i)+t*p(i)*const(i)*scale
      flast=phi(2)
      call compfg(x,.true.,escf,.true.,efs,.true.)
      f=ddot(n,efs,1,efs,1)
      if(f.lt.sqstor) call mopexc(f,sqstor,energy,estor,x,xstor,t,alfs,
     +  n)
      do 50 i=1,m
   50 gstor(i)=efs(i)
      if(f.lt.fin) lower = .true.
      ncount = ncount+2
      phi(3) = f
      if (iprint) 60,70,70
   60 write (mfgw,310) vt(1),phi(1),vt(2),phi(2),vt(3),phi(3)
   70 mxct=mxcnt2
      do 250 ictr=3,mxct
         xmaxm=xmaxm*3.d0
         alpha = vt(2) - vt(3)
         beta = vt(3) - vt(1)
         gamma = vt(1)-vt(2)
         if(alpha.eq.0.d0)alpha=1.d-20
         if(beta.eq.0.d0)beta=1.d-20
         if(gamma.eq.0.d0)gamma=1.d-20
         abg =-(phi(1)*alpha+phi(2)*beta+phi(3)*gamma)/alpha
         abg=abg/beta
         abg=abg/gamma
         alpha=abg
         beta = ((phi(1)-phi(2))/gamma)-alpha*(vt(1)+vt(2))
         if (alpha)  80,80,110
   80    if (phi(right) .gt. phi(left))  go to 90
         t = 3.0d0*vt(right)-2.0d0*vt(center)
         go to 100
   90    t = 3.0d0*vt(left)-2.0d0*vt(center)
  100    s=t-tlast
         t=s+tlast
         go to 150
  110    t = -beta/(2.0d0*alpha)
         s=t-tlast
         if (s) 120,260,130
  120    amdis=vt(left)-tlast-xmaxm
         go to 140
  130    amdis=vt(right)-tlast+xmaxm
  140    if(dabs(s).gt.dabs(amdis)) s=amdis
         t=s+tlast
  150    continue
         if(ictr.gt.3.and.dabs(s*xminm).lt.xcrit) then
            if( debug )
     1    write(mfgw,'('' exit due to small projected step'')')
            go to 260
         endif
         t=s+tlast
         do 160 i=1,n
  160    x(i) = x(i)+s*p(i)*const(i)*scale
         flast=f
         call compfg(x,.true.,escf,.true.,efs,.true.)
         f=ddot(n,efs,1,efs,1)
         if(f.lt.sqstor) call mopexc(f,sqstor,energy,estor,x,xstor,t,
     +  alfs,n)
         do 170 i=1,m
  170    gstor(i)=efs(i)
         if(f.lt.fin) lower = .true.
         ncount = ncount+1
         if (iprint) 180,190,190
  180    write (mfgw,320) vt(left),phi(left),vt(center),phi(center),
     1  vt(right),phi(right),t,f
  190    continue
c
c    test for excited states and potholes
c
         itrap=0
         if(dabs(vt(center)).gt.1.d-10) goto 200
         if(dabs(t)/(dabs(vt(left))+1.d-15).gt.0.3333d0) goto 200
         if(2.5d0*f-phi(right)-phi(left).lt.0.5d0*phi(center)) goto 200
c
c   we are stuck on a false minimum
c
         itrap=1
         goto 260
  200    continue
*
* now for the main stopping tests.  locmin will stop if:-
*     the error function has been reduced, and
*     the rate of drop of the error function is less than 0.5% per step
*     and
*     (a) the ratio of the proposed step to the total step is less than
*         eps,   or
*     (b) the last drop in error function was less than 5%ofthetotaldrop
*         during this call to locmin.
*
         if(debug)write(mfgw,'('' f/flast'',f13.6)')f/flast
         if( lower  .and. f/flast .gt. 0.995d0) then
            if((dabs(t-tlast).le.eps*dabs(t+tlast)+tee)) then
               if( debug )
     1       write(mfgw,'('' exit as step is absolutely small '')')
               go to 260
            endif
            sum=dmin1(dabs(f-phi(1)),dabs(f-phi(2)),dabs(f-phi(3)))
            sum2=(fin-sqstor)*0.05d0
            if(sum .lt. sum2) then
               if( debug )
     1        write(mfgw,'('' exit due to having reached bottom'')')
               goto 260
            endif
         endif
         tlast = t
         if ((t .gt. vt(right)) .or. (t .gt. vt(center) .and. f .lt.
     1  phi(center)) .or. (t .gt. vt(left) .and. t .lt. vt(center) .and.
     2  f .gt. phi(center)))  go to 210
         vt(right) = t
         phi(right) = f
         go to 220
  210    vt(left) = t
         phi(left) = f
  220    if (vt(center) .lt. vt(right))  go to 230
         i = center
         center = right
         right = i
  230    if (vt(left) .lt. vt(center))  go to 240
         i = left
         left = center
         center = i
  240    if (vt(center) .lt. vt(right))  go to 250
         i = center
         center = right
         right = i
  250 continue
  260 continue
      call mopexc(sqstor,f,estor,energy,xstor,x,alfs,t,n)
      do 270 i=1,m
  270 efs(i)=gstor(i)
      ssq=(f)
      alf=t
      if (t) 280,300,300
  280 t = -t
      do 290 i=1,n
  290 p(i) = -p(i)
  300 continue
      alf=t
      return
  310 format(' ---locmin'/5x,'left   ...',2f19.6/5x,'center ...',
     1  2f19.6/5x,'right  ...',2f19.6/' ')
  320 format(5x,'left   ...',2f19.6/5x,'center ...',2f19.6/5x,
     1  'right  ...',2f19.6/5x,'new    ...',2f19.6/' ')
      end
      subroutine mamult(a,b,c,n,one)
      implicit REAL (a-h,o-z)
      dimension a(*),b(*),c(*)
************************************************************************
*
*   mamult multiplies a by b and puts the result in c
*
************************************************************************
      l=0
      do 40 i=1,n
         ii=((i-1)*i)/2
         do 40 j=1,i
            jj=((j-1)*j)/2
            l=l+1
            sum=0.d0
            do 10 k=1,j
   10       sum=sum+a(ii+k)*b(jj+k)
            do 20 k=j+1,i
   20       sum=sum+a(ii+k)*b(((k-1)*k)/2+j)
            do 30 k=i+1,n
               kk=(k*(k-1))/2
   30       sum=sum+a(kk+i)*b(kk+j)
   40 c(l)=sum+one*c(l)
      return
      end
      subroutine me08a(a,alpha,beta,n,ia,q)
      COMPLEX      a(ia,*),alpha(*),beta(*),q(*),cw,qj,czero
      COMPLEX      fm06as,fm06bs
      REAL  pp,zero,p5,h
      REAL  s1,pp1
      data zero/0.0d0/, p5 /0.50d0/
      czero=zero
c**************************************************************
c the reduction of full hermitian matrix into tri-diagonal hermitian
c form is done in n-2 steps.at the i th step zeros are introduced in
c the i th row and columns without destroying previously produced zeros
c
c                                                    h
c at the i th step we have  a =p a   p  with p =i-u u  /k
c                            i  i i-1 i       i    i i   i
c
c where u =(0,0,...,a     (1+s /t ),a     ,...,a   )
c        i           i,i+1    i  i   i,i+2      i,n
c        2   n          2        2                2
c       s = sum  ] a   ]     k =s +t   and  t = sqrt(]a     ] s )
c        i   j=i+1  i,j       i  i  i        i         i,i+1   i
c
c computational details at the i th stage are (1) form s  ,k   then
c                                                       i   i
c
c                                     h                      h     h
c (2) q =a   u  /k    (3) q =q -.5u (u q /k ) (4) a =a   -u q  -q u
c      i  i-1 i   i        i  i    i  i i  i       i  i-1  i i   i i
c
c  the vectors u being appropiately in a.
      if(n.le.0)go to 90
      do 10 j=1,n
         alpha(j)=a(j,j)
         do 10 i=1,j
   10 a(i,j)=conjg(a(j,i))
      if(n-2)90,80,20
   20 n2=n-2
      do 60 i=1,n2
         i1=i+1
c                       (1)
         cw=fm06bs(n-i,a(i,i+1),ia,a(i,i+1),ia)
         pp=cw
         pp1=dsqrt(pp)
         beta(i+1)=cmplx(-pp1,zero)
         s1=cdabs(a(i,i+1))
         if(s1.gt.zero)beta(i+1)=beta(i+1)*a(i,i+1)/s1
         if(pp.le.1.d-15)go to 60
         h=pp+pp1*s1
         a(i,i+1)=a(i,i+1)-beta(i+1)
c                       (2)
         do 30 k=i1,n
            qj=fm06as(-(i-k),a(i+1,k),1,a(i,i+1),ia)
            qj=fm06bs(n-k,a(k,k+1),ia,a(i,k+1),ia)+conjg(qj)
   30    q(k)=qj/h
c                       (3)
         cw=fm06as(n-i,a(i,i+1),ia,q(i+1),1)
         pp=cw*p5/h
         do 40 k=i1,n
   40    q(k)=q(k)-pp*conjg(a(i,k))
c                       (4)
         do 50 k=i1,n
   50    call me08b (a(k,k),q(k),a(i,k),n-k+1,ia*2)
   60 continue
      do 70 i=2,n
         qj=alpha(i)
         alpha(i)=a(i,i)
   70 a(i,i)=qj
   80 beta(n)=a(n-1,n)
   90 return
      end
      subroutine me08b (a,q,b,n,ia)
      REAL  a(ia,*),q(2,*),b(ia,*)
      do 10 i=1,n
         a(1,i)=a(1,i) -q(1,1)*b(1,i)+q(2,1)*b(2,i)
     1 -q(1,i)*b(1,1)+q(2,i)*b(2,1)
   10 a(2,i)=a(2,i)-q(2,1)*b(1,i)-q(1,1)*b(2,i)
     1 +q(2,i)*b(1,1)+q(1,i)*b(2,1)
      return
      end
      function meci(eigs,coeff)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
***********************************************************************
*
*                 program meci
*
*   a multi-electron configuration interaction calculation
*
*   written by james j. p. stewart, at the
*              frank j. seiler research laboratory
*              usafa, colorado springs, co 80840
*
*              1985
*
***********************************************************************
c
      REAL  meci
c
c   matrices for permutation work
c
      dimension nfa(2*nmeci), nperma(nmeci,6*nmeci),
     1npermb(nmeci,6*nmeci), eiga(nmeci)
      common / readme / ird
c
c   matrices for one and two electron integrals
c
      common /rjks/rjkab(nmeci,nmeci), rjkaa(nmeci,nmeci)
c
c   spin matrices
c
      dimension spin(nmeci**2)
      logical debug,  large, prnt, lspin, lspin1,
     1 first1, bigprt, sing, doub, trip, quar, quin, sext,
     2 prnt2, force, geook
      character keywrd*241, tspin(7)*8, line*80
      character citxt*6
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),
     1                nlast(numatm), norbs, nelecs,
     2                ndummy(2), nclose, nopen, ndumy, fract
      common /last/ last
      common /spqr/ ispqr(nmeci**2,nmeci),is,i,k
      common /keywrd/ keywrd
      dimension eigs(norbs), coeff(norbs,norbs)
c
c   matrices for sec.det., vectors, and eigenvalues.
c
      common /work2/ cimat(nmeci**4), eig(nmeci**2), diiag(2*nmeci**3)
      common /baseoc/ occa(nmeci)
      common /work3/ dijkl(mpack*4)
      common /civect/ vectci(nmeci**2),conf(nmeci**4+1)
      common /nalmat/ nalpha(nmeci**2)
      common /micros/
     +   microa(nmeci,4*nmeci**2), microb(nmeci,4*nmeci**2)
      common /cibits/ nmos,lab,nelec, nbo(3)
      common /xyijkl/ xy(nmeci,nmeci,nmeci,nmeci)
      common /numcal/ numcal
      common/iofile/mfgr,mfgw
      save
************************
*     save first1, tspin
*     save j,l, debug, prnt2,mdim, lspin1, force
*     save large, lroot, sing, doub, quar, quin, sext, smult, ne
*     save nleft, geook
*     save icalcn
************************
      data icalcn/0/
      data tspin/'singlet ','doublet ','triplet ','quartet ','quintet ',
     1'sextet  ','septet  '/
      citxt = 'c.i.=('
      if (icalcn.ne.numcal) then
         icalcn=numcal
         first1=.true.
         mdim=nmeci**2
         geook=(index(keywrd,'geo-ok').ne.0)
         force=(index(keywrd,'force').ne.0)
         lspin1=(index(keywrd,'esr').ne.0)
         debug=(index(keywrd,'debug').ne.0)
         prnt2=(index(keywrd,'meci').ne.0)
         debug=(debug.and.prnt2)
         large=(index(keywrd,'large').ne.0)
         ndoubl=99
         if(index(keywrd,citxt).ne.0)then
            ndoubl=reada(keywrd,index(keywrd,citxt)+7)
            nmos=reada(keywrd,index(keywrd,citxt)+5)
         elseif (index(keywrd,'c.i.=').ne.0)then
            nmos=reada(keywrd,index(keywrd,'c.i.=')+5)
         else
            nmos=nopen-nclose
         endif
         lroot=1
         if(index(keywrd,'exci').ne.0)lroot=2
         i=index(keywrd,'root')
         if(i.ne.0)lroot=reada(keywrd,i)
         if(ndoubl.eq.99)then
            j=max0(
     +          min0((nclose+nopen+1)/2-(nmos-1)/2,norbs-nmos+1),1)
         else
            j=nclose-ndoubl+1
            if(fract.gt.1.99d0)j=j+1
         endif
         l=0
         do 10 i=j,nclose
            l=l+1
   10    occa(l)=1
         do 20 i=nclose+1,nopen
            l=l+1
   20    occa(l)=fract*0.5d0
         do 30 i=nopen+1,j+nmos-1
            l=l+1
   30    occa(l)=0.d0
c#         write(mfgw,'('' initial orbital occupancies'')')
c#         write(mfgw,'(6f12.6)')(occa(l),l=1,nmos)
         sing=(index(keywrd,'sing')+
     1         index(keywrd,'exci')+
     2         index(keywrd,'birad').ne.0)
         doub=(index(keywrd,'doub').ne.0)
         trip=(index(keywrd,'trip').ne.0)
         quar=(index(keywrd,'quar').ne.0)
         quin=(index(keywrd,'quin').ne.0)
         sext=(index(keywrd,'sext').ne.0)
c
c  define magnetic component of spin
c
         msdel=index(keywrd,' ms')
         if(msdel.ne.0)then
            msdel=1.0001d0*reada(keywrd,index(keywrd,' ms'))
         else
            if(trip.or.quar)msdel=1
            if(quin.or.sext)msdel=2
         endif
         smult=-.5d0
         if(sing) smult=0.00d0
         if(doub) smult=0.75d0
         if(trip) smult=2.00d0
         if(quar) smult=3.75d0
         if(quin) smult=6.00d0
         if(sext) smult=8.75d0
         x=0.d0
         do 40 j=1,nmos
   40    x=x+occa(j)
         xx=x+x
         ne=xx+0.5
         nelec=(nelecs-ne+1)/2
         nleft=norbs-nmos-nelec
      endif
      prnt=(debug.or.last.eq.3.and.prnt2)
      bigprt=(prnt.and.large)
c
c    test to see if the set of energy levels used in meci is complete,
c    i.e., all components of degenerate irreducible representations
c    are used.  if not, then results will be nonsense.  give users a
c    chance to really foul things up by allowing job to continue if
c    'geo-ok' is specified.
c
      do 50 i=1,nmos
         in=i+nelec
   50 eiga(i)=eigs(in)
      lspin=(lspin1.and. last.eq.3)
      if(bigprt)then
      write(mfgw,'(''  initial eigenvalues'')')
      write(mfgw,'(5f12.6)')(eiga(i),i=1,nmos)
      write(mfgw,'(//10x,''number of electrons in c.i. ='',f5.1)')xx
      endif
      if(.not.geook.and.nelec.gt.0)then
         if(dabs(eigs(nelec+1)-eigs(nelec)).lt.1.d-1.or.
     1      dabs(eigs(nelec+1+nmos)-eigs(nelec+nmos)).lt.1.d-1)then
         write(mfgw,'(///10x,a)')'degenerate energy levels detected in m
     1eci'
         write(mfgw,'(10x,a)')'some of these levels would be treated by'
     1//' meci,'
         write(mfgw,'(10x,a)')'while others would not.  this would resul
     1t in'
         write(mfgw,'(10x,a)')'non-reproducible electronic energies.'
         write(mfgw,'(10x,a)')'  job stopped.  to continue, specify "geo
     1-ok"'
_IF(ipsc,tools)
            call pend
_ELSE
            stop
_ENDIF
         endif
      endif
      if( bigprt ) then
         write(mfgw,'(//10x,''eigenvectors'',/)')
         do 60 i=1,norbs
   60    write(mfgw,'(6f12.6)')(coeff(i,j+nelec),j=1,nmos)
      endif
      nfa(2)=1
      nfa(1)=1
      do 70 i=3,nmeci+1
   70 nfa(i)=nfa(i-1)*(i-1)
      call mopi(coeff(1,nelec+1),coeff,nelec,nmos,dijkl)
      do 80 i=1,nmos
         do 80 j=1,nmos
            rjkaa(i,j)=xy(i,i,j,j)-xy(i,j,i,j)
   80 rjkab(i,j)=xy(i,i,j,j)
      do 100 i=1,nmos
         x=0.0d0
         do 90 j=1,nmos
            x=x+(rjkaa(i,j)+rjkab(i,j))*occa(j)
   90    continue
         eiga(i)=eiga(i)-x
c#      if(abs(occa(i)-0.5).lt.1.d-4)eiga(i)=eiga(i)+xy(i,i,i,i)*0.25d0
  100 continue
      if(bigprt) then
         write(mfgw,110)
  110    format(/,5x,'eigenvalues after removal of inter-electronic inte
     1ractions',/)
         write(mfgw,'(6f12.6)')(eiga(i),i=1,nmos)
         write(mfgw,'(///10x,''two-electron j-integrals'',/)')
         do 120 i1=1,nmos
  120    write(mfgw,'(10f10.4)')(rjkab(i1,j1),j1=1,nmos)
         write(mfgw,'(///10x,''two-electron k-integrals'',/)')
         do 130 i1=1,nmos
  130    write(mfgw,'(10f10.4)')(rjkab(i1,j1)-rjkaa(i1,j1),j1=1,nmos)
      endif
      natoms=numat
      do 140 i=1,nmos
         do 140 j=1,nmos
            rjkaa(i,j)=rjkaa(i,j)*0.5d0
  140 continue
      if(first1) then
         i=index(keywrd,'micros')
         if(i.ne.0)then
            k=reada(keywrd,i)
            lab=k
            if(prnt)write(mfgw,'(''    microstates read in'')')
            ntot=xx+0.5
            rewind ird
            do 150 i=1,1000
               read(ird,'(a)')line
  150       if(index(line,'micro').ne.0)goto 160
  160       do 170 i=1,1000
               read(ird,'(a)')line
  170       if(index(line,'micro').ne.0)goto 180
  180       do 210 i=1,lab
               read(ird,'(a)')line
               izero=max0(0,min0(index(line,'0'),index(line,'1'))-1)
               do 190 j=1,nmos
                  if(line(j+izero:j+izero).ne.'1')
     1            line(j+izero:j+izero)='0'
                  if(line(j+nmos+izero:j+nmos+izero).ne.'1')
     1            line(j+nmos+izero:j+nmos+izero)='0'
                  microa(j,i)=ichar(line(j+izero:j+izero))-
     1          ichar('0')
                  microb(j,i)=ichar(line(j+nmos+izero:j+nmos+izero))-
     1          ichar('0')
  190          continue
               if(prnt)write(mfgw,'(20i6)')(microa(j,i),j=1,nmos),
     1        (microb(j,i),j=1,nmos)
               k=0
               do 200 j=1,nmos
  200          k=k+microa(j,i)+microb(j,i)
               if(k.ne.ntot)then
                  ntot=k
                  xx=k
               write(mfgw,'(/,''number of electrons in c.i. redefined to
     1:'',i4,/)')k
               endif
  210       continue
            first1=.false.
            goto 260
         endif
         nupp=(ne+1)/2 +msdel
         ndown=ne-nupp
         ams=(nupp-ndown)*0.5d0
         if(prnt)write(mfgw,220) ams
  220    format(10x,'component of spin  = ',f4.1)
         if(nupp*ndown.lt.0) then
            write(mfgw,'(/10x,''impossible value of delta s'')')
_IF(ipsc,tools)
            call pend
_ELSE
            stop
_ENDIF
         endif
         lima=nfa(nmos+1)/(nfa(nupp+1)*nfa(nmos-nupp+1))
         limb=nfa(nmos+1)/(nfa(ndown+1)*nfa(nmos-ndown+1))
         lab=lima*limb
         if(prnt)write(mfgw,230) lab
  230    format(//10x,35h no of configurations considered = ,i4)
c#      if(lab.lt.101) goto 240
c#      write(mfgw,230)
c#  230 format(10x,24h too many configurations/)
c#      goto 160
c#  240 continue
         call perm(nperma, nupp, nmos, nmeci, lima)
         call perm(npermb, ndown, nmos, nmeci, limb)
         k=0
         do 240 i=1,lima
            do 240 j=1,limb
               k=k+1
               do 240 l=1,nmos
                  microa(l,k)=nperma(l,i)
  240    microb(l,k)=npermb(l,j)
  260    continue
         lima=lab
         limb=lab
      endif
      gse=0.0d0
      do 270 i=1,nmos
         gse=gse+eiga(i)*occa(i)*2.d0
         gse=gse+xy(i,i,i,i)*occa(i)*occa(i)
         do 270 j=i+1,nmos
  270 gse=gse+2.d0*(2.d0*xy(i,i,j,j) - xy(i,j,i,j))*occa(i)*occa(j)
      j=0
      do 280 i=1,lab
         diiag(i)=emsiab(microa(1,i),microb(1,i),eiga,xy,nmos)-gse
  280 continue
  290 continue
      if(lab.le.mdim) goto 330
      x=-100.d0
      do 300 i=1,lab
         if(diiag(i).gt.x)then
            x=diiag(i)
            j=i
         endif
  300 continue
      if(j.ne.lab) then
         do 320 i=j,lab
            i1=i+1
            do 310 k=1,nmos
               microa(k,i)=microa(k,i1)
  310       microb(k,i)=microb(k,i1)
  320    diiag(i)=diiag(i1)
      endif
      lab=lab-1
      goto 290
  330 continue
c
c     build spin and number of alpha spin tables.
c     -------------------------------------------
      do 350 i=1,lab
         k=0
         x=0.d0
         do 340 j=1,nmos
            x=x+microa(j,i)*microb(j,i)
  340    k=k+microa(j,i)
         nalpha(i)=k
  350 spin(i)=4.d0*x-(xx-2*nalpha(i))**2
c
c   before starting, check that the root wanted can exist
c
      if(lab.lt.lroot)then
      write(mfgw,'(//10x,''c.i. is of size less than root specified'')')
      write(mfgw,'(10x,''modify size of c.i. or root number'')')
_IF(ipsc,tools)
         call pend
_ELSE
         stop
_ENDIF
      endif
      if(prnt)then
      write(mfgw,'(/,'' configurations considered in c.i.      '',/
     1          '' m.o. number :      '',10i4)')(i,i=nelec+1,nelec+nmos)
         write(mfgw,'(''          energy'')')
         do 360 i=1,lab
         write(mfgw,'(/10x,i4,6x,10i4)') i,(microa(k,i),k=1,nmos)
  360    write(mfgw,'(6x,f10.4,4x,10i4)')diiag(i),(microb(k,i),k=1,nmos)
      endif
      call mecih(diiag,cimat,nmos,lab)
      if(bigprt)then
         write(mfgw,'(//,'' c.i. matrix'')')
         i=min0(lab,maxorb)
         if(i.ne.lab)write(mfgw,'(''   (output has been truncated)'')')
         call vecprt(cimat,-i)
      else
         if(prnt)write(mfgw,'(//,'' diagonal of c.i. matrix'')')
         if(prnt)write(mfgw,'(5f13.6)')(cimat((i*(i+1))/2),i=1,lab)
      endif
c#       call timop('sec. det. constructed')
      labsiz=min0(lab,lroot+10)
      call hqrii(cimat,lab,labsiz,eig,conf)
c#       call timop('diag. done')
c
c   decide which root to extract
c
      kroot=0
      if(smult.lt.-0.1d0)then
         meci=eig(lroot)
         do 370 j=1,lab
  370    vectci(j)=conf(j+lab*(lroot-1))
         kroot=lroot
      endif
      if(bigprt)  then
         write(mfgw,'(//20x,''state vectors'',//)')
         i=min0(lab,norbs)
         j=min0(labsiz,norbs)
         call mopmat(conf,eig,j,i,lab)
      endif
      if(prnt)then
         write(mfgw,380)
  380    format(///,' state energies '
     1,' expectation value of s**2  s from s**2=s(s+1)',//)
      endif
      iroot=0
      do 390 i=1,9
  390 cimat(i)=0.1d0
      do 440 i=1,labsiz
         x=0.5d0*xx
         ii=(i-1)*lab
         do 420 j=1,lab
            ji=j+ii
            x=x-conf(ji)*conf(ji)*spin(j)*0.25d0
            k=ispqr(j,1)
            if(k.eq.1)  goto  410
            do 400 l=2,k
               li=ispqr(j,l)+ii
  400       x=x+conf(ji)*conf(li)*2.d0
  410       continue
  420    continue
         y=(-1.d0+dsqrt(1.d0+4.d0*x))*0.5d0
         if(dabs(smult-x).lt.0.01d0)then
            iroot=iroot+1
            if(iroot.eq.lroot) then
               kroot=i
               meci=eig(i)
               do 430 j=1,lab
  430          vectci(j)=conf(j+lab*(i-1))
            endif
         endif
         j=y*2.d0+1.5d0
         cimat(j)=cimat(j)+1.0d0
  440 if(prnt)write(mfgw,460) i,eig(i),tspin(j),x,y
      if(kroot.eq.0)then
      write(mfgw,'(//10x,''the state required is not present in the'')')
      write(mfgw,'(10x,  ''    set of configurations available'')')
      write(mfgw,'(/ 4x,''number of states accessible using current key-
     1words'',/)')
         do 450 i=1,7
  450    if(cimat(i).gt.0.5d0)
     1write(mfgw,'((24x,a8,i4))')tspin(i),nint(cimat(i))
_IF(ipsc,tools)
         call pend
_ELSE
         stop
_ENDIF
      endif
  460 format(i5,f12.6,3x,a8,f15.5,f10.5)
      maxvec=0
      if(lspin)maxvec=min0(4,lab)
      if(lspin.and.(ne/2)*2.eq.ne) then
      write(mfgw,'(''   esr specified for an even-electron system'')')
      endif
c#      do 570 i=1,nmos
c#         do 570 j=1,norbs
c#  570 coeff(j,i+nelec)=coeff(j,i+nelec)**2
      do 540 iuj=1,maxvec
         iofset=(iuj-1)*lab
         write(mfgw,'(//,''      microstate contributions to '',
     1''state eigenfunction'',i3)')iuj
         write(mfgw,'(5f13.6)')(conf(i+iofset),i=1,lab)
         do 480 i=1,lab
  480    conf(i)=conf(i+iofset)**2
c                                             second vector!
         do 500 i=1,nmos
            sum=0.d0
            do 490 j=1,lab
  490       sum=sum+(microa(i,j)-microb(i,j))*conf(j)
  500    eiga(i)=sum
      write(mfgw,'(/,''    spin densities from each m.o., energy:''
     1,f7.3)')eig(iuj)
      write(mfgw,'(5f12.6)') (eiga(i),i=1,nmos)
      write(mfgw,*)
      write(mfgw,*)'     spin densities from each atomic orbital'
      write(mfgw,*)'                              s        px        '//
     1'py        pz        total'
         do 530 i=1,natoms
            il=nfirst(i)
            iu=nlast(i)
            l=0
            summ=0.d0
            do 520 k=il,iu
               l=l+1
               sum=0.d0
               do 510 j=1,nmos
  510          sum=sum+coeff(k,j+nelec)*eiga(j)
               summ=summ+sum
  520       eigs(l)=sum
            if(l.eq.4)then
            write(mfgw,'(''  atom'',i4,''    spin density  '',5f10.7)')
     1i,(eigs(k),k=1,l),summ
            else
            write(mfgw,'(''  atom'',i4,''    spin density  '',f10.7,30x,
     1f10.7)')i,eigs(1),summ
            endif
  530    continue
  540 continue
      return
      end
      subroutine mecid(eigs,gse,eiga,diiag)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      dimension eigs(*), eiga(*), diiag(*)
************************************************************************
*
*   mecid calculates the effect of removing the electrons involved in
*   the c.i. from the ground-state configuration, and calculates the
*   microstate energies of the microstates involved in the c.i.
*
*  the quantities nmos, nelec, and lab, and the arrays eigs, occa,
*  microa, and microb are used, but unchanged on exit
*
*   on exit, gse is the electronic energy of stabilization due to
*            removal of the electrons involved in the c.i.
*
*            eiga holds the one-electron energy levels resulting from
*            removal of the electrons involved in the c.i.
*
*            diag holds the microstate energies of all states involved
*            in the c.i.  this can be used as the diagonal of a c.i.
*            matrix
*
************************************************************************
      common /baseoc/ occa(nmeci)
      common /micros/ microa(nmeci,4*nmeci**2),microb(nmeci,4*nmeci**2)
      common /cibits/ nmos,lab,nelec, nbo(3)
      common /xyijkl/ xy(nmeci,nmeci,nmeci,nmeci)
      gse=0.d0
      do 20 i=1,nmos
         x=0.0d0
         do 10 j=1,nmos
   10    x=x+(2.d0*xy(i,i,j,j)-xy(i,j,i,j))*occa(j)
         eiga(i)=eigs(i+nelec)-x
         gse=gse+eiga(i)*occa(i)*2.d0
         gse=gse+xy(i,i,i,i)*occa(i)*occa(i)
         do 20 j=i+1,nmos
   20 gse=gse+2.d0*(2.d0*xy(i,i,j,j) - xy(i,j,i,j))*occa(i)*occa(j)
      do 30 i=1,lab
   30 diiag(i)=emsiab(microa(1,i),microb(1,i),eiga,xy,nmos)-gse
      return
      end
      subroutine mecih(diiag,cimat,nmos,lab)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      dimension diiag(*),cimat(*)
c
c     build the c.i. matrix 'cimat' in packed canonical form.
c
      common /spqr/ ispqr(nmeci**2,nmeci),is,i,k
      common /nalmat/ nalpha(nmeci**2)
      common /micros/
     +   microa(nmeci,4*nmeci**2), microb(nmeci,4*nmeci**2)
c
      ik=0
c
c     outer loop to fill c.i. matrix.
      do 30 i=1,lab
         is=2
c
c     inner loop.
         do 20 k=1,i
            ik=ik+1
            cimat(ik)=0.d0
            ix=0
            iy=0
            do 10 j=1,nmos
               ix=ix+iabs(microa(j,i)-microa(j,k))
   10       iy=iy+iabs(microb(j,i)-microb(j,k))
c
c                              check if matrix element has to be zero
c
            if(ix+iy.gt.4 .or. nalpha(i).ne.nalpha(k)) go to 20
            if(ix+iy.eq.4) then
               if(ix.eq.0)then
                  cimat(ik)=babbcd(microa(1,i),microb(1,i)
     1                            ,microa(1,k),microb(1,k),nmos)
               else if(ix.eq.2) then
                  cimat(ik)=aabbcd(microa(1,i),microb(1,i)
     1                            ,microa(1,k),microb(1,k),nmos)
               else
                  cimat(ik)=aabacd(microa(1,i),microb(1,i)
     1                            ,microa(1,k),microb(1,k),nmos)
               endif
            else if(ix.eq.2) then
               cimat(ik)=aababc(microa(1,i),microb(1,i)
     1                         ,microa(1,k),nmos)
            else if(iy.eq.2) then
               cimat(ik)=babbbc(microa(1,i),microb(1,i)
     1                         ,microb(1,k),nmos)
            else
               cimat(ik)=diiag(i)
            endif
   20    continue
   30 ispqr(i,1)=is-1
      return
      end
      subroutine mecip(coeffs,norbs,deltap, delta)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
************************************************************************
*
*   mecip will correct the total density matrix for the effect of the
*   c.i.
*              on input
*
*  coeffs       : all m.o.'s (norbs m.o.s)
*  norbs        : number of molecular orbitals = number of a.o.'s
*  p            : total density matrix
*  nmos         : number of m.o.'s in active space
*  vectci       : state vector of length lab
*  microa(i,j)  : alpha occupancy of m.o. 'i' in microstate 'j'
*  microb(i,j)  : beta  occupancy of m.o. 'i' in microstate 'j'
*
*  note: this is a modification of code originally written by
*        prof. daniel liotard
************************************************************************
      common /cibits/ nmos,lab,nelec, nbo(3)
      dimension coeffs(norbs,norbs), deltap(nmos,nmos),
     1delta(norbs,nmos)
      common /densty/ p(mpack), pa(mpack), pb(mpack)
      common /nalmat/ nalpha(nmeci**2)
      common /baseoc/ occa(nmeci)
      common /civect/ vectci(nmeci**2),conf(nmeci**4+1)
      common /micros/
     +   microa(nmeci,4*nmeci**2), microb(nmeci,4*nmeci**2)
c     initialize with the opposite of the 'scf' density.
      do 10 i=1,nmos
         deltap(i,i)=-occa(i)*2.d0
         do 10 j=1,i-1
   10 deltap(i,j)=0.d0
c
c     add the c.i. correction
      do 120 id=1,lab
         do 120 jd=1,id
c     check spin agreement
            if(nalpha(id).ne.nalpha(jd)) go to 120
            ix=0
            iy=0
            do 20 j=1,nmos
               ix=ix+iabs(microa(j,id)-microa(j,jd))
   20       iy=iy+iabs(microb(j,id)-microb(j,jd))
c     check number of differing m.o.
            if(ix+iy.gt.2) go to 120
            if(ix.eq.2) then
c        determinants id and jd differ by m.o i in id and m.o j in jd:
               do 30 i=1,nmos
   30          if(microa(i,id).ne.microa(i,jd)) go to 40
   40          ij=microb(i,id)
               do 50 j=i+1,nmos
                  if(microa(j,id).ne.microa(j,jd)) go to 60
   50          ij=ij+microa(j,id)+microb(j,id)
c        ij gives the sign of the permutation
   60          deltap(j,i)=deltap(j,i)+vectci(id)*vectci(jd)*
     +                     dfloat(1-2*mod(ij,2))
            else if(iy.eq.2) then
c        determinants id and jd differ by m.o j in id and m.o i in jd:
               do 70 i=1,nmos
   70          if(microb(i,id).ne.microb(i,jd)) go to 80
   80          ij=0
               do 90 j=i+1,nmos
                  if(microb(j,id).ne.microb(j,jd)) go to 100
   90          ij=ij+microa(j,id)+microb(j,id)
  100          ij=ij+microa(j,id)
               deltap(j,i)=deltap(j,i)+vectci(id)*vectci(jd)*
     +                     dfloat(1-2*mod(ij,2))
            else
c        determinants id and jd are identical:
               do 110 i=1,nmos
  110          deltap(i,i)=deltap(i,i)+(microa(i,id)+microb(i,id))*
     +         vectci(id)**2
            endif
  120 continue
c
c     back transform into a.o. basis.
c     -------------------------------
c     p(c.i.) = p(scf) + c * deltap * c'
      do 130 i=1,nmos
cdir$ ivdep
         do 130 j=1,i-1
  130 deltap(j,i)=deltap(i,j)
c     step 1: deltap = c * deltap
      call mxm (coeffs(1,nelec+1),norbs,deltap,nmos,delta,nmos)
c     step 2: p = p + deltap * c'
      ij=0
      do 150 i=1,norbs
         do 150 j=1,i
            ij=ij+1
            sum=0.d0
            do 140 k=1,nmos
  140       sum=sum+delta(i,k)*coeffs(j,nelec+k)
  150 p(ij)=p(ij)+sum
c     note from d.l.: at this point the 'natural orbitals' of this state
c     can be obtained straightway as eigenvectors of the density matrix.
      return
      end
      subroutine minv(a,n,d)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      dimension a(*)
**********************************************************************
*
*     invert a matrix using gauss-jordan method.  part of diis
*     a - input matrix (must be a general matrix), destroyed in
*        computation and replaced by resultant inverse.
*     n - order of matrix a
*     d - resultant determinant
*
**********************************************************************
      dimension m(maxpar), l(maxpar)
c
c     search for largest element
c
      d=1.0d0
      nk=-n
      do 180 k=1,n
         nk=nk+n
         l(k)=k
         m(k)=k
         kk=nk+k
         biga=a(kk)
         do 20 j=k,n
            iz=n*(j-1)
            do 20 i=k,n
               ij=iz+i
               if (dabs(biga).lt.dabs(a(ij)))then
                  biga=a(ij)
                  l(k)=i
                  m(k)=j
               endif
   20    continue
c
c     interchange rows
c
         j=l(k)
         if (j-k) 50,50,30
   30    ki=k-n
         do 40 i=1,n
            ki=ki+n
            hold=-a(ki)
            ji=ki-k+j
            a(ki)=a(ji)
   40    a(ji)=hold
c
c     interchange columns
c
   50    i=m(k)
         if (i-k) 80,80,60
   60    jp=n*(i-1)
         do 70 j=1,n
            jk=nk+j
            ji=jp+j
            hold=-a(jk)
            a(jk)=a(ji)
   70    a(ji)=hold
c
c     divide column by minus pivot (value of pivot element is
c     contained in biga)
c
   80    if (biga) 100,90,100
   90    d=0.0d0
         return
  100    do 120 i=1,n
            if (i-k) 110,120,110
  110       ik=nk+i
            a(ik)=a(ik)/(-biga)
  120    continue
c  reduce matrix
         do 150 i=1,n
            ik=nk+i
            hold=a(ik)
            ij=i-n
            do 150 j=1,n
               ij=ij+n
               if (i-k) 130,150,130
  130          if (j-k) 140,150,140
  140          kj=ij-i+k
               a(ij)=hold*a(kj)+a(ij)
  150    continue
c
c     divide row by pivot
c
         kj=k-n
         do 170 j=1,n
            kj=kj+n
            if (j-k) 160,170,160
  160       a(kj)=a(kj)/biga
  170    continue
c
c     product of pivots
c
         d=dmax1(-1.0d25,dmin1(1.0d25,d))
         d=d*biga
c
c     replace pivot by reciprocal
c
         a(kk)=1.0d0/biga
  180 continue
c
c     final row and column interchange
c
      k=n
  190 k=(k-1)
      if (k) 260,260,200
  200 i=l(k)
      if (i-k) 230,230,210
  210 jq=n*(k-1)
      jr=n*(i-1)
      do 220 j=1,n
         jk=jq+j
         hold=a(jk)
         ji=jr+j
         a(jk)=-a(ji)
  220 a(ji)=hold
  230 j=m(k)
      if (j-k) 190,190,240
  240 ki=k-n
      do 250 i=1,n
         ki=ki+n
         hold=a(ki)
         ji=ki-k+j
         a(ki)=-a(ji)
  250 a(ji) =hold
      go to 190
  260 return
      end
      subroutine moldat(mode)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      common /geokst/ natoms,labels(numatm),
     1                na(numatm),nb(numatm),nc(numatm)
      common /molmec/ htype(4),nhco(4,20),nnhco,itype
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),
     1                nlast(numatm), norbs, nelecs,nalpha,nbeta,
     2                nclose,nopen,ndumy,fract
      common /keywrd/ keywrd
      common /cmporb/ natorb(107)
      common /corec/ core(107)
      common /betas/ betas(107),betap(107),betad(107)
      common /molorb/ uspd(maxorb),pspd(maxorb)
      common /vsips/ vs(107),vp(107),vd(107)
      common /cmpone/ uss(107),upp(107),udd(107)
      common /atheat/ atheat
      common /polvol/ polvol(107)
      common /multip/ dd(107),qq(107),am(107),ad(107),aq(107)
      common /twoele/ gss(107),gsp(107),gpp(107),gp2(107),hsp(107)
     4                ,gsd(107),gpd(107),gdd(107)
      common /ideaa/ guesa1(107,10),guesa2(107,10),guesa3(107,10)
      common /ideas/ guess1(107,10),guess2(107,10),guess3(107,10)
      common /ideap/ guesp1(107,10),guesp2(107,10),guesp3(107,10)
      common /alpha/ alp(107)
      common /refs/ allref(107,4)
      common /mndo/  ussm(107), uppm(107), uddm(107), zsm(107),
     1zpm(107), zdm(107), betasm(107), betapm(107), betadm(107),
     2alpm(107), eisolm(107), ddm(107), qqm(107), amm(107),
     3adm(107), aqm(107), gssm(107), gspm(107), gppm(107),
     4gp2m(107), hspm(107), polvom(107)
      common /pm3/  usspm3(107), upppm3(107), uddpm3(107), zspm3(107),
     1zppm3(107), zdpm3(107), betasp(107), betapp(107), betadp(107),
     2alppm3(107), eisolp(107), ddpm3(107), qqpm3(107), ampm3(107),
     3adpm3(107), aqpm3(107) ,gsspm3(107), gsppm3(107), gpppm3(107),
     4gp2pm3(107), hsppm3(107),polvop(107)
      common /am1blo/ussam1(107), uppam1(107), uddam1(107), zsam1(107),
     1zpam1(107), zdam1(107), betasa(107), betapa(107), betada(107),
     2alpam1(107), eisola(107), ddam1(107), qqam1(107), amam1(107),
     3adam1(107), aqam1(107) ,gssam1(107), gspam1(107), gppam1(107),
     4gp2am1(107), hspam1(107),polvoa(107)
      common /cmpg/ geo(3,numatm)
      parameter (mdumy=maxpar**2-mpack)
      common /scrach/ rxyz(mpack), xdumy(mdumy)
*
*  common blocks for mindo/3
*
      common /onele3/  uss3(18),upp3(18)
      common /atomi3/  eisol3(18),eheat3(18)
      common /expon3/  zs3(18),zp3(18)
*
*  end of mindo/3 common blocks
*
      common /expont/ zs(107),zp(107),zd(107)
      common /atomic/ eisol(107),eheat(107)
      common/iofile/mfgr,mfgw
      dimension coord(3,numatm), iswap(2,20), estore(107)
      character*241 keywrd, olde(20)*6, allref*80, citxt*6
      logical debug, uhf,exci, trip, mindo3, birad, am1, open, lpm3,
     1lmndo, halfe, slow
      data estore(1)/0.d0/
      if(estore(1).eq.0.d0)then
      do 9 i=1,107
   9  estore(i)=eheat(i)
      endif
      do 8 i=1,107
  8   eheat(i)=estore(i)
      citxt = 'c.i.=('
      debug = (index(keywrd,'moldat').ne.0)
      lpm3  = (index(keywrd,'pm3').ne.0)
      mindo3= (index(keywrd,'mindo').ne.0)
      uhf=(index(keywrd,'uhf') .ne. 0)
      am1= (index(keywrd,'am1').ne.0)
      lmndo=(.not.am1.and..not.lpm3)
      kharge=0
      i=index(keywrd,'charge')
      if(i.ne.0) kharge=reada(keywrd,i)
      elecs=-kharge
      ndorbs=0
      atheat=0.d0
      eat=0.d0
      numat=0
      if(mode.eq.1) goto 80
      if ( lmndo ) then
*
*    switch in mndo parameters
*
c
c       zero out gaussian 1 for carbon.  this will be used in
c       rotate to decide whether or not to use am1-type gaussians
c
         guess1(6,1)=0.d0
         do 10 i=1,107
            if(.not.mindo3) polvol(i)=polvom(i)
            zs(i)=zsm(i)
            zp(i)=zpm(i)
            zd(i)=zdm(i)
            uss(i)=ussm(i)
            upp(i)=uppm(i)
            udd(i)=uddm(i)
            betas(i)=betasm(i)
            betap(i)=betapm(i)
            betad(i)=betadm(i)
            alp(i)=alpm(i)
            eisol(i)=eisolm(i)
            dd(i)=ddm(i)
            qq(i)=qqm(i)
            am(i)=amm(i)
            ad(i)=adm(i)
            aq(i)=aqm(i)
            gss(i)=gssm(i)
            gpp(i)=gppm(i)
            gsp(i)=gspm(i)
            gp2(i)=gp2m(i)
            hsp(i)=hspm(i)
   10    continue
      elseif( lpm3 ) then
*
*    switch in mndo-pm3 parameters
*
         do 30 i=1,107
            do 20 j=1,10
               guess1(i,j)=guesp1(i,j)
               guess2(i,j)=guesp2(i,j)
   20       guess3(i,j)=guesp3(i,j)
            polvol(i)=polvop(i)
            zs(i)=zspm3(i)
            zp(i)=zppm3(i)
            zd(i)=zdpm3(i)
            uss(i)=usspm3(i)
            upp(i)=upppm3(i)
            udd(i)=uddpm3(i)
            betas(i)=betasp(i)
            betap(i)=betapp(i)
            betad(i)=betadp(i)
            alp(i)=alppm3(i)
            eisol(i)=eisolp(i)
            dd(i)=ddpm3(i)
            qq(i)=qqpm3(i)
            am(i)=ampm3(i)
            ad(i)=adpm3(i)
            aq(i)=aqpm3(i)
            gss(i)=gsspm3(i)
            gpp(i)=gpppm3(i)
            gsp(i)=gsppm3(i)
            gp2(i)=gp2pm3(i)
            hsp(i)=hsppm3(i)
   30    continue
      else
*
*    switch in am1 parameters
*
         do 50 i=1,107
            do 40 j=1,10
               guess1(i,j)=guesa1(i,j)
               guess2(i,j)=guesa2(i,j)
   40       guess3(i,j)=guesa3(i,j)
            polvol(i)=polvoa(i)
            zs(i)=zsam1(i)
            zp(i)=zpam1(i)
            zd(i)=zdam1(i)
            uss(i)=ussam1(i)
            upp(i)=uppam1(i)
            udd(i)=uddam1(i)
            betas(i)=betasa(i)
            betap(i)=betapa(i)
            betad(i)=betada(i)
            alp(i)=alpam1(i)
            eisol(i)=eisola(i)
            dd(i)=ddam1(i)
            qq(i)=qqam1(i)
            am(i)=amam1(i)
            ad(i)=adam1(i)
            aq(i)=aqam1(i)
            gss(i)=gssam1(i)
            gpp(i)=gppam1(i)
            gsp(i)=gspam1(i)
            gp2(i)=gp2am1(i)
            hsp(i)=hspam1(i)
   50    continue
      endif
c
c        swap in old parameters for elements.  olde contains the
c        character name of the element, and iswap(1,1:newele) contains
c        the atomic number of the element. iswap(2,1:newele) contains
c        the storage address of the old set of parameters.
c
      newele=2
      olde(1)=' s1978'
      iswap(1,1)=16
      iswap(2,1)=91
      olde(2)='si1978'
      iswap(1,2)=14
      iswap(2,2)=90
c$doit asis
      do 60 k=1,newele
         if(index(keywrd,olde(k)).ne.0)then
            i=iswap(1,k)
            j=iswap(2,k)
            allref(i,3)=allref(j,1)
            allref(i,1)=allref(j,1)
            zs(i)=zs(j)
            zp(i)=zp(j)
            zd(i)=zd(j)
            uss(i)=uss(j)
            upp(i)=upp(j)
            udd(i)=udd(j)
            betas(i)=betas(j)
            betap(i)=betap(j)
            betad(i)=betad(j)
            alp(i)=alp(j)
            eisol(i)=eisol(j)
            dd(i)=dd(j)
            qq(i)=qq(j)
            am(i)=am(j)
            ad(i)=ad(j)
            aq(i)=aq(j)
            if(gss(j).ne.0)gss(i)=gss(j)
            if(gpp(j).ne.0)gpp(i)=gpp(j)
            if(gsp(j).ne.0)gsp(i)=gsp(j)
            if(gp2(j).ne.0)gp2(i)=gp2(j)
            if(hsp(j).ne.0)hsp(i)=hsp(j)
         endif
   60 continue
      if( mindo3 ) then
         do 70 i=1,17
            if(i.ne.2.and.i.ne.10)then
               uss(i)=uss3(i)
               upp(i)=upp3(i)
               eisol(i)=eisol3(i)
               eheat(i)=eheat3(i)
               zs(i)=zs3(i)
               zp(i)=zp3(i)
               gss(i)=gssm(i)
               gpp(i)=gppm(i)
               gsp(i)=gspm(i)
               gp2(i)=gp2m(i)
               hsp(i)=hspm(i)
            endif
   70    continue
      endif
   80 continue
      if(uss(1) .gt. -1.d0) then
      write(mfgw,'(''  the hamiltonian requested is not available in''
     1,'' this program'')')
_IF(ipsc,tools)
         call pend
_ELSE
         stop
_ENDIF
      endif
      ia=1
      ib=0
      nheavy=0
      do 130 ii=1,natoms
         if(labels(ii).eq.99.or.labels(ii).eq.107) goto 130
         numat=numat+1
         nat(numat)=labels(ii)
         nfirst(numat)=ia
         ni=nat(numat)
         atheat=atheat+eheat(ni)
         eat   =eat   +eisol(ni)
         elecs=elecs+core(ni)
         ib=ia+natorb(ni)-1
         nmidle(numat)=ib
         if(natorb(ni).eq.9)ndorbs=ndorbs+5
         if(natorb(ni).eq.9)nmidle(numat)=ia+3
         nlast(numat)=ib
         if(ia.gt.maxorb) goto 270
         uspd(ia)=uss(ni)
         if(ia.eq.ib) goto 120
         k=ia+1
         k1=ia+3
c$doit asis
         do 90 j=k,k1
            if(j.gt.maxorb) goto 270
            uspd(j)=upp(ni)
   90    continue
         nheavy=nheavy+1
         if(k1.eq.ib)goto 120
         k=k1+1
c$doit asis
         do 110 j=k,ib
  110    uspd(j)=udd(ni)
  120    continue
  130 ia=ib+1
      if(numat.eq.1)then
         if(index(keywrd,'force').ne.0)then
         write(mfgw,'(///,a)')'      a single atom has no vibrational mo
     1des'
_IF(ipsc,tools)
            call pend
_ELSE
            stop
_ENDIF
         endif
      endif
      if(mode.ne.1)call refer
      atheat=atheat-eat*23.061d0
      norbs=nlast(numat)
      if(norbs.gt.maxorb)then
         write(mfgw,'(//10x,''**** max. number of orbitals:'',i4,/
     1            10x,''number of orbitals in system:'',i4)')
     2maxorb,norbs
_IF(ipsc,tools)
         call pend
_ELSE
         stop
_ENDIF
      endif
      nlight=numat-nheavy
      n2el=50*nheavy*(nheavy-1)+10*nheavy*nlight+(nlight*(nlight-1))/2
      if(n2el.gt.n2elec)then
      write(mfgw,'(//10x,''**** max. number of two-electron integrals:''
     1,i8,/
     2            10x,''number of two electron integrals in system:'',
     3i8)')
     4n2elec,n2el
_IF(ipsc,tools)
         call pend
_ELSE
         stop
_ENDIF
      endif
c
c   now to calculate the number of levels occupied
      trip=(index(keywrd,'trip').ne.0)
      exci=(index(keywrd,'exci').ne.0)
      birad=(exci.or.index(keywrd,'birad').ne.0)
      if(index(keywrd,'c.i.') .ne. 0 .and. uhf ) then
         write(mfgw,'(//10x,''c.i. not allowed with uhf '')')
_IF(ipsc,tools)
         call pend
_ELSE
         stop
_ENDIF
      endif
c
c now to work out how many electrons are in each type of shell
c
      nalpha=0
      nbeta=0
c
c      protect dumb users from dumb errors!
c
      nelecs=dmax1(elecs+0.5d0,0.d0)
      nelecs=min0(2*norbs,nelecs)
      nclose=0
      nopen=0
      if( uhf ) then
         fract=1.d0
         nbeta=nelecs/2
         if( trip ) then
            if(nbeta*2 .ne. nelecs) then
            write(mfgw,'(//10x,''triplet specified with odd number'',
     1         '' of electrons, correct fault '')')
_IF(ipsc,tools)
            call pend
_ELSE
            stop
_ENDIF
            else
               if(mode.ne.1)
     1write(mfgw,'(//'' triplet state calculation'')')
               nbeta=nbeta-1
            endif
         endif
         if(index(keywrd,'quar').ne.0) then
            if(nbeta*2 .eq. nelecs) then
            write(mfgw,'(//10x,''quartet specified with even number'',
     1            '' of electrons, correct fault '')')
_IF(ipsc,tools)
               call pend
_ELSE
               stop
_ENDIF
            else
               if(mode.ne.1)
     1write(mfgw,'(//'' quartet state calculation'')')
               nbeta=nbeta-1
            endif
         endif
         if(index(keywrd,'quin').ne.0) then
            if(nbeta*2 .ne. nelecs) then
            write(mfgw,'(//10x,''quintet specified with odd number'',
     1            '' of electrons, correct fault '')')
_IF(ipsc,tools)
               call pend
_ELSE
               stop
_ENDIF
            else
               if(mode.ne.1)
     1write(mfgw,'(//'' quintet state calculation'')')
               nbeta=nbeta-2
            endif
         endif
         if(index(keywrd,'sext').ne.0) then
            if(nbeta*2 .eq. nelecs) then
            write(mfgw,'(//10x,''sextet specified with even number'',
     1            '' of electrons, correct fault '')')
_IF(ipsc,tools)
               call pend
_ELSE
               stop
_ENDIF
            else
            if(mode.ne.1)write(mfgw,'(//'' sextet state calculation'')')
               nbeta=nbeta-2
            endif
         endif
         nalpha=nelecs-nbeta
         if(mode.ne.1)
     1write(mfgw,
     +   '(//10x,''uhf calculation, no. of alpha electrons ='',i
     23,/27x,''no. of beta  electrons ='',i3)')nalpha,nbeta
      else
c
c   now to determine open and closed shells
c
         open=.false.
         ielec=0
         ilevel=0
         if( trip .or. exci .or. birad ) then
            if( (nelecs/2)*2 .ne. nelecs) then
            write(mfgw,'(//10x,''system specified with odd number'',
     1            '' of electrons, correct fault '')')
_IF(ipsc,tools)
               call pend
_ELSE
               stop
_ENDIF
            endif
            if(mode.ne.1) then
            if(birad)write(mfgw,'(//'' system is a biradical'')')
            if(trip )write(mfgw,'(//'' triplet state calculation'')')
            if(exci )write(mfgw,'(//'' excited state calculation'')')
            endif
            ielec=2
            ilevel=2
         elseif((nelecs/2)*2.ne.nelecs) then
            ielec=1
            ilevel=1
         endif
         if(index(keywrd,'quar').ne.0) then
         if(mode.ne.1)write(mfgw,'(//'' quartet state calculation'')')
            ielec=3
            ilevel=3
         endif
         if(index(keywrd,'quin').ne.0) then
         if(mode.ne.1)write(mfgw,'(//'' quintet state calculation'')')
            ielec=4
            ilevel=4
         endif
         if(index(keywrd,'sext').ne.0) then
         if(mode.ne.1)write(mfgw,'(//'' sextet state calculation'')')
            ielec=5
            ilevel=5
         endif
         i=index(keywrd,'open(')
         if(i.ne.0)then
            ielec=reada(keywrd,i)
            ilevel=reada(keywrd,i+7)
         endif
         nclose=nelecs/2
         nopen = nelecs-nclose*2
         if( ielec.ne.0 )then
            if((nelecs/2)*2.eq.nelecs .neqv.
     1                  (ielec/2)*2.eq.ielec) then
            write(mfgw,'('' impossible number of open shell electr
     1ons'')')
_IF(ipsc,tools)
               call pend
_ELSE
               stop
_ENDIF
            endif
            nclose=nclose-ielec/2
            nopen=ilevel
            if(nclose+nopen.gt.norbs)then
            write(mfgw,'(a)')' number of doubly filled plus partly fille
     1d levels'
            write(mfgw,'(a)')' greater than total number of orbitals.'
_IF(ipsc,tools)
               call pend
_ELSE
               stop
_ENDIF
            endif
            fract=ielec*1.d0/ilevel
            if(mode.ne.1)
     1write(mfgw,'('' there are'',i3,'' doubly filled levels'')')nclose
         endif
         if(mode.ne.1)write(mfgw,'(//10x,''rhf calculation, no. of '',
     1''doubly occupied levels ='',i3)')nclose
         if(mode.ne.1 .and. nopen.ne.0.and.dabs(fract-1.d0).lt.1.d-4)
     1write(mfgw,'(/27x,''no. of singly occupied levels ='',i3)')nopen
         if(mode.ne.1 .and. nopen.ne.0.and.dabs(fract-1.d0).gt.1.d-4)
     1write(mfgw,
     +  '(/27x,''no. of levels with occupancy'',f6.3,''  ='',i3)')
     2fract,nopen
         if(index(keywrd,citxt).ne.0) then
            i=reada(keywrd,index(keywrd,citxt)+5)-
     1      reada(keywrd,index(keywrd,citxt)+7)
            if(nopen.gt.i)then
            write(mfgw,'(//,'' number of open-shells allowed in c.i. is
     1less ''            /''    than that specified by other keywords'')
     2')
_IF(ipsc,tools)
               call pend
_ELSE
               stop
_ENDIF
            endif
         endif
         if(index(keywrd,'c.i.').ne.0.and.nopen.eq.0)then
            nopen=1
            nclose=nclose-1
            fract=2.d0
         endif
         nopen=nopen+nclose
      endif
c
c  work out if defined spin-state allowed
c
      msdel=index(keywrd,' ms')
      if(msdel.ne.0)then
         msdel=1.0001d0*reada(keywrd,index(keywrd,' ms'))
      else
         if(index(keywrd,'trip')+index(keywrd,'quar').gt.0)msdel=1
         if(index(keywrd,'quin')+index(keywrd,'sext').gt.0)msdel=2
      endif
      if(msdel.ne.0.and..not.uhf)then
c
c   msdel = number of alpha electrons - number of beta electrons
c
         ndoubl=99
         if(index(keywrd,citxt).ne.0)then
            ndoubl=reada(keywrd,index(keywrd,citxt)+7)
            nmos=reada(keywrd,index(keywrd,citxt)+5)
         elseif (index(keywrd,'c.i.=').ne.0)then
            nmos=reada(keywrd,index(keywrd,'c.i.=')+5)
         else
            nmos=nopen-nclose
         endif
         if(ndoubl.eq.99)then
            j=max0(
     +         min0((nclose+nopen+1)/2-(nmos-1)/2,norbs-nmos+1),1)
         else
            j=nclose-ndoubl+1
         endif
         ne=dmax1(0.d0,(nclose-j+1.d0))*2.d0+
     1     dmax1(0.d0,(nopen-nclose)*fract) + 0.5d0
         nupp=(ne+1)/2+msdel
         ndown=ne-nupp
c
c  nupp  = number of alpha electrons in active space
c  ndown = number of beta  electrons in active space
c
         if(nupp*ndown.lt.0.or.nupp.gt.nmos.or.ndown.gt.nmos)then
            write(mfgw,'(a)')
     1' specified spin component not spanned by active space'
_IF(ipsc,tools)
            call pend
_ELSE
            stop
_ENDIF
         endif
      endif
c#      write(6,'(''  nopen,nclose,nalpha,nbeta,fract'',4i4,f12.5)')
c#     1 nopen, nclose, nlapha, nbeta, fract
c
c   make sure analyt is not used with analytical c.i. derivatives
c
      halfe = (nopen.gt.nclose.and.fract.ne.2.d0.and.fract.ne.0.d0
     1 .or. index(keywrd,'c.i.').ne.0)
      slow=(index(keywrd,'exci').ne.0.or.
     1index(keywrd,'root').ne.0.and.index(keywrd,'root=1').eq.0)
      if(halfe)halfe=(.not.slow)
      if(index(keywrd,'noanci').eq.0.and.
     1index(keywrd,'analyt').ne.0.and.halfe)then
      write(mfgw,*)
      write(mfgw,'(a)')' keyword ''analyt'' cannot be used here: ',
     1' analyical c.i. derivatives must use finite differences',
     2' to correct, remove keyword ''analyt'' or add ''noanci'''
_IF(ipsc,tools)
         call pend
_ELSE
         stop
_ENDIF
      endif
      yy=dfloat(kharge)/(norbs+1.d-10)
      l=0
      do 160 i=1,numat
         ni=nat(i)
         xx=1.d0/(nlast(i)-nfirst(i)+1+1.d-10)
         w=core(ni)*xx-yy
         ia=nfirst(i)
         ic=nmidle(i)
         ib=nlast(i)
c$doit asis
         do 140 j=ia,ic
            l=l+1
  140    pspd(l)=w
c$doit asis
         do 150 j=ic+1,ib
            l=l+1
  150    pspd(l)=0.d0
  160 continue
c
c   write out the interatomic distances
c
      call gmetry(geo,coord)
      rmin=100.d0
      l=0
      do 170 i=1,numat
         do 170 j=1,i
            l=l+1
            rxyz(l)=dsqrt((coord(1,i)-coord(1,j))**2+
     1                     (coord(2,i)-coord(2,j))**2+
     2                     (coord(3,i)-coord(3,j))**2)
            if(rmin.gt.rxyz(l) .and. i .ne. j .and.
     1 (nat(i).lt.103 .or. nat(j).lt.103)) then
               iminr=i
               jminr=j
               rmin=rxyz(l)
            endif
  170 continue
      nnhco=0
c
c   set up molecular-mechanics correction to -(c=o)-(nh)- linkage
c   this will be used if mmok has been specified.
c
      itype=1
      if(index(keywrd,'am1').ne.0)itype=2
      if(index(keywrd,'pm3').ne.0)itype=3
      if(index(keywrd,'mindo').ne.0)itype=4
c
c   identify o=c-n-h systems via the interatomic distances matrix
      do 220 i=1,numat
         if(nat(i).ne.8) goto 220
         do 210 j=1,numat
            if(nat(j).ne.6) goto 210
            ij=max0(i,j)
            ji=i+j-ij
            if(rxyz((ij*(ij-1))/2+ji).gt.1.3)goto 210
            do 200 k=1,numat
               if(nat(k).ne.7) goto 200
               jk=max0(j,k)
               kj=j+k-jk
               if(rxyz((jk*(jk-1))/2+kj).gt.1.6)goto 200
               do 190 l=1,numat
                  if(nat(l).ne.1) goto 190
                  kl=max0(k,l)
                  lk=k+l-kl
                  if(rxyz((kl*(kl-1))/2+lk).gt.1.3)goto 190
c
c   we have a h-n-c=o system.  the atom numbers are l-k-j-i
c   now search out atom attached to nitrogen, this specifies
c   the system x-n-c=o
c
                  do 180 m=1,numat
                     if(m.eq.k.or.m.eq.l.or.m.eq.j) goto 180
                     mk=max0(m,k)
                     km=m+k-mk
                     if(rxyz((mk*(mk-1))/2+km).gt.1.7)goto 180
                     nnhco=nnhco+1
                     nhco(1,nnhco)=i
                     nhco(2,nnhco)=j
                     nhco(3,nnhco)=k
                     nhco(4,nnhco)=m
                     nnhco=nnhco+1
                     nhco(1,nnhco)=i
                     nhco(2,nnhco)=j
                     nhco(3,nnhco)=k
                     nhco(4,nnhco)=l
                     goto 190
  180             continue
  190          continue
  200       continue
  210    continue
  220 continue
      if(mode.ne.1.and.nnhco.ne.0)then
         if(index(keywrd,'mmok').ne.0) then
      write(mfgw,'(a)')' molecular mechanics correction applied to pe
     1ptidelinkage'
         elseif(index(keywrd,'nomm').ne.0)then
         write(mfgw,'(a,i2,2a)')' there are ',nnhco/2,' peptide linkages
     1',' identified in this system'
         write(mfgw,'(a)')' if you want mm correction to the conh barrie
     1r, add the key-word "mmok"'
            nnhco=0
         else
         write(mfgw,'(a)')' this system contains -hnco- groups.'
         write(mfgw,'(a)')' you must specify "nomm" or "mmok" regarding
     1molecular mechanics correction'
_IF(ipsc,tools)
         call pend
_ELSE
         stop
_ENDIF
         endif
      endif
      if(mode.ne.1.and.index(keywrd,'nointer') .eq. 0) then
         write(mfgw,'(//10x,''  interatomic distances'')')
         call vecprt(rxyz,numat)
      endif
      if(rmin.lt.0.8d0.and.index(keywrd,'geo-ok') .eq.0) then
         write(mfgw,230)iminr,jminr,rmin
  230    format(//,'   atoms',i3,' and',i3,' are separated by',f8.4,
     1' angstroms.',/'   to continue calculation specify "geo-ok"')
_IF(ipsc,tools)
         call pend
_ELSE
         stop
_ENDIF
      endif
      if(.not. debug) return
      write(mfgw,240)numat,norbs,ndorbs,natoms
  240 format('   number of real atoms:',i4,/
     1      ,'   number of orbitals:  ',i4,/
     2      ,'   number of d orbitals:',i4,/
     3      ,'   total no. of atoms:  ',i4)
      write(mfgw,250)(uspd(i),i=1,norbs)
  250 format('   one-electron diagonal terms',/,10(/,10f8.3))
      write(mfgw,260)(pspd(i),i=1,norbs)
  260 format('   initial p for all atomic orbitals',/,10(/,10f8.3))
      return
  270 write(mfgw,
     +  '(//10x,'' maximum number of atomic orbitals exceeded'')')
      write(mfgw,'(  10x,'' maximum allowed ='',i4)')maxorb
_IF(ipsc,tools)
      call pend
_ELSE
      stop
_ENDIF
      end
      subroutine molval(c,p,nocc,rhfuhf)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),
     1                nlast(numatm), norbs, nelecs,nalpha,nbeta,
     2                nclose,nopen,ndumy,fract
      common/iofile/mfgr,mfgw
      dimension c(norbs,norbs), p(*)
      dimension val(maxorb)
      do 40 i=1,nocc
         sum=0.d0
         do 30 jj=1,numat
            jl=nfirst(jj)
            ju=nlast(jj)
            do 30 j=jl,ju
               do 30 kk=1,numat
                  if(kk.eq.jj) goto 20
                  kl=nfirst(kk)
                  ku=nlast(kk)
                  do 10 k=kl,ku
                     l1=max0(j,k)
                     l2=j+k-l1
                     l=(l1*(l1-1))/2+l2
                     sum=sum+c(j,i)*c(k,i)*p(l)
   10             continue
   20             continue
   30    continue
         val(i)=sum*rhfuhf
   40 continue
      write(mfgw,'(10f8.4)')(val(i),i=1,nocc)
      end
*gamess
_IF(ipsc,tools)
      program mopac
_ELSE
      subroutine mopac(core,quit)
_ENDIF
c
c         notice of public domain nature of mopac
c
c      'this computer program is a work of the united states
c       government and as such is not subject to protection by
c       copyright (17 u.s.c. # 105.)  any person who fraudulently
c       places a copyright notice or does any other act contrary
c       to the provisions of 17 u.s. code 506(c) shall be subject
c       to the penalties provided therein.  this notice shall not
c       be altered or removed from this software and is to be on
c       all reproductions.'
c
c
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
*gamess
      logical quit,gamess,ostop
      common /scftyp/ emin, limscf
      common /keywrd/ keywrd
      common /okmany/ isok
      common /geovar/ nvar,loc(2,maxpar), idumy, xparam(maxpar)
      common /mesage/ iflepo,iscf
      common /geosym/ ndep,locpar(maxpar),idepfn(maxpar),locdep(maxpar)
      common /geokst/ natoms,labels(numatm),
     1na(numatm),nb(numatm),nc(numatm)
      common /cmpg/ geo(3,numatm)
      common /gradnt/ grad(maxpar),gnorm
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),
     1                nlast(numatm), norbs, nelecs,nalpha,nbeta,
     2                nclose,nopen,ndumy,fract
      common /atheat/ atheat
      common /last/ last
      common /atomic/ eisol(107),eheat(107)
      common /numcal/ numcal
      common /timem/ time0
      common /path/ latom,lparam,react(200)
      common /readme/ ird
      common /iofile/ iread,iwrite
      character*241 keywrd
c     character getmop*80
      logical isok, limscf
_IF(ipsc,tools)
_IF(tools)
      call pbeginf
_ENDIF
      begtim=dclock()
      call initia
_ELSE
*gamess
      dimension core(*)
*gamess
_ENDIF
      quit = .true.
      ostop = .false.
      gamess = .false.
*gamess
      call getdat(gamess)
c
c   close unit 6 in case it was already pre-assigned
c
*gamess      close (6)
*gamess      open(unit=6,file=getmop(2),status='new')
*gamess      rewind 6
c#      call timop('first line')
      numcal=0
      isok=.true.
   10 numcal=numcal+1
c
      time0=secmop()
c
c read and check input file, exit if necessary.
c     write input file to unit 6 as feedback to user
c
c is mopac run to be followed by ab initio calculation
      if(numcal.gt.1)then
       if(gamess.or.index(keywrd,'abinitio').ne.0) then
       quit = .false.
_IF(ipsc,tools)
       call pend
_ELSE
       return
_ENDIF
       endif
      endif
      call moprdm(ostop)
      if (ostop.or.natoms.eq.0) then
c      close(iread,status='delete')
c      stop
       go to 50
      endif
      emin=0.d0
c#      call timop('after read')
      if(natoms.eq.0) goto 50
      if(index(keywrd,'author') .ne. 0) then
         write(iwrite,'(10x,
     +    '' mopac - a general molecular orbital package'',
     1/         ,10x,''   original version written in 1983'')')
         write(iwrite,'(10x,
     +    ''     by james j. p. stewart at the'',/
     1         ,10x,''     university of texas at austin'',/
     2         ,10x,''          austin, texas, 78712'')')
         write(iwrite,'(10x,
     +    ''  modified to do esp calculations by''
     1          ,10x,''    brent h. besler and k. m. merz jr. 1989'')')
      endif
c
c initialize calculation and write calculation independent info
c
      if(index(keywrd,'0scf') .ne. 0) then
         write(iwrite,'(a)')' geometry in mopac z-matrix format'
         call geout(6)
         if(index(keywrd,' aigout').ne.0)then
            write(iwrite,'(//,a)')
     +     '  geometry in gaussian z-matrix format'
            call wrttxt(iwrite)
            call geoutg(iwrite,.false.)
         endif
         if(index(keywrd,' out=gamess').ne.0)then
            write(iwrite,'(//,a)')'  geometry in gamess z-matrix format'
            call wrttxt(iwrite)
            call geoutg(6,.true.)
         endif
         goto 50
      endif
      call moldat(0)
      if(index(keywrd,'external') .ne. 0) then
         call datin
c
c  recalculate the atomic energy
c
         atheat=0.d0
         eat=0.d0
         do 30 ii=1,numat
            ni=nat(ii)
            atheat=atheat+eheat(ni)
   30    eat   =eat   +eisol(ni)
         atheat=atheat-eat*23.061d0
      endif
      if (index(keywrd,'restart').eq.0)then
         if (index(keywrd,'1scf').ne.0) then
            if(latom.ne.0)then
               write(6,'(//,10x,a)')'1scf specified with path.  this pai
     1r of'
               write(6,'(   10x,a)')'options is not allowed'
               goto 50
            endif
            iflepo=1
            iscf=1
            last=1
            i=index(keywrd,'grad')
            do 39 j=1,nvar
  39        grad(j)=0.d0
            call compfg(xparam,.true.,escf,.true.,grad,i.ne.0)
            goto 40
         endif
      endif
c
c calculate dynamic reaction coordinate.
c
c
      if(index(keywrd,'saddle') .ne. 0) then
         call react1(escf)
         goto 50
      endif
      if(index(keywrd,'step1') .ne. 0) then
         call mopg()
         goto 50
      endif
      if (latom .ne. 0) then
c
c       do path
c
         if (index(keywrd,'step').eq.0.or.
     1index(keywrd,'point').eq.0) then
            call mopth()
            goto 50
         endif
         call pathk
         goto 50
      endif
      if (   index(keywrd,'force') .ne. 0
     1  .or. index(keywrd,'irc=' ) .ne. 0
     2  .or. index(keywrd,'therm') .ne. 0 ) then
c
c force calculation if desired
c
         call force
         goto 50
      endif
      if(index(keywrd,' drc') + index(keywrd,' irc') .ne. 0) then
c
c   in this context, "react" holds initial velocity vector components.
c
         call drc(react,react)
         goto 50
      endif
c
      if(index(keywrd,'nllsq') .ne. 0) then
         call nllsq(xparam, nvar )
         call compfg(xparam,.true.,escf,.true.,grad,.true.)
         goto 40
      endif
c
      if(index(keywrd,'sigma') .ne. 0) then
         call powsq(xparam, nvar, escf)
         goto 40
      endif
c
c  ef optimisation
c
      if(index(keywrd,' ef').ne.0 .or. index(keywrd,' ts').ne.0) then
         if(index(keywrd,'geo-ok').eq.0.and.nvar.gt.3*natoms-6)then
            write(6,'(a)')' eigenvector following is not recommended whe
     1n'
            write(6,'(a)')' more than 3n-6 coordinates are to be optimiz
     1ed'
            write(6,'(a)')' to continue, specify ''geo-ok'''
_IF(ipsc,tools)
            call pend
_ELSE
            stop
_ENDIF
         endif
         call ef (xparam,nvar,escf)
         goto 40
      endif
c
c ordinary geometry optimisation
c
c
c ordinary geometry optimisation
c
c#      call timop('before flepo')
      call flepo(xparam, nvar, escf)
   40 last=1
      if(iflepo.ge.0)call writmo(time0, escf)
      if(index(keywrd,'polar') .ne. 0) then
         call polar
      endif
      if(index(keywrd,' esp') .ne. 0)then
c  if you want to use the esp program, uncomment the line
c  "c#      call esp", add "esp, " to mopac.opt, then compile esp and
c  mndo, and relink.
      call esp
      endif
   50 tim=secmop()-time0
      limscf=.false.
      write(iwrite,
     +   '(///,'' total cpu time: '',f16.2,'' seconds'')') tim
      write(iwrite,'(/,'' == mopac done =='')')
_IFN(ipsc,tools)
      if(isok) goto 10
      close(iread,status='delete')
      return
_ELSE
c     if(isok) goto 10
      endtim=dclock()
      runtim=endtim-begtim
      write(iwrite,60)runtim
   60 format(/' mopac runtime = ',f10.2,' elapsed seconds'/)
_IF(tools)
c
      if (nodeid().eq.0) call stats
      close(ird,status='delete')
_ENDIF
      call pend
_ENDIF
      end
      subroutine mopd(fao,vector,nocc,eig,mdim,n)
      implicit REAL  (a-h,o-z)
INCLUDE(common/sizes)
      dimension fao(*),vector(mdim,*),eig(*),ws(maxorb)
c***********************************************************************
c
c   "fast" diagonalisation procedure.
c
c    on input fao contains the lower half triangle of the matrix to be
c                         diagonalised, packed.
c             vector  contains the old eigenvectors on input, the new
c             vectors on exiting.
c             nocc = number of occupied molecular orbitals.
c             eig  = eigenvalues from an exact diagonalisation
c             mdim = declared size of matrix "c".
c             n = number of atomic orbitals in basis set
c
c  diag is a pseudo-diagonalisation procedure, in that the vectors that
c       are generated by it are more nearly able to block-diagonalise
c       the fock matrix over molecular orbitals than the starting
c       vectors. it must be considered pseudo for several reasons:
c       (a) it does not generate eigenvectors - the secular determinant
c           is not diagonalised, only the occupied-virtual intersection.
c       (b) many small elements in the sec.det. are ignored as being too
c           small compared with the largest element.
c       (c) when elements are eliminated by rotation, the rest of the
c           sec. det. is assumed not to change, i.e. elements created
c           are ignored.
c       (d) the rotation required to eliminate those elements considered
c           significant is approximated to using the eigenvalues of the
c           exact diagonalisation throughout the rest of the iterative
c           procedure.
c
c  (note:- in an iterative procedure all the approximations present in
c          diag become valid at self-consistency, self-consistency is
c          not slowed down by use of these approximations)
c
c    reference:
c             "fast semiempirical calculations",
c             stewart. j.j.p., csaszar, p., pulay, p., j. comp. chem.,
c             3, 227, (1982)
c
c***********************************************************************
      common /scrach/ fmo(morb2), xdumy(maxpar**2-morb2)
c             fmo  is a work-space of size (n-nocc)*nocc, it will hold
c                  the fock molecular orbital interaction matrix.
c
c  first, construct that part of a secular determinant over molecular
c  orbitals which connects the occupied and virtual sets.
c
c***********************************************************************
c
      logical first
      data first /.true./
      save first,eps,eta,bigeps
      if(first)then
         first=.false.
c
c   eps is the smallest number which, when added to 1.d0, is not
c   equal to 1.d0
         call epseta(eps,eta)
c
c   increase eps to allow for a lot of round-off
c
         bigeps=10.d0*dsqrt(eps)
      endif
      tiny=0.d0
      lumo=nocc+1
      ij=0
c#      call timop('squaring')
      do 60 i=lumo,n
         kk=0
         do 30 j=1,n
_IFN(blas)
            sum=0.d0
            do 10 k=1,j
               kk=kk+1
   10       sum=sum+fao(kk)*vector(k,i)
_ELSE
      sum=ddot(j,fao(kk+1),1,vector(1,i),1)
      kk=kk+j
_ENDIF
            if(j.eq.n) goto 30
            j1=j+1
            k2=kk
            do 20 k=j1,n
               k2=k2+k-1
   20       sum=sum+fao(k2)*vector(k,i)
   30    ws(j)=sum
         do 50 j=1,nocc
            ij=ij+1
_IFN(blas)
            sum=0.d0
            do 40 k=1,n
   40       sum=sum+ws(k)*vector(k,j)
_ELSE
      sum=ddot(n,ws(1),1,vector(1,j),1)
_ENDIF
            if(tiny.lt.dabs(sum)) tiny=dabs(sum)
   50    fmo(ij)=sum
   60 continue
      tiny=0.05d0*tiny
c***********************************************************************
c
c   now do a crude 2 by 2 rotation to "eliminate" significant elements
c
c***********************************************************************
c#      call timop('rotating')
      ij=0
      do 90 i=lumo,n
         do 80 j=1,nocc
            ij=ij+1
            if(dabs(fmo(ij)).lt.tiny) goto 80
c
c      begin 2 x 2 rotations
c
            a=eig(j)
            b=eig(i)
            c=fmo(ij)
            d=a-b
c
c    use bigeps to determine whether to do a 2 by 2 rotation
c
            if(dabs(c/d).lt.bigeps) goto 80
c
c  at this point we know that
            e=dsign(dsqrt(4.d0*c*c+d*d),d)
            alpha=dsqrt(0.5d0*(1.d0+d/e))
            beta=-dsign(dsqrt(1.d0-alpha*alpha),c)
c
c      rotation of pseudo-eigenvectors
c
_IFN(blas)
            do 70 m=1,n
               a=vector(m,j)
               b=vector(m,i)
               vector(m,j)=alpha*a+beta*b
               vector(m,i)=alpha*b-beta*a
   70       continue
_ELSE
      call drot(n,vector(1,j),1,vector(1,i),1,alpha,beta)
_ENDIF
   80    continue
   90 continue
c#      call timop('returning')
      return
      end
      subroutine mopdv(geo,grad)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      dimension grad(*), geo(3,*)
************************************************************************
*
*    deriv calculates the derivatives of the energy with respect to the
*          internal coordinates. this is done by finite differences.
*
*    the main arrays in deriv are:
*        loc    integer array, loc(1,i) contains the address of the atom
*               internal coordinate loc(2,i) is to be used in the
*               derivative calculation.
*        geo    array \geo\ holds the internal coordinates.
*        grad   on exit, contains the derivatives
*
************************************************************************
      common / readme / ird
      common / euler/ tvec(3,3), id
      common /okmany/ isok
      common /geovar/ nvar,loc(2,maxpar), idumy, dummy(maxpar)
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),
     1                nlast(numatm), norbs, nelecs,nalpha,nbeta,
     2                nclose,nopen,ndumy,fract
      common /geokst/ natoms,labels(numatm),
     1na(numatm),nb(numatm),nc(numatm)
      common /gravec/ cosine
      common /geosym/ ndep, locpar(maxpar), idepfn(maxpar),
     1locdep(maxpar)
      common /path/ latom,lparam,react(200)
      common /ucell/ l1l,l2l,l3l,l1u,l2u,l3u
      common /xyzgra/ dxyz(9*numatm)
      common /enuclr/ enuclr
      common /numcal/ numcal
      common /hmatrx/ h(mpack)
      common /atheat/ atheat
      common /keywrd/ keywrd
      common /errfn/ errfn(maxpar), aicorr(maxpar)
      common /work3 / work2(4*mpack)
      common /cmopgl/ coord(3,numatm), cold(3,numatm*3), gold(maxpar),
     1 xparam(maxpar)
      common/iofile/mfgr,mfgw
      character*241 keywrd, line*80, getmop*80
      dimension change(3), xderiv(3), xjuc(3), aidref(maxpar)
      save scf1, halfe, idelta, slow, xderiv
      logical debug, halfe, scf1, ci, precis, slow, aic, noanci,
     1aifrst, isok, geook, int
      save icalcn,debug,aifrst,precis,int,geook,ci,aic,change
      save aidref,xjuc,grlim
      data icalcn /0/
      if(icalcn.ne.numcal) then
         aifrst= (index(keywrd,'restart').eq.0)
         debug = (index(keywrd,'deriv') .ne. 0)
         precis= (index(keywrd,'prec') .ne. 0)
         int   = (index(keywrd,' xyz') .eq. 0)
         geook = (index(keywrd,'geo-ok') .ne. 0)
         ci    = (index(keywrd,'c.i.') .ne. 0)
         scf1  = (index(keywrd,'1scf') .ne. 0)
         aic=(index(keywrd,'aider').ne.0)
         icapa=ichar('a')
         ilowa=ichar('a')
         ilowz=ichar('z')
         if(aic.and.aifrst)then
            open(unit=ird,file=getmop(1),status='old',blank='zero')
            rewind ird
c
c  isok is set false: only one system allowed
c
            isok=.false.
            do 10 i=1,3
   10       read(ird,'(a)')line
            do 30 j=1,1000
               read(ird,'(a)',end=40,err=40)line
************************************************************************
               do 20 i=1,80
                  iline=ichar(line(i:i))
                  if(iline.ge.ilowa.and.iline.le.ilowz) then
                     line(i:i)=char(iline+icapa-ilowa)
                  endif
   20          continue
************************************************************************
   30       if(index(line,'aider').ne.0)goto 60
   40       write(mfgw,'(//,a)')' keyword "aider" specified, but not'
            write(mfgw,'(a)')' present after z-matrix.  job stopped'
_IF(ipsc,tools)
            call pend
_ELSE
            stop
_ENDIF
   50       write(mfgw,'(//,a)')
     +   '  fault in read of ab initio derivatives'
            write(mfgw,'(a)')'  derivatives read in are as follows'
            write(mfgw,'(6f12.6)')(aidref(j),j=1,i)
_IF(ipsc,tools)
            call pend
_ELSE
            stop
_ENDIF
   60       continue
            if(natoms.gt.2)then
               j=3*natoms-6
            else
               j=1
            endif
            read(ird,*,end=50,err=50)(aidref(i),i=1,j)
            write(mfgw,'(/,a,/)')
     1' ab-initio derivatives in kcal/mol/(angstrom or radian)'
            write(mfgw,'(5f12.6)')(aidref(i),i=1,j)
            do 70 i=1,nvar
               if(loc(1,i).gt.3)then
                  j=3*loc(1,i)+loc(2,i)-9
               elseif(loc(1,i).eq.3)then
                  j=loc(2,i)+1
               else
                  j=1
               endif
   70       aidref(i)=aidref(j)
            write(mfgw,'(/,a,/)')
     1' ab-initio derivatives for variables'
            write(mfgw,'(5f12.6)')(aidref(i),i=1,nvar)
            if(ndep.ne.0)then
               do 90 i=1,nvar
                  sum=aidref(i)
                  do 80 j=1,ndep
                     if(loc(1,i).eq.locpar(j).and.(loc(2,i).eq.idepfn(j)
     1.or.loc(2,i).eq.3.and.idepfn(j).eq.14)) aidref(i)=aidref(i)+sum
   80             continue
   90          continue
               write(mfgw,'(/,a,/)')
     1' ab-initio derivatives after symmetry weighting'
               write(mfgw,'(5f12.6)')(aidref(j),j=1,nvar)
            endif
         endif
         icalcn=numcal
         if(index(keywrd,'restart') .eq. 0) then
            do 100 i=1,nvar
  100       errfn(i)=0.d0
         endif
         grlim=0.01d0
         if(precis)grlim=0.0001d0
         halfe = (nopen.gt.nclose.and.fract.ne.2.d0.and.fract.ne.0.d0
     1 .or. ci)
         idelta=-7
*
*   idelta is a machine-precision dependant integer
*
         change(1)= 10.d0**idelta
         change(2)= 10.d0**idelta
         change(3)= 10.d0**idelta
c
c    change(i) is the step size used in calculating the derivatives.
c    for "cartesian" derivatives, calculated using dcart,an
c    infinitesimal step, here 0.000001, is acceptable. in the
c    half-electron method a quite large step is needed as full scf
c    calculations are needed, and the difference between the total
c    energies is used. the step cannot be very large, as the second
c    derivitive in flepo is calculated from the differences of two
c    first derivatives. change(1) is for change in bond length,
c    (2) for angle, and (3) for dihedral.
c
         xderiv(1)= 0.5d0/change(1)
         xderiv(2)= 0.5d0/change(2)
         xderiv(3)= 0.5d0/change(3)
      endif
      if(nvar.eq.0) return
      if(debug)then
      write(mfgw,'('' geo at start of deriv'')')
      write(mfgw,'(f19.5,2f12.5)')((geo(j,i),j=1,3),i=1,natoms)
      endif
      gnorm=0.d0
      do 110 i=1,nvar
         gold(i)=grad(i)
         xparam(i)=geo(loc(2,i),loc(1,i))
  110 gnorm=gnorm+grad(i)**2
      gnorm=dsqrt(gnorm)
      slow=.false.
      noanci=.false.
      if(halfe) then
         noanci=(index(keywrd,'noanci').ne.0 .or. nopen.eq.norbs)
         slow=(noanci.and.(gnorm .lt. grlim .or. scf1))
      endif
      if(ndep.ne.0) call mopsym()
      call gmetry(geo,coord)
c
c  coord now holds the cartesian coordinates
c
      if(halfe.and..not.noanci) then
      if(debug)write(mfgw,*) 'doing analytical c.i. derivatives'
         call dernvo(coord,dxyz)
      else
      if(debug)write(mfgw,*) 'doing variationally opimized derivatives'
         call dcart(coord,dxyz)
      endif
      ij=0
      do 150 ii=1,numat
         do 140 il=l1l,l1u
            do 140 jl=l2l,l2u
               do 140 kl=l3l,l3u
c$doit asis
                  do 120 ll=1,3
  120             xjuc(ll)=coord(ll,ii)+tvec(ll,1)*il+tvec(ll,2)*jl+tvec
     1(ll,3)*kl
                  ij=ij+1
c$doit asis
                  do 130 kk=1,3
                     cold(kk,ij)=xjuc(kk)
  130             continue
  140    continue
  150 continue
      step=change(1)
      call jcarin (coord,xparam,step,precis,work2,ncol)
      call mxm (work2,nvar,dxyz,ncol,grad,1)
      if (precis) then
         step=0.5d0/step
      else
         step=1.0d0/step
      endif
      do 160 i=1,nvar
  160 grad(i)=grad(i)*step
c
c  now to ensure that internal derivatives accurately reflect cartesian
c  derivatives
c
      if(int.and. .not. geook .and. nvar.ge.numat*3-6.and.id.eq.0)then
c
c  number of variables looks o.k.
c
         sum=ddot(nvar,grad,1,grad,1)
         if(sum.lt.2.d0.and.ddot(3*numat,dxyz,1,dxyz,1).gt.
     +            dmax1(4.d0,sum*4.d0))then
c
c oops, looks like an error.
c
            do 170 i=1,nvar
               j=xparam(i)/3.141d0
               if(loc(2,i).eq.2.and.loc(1,i).gt.3.and.
     1 dabs(xparam(i)-j*3.1415926d0).lt.0.005d0 )then
c
c  error located, but cannot correct in this run
c
                  write(mfgw,'(//,3(a,/),i3,a)')
     1' internal coordinate derivatives do not reflect',
     2' cartesian coordinate derivatives',
     3' to correct error, increase dihedral of atom',loc(1,i),
     4' by 90 degrees'
                  write(mfgw,'(//,a)')'     current geometry'
                  call geout(6)
_IF(ipsc,tools)
                  call pend
_ELSE
                  stop
_ENDIF
               endif
  170       continue
         endif
      endif
c
c  this code is only used if the keyword noanci is specified
      if(slow)then
         if(debug)write(mfgw,*) 'doing full scf derivatives'
         call deritr(errfn,geo)
c
c the array errfn holds the exact derivatives minus the approximate
c derivatives
         do 180 i=1,nvar
  180    errfn(i)=errfn(i)-grad(i)
      endif
      cosine=ddot(nvar,grad,1,gold,1)/
     1 dsqrt(ddot(nvar,grad,1,grad,1)*
     +       ddot(nvar,gold,1,gold,1)+1.d-20)
      do 190 i=1,nvar
  190 grad(i)=grad(i)+errfn(i)
      if(aic)then
         if(aifrst)then
            aifrst=.false.
            do 200 i=1,nvar
  200       aicorr(i)=-aidref(i)-grad(i)
         endif
c#         write(6,'('' gradients before ai correction'')')
c#         write(6,'(10f8.3)')(grad(i),i=1,nvar)
         do 210 i=1,nvar
  210    grad(i)=grad(i)+aicorr(i)
      endif
      if(debug) then
         write(mfgw,'('' gradients'')')
         write(mfgw,'(10f8.3)')(grad(i),i=1,nvar)
         if(slow)then
            write(mfgw,'('' error function'')')
            write(mfgw,'(10f8.3)')(errfn(i),i=1,nvar)
         endif
      endif
      if(debug)
     1write(mfgw,'('' cosine of search direction ='',f30.6)')cosine
      return
      end
      subroutine mopexc (a,b,c,d,x,y,t,q,n)
      implicit REAL (a-h,o-z)
      dimension x(*), y(*)
c********************************************************************
c
c the contents of a, c, t, and x are stored in b, d, q, and y!
c
c   this is a dedicated routine, it is called by linmin and locmin only.
c
c********************************************************************
      b=a
      d=c
      q=t
      do 10 i=1,n
         y(i)=x(i)
   10 continue
      return
c
      end
      subroutine mopfd(eigval,fx,nvar,fail,oride)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      dimension eigval(maxpar),fx(maxpar)
      REAL  lamda,lamda0,lamda1,lamda2
      logical fail,oride
      common /fmatrx/oldf(maxpar),d(maxpar),vmode(maxpar),
     1u(maxpar,maxpar),dd,mode,nstep,negreq,iprnt
      common/iofile/mfgr,mfgw
c
      data zero/0.0d0/, half/0.5d0/, toll/1.0d-8/
      data step/0.05d0/, ten/1.0d+0/, one/1.0d+0/, big/1.0d+3/
c
c
c  ts search    forms a step by p-rfo that tries to maximize
c               along the direction of a choosen hessian mode
c               and minimize along all other modes
c  min search   forms a step by simple rfo that attempts to
c               minimize along all hessian modes
c
      maxit=999
      iprt=0
      numit=0
      it=0
      if(negreq.eq.0) go to 30
c
c  (a) maximization along one of the hessian modes
c
      if(mode.ne.0) then
         call overlp(newmod,nvar)
c
c  on return from overlp, newmod is the mode along which
c  the energy is to be maximized
c
         if(newmod.ne.mode.and.iprt.ge.2) write(mfgw,210) mode,newmod
         mode=newmod
         if (iprnt.ge.5) write(mfgw,220) mode
         it=mode
c
c  if the mode being followed is now the lowest mode,
c  then switch off mode following
c
         if(mode.eq.1) then
            mode=0
            if(iprnt.ge.2)write(mfgw,230)
         endif
c
      else
c
         if (iprnt.ge.5) write(mfgw,240)
         it=1
      endif
c
      if (iprnt.ge.1) then
         write(mfgw,10)it,eigval(it)
         write(mfgw,20)(u(i,it),i=1,nvar)
   10    format(/,5x,'ts mode is number',i3,' with eigenvalue',f9.1,/,
     15x,'and components',/)
   20    format(5x,8f9.4)
      endif
c
      lamda0=eigval(it)+dsqrt(eigval(it)*eigval(it)
     +       +4.0d0*fx(it)*fx(it))
      lamda0=half*lamda0
      if(iprnt.ge.2)write(mfgw,250) lamda0
      if(nvar.eq.1) go to 60
c
c  (b) minimization along all other modes
c
   30 continue
      jt=1+it
      if(jt.gt.2) jt=1
c
      if ((iprnt.ge.5).and.(negreq.eq.1)) write(mfgw,270)
      if ((iprnt.ge.5).and.(negreq.eq.0)) write(mfgw,280)
c
c  solve iteratively for lamda
c  initial guess for lamda is zero except note that
c  lamda should be less than eigval(jt)
c
      lamda=zero
      if(eigval(jt).lt.zero) lamda=eigval(jt)-step
c     lets first try a newton-raphson with above lamda as guess.
c     it will almost always work and it is fast. fff is function,
c     ff1 the gradient of the lamda function.
   40 numit=numit+1
      itry=0
      fff = zero
      ff1 = zero
      do 50 i=1,nvar
         if (i.eq.it) goto 50
         fff = fff + (fx(i)*fx(i))/(lamda-eigval(i))
         ff1 = ff1 - (fx(i)*fx(i))/((lamda-eigval(i))**2)
   50 continue
      fff = fff - lamda
      ff1 = ff1 - one
      temp = fff/ff1
      lamda = lamda -temp
      if (iprnt.ge.5) write(mfgw,310)lamda,temp
      if (dabs(temp) .lt. toll) goto 130
c     check max number of iterations
      if (numit .gt. maxit) goto 60
      goto 40
c     newton-raphson failed or produced an unacceptable root.
c     first try to determine if it is likely that there is a
c     a root in the interval eigval(jt) to "-infinity" (=-10**6).
   60 maxit=9999
      itry=itry+1
      numit=0
      lamda1=zero
      if(eigval(jt).lt.zero) lamda1=eigval(jt)-step
      ff1 = zero
      do 70 i=1,nvar
         if (i.eq.it) goto 70
         ff1 = ff1 + (fx(i)*fx(i))/(lamda1 - eigval(i))
   70 continue
      ff1 = ff1 - lamda1
      xstep = dabs(lamda1)/big
      if (xstep.lt.ten)xstep=ten
   80 numit=numit+1
      if (numit.gt.maxit) goto 190
      ff2 = zero
      lamda2 = lamda1 - numit*xstep
      do 90 j=1,nvar
         if (j.eq.it) goto 90
         ff2 = ff2 + (fx(j)*fx(j))/(lamda2 - eigval(j))
   90 continue
      ff2 = ff2 - lamda2
      if (ff2*ff1 .lt. zero) goto 100
      goto 80
c     since ff1(lamda1) has opposite sign as ff2(lamda2) there
c     must be a root in the interval. now hunt it down with
c     brute force bisect method.
  100 numit=0
      if(iprnt.ge.1)write(mfgw,*)'bisect found boundaries',lamda1,lamda2
  110 numit=numit+1
      if (numit .gt. maxit) goto 190
      temp = (lamda1 + lamda2)/2
      ff3 = zero
      do 120 i=1,nvar
         if (i.eq.it) goto 120
         ff3 = ff3 + (fx(i)*fx(i))/(temp - eigval(i))
  120 continue
      ff3 = ff3 - temp
      if (dabs(temp-lamda2).lt.toll) then
         lamda=temp
         goto 130
      endif
      if (ff3*ff1 .lt. zero) then
         lamda2=temp
      else
         lamda1=temp
      endif
      goto 110
c
c  at this point we have a solution. if itry = 0 then it is from
c  newton-raphson. check to see if it is acceptable. it not, check
c  to see if we missed any roots. if itry .gt. 0 then bisect has
c  found another root. it should be ok, but check it anyway.
c
  130 if(iprnt.ge.2)write(mfgw,260) lamda
      if((iprnt.ge.1).and.(itry.gt.0))
     +   write(mfgw,*)'lamda found by bisect'
      if ((lamda.gt.eigval(jt)) .or.
     1   (eigval(jt).gt.zero.and.lamda.gt.zero)) then
         if (itry.gt.0) then
            goto 180
         else
            goto 60
         endif
      endif
c
c  calculate the step
c
  140 do 150 i=1,nvar
         d(i)=zero
  150 continue
      do 170 i=1,nvar
         temp=fx(i)/(lamda-eigval(i))
         if(i.eq.it) temp=fx(i)/(lamda0-eigval(i))
         do 160 j=1,nvar
            d(j)=d(j)+temp*u(j,i)
  160    continue
  170 continue
c
      return
c
c
c    error section
c
  180 continue
c     if we get to here bisect has found an unacceptable root.
c     this should not could happen..... set iflepo=7
      write(mfgw,290)
      if((iprnt.ge.5).and.(itry.gt.0))write(mfgw,*)
     +  'bisect method failed,numit,ff1,ff2,ff3,lamd1,lamd2',
     +   numit,ff1,ff2,ff3,lamda1,lamda2
      fail=.true.
      iflepo=7
      return
  190 continue
      write(mfgw,300)
      if((iprnt.ge.5).and.(itry.gt.0))write(mfgw,*)'bisect method failed,
     1numit,ff1,ff2,ff3,lamd1,lamd2',numit,ff1,ff2,ff3,lamda1,lamda2
c     if override is turned on, use lamda anyway.....
      if (oride) write(mfgw,200)
  200 format(5x,'** overide is turned on, using lamda(s) anyway **')
      if (oride) goto 140
      fail=.true.
      return
c
  210 format(5x,'warning!! mode switching. was following mode ',i3,
     1       ' now following mode ',i3)
  220 format(5x,'searching for lamda that maximizes along mode ',i3)
  230 format(5x,'mode following switched off')
  240 format(' searching for lamda that maximizes along the',
     1       ' lowest mode')
  250 format(5x,'lamda that maximizes along ts mode =           ',f13.7)
  260 format(5x,'lamda that minimizes along all (other) modes = ',f13.7)
  270 format(' searching for lamda that minimizes along all',
     1       ' other modes')
  280 format(' searching for lamda that minimizes along all modes')
  290 format(//' *****************************************'/
     1         ' ** error in determining lamda in formd **'/
     2         ' *****************************************'//)
  300 format(  ' *** unable to determine lamda in formd ***')
c070  format( /' *****************************************'/
c    $         ' *** unable to determine lamda in formd **'/
c    $         ' *****************************************'/ )
  310 format(' in iterative cycle:  lamda= ',f20.5,' temp= ',f25.10)
      end
      subroutine mopfr(fmat,numat,mode,shift)
      implicit REAL (a-h,o-z)
      dimension fmat(*), shift(6)
INCLUDE(common/sizes)
      common /coord/coord(3,numatm)
      common /atmass/ atmass(numatm)
      dimension vib(6,maxpar), rot(3,3), coord1(3,numatm)
***********************************************************************
*
*   frame applies an rigid orientation to the molecule in a force
*         calculation. the translations are given a 'force constant'
*         of t(x)=500 millidynes/angstrom
*            t(y)=600 millidynes/angstrom
*            t(z)=700 millidynes/angstrom
*         and the rotations are given a 'force constant' of
*            r(x)=800 millidynes/angstrom
*            r(y)=900 millidynes/angstrom
*            r(z)=1000 millidynes/angstrom,
*    the rotations are made about axes determined by the moments
*    of inertia, which in turn depend on the isotopic masses. for
*    the normal frequency calculation these are the real masses,
*    for the force calculation they are all unity.
***********************************************************************
      common /euler/ tvec(3,3), id
      call axis(coord,numat,a,b,c,sumw, mode,rot )
      do 20 i=1,numat
         do 20 j=1,3
            sum=0.d0
            do 10 k=1,3
   10       sum=sum+coord(k,i)*rot(k,j)
   20 coord1(j,i)=sum
      n3=numat*3
      j=0
      wtmass=1.d0
      do 30 i=1,numat
         if(mode.eq.1)  wtmass=dsqrt(atmass(i))
         j=j+1
         vib(1,j)=wtmass
         vib(2,j)=0.d0
         vib(3,j)=0.d0
         vib(4,j)=0.d0
         vib(5,j)=coord1(3,i)*wtmass
         vib(6,j)=coord1(2,i)*wtmass
         j=j+1
         vib(1,j)=0.d0
         vib(2,j)=wtmass
         vib(3,j)=0.d0
         vib(4,j)=coord1(3,i)*wtmass
         vib(5,j)=0.d0
         vib(6,j)=-coord1(1,i)*wtmass
         j=j+1
         vib(1,j)=0.d0
         vib(2,j)=0.d0
         vib(3,j)=wtmass
         vib(4,j)=-coord1(2,i)*wtmass
         vib(5,j)=-coord1(1,i)*wtmass
         vib(6,j)=0.d0
   30 continue
      j=1
      do 50 i=1,numat
         do 40 k=4,6
            x=vib(k,j)
            y=vib(k,j+1)
            z=vib(k,j+2)
            vib(k,j  )=x*rot(1,1)+y*rot(1,2)+z*rot(1,3)
            vib(k,j+1)=x*rot(2,1)+y*rot(2,2)+z*rot(2,3)
            vib(k,j+2)=x*rot(3,1)+y*rot(3,2)+z*rot(3,3)
   40    continue
         j=j+3
   50 continue
      sum1=0.d0
      sum2=0.d0
      sum3=0.d0
      sum4=0.d0
      sum5=0.d0
      sum6=0.d0
      do 60 i=1,n3
         sum1=sum1+vib(1,i)**2
         sum2=sum2+vib(2,i)**2
         sum3=sum3+vib(3,i)**2
         sum4=sum4+vib(4,i)**2
         sum5=sum5+vib(5,i)**2
   60 sum6=sum6+vib(6,i)**2
      if(sum1.gt.1.d-5)sum1=dsqrt(1.d0/sum1)
      if(sum2.gt.1.d-5)sum2=dsqrt(1.d0/sum2)
      if(sum3.gt.1.d-5)sum3=dsqrt(1.d0/sum3)
      if(sum4.gt.1.d-5)sum4=dsqrt(1.d0/sum4)
      if(sum5.gt.1.d-5)sum5=dsqrt(1.d0/sum5)
      if(sum6.gt.1.d-5)sum6=dsqrt(1.d0/sum6)
      if(id.ne.0)then
         sum4=0.d0
         sum5=0.d0
         sum6=0.d0
      endif
      do 70 i=1,n3
         vib(1,i)=vib(1,i)*sum1
         vib(2,i)=vib(2,i)*sum2
         vib(3,i)=vib(3,i)*sum3
         vib(4,i)=vib(4,i)*sum4
         vib(5,i)=vib(5,i)*sum5
   70 vib(6,i)=vib(6,i)*sum6
      do 80 i=1,6
   80 shift(i)=400.d0+i*100.d0
      l=0
      do 100 i=1,n3
         do 100 j=1,i
            l=l+1
            sum1=0.d0
            do 90 k=1,6
   90       sum1=sum1+vib(k,i)*shift(k)*vib(k,j)
  100 fmat(l)=fmat(l)+sum1
      end
      subroutine mopg
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
************************************************************************
*
*  grid calculates the energy-surface resulting from variation of
*       two coordinates. the step-size is step1 and step2, and a 11
*       by 11 grid of points is generated
*
*        this routine is extensively modified by manyin yi, aug 1989.
*
*        new features:
*      1. the input geometry definition should always be the upper-left
*          corner(smallest coordinates) instead of the middle point;
*       2. the starting point for calculation can be one of the four
*          corners by setting "+/-" step1/2;
*       3. the grid size(max 23*23) is controlled by point1/2,
*          if point1/2 is omitted, then a size of 11*11 is assumed;
*          kwd max sets the max size;
*       4. the upper-left corner of the plotting grid always corresponds
*          to the smallest coordinates, the lower-right corner to the
*          largest, no matter where the calculation starts;
*       5. restartable.
*       6. write out unimap irregular data ump.dat
*
************************************************************************
      common /cmpg/ geo(3,numatm)
      common/iofile/mfgr,mfgw
      common /geovar/ nvar,loc(2,maxpar), idumy, xparam(maxpar)
      common /gradnt/ grad(maxpar),gnorm
      common /gravec/ cosine
      common /mesh/ latom1, lpara1, latom2, lpara2
      common /gparam/ currt1,currt2
      common /ijlp/ ijlp, ilp, jlp, jlp1, ione
      common /surf/ surf
      common /keywrd/ keywrd
      common /titles/ koment, title
      character keywrd*241, koment*81, title*81, getmop*80
      logical restrt
      dimension gd(maxpar),xlast(maxpar),mdfp(20),xdfp(20)
      dimension surfac(23,23)
      dimension surf(23*23)
      dimension umpx(23),umpy(23),umpz(23*23)
c
      step1=reada(keywrd,index(keywrd,'step1')+6)
      step2=reada(keywrd,index(keywrd,'step2')+6)
      npts1=11
      npts2=11
      if (index(keywrd,' max').ne.0) then
         npts1=23
         npts2=23
         goto 10
      endif
      if (index(keywrd,'point1').ne.0)
     1 npts1=dabs(reada(keywrd,index(keywrd,'point1')+7))
      if (index(keywrd,'point2').ne.0)
     1 npts2=dabs(reada(keywrd,index(keywrd,'point2')+7))
   10 restrt=(index(keywrd,'restart').ne.0)
c
c  the top-left value of the first and second dimensions are
c      geo(lpara1,latom1) and geo(lpara2,latom2)
c
      umpy(1)=geo(lpara1,latom1)
      umpx(1)=geo(lpara2,latom2)
      degree=180.d0/3.14159265359d0
      if(lpara1.ne.1)step1=step1/degree
      if(lpara2.ne.1)step2=step2/degree
c
c  now set the starting point to the desired corner
c
      if(step1.gt.0.0d0.and.step2.gt.0.0d0) then
         start1=geo(lpara1,latom1)
         start2=geo(lpara2,latom2)
      endif
c bottom-left
      if(step1.lt.0.0d0.and.step2.gt.0.0d0)then
         start1=geo(lpara1,latom1)+(npts1-1)*(dabs(step1))
         start2=geo(lpara2,latom2)
      endif
c top-right
      if(step1.gt.0.0d0.and.step2.lt.0.0d0)then
         start1=geo(lpara1,latom1)
         start2=geo(lpara2,latom2)+dabs((npts2-1)*step2)
      endif
c bottom-right
      if(step1.lt.0.0d0.and.step2.lt.0.0d0)then
         start1=geo(lpara1,latom1)+dabs((npts1-1)*step1)
         start2=geo(lpara2,latom2)+dabs((npts2-1)*step2)
      endif
c
c  now to sweep through the grid of points left to right then right
c  to left or visa versa. this should avoid the geometry or scf getting
c  messed up.
c
      if(lpara1.ne.1) then
         c1=degree
      else
         c1=1.d0
      endif
      if(lpara2.ne.1) then
         c2=degree
      else
         c2=1.d0
      endif
c   these parameters need to be dumped in '.res'
      currt1=start1
      currt2=start2
      ione=-1.d0
      cputot=0.0d0
      ijlp=0
      ilp=1
      jlp=1
      jlp1=1
      surf(1)=0.d0
c
      if (restrt) then
         mdfp(9)=0
         call dfpsav(cputot,xparam,gd,xlast,escf,mdfp,xdfp)
      endif
c
      geo(lpara1,latom1)=currt1
      geo(lpara2,latom2)=currt2
      do 30 iloop=ilp,npts1
         ione=-ione
         do 20 jloop=jlp,npts2
            jloop1=0
            if(ione.lt.0)jloop1=npts2+1
            if(restrt) then
               jloop1=jlp1
               ione=-ione
               restrt=.false.
            else
               jloop1=jloop1+ione
               jlp1=jloop1
            endif
            cpu1=secmop()
            currt1=geo(lpara1,latom1)
            currt2=geo(lpara2,latom2)
            call flepo(xparam, nvar, escf)
            cpu2=secmop()
            cpu3=cpu2-cpu1
            cputot=cputot+cpu3
            jlp=jlp+1
            ijlp=ijlp+1
            surf(ijlp)=escf
            write(mfgw,
     + '(/''       first variable   second variable function'')')
            write(mfgw,
     + '('' :'',f16.5,f16.5,f16.6)')geo(lpara1,latom1)*c1,
     1        geo(lpara2,latom2)*c2,escf
            call geout(6)
            geo(lpara2,latom2)=geo(lpara2,latom2)+step2*ione
   20    continue
         geo(lpara1,latom1)=geo(lpara1,latom1)+step1
         geo(lpara2,latom2)=geo(lpara2,latom2)-step2*ione
         ilp=ilp+1
         jlp=1
   30 continue
      write(mfgw,'(/10x,''horizontal: varying second parameter,'',
     1          /10x,''vertical:   varying first parameter'')')
      write(mfgw,'(/10x,''whole of grid, suitable for plotting'',//)')
c
c  archive
      open(unit=12,file=getmop(6),status='unknown')
      open(unit=20,file=getmop(9),status='new',err=31)
      goto 32
  31  open(unit=20,file=getmop(9),status='old')
  32  continue
      write(12,40)
      call wrttxt(12)
   40 format(' archive file for grid calculation'/'grid of heats'/)
      write(12,'(/'' total cpu time in flepo : '',f10.3/)') cputot
c
c  write out the grids
      ione=1.d0
      iloop=1
      jloop1=1
      do 50 ij=1,npts1*npts2
         surfac(jloop1,iloop)=surf(ij)
         n=ij-(ij/npts2)*npts2
         if (n.eq.0) then
            iloop=iloop+1
            jloop1=jloop1+ione
            ione=-ione
         endif
         jloop1=jloop1+ione
   50 continue
c
      do 60 i=2,npts1
   60 umpy(i)=umpy(1)+(i-1)*dabs(step1)
      do 70 i=2,npts2
   70 umpx(i)=umpx(1)+(i-1)*dabs(step2)
      n=0
      if(step1.gt.0.0d0.and.step2.gt.0.0d0) then
         do 90 i=1,npts1
            do 80 j=1,npts2
               n=n+1
   80       umpz(n)=surfac(j,i)
            write(mfgw,'(11f7.2)')(surfac(j,i),j=1,npts2)
   90    write(12,'(11f7.2)')(surfac(j,i),j=1,npts2)
      endif
      if(step1.lt.0.0d0.and.step2.gt.0.0d0) then
         do 110 i=npts1,1,-1
            do 100 j=1,npts2
               n=n+1
  100       umpz(n)=surfac(j,i)
            write(mfgw,'(11f7.2)')(surfac(j,i),j=1,npts2)
  110    write(12,'(11f7.2)')(surfac(j,i),j=1,npts2)
      endif
      if(step1.gt.0.0d0.and.step2.lt.0.0d0) then
         do 130 i=1,npts1
            do 120 j=npts2,1,-1
               n=n+1
  120       umpz(n)=surfac(j,i)
            write(mfgw,'(11f7.2)')(surfac(j,i),j=npts2,1,-1)
  130    write(12,'(11f7.2)')(surfac(j,i),j=npts2,1,-1)
      endif
      if(step1.lt.0.0d0.and.step2.lt.0.0d0) then
         do 150 i=npts1,1,-1
            do 140 j=npts2,1,-1
               n=n+1
  140       umpz(n)=surfac(j,i)
            write(mfgw,'(11f7.2)')(surfac(j,i),j=npts2,1,-1)
  150    write(12,'(11f7.2)')(surfac(j,i),j=npts2,1,-1)
      endif
      do 160 i=0,npts1-1
         do 160 j=1,npts2
            n=i*npts2+j
  160 write(20,'(3(1x,f8.3))')umpx(j),umpy(i+1),umpz(n)
      close(20)
      end
      subroutine mophc (coord,h,w, wj,wk,enuclr)
      implicit REAL (a-h,o-z)
      logical fldon
INCLUDE(common/sizes)
      dimension coord(3,*),h(*), wj(n2elec), wk(n2elec), w(n2elec)
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),
     1                nlast(numatm), norbs, nelecs,nalpha,nbeta,
     2                nclose,nopen,ndumy,fract
      common /molorb/ uspd(maxorb),dumy(maxorb)
      common /keywrd/ keywrd
      common /euler/ tvec(3,3), id
      common /multip/ dd(107),qq(107),am(107),ad(107),aq(107)
      common /corec/ core(107)
      common /cmpfd/ efield(3)
      common /numcal/ numcal
      common/iofile/mfgr,mfgw
************************************************************************
c
c   mophc generates the one-electron matrix and two electron integrals
c         for a given molecule whose geometry is defined in cartesian
c         coordinates.
c
c  on input  coord   = coordinates of the molecule.
c
c  on output  h      = one-electron matrix.
c             w      = two-electron integrals.
c             enuclr = nuclear energy
************************************************************************
      character*241 keywrd
      logical first,debug
      save first, ione, cutoff, debug
      save icalcn
      dimension e1b(10),e2a(10),di(9,9), wjd(100), wkd(100)
      data icalcn/0/
      first=(icalcn.ne.numcal)
      icalcn=numcal
      if (first) then
         ione=1
         cutoff=1.d10
         if(id.ne.0)cutoff=60.d0
         if(id.ne.0)ione=0
         debug=(index(keywrd,'hcore') .ne. 0)
c  *** following 3 lines added as noted
c  in qcpe bulletin vol. 11, no. 3, pp. 52-54 (1991).
         efield(1)=0.d0
         efield(2)=0.d0
         efield(3)=0.d0
      endif
      fldon = .false.
      if ((efield(1).ne.0.0d00).or.(efield(2).ne.0.0d00).or.
     1    (efield(3).ne.0.0d00)) then
         fldcon = 51.4257d00
         fldon = .true.
      endif
      do 10 i=1,(norbs*(norbs+1))/2
   10 h(i)=0.d0
      enuclr=0.d0
      kr=1
      do 110 i=1,numat
         ia=nfirst(i)
         ib=nlast(i)
         ic=nmidle(i)
         ni=nat(i)
c
c first we fill the diagonals, and off-diagonals on the same atom
c
         do 30 i1=ia,ib
            i2=i1*(i1-1)/2+ia-1
            do 20 j1=ia,i1
               i2=i2+1
               h(i2)=0.d0
               if (fldon) then
                  io1 = i1 - ia
                  jo1 = j1 - ia
                  if ((jo1.eq.0).and.(io1.eq.1)) then
                     hterme = -0.529177d00*dd(ni)*efield(1)*fldcon
                     h(i2) = hterme
                  endif
                  if ((jo1.eq.0).and.(io1.eq.2)) then
                     hterme = -0.529177d00*dd(ni)*efield(2)*fldcon
                     h(i2) = hterme
                  endif
                  if ((jo1.eq.0).and.(io1.eq.3)) then
                     hterme = -0.529177d00*dd(ni)*efield(3)*fldcon
                     h(i2) = hterme
                  endif
               endif
   20       continue
            h(i2) = uspd(i1)
            if (fldon) then
               fnuc = -(efield(1)*coord(1,i) + efield(2)*coord(2,i) +
     1              efield(3)*coord(3,i))*fldcon
               h(i2) = h(i2) + fnuc
            endif
   30    continue
c
c   fill the atom-other atom one-electron matrix<psi(lambda)|psi(sigma)>
c
         im1=i-ione
         do 100 j=1,im1
            half=1.d0
            if(i.eq.j)half=0.5d0
            ja=nfirst(j)
            jb=nlast(j)
            jc=nmidle(j)
            nj=nat(j)
            call h1elec(ni,nj,coord(1,i),coord(1,j),di)
            i2=0
            do 40 i1=ia,ib
               ii=i1*(i1-1)/2+ja-1
               i2=i2+1
               j2=0
               jj=min0(i1,jb)
               do 40 j1=ja,jj
                  ii=ii+1
                  j2=j2+1
   40       h(ii)=h(ii)+di(i2,j2)
c
c   calculate the two-electron integrals, w; the electron nuclear terms
c   e1b and e2a; and the nuclear-nuclear term enuc.
c
            if(id.eq.0) then
               call moprat(ni,nj,coord(1,i),coord(1,j),w(kr),kr,e1b,e2a
     +  ,enuc,cutoff)
            else
               kro=kr
               call solrot(ni,nj,coord(1,i),coord(1,j),
     1                wjd, wkd,kr,e1b,e2a,enuc,cutoff)
               jj=0
               do 50 ii=kro,kr-1
                  jj=jj+1
                  wj(ii)=wjd(jj)
   50          wk(ii)=wkd(jj)
            endif
            enuclr = enuclr + enuc
c
c   add on the electron-nuclear attraction term for atom i.
c
            i2=0
            do 60 i1=ia,ic
               ii=i1*(i1-1)/2+ia-1
               do 60 j1=ia,i1
                  ii=ii+1
                  i2=i2+1
   60       h(ii)=h(ii)+e1b(i2)*half
            do  70 i1=ic+1,ib
               ii=(i1*(i1+1))/2
   70       h(ii)=h(ii)+e1b(1)*half
c
c   add on the electron-nuclear attraction term for atom j.
c
            i2=0
            do 80 i1=ja,jc
               ii=i1*(i1-1)/2+ja-1
               do 80 j1=ja,i1
                  ii=ii+1
                  i2=i2+1
   80       h(ii)=h(ii)+e2a(i2)*half
            do 90 i1=jc+1,jb
               ii=(i1*(i1+1))/2
   90       h(ii)=h(ii)+e2a(1)*half
  100    continue
  110 continue
      if( .not. debug) return
      write(mfgw,'(//10x,''one-electron matrix from hcore'')')
      call vecprt(h,norbs)
      j=min0(400,kr)
      if(id.eq.0) then
         write(mfgw,'(//10x,''two-electron matrix in hcore''/)')
         write(mfgw,120)(w(i),i=1,j)
      else
         write(mfgw,'(//10x,''two-electron j matrix in hcore''/)')
         write(mfgw,120)(wj(i),i=1,j)
         write(mfgw,'(//10x,''two-electron k matrix in hcore''/)')
         write(mfgw,120)(wk(i),i=1,j)
      endif
  120 format(10f8.4)
      return
      end
      subroutine mophes(svec,tvec,nvar,iupd)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      dimension tvec(*),svec(*)
      logical first
      common /fmatrx/oldf(maxpar),d(maxpar),vmode(maxpar),
     1u(maxpar,maxpar),dd,mode,nstep,negreq,iprnt
      common /nllcom/ hess(maxpar,maxpar*3)
      common /gradnt/ grad(maxpar),gnfina
      common /numcal/ numcal
      common/iofile/mfgr,mfgw
c
      save icalcn
      data icalcn/0/
      data zero/0.0d0/
c
c  updating of the hessian
c  depends on current gradients, old gradients and the
c  correction vector used on the last cycle
c  svec & tvec are for temporary storage
c
c  2 updating procedures are possible
c  (i)   the powell update
c        this preserves the symmetric character of the hessian
c        whilst allowing its eigenvalue structure to change.
c        it is the default update for a transition state search
c  (ii)  the bfgs update
c        this update has the important characteristic of retaining
c        positive definiteness (note: this is not rigorously
c        guaranteed, but can be checked for by the program).
c        it is the default update for a minimum search
c
c     switch : iupd
c       iupd = 0  :  skip update
c       iupd = 1  :  powell
c       iupd = 2  :  bfgs
c
      first = icalcn.eq.numcal
      icalcn = numcal
      if (.not. first) then
         first=.true.
         if(iprnt.ge.2) then
            if (iupd.eq.0)write(mfgw,90)
            if (iupd.eq.1)write(mfgw,80)
            if (iupd.eq.2)write(mfgw,120)
         endif
      endif
      if(iupd.eq.0) return
      do 10 i=1,nvar
         tvec(i)=zero
         do 10 j=1,nvar
            tvec(i)=tvec(i) + hess(i,j)*d(j)
   10 continue
c
      if(iupd.eq.1) then
c
c   (i) powell update
c
         do 20 i=1,nvar
            tvec(i)=grad(i)-oldf(i)-tvec(i)
   20    continue
         dds=dd*dd
         ddtd=ddot(nvar,tvec,1,d,1)
         ddtd=ddtd/dds
c
         do 40 i=1,nvar
            do 30 j=1,i
               temp=tvec(i)*d(j) + d(i)*tvec(j) - d(i)*ddtd*d(j)
               hess(i,j)=hess(i,j)+temp/dds
               hess(j,i)=hess(i,j)
   30       continue
   40    continue
c
      endif
      if (iupd.eq.2) then
c
c  (ii) bfgs update
c
         do 50 i=1,nvar
            svec(i)=grad(i)-oldf(i)
   50    continue
         dds=ddot(nvar,svec,1,d,1)
c
c  if dds is negative, retention of positive definiteness is not
c  guaranteed. print a warning and skip update this cycle.
c
         if(dds.lt.zero) then
            write(mfgw,100)
            write(mfgw,110)
            return
         endif
c
         ddtd=ddot(nvar,d,1,tvec,1)
c
         do 70 i=1,nvar
            do 60 j=1,i
               temp= (svec(i)*svec(j))/dds - (tvec(i)*tvec(j))/ddtd
               hess(i,j)=hess(i,j)+temp
               hess(j,i)=hess(i,j)
   60       continue
   70    continue
      endif
c
      return
c
   80 format(/,5x,'hessian is being updated using the powell update',/)
   90 format(/,5x,'hessian is not being updated',/)
  100 format(5x,'warning! hereditary positive definiteness endangered')
  110 format(5x,'update skipped this cycle')
  120 format(/,5x,'hessian is being updated using the bfgs update',/)
      end
      subroutine mopi(cp, cf, nelec, nmos, dijkl)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
************************************************************************
*
*   mopi fills the xy array.  xy holds the two-electron integrals over
*        molecular orbitals in the active space.
*        xy(i,j,k,l) = <ij|1/r(1,2)|kl>
*
*           on input
*
* cp     = m.o.'s over c.i. active space (normally 1 to 5 m.o.s)
* cf     = all m.o.'s, including those in cp
* norbs  = number of atomic orbitals
* nelec  = number of occupied m.o.s not involved in the c.i.
* nmos   = number of m.o.s involved in the c.i. (normally 1 to 5 m.o.s)
*          also called the active space of the c.i.
*
*  note: this routine is unusual in that one function is to
*        fill the array xy which is not passed as an argument,
*        instead it is passed via common block xyijkl.
*
************************************************************************
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),
     1                nlast(numatm), norbs, nelecs,nalpha,nbeta,
     2                nclose,nopen,ndumy,fract
      dimension cp(norbs,nmos), cf(norbs,norbs),
     1dijkl(norbs,nmos,(nmos*(nmos+1)/2))
      common /vector/ dumy1(morb2+maxorb), cij(10*maxorb),
     1wcij(10*maxorb), dumy(morb2-19*maxorb)
      common /xyijkl/ xy(nmeci,nmeci,nmeci,nmeci)
      dimension ckl(10*maxorb)
      dimension nb(0:8)
      equivalence (ckl, cij)
      data nb /1,0,0,10,0,0,0,0,45/
c
c  calculate two-electron integrals for the set dijkl(k,l,ij)
c  the index k runs over all m.o.'s, l over active-space m.o.'s,
c  and ij over lower-half triangle of active-space m.o.'s, j faster than
c  i.
c  all active-space interactions are copied into the array xy
c
      ij=0
      do 70 i=1,nmos
         do 70 j=1,i
            ij=ij+1
            ipq=0
            do 10 ii=1,numat
               do 10 ip=nfirst(ii),nlast(ii)
                  do 10 iq=nfirst(ii),ip
                     ipq=ipq+1
   10       cij(ipq)=cp(ip,i)*cp(iq,j)+cp(ip,j)*cp(iq,i)
c
c  cij holds the density distribution psi(i)*psi(j) over atomic bases
c  i and j are m.o. indices within the active space.  cij(m,n) is for
c  the atomic bases m and n for m.o.'s i and j.
c
            call partxy (cij,wcij)
c
c wcij holds the ket part of the integral <k,l|1/r(1,2)|i,j>
c that is, |1/r(1,2)|i,j>.  wcij(m,n) is for the atomic bases m and n
c for m.o.'s k and l.
c
            do 60 k=1,norbs
               do 50 l=1,nmos
c
c  about to calculate <i,j|1/r(1,2)|k,l>
c
                  ipq=0
                  do 30 ii=1,numat
                     do 30 ip=nfirst(ii),nlast(ii)
                        do 30 iq=nfirst(ii),ip
                           ipq=ipq+1
   30             ckl(ipq)=cf(ip,k)*cp(iq,l)+cp(ip,l)*cf(iq,k)
c
c ckl holds the density distribution psi(k)*psi(l) over atomic bases.
c k is the index of a m.o.; l is an index of a m.o. in the active space.
c
                  sum=0.d0
                  do 40 ii=1,ipq
   40             sum=sum+ckl(ii)*wcij(ii)
c
c  sum is the integral <i,j|1/r(1,2)|k,l>
c
                  dijkl(k,l,ij)=sum
   50          continue
   60       continue
   70 continue
c
c  now spread the integrals over the xy array.  xy is entirely
c  in active space
c
      do 80 k=1,nmos
         kk=nelec+k
c
c  k is a m.o. index in active space
c kk is a m.o. index
c
         do 80 l=1,nmos
            ij=0
            do 80 i=1,nmos
               do 80 j=1,i
                  ij=ij+1
                  sum=dijkl(kk,l,ij)
                  xy(i,j,k,l)=sum
                  xy(i,j,l,k)=sum
                  xy(j,i,k,l)=sum
                  xy(j,i,l,k)=sum
                  xy(k,l,i,j)=sum
                  xy(k,l,j,i)=sum
                  xy(l,k,i,j)=sum
   80 continue
      return
      end
      subroutine moplo(c,mdim,nocc,eig)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      dimension c(mdim,mdim), eig(maxorb)
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),
     1                nlast(numatm), norbs, nelecs,nalpha,nbeta,
     2                nclose,nopen,ndumy,fract
c**********************************************************************
c
c   localisation subroutine
c on input
c        c = eigenvectors in an mdim*mdim matrix
c        nocc = number of filled levels
c        norbs = number of orbitals
c        numat = number of atoms
c        nlast   = integer array of atom orbital counters
c        nfirst   = integer array of atom orbital counters
c
c       subroutine maximizes (psi)**4
c       reference_
c       a new rapid method for orbital localisation, p.g. perkins and
c       j.j.p. stewart, j.c.s. faraday (ii) 77, 000, (1981).
c
c       modified and corrected to avoid sigma-pi orbital mixing by
c       juan carlos paniagua, university of barcelona, may 1983.
c
c**********************************************************************
      common /scrach/
     +   cold(maxorb,maxorb),xdumy(maxpar**2-maxorb*maxorb)
      common/iofile/mfgr,mfgw
      dimension eig1(maxorb),psi1(maxorb),psi2(maxorb),
     1          cii(maxorb), refeig(maxorb),iel(20)
      save elemnt
      character*2 elemnt(99)
      data elemnt/'h','he',
     1 'li','be','b','c','n','o','f','ne',
     2 'na','mg','al','si','p','s','cl','ar',
     3 'k','ca','sc','ti','v','cr','mn','fe','co','ni','cu',
     4 'zn','ga','ge','as','se','br','kr',
     5 'rb','sr','y','zr','nb','mo','tc','ru','rh','pd','ag',
     6 'cd','in','sn','sb','te','i','xe',
     7 'cs','ba','la','ce','pr','nd','pm','sm','eu','gd','tb','dy',
     8 'ho','er','tm','yb','lu','hf','ta','w','re','os','ir','pt',
     9 'au','hg','tl','pb','bi','po','at','rn',
     1 'fr','ra','ac','th','pa','u','np','pu','am','cm','bk','cf','xx'/
      niter=100
      eps=1.0d-7
      do 10 i=1,norbs
         refeig(i)=eig(i)
         do 10 j=1,norbs
   10 cold(i,j)=c(i,j)
      iter=0
   20 continue
      sum=0.d0
      iter=iter+1
      do 80 i=1,nocc
         do 70 j=1,nocc
            if(j.eq.i) goto 70
            xijjj=0.0d0
            xjiii=0.0d0
            xiiii=0.0d0
            xjjjj=0.0d0
            xijij=0.0d0
            xiijj=0.0d0
            do 30 k=1,norbs
               psi1(k)=c(k,i)
   30       psi2(k)=c(k,j)
c now follows the rate-determining step for the calculation
            do 50 k1=1,numat
               kl=nfirst(k1)
               ku=nlast(k1)
               dij=0.d0
               dii=0.d0
               djj=0.d0
c$doit asis
               do 40 k=kl,ku
                  dij=dij+psi1(k)*psi2(k)
                  dii=dii+psi1(k)*psi1(k)
                  djj=djj+psi2(k)*psi2(k)
   40          continue
               xijjj=xijjj+dij*djj
               xjiii=xjiii+dij*dii
               xiiii=xiiii+dii*dii
               xjjjj=xjjjj+djj*djj
               xijij=xijij+dij*dij
               xiijj=xiijj+dii*djj
   50       continue
            aij=xijij-(xiiii+xjjjj-2.0d0*xiijj)/4.0d0
            bij=xjiii-xijjj
            ca=dsqrt(aij*aij+bij*bij)
            sa=aij+ca
            if(sa.lt.1.0d-14) go to 70
            sum=sum+sa
            ca=-aij/ca
            ca=(1.0d0+dsqrt((1.0d0+ca)/2.0d0))/2.0d0
            if((2.0d0*ca-1.0d0)*bij.lt.0.0d0)ca=1.0d0-ca
            sa=dsqrt(1.0d0-ca)
            ca=dsqrt(ca)
            do 60 k=1,norbs
               c(k,i)=ca*psi1(k)+sa*psi2(k)
   60       c(k,j)=-sa*psi1(k)+ca*psi2(k)
   70    continue
   80 continue
      sum1=0.d0
      do 100 i=1,nocc
         do 100 j=1,numat
            il=nfirst(j)
            iu=nlast(j)
            x=0.0d0
c$doit asis
            do 90 k=il,iu
   90       x=x+c(k,i)**2
  100 sum1=sum1+x*x
      if(sum.gt.eps.and.iter.lt.niter) go to 20
      write(mfgw,110)iter,sum1
  110 format(/10x,'number of iterations =',i4/
     110x,'localisation value =',f14.9,/)
      write(mfgw,120)
  120 format(3x,'number of centers',14x,'(composition of orbitals)'//)
      do 150 i=1,nocc
         sum=0.d0
         do 140 j=1,nocc
            co=0.d0
            do 130 k=1,norbs
  130       co=co+cold(k,j)*c(k,i)
  140    sum=sum+co*co*eig(j)
  150 eig1(i)=sum
      do 180 i=1,nocc
         x=100.d0
         do 160 j=i,nocc
            if (x.lt.eig1(j))  goto  160
            x=eig1(j)
            i1=j
  160    continue
         eig(i)=eig1(i1)
         x=eig1(i1)
         eig1(i1)=eig1(i)
         eig1(i)=x
         do 170 j=1,norbs
            x=c(j,i1)
            c(j,i1)=c(j,i)
  170    c(j,i)=x
  180 continue
      do 250 i=1,nocc
         x=0.d0
         do 200 k1=1,numat
            kl=nfirst(k1)
            ku=nlast(k1)
            dii=0.d0
            do 190 k=kl,ku
  190       dii=dii+c(k,i)**2
            x=x+dii*dii
  200    psi1(k1)=dii*100.d0
         x=1/x
         do 220 ii=1,numat
            sum=0.d0
            do 210 j=1,numat
               if(psi1(j).lt.sum) goto 210
               sum=psi1(j)
               k=j
  210       continue
            psi1(k)=0.d0
            cii(ii)=sum
            iel(ii)=k
            if(sum.lt.1.d0) goto 230
  220    continue
  230    continue
         ii=ii-1
         write(mfgw,240)x,(elemnt(nat(iel(k))),iel(k),cii(k),k=1,ii)
  240    format(f10.4,4(5(3x,a2,i3,f6.2),/10x))
  250 continue
  260 format(//20x,20h localized orbitals   ,//)
      write(mfgw,260)
      call mopmat(c,eig,nocc,norbs,mdim)
c 270 format(10f12.6)
      do 280 i=1,nocc
         eig(i)=refeig(i)
         do 280 j=1,norbs
  280 c(j,i)=cold(j,i)
      return
      end
      subroutine mopm (a,nar,b,nbr,c,ncc)
      implicit REAL (a-h,o-z)
c     matrix product c(nar,ncc) = a(nar,nbr) * (b(ncc,nbr))'
c     all matrices rectangular , packed.
      dimension a(nar,nbr),b(ncc,nbr),c(nar,ncc)
      do 20 j=1,ncc
         do 10 i=1,nar
   10    c(i,j)=0.d0
         do 20 k=1,nbr
            do 20 i=1,nar
   20 c(i,j)=c(i,j)+a(i,k)*b(j,k)
      return
      end
      subroutine moppun (a,b,nc,nr,ndim,iwrite)
      implicit REAL (a-h,o-z)
      character elemnt*2
INCLUDE(common/sizes)
      dimension a(ndim,ndim), b(ndim)
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),
     1                nlast(numatm), norbs, nelecs,nalpha,nbeta,
     2                nclose,nopen,ndumy,fract
      common /elemts/ elemnt(107)
c**********************************************************************
c
c      moppun punches a square matrix of eigenvectors and eigenvalues
c
c    on input a contains the matrix to be printed.
c             b contains the eigenvalues.
c             nc number of molecular orbitals to be printed.
c             nr is the size of the square array to be printed.
c             ndim is the actual size of the square array "a".
c             nfirst and nlast contain atom orbital counters.
c             nat = array of atomic numbers of atoms.
c
c***********************************************************************
      if(numat.eq.0) return
c
      write (iwrite,*) 'vectors mopac'
      do 50 j = 1 , nc
         imax = 0
         ic = 0
 40      imin = imax + 1
         imax = imax + 5
         ic = ic + 1
         if (imax.gt.nr) imax = nr
         write (iwrite,6040) j , ic , (a(i,j),i=imin,imax)
 6040    format (i2,i3,5e15.8)
         if (imax.lt.nr) go to 40
 50   continue
      return
      end
      subroutine moprat (ni,nj,xi,xj,w,kr,e1b,e2a,enuc,cutoff)
      implicit REAL (a-h,o-z)
c***********************************************************************
c
c..improved scalar version
c..written by ernest r. davidson, indiana university.
c
c
c   rotate calculates the two-particle interactions.
c
c   on input  ni     = atomic number of first atom.
c             nj     = atomic number of second atom.
c             xi     = coordinate of first atom.
c             xj     = coordinate of second atom.
c
c on output w      = array of two-electron repulsion integrals.
c           e1b,e2a= array of electron-nuclear attraction integrals,
c                    e1b = electron on atom ni attracting nucleus of nj.
c           enuc   = nuclear-nuclear repulsion term.
c
c
c *** this routine computes the repulsion and nuclear attraction
c     integrals over molecular-frame coordinates.  the integrals over
c     local frame coordinates are evaluated by routine reppp and
c     stored as follows (where p-sigma = o,   and p-pi = p and p* )
c     in ri
c     (ss/ss)=1,   (so/ss)=2,   (oo/ss)=3,   (pp/ss)=4,   (ss/os)=5,
c     (so/so)=6,   (sp/sp)=7,   (oo/so)=8,   (pp/so)=9,   (po/sp)=10,
c     (ss/oo)=11,  (ss/pp)=12,  (so/oo)=13,  (so/pp)=14,  (sp/op)=15,
c     (oo/oo)=16,  (pp/oo)=17,  (oo/pp)=18,  (pp/pp)=19,  (po/po)=20,
c     (pp/p*p*)=21,   (p*p/p*p)=22.
c
c***********************************************************************
      common /numcal/ numcal
      save analyt, icalcn
      common /molmec/ htype(4),nhco(4,20),nnhco,itype
      character*241 keywrd
      logical si,sj, analyt
      common /cmporb/ natorb(107)
      common /twoel3/ f03(107)
      common /alpha3/ alp3(153)
      common /alpha/ alp(107)
      common /corec/ tore(107)
      common /ideas/ fn1(107,10),fn2(107,10),fn3(107,10)
      common /alptm/ alptm(30), emudtm(30)
      common /rotdum/ css1,csp1,cpps1,cppp1,css2,csp2,cpps2,cppp2
      common /rotdu2/ x(3),y(3),z(3)
      common /keywrd/ keywrd
      dimension xi(3),xj(3),w(100),e1b(10),e2a(10)
      dimension ri(22),ccore(4,2), boron1(3,4), boron2(3,4), boron3(3,4)
      equivalence (ccore(1,1),css1)
      data icalcn/0/
      data boron1/  0.182613d0,  0.118587d0, -0.073280d0,
     1              0.412253d0, -0.149917d0,  0.000000d0,
     2              0.261751d0,  0.050275d0,  0.000000d0,
     3              0.359244d0,  0.074729d0,  0.000000d0/
      data boron2/  6.d0,  6.d0,  5.d0,
     1             10.d0,  6.d0,  0.d0,
     2              8.d0,  5.d0,  0.d0,
     3              9.d0,  9.d0,  0.d0/
      data boron3/  0.727592d0,  1.466639d0,  1.570975d0,
     1              0.832586d0,  1.186220d0,  0.000000d0,
     2              1.063995d0,  1.936492d0,  0.000000d0,
     3              0.819351d0,  1.574414d0,  0.000000d0/
c
      if(icalcn.ne.numcal)then
         icalcn=numcal
         analyt=(index(keywrd,'analyt') .ne. 0)
         if(analyt)then
            open(unit=2,status='scratch',form='unformatted')
            rewind 2
         endif
      endif
c
      x(1)=xi(1)-xj(1)
      x(2)=xi(2)-xj(2)
      x(3)=xi(3)-xj(3)
      rij=x(1)*x(1)+x(2)*x(2)+x(3)*x(3)
      if (rij.lt.0.00002d0) then
c
c     small rij case
c
         do 10 i=1,10
            e1b(i)=0.d0
            e2a(i)=0.d0
   10    continue
         w(kr)=0.d0
         enuc=0.d0
c
      else if (itype.eq.4) then
c
c     mindo case
c
         sum=14.399d0/dsqrt(rij+(7.1995d0/f03(ni)+7.1995d0/f03(nj))**2)
         w(1)=sum
         kr=kr+1
         do 20 l=1,10
            e1b(l)=0.d0
            e2a(l)=0.d0
   20    continue
         e1b(1) = -sum*tore(nj)
         e1b(3) = e1b(1)
         e1b(6) = e1b(1)
         e1b(10)= e1b(1)
         e2a(1) = -sum*tore(ni)
         e2a(3) = e2a(1)
         e2a(6) = e2a(1)
         e2a(10)= e2a(1)
         ii = max0(ni,nj)
         nbond = (ii*(ii-1))/2+ni+nj-ii
         rij = dsqrt(rij)
         if(nbond.lt.154) then
            if(nbond.eq.22 .or. nbond .eq. 29) then
c              nbond = 22 is c-h case
c              nbond = 29 is n-h case
               scale=alp3(nbond)*dexp(-rij)
            else
c              nbond < 154  is ni < 18 and nj < 18 case
               scale=dexp(-alp3(nbond)*rij)
            endif
         else
c              nbond > 154 involves ni or nj > 18
            scale = 0
            if(natorb(ni).eq.0) scale=      dexp(-alp(ni)*rij)
            if(natorb(nj).eq.0) scale=scale+dexp(-alp(ni)*rij)
         endif
         if (dabs(tore(ni)).gt.20.d0 .and. dabs(tore(nj)).gt.20.d0)
     +                 then
            enuc=0.d0
         else if (rij.lt.1.d0 .and. natorb(ni)*natorb(nj).eq.0) then
            enuc=0.d0
         else
            enuc = tore(ni)*tore(nj)*sum
     1       + dabs(tore(ni)*tore(nj)*(14.399d0/rij-sum)*scale)
         endif
c
c     mndo and am1 cases
c
c *** the repulsion integrals over molecular frame (w) are stored in the
c     order in which they will later be used.  ie.  (i,j/k,l) where
c     j.le.i  and  l.le.k     and l varies most rapidly and i least
c     rapidly.  (anti-normal computer storage)
c
      else
c
         rijx = dsqrt(rij)
         rij = dmin1(rijx,cutoff)
c
c *** compute integrals in diatomic frame
c
         call reppp(ni,nj,rij,ri,ccore)
         if(analyt)write(2)(ri(i),i=1,22)
c
         gam = ri(1)
         a=1.d0/rijx
         x(1) = x(1)*a
         x(2) = x(2)*a
         x(3) = x(3)*a
         if (dabs(x(3)).gt.0.99999999d0) then
            x(3) = dsign(1.d0,x(3))
            y(1) = 0.d0
            y(2) = 1.d0
            y(3) = 0.d0
            z(1) = 1.d0
            z(2) = 0.d0
            z(3) = 0.d0
         else
            z(3)=dsqrt(1.d0-x(3)*x(3))
            a=1.d0/z(3)
            y(1)=-a*x(2)*dsign(1.d0,x(1))
            y(2)=dabs(a*x(1))
            y(3)=0.d0
            z(1)=-a*x(1)*x(3)
            z(2)=-a*x(2)*x(3)
         endif
         si = (natorb(ni).gt.1)
         sj = (natorb(nj).gt.1)
         if ( si .or. sj) then
            xx11 = x(1)*x(1)
            xx21 = x(2)*x(1)
            xx22 = x(2)*x(2)
            xx31 = x(3)*x(1)
            xx32 = x(3)*x(2)
            xx33 = x(3)*x(3)
            yy11 = y(1)*y(1)
            yy21 = y(2)*y(1)
            yy22 = y(2)*y(2)
            zz11 = z(1)*z(1)
            zz21 = z(2)*z(1)
            zz22 = z(2)*z(2)
            zz31 = z(3)*z(1)
            zz32 = z(3)*z(2)
            zz33 = z(3)*z(3)
            yyzz11 = yy11+zz11
            yyzz21 = yy21+zz21
            yyzz22 = yy22+zz22
            xy11 = 2.d0*x(1)*y(1)
            xy21 =      x(1)*y(2)+x(2)*y(1)
            xy22 = 2.d0*x(2)*y(2)
            xy31 =      x(3)*y(1)
            xy32 =      x(3)*y(2)
            xz11 = 2.d0*x(1)*z(1)
            xz21 =      x(1)*z(2)+x(2)*z(1)
            xz22 = 2.d0*x(2)*z(2)
            xz31 =      x(1)*z(3)+x(3)*z(1)
            xz32 =      x(2)*z(3)+x(3)*z(2)
            xz33 = 2.d0*x(3)*z(3)
            yz11 = 2.d0*y(1)*z(1)
            yz21 =      y(1)*z(2)+y(2)*z(1)
            yz22 = 2.d0*y(2)*z(2)
            yz31 =      y(1)*z(3)
            yz32 =      y(2)*z(3)
         endif
c
c     (s s/s s)
         w(1)=ri(1)
         ki = 1
         if (sj) then
c     (s s/px s)
            w(2)=ri(5)*x(1)
c     (s s/px px)
            w(3)=ri(11)*xx11+ri(12)*yyzz11
c     (s s/py s)
            w(4)=ri(5)*x(2)
c     (s s/py px)
            w(5)=ri(11)*xx21+ri(12)*yyzz21
c     (s s/py py)
            w(6)=ri(11)*xx22+ri(12)*yyzz22
c     (s s/pz s)
            w(7)=ri(5)*x(3)
c     (s s/pz px)
            w(8)=ri(11)*xx31+ri(12)*zz31
c     (s s/pz py)
            w(9)=ri(11)*xx32+ri(12)*zz32
c     (s s/pz pz)
            w(10)=ri(11)*xx33+ri(12)*zz33
            ki = 10
         endif
c
         if (si) then
c     (px s/s s)
            w(11)=ri(2)*x(1)
            if (sj) then
c     (px s/px s)
               w(12)=ri(6)*xx11+ri(7)*yyzz11
c     (px s/px px)
               w(13)=x(1)*(ri(13)*xx11+ri(14)*yyzz11)
     1           +ri(15)*(y(1)*xy11+z(1)*xz11)
c     (px s/py s)
               w(14)=ri(6)*xx21+ri(7)*yyzz21
c     (px s/py px)
               w(15)=x(1)*(ri(13)*xx21+ri(14)*yyzz21)
     1           +ri(15)*(y(1)*xy21+z(1)*xz21)
c     (px s/py py)
               w(16)=x(1)*(ri(13)*xx22+ri(14)*yyzz22)
     1           +ri(15)*(y(1)*xy22+z(1)*xz22)
c     (px s/pz s)
               w(17)=ri(6)*xx31+ri(7)*zz31
c     (px s/pz px)
               w(18)=x(1)*(ri(13)*xx31+ri(14)*zz31)
     1           +ri(15)*(y(1)*xy31+z(1)*xz31)
c     (px s/pz py)
               w(19)=x(1)*(ri(13)*xx32+ri(14)*zz32)
     1           +ri(15)*(y(1)*xy32+z(1)*xz32)
c     (px s/pz pz)
               w(20)=x(1)*(ri(13)*xx33+ri(14)*zz33)
     1           +ri(15)*(          z(1)*xz33)
c     (px px/s s)
               w(21)=ri(3)*xx11+ri(4)*yyzz11
c     (px px/px s)
               w(22)=x(1)*(ri(8)*xx11+ri(9)*yyzz11)
     1           +ri(10)*(y(1)*xy11+z(1)*xz11)
c     (px px/px px)
               w(23) =
     1     (ri(16)*xx11+ri(17)*yyzz11)*xx11+ri(18)*xx11*yyzz11
     2     +ri(19)*(yy11*yy11+zz11*zz11)
     3     +ri(20)*(xy11*xy11+xz11*xz11)
     4     +ri(21)*(yy11*zz11+zz11*yy11)
     5     +ri(22)*yz11*yz11
c     (px px/py s)
               w(24)=x(2)*(ri(8)*xx11+ri(9)*yyzz11)
     1           +ri(10)*(y(2)*xy11+z(2)*xz11)
c     (px px/py px)
               w(25) =
     1     (ri(16)*xx11+ri(17)*yyzz11)*xx21+ri(18)*xx11*yyzz21
     2     +ri(19)*(yy11*yy21+zz11*zz21)
     3     +ri(20)*(xy11*xy21+xz11*xz21)
     4     +ri(21)*(yy11*zz21+zz11*yy21)
     5     +ri(22)*yz11*yz21
c     (px px/py py)
               w(26) =
     1     (ri(16)*xx11+ri(17)*yyzz11)*xx22+ri(18)*xx11*yyzz22
     2     +ri(19)*(yy11*yy22+zz11*zz22)
     3     +ri(20)*(xy11*xy22+xz11*xz22)
     4     +ri(21)*(yy11*zz22+zz11*yy22)
     5     +ri(22)*yz11*yz22
c     (px px/pz s)
               w(27)=x(3)*(ri(8)*xx11+ri(9)*yyzz11)
     1           +ri(10)*(         +z(3)*xz11)
c     (px px/pz px)
               w(28) =
     1      (ri(16)*xx11+ri(17)*yyzz11)*xx31
     2     +(ri(18)*xx11+ri(19)*zz11+ri(21)*yy11)*zz31
     3     +ri(20)*(xy11*xy31+xz11*xz31)
     4     +ri(22)*yz11*yz31
c     (px px/pz py)
               w(29) =
     1      (ri(16)*xx11+ri(17)*yyzz11)*xx32
     2     +(ri(18)*xx11+ri(19)*zz11+ri(21)*yy11)*zz32
     3     +ri(20)*(xy11*xy32+xz11*xz32)
     4     +ri(22)*yz11*yz32
c     (px px/pz pz)
               w(30) =
     1      (ri(16)*xx11+ri(17)*yyzz11)*xx33
     2     +(ri(18)*xx11+ri(19)*zz11+ri(21)*yy11)*zz33
     3     +ri(20)*xz11*xz33
c     (py s/s s)
               w(31)=ri(2)*x(2)
c     (py s/px s)
               w(32)=ri(6)*xx21+ri(7)*yyzz21
c     (py s/px px)
               w(33)=x(2)*(ri(13)*xx11+ri(14)*yyzz11)
     1           +ri(15)*(y(2)*xy11+z(2)*xz11)
c     (py s/py s)
               w(34)=ri(6)*xx22+ri(7)*yyzz22
c     (py s/py px)
               w(35)=x(2)*(ri(13)*xx21+ri(14)*yyzz21)
     1           +ri(15)*(y(2)*xy21+z(2)*xz21)
c     (py s/py py)
               w(36)=x(2)*(ri(13)*xx22+ri(14)*yyzz22)
     1           +ri(15)*(y(2)*xy22+z(2)*xz22)
c     (py s/pz s)
               w(37)=ri(6)*xx32+ri(7)*zz32
c     (py s/pz px)
               w(38)=x(2)*(ri(13)*xx31+ri(14)*zz31)
     1           +ri(15)*(y(2)*xy31+z(2)*xz31)
c     (py s/pz py)
               w(39)=x(2)*(ri(13)*xx32+ri(14)*zz32)
     1           +ri(15)*(y(2)*xy32+z(2)*xz32)
c     (py s/pz pz)
               w(40)=x(2)*(ri(13)*xx33+ri(14)*zz33)
     1           +ri(15)*(         +z(2)*xz33)
c     (py px/s s)
               w(41)=ri(3)*xx21+ri(4)*yyzz21
c     (py px/px s)
               w(42)=x(1)*(ri(8)*xx21+ri(9)*yyzz21)
     1           +ri(10)*(y(1)*xy21+z(1)*xz21)
c     (py px/px px)
               w(43) =
     1     (ri(16)*xx21+ri(17)*yyzz21)*xx11+ri(18)*xx21*yyzz11
     2     +ri(19)*(yy21*yy11+zz21*zz11)
     3     +ri(20)*(xy21*xy11+xz21*xz11)
     4     +ri(21)*(yy21*zz11+zz21*yy11)
     5     +ri(22)*yz21*yz11
c     (py px/py s)
               w(44)=x(2)*(ri(8)*xx21+ri(9)*yyzz21)
     1           +ri(10)*(y(2)*xy21+z(2)*xz21)
c     (py px/py px)
               w(45) =
     1     (ri(16)*xx21+ri(17)*yyzz21)*xx21+ri(18)*xx21*yyzz21
     2     +ri(19)*(yy21*yy21+zz21*zz21)
     3     +ri(20)*(xy21*xy21+xz21*xz21)
     4     +ri(21)*(yy21*zz21+zz21*yy21)
     5     +ri(22)*yz21*yz21
c     (py px/py py)
               w(46) =
     1     (ri(16)*xx21+ri(17)*yyzz21)*xx22+ri(18)*xx21*yyzz22
     2     +ri(19)*(yy21*yy22+zz21*zz22)
     3     +ri(20)*(xy21*xy22+xz21*xz22)
     4     +ri(21)*(yy21*zz22+zz21*yy22)
     5     +ri(22)*yz21*yz22
c     (py px/pz s)
               w(47)=x(3)*(ri(8)*xx21+ri(9)*yyzz21)
     1           +ri(10)*(         +z(3)*xz21)
c      (py px/pz px)
               w(48) =
     1     (ri(16)*xx21+ri(17)*yyzz21)*xx31
     2     +(ri(18)*xx21+ri(19)*zz21+ri(21)*yy21)*zz31
     3     +ri(20)*(xy21*xy31+xz21*xz31)
     4     +ri(22)*yz21*yz31
c      (py px/pz py)
               w(49) =
     1     (ri(16)*xx21+ri(17)*yyzz21)*xx32
     2     +(ri(18)*xx21+ri(19)*zz21+ri(21)*yy21)*zz32
     3     +ri(20)*(xy21*xy32+xz21*xz32)
     4     +ri(22)*yz21*yz32
c      (py px/pz pz)
               w(50) =
     1     (ri(16)*xx21+ri(17)*yyzz21)*xx33
     2     +(ri(18)*xx21+ri(19)*zz21+ri(21)*yy21)*zz33
     3     +ri(20)*xz21*xz33
c     (py py/s s)
               w(51)=ri(3)*xx22+ri(4)*yyzz22
c     (py py/px s)
               w(52)=x(1)*(ri(8)*xx22+ri(9)*yyzz22)
     1           +ri(10)*(y(1)*xy22+z(1)*xz22)
c      (py py/px px)
               w(53) =
     1     (ri(16)*xx22+ri(17)*yyzz22)*xx11+ri(18)*xx22*yyzz11
     2     +ri(19)*(yy22*yy11+zz22*zz11)
     3     +ri(20)*(xy22*xy11+xz22*xz11)
     4     +ri(21)*(yy22*zz11+zz22*yy11)
     5     +ri(22)*yz22*yz11
c     (py py/py s)
               w(54)=x(2)*(ri(8)*xx22+ri(9)*yyzz22)
     1           +ri(10)*(y(2)*xy22+z(2)*xz22)
c      (py py/py px)
               w(55) =
     1     (ri(16)*xx22+ri(17)*yyzz22)*xx21+ri(18)*xx22*yyzz21
     2     +ri(19)*(yy22*yy21+zz22*zz21)
     3     +ri(20)*(xy22*xy21+xz22*xz21)
     4     +ri(21)*(yy22*zz21+zz22*yy21)
     5     +ri(22)*yz22*yz21
c      (py py/py py)
               w(56) =
     1     (ri(16)*xx22+ri(17)*yyzz22)*xx22+ri(18)*xx22*yyzz22
     2     +ri(19)*(yy22*yy22+zz22*zz22)
     3     +ri(20)*(xy22*xy22+xz22*xz22)
     4     +ri(21)*(yy22*zz22+zz22*yy22)
     5     +ri(22)*yz22*yz22
c     (py py/pz s)
               w(57)=x(3)*(ri(8)*xx22+ri(9)*yyzz22)
     1           +ri(10)*(         +z(3)*xz22)
c      (py py/pz px)
               w(58) =
     1     (ri(16)*xx22+ri(17)*yyzz22)*xx31
     2     +(ri(18)*xx22+ri(19)*zz22+ri(21)*yy22)*zz31
     3     +ri(20)*(xy22*xy31+xz22*xz31)
     4     +ri(22)*yz22*yz31
c      (py py/pz py)
               w(59) =
     1     (ri(16)*xx22+ri(17)*yyzz22)*xx32
     2     +(ri(18)*xx22+ri(19)*zz22+ri(21)*yy22)*zz32
     3     +ri(20)*(xy22*xy32+xz22*xz32)
     4     +ri(22)*yz22*yz32
c      (py py/pz pz)
               w(60) =
     1     (ri(16)*xx22+ri(17)*yyzz22)*xx33
     2     +(ri(18)*xx22+ri(19)*zz22+ri(21)*yy22)*zz33
     3     +ri(20)*xz22*xz33
c     (pz s/ss)
               w(61)=ri(2)*x(3)
c     (pz s/px s)
               w(62)=ri(6)*xx31+ri(7)*zz31
c     (pz s/px px)
               w(63)=x(3)*(ri(13)*xx11+ri(14)*yyzz11)
     1           +ri(15)*(         +z(3)*xz11)
c     (pz s/py s)
               w(64)=ri(6)*xx32+ri(7)*zz32
c     (pz s/py px)
               w(65)=x(3)*(ri(13)*xx21+ri(14)*yyzz21)
     1           +ri(15)*(         +z(3)*xz21)
c     (pz s/py py)
               w(66)=x(3)*(ri(13)*xx22+ri(14)*yyzz22)
     1           +ri(15)*(         +z(3)*xz22)
c     (pz s/pz s)
               w(67)=ri(6)*xx33+ri(7)*zz33
c     (pz s/pz px)
               w(68)=x(3)*(ri(13)*xx31+ri(14)*zz31)
     1           +ri(15)*(         +z(3)*xz31)
c     (pz s/pz py)
               w(69)=x(3)*(ri(13)*xx32+ri(14)*zz32)
     1           +ri(15)*(         +z(3)*xz32)
c     (pz s/pz pz)
               w(70)=x(3)*(ri(13)*xx33+ri(14)*zz33)
     1           +ri(15)*(         +z(3)*xz33)
c     (pz px/s s)
               w(71)=ri(3)*xx31+ri(4)*zz31
c     (pz px/px s)
               w(72)=x(1)*(ri(8)*xx31+ri(9)*zz31)
     1           +ri(10)*(y(1)*xy31+z(1)*xz31)
c      (pz px/px px)
               w(73) =
     1     (ri(16)*xx31+ri(17)*zz31)*xx11+ri(18)*xx31*yyzz11
     2     +ri(19)*zz31*zz11
     3     +ri(20)*(xy31*xy11+xz31*xz11)
     4     +ri(21)*zz31*yy11
     5     +ri(22)*yz31*yz11
c     (pz px/py s)
               w(74)=x(2)*(ri(8)*xx31+ri(9)*zz31)
     1           +ri(10)*(y(2)*xy31+z(2)*xz31)
c      (pz px/py px)
               w(75) =
     1     (ri(16)*xx31+ri(17)*zz31)*xx21+ri(18)*xx31*yyzz21
     2     +ri(19)*zz31*zz21
     3     +ri(20)*(xy31*xy21+xz31*xz21)
     4     +ri(21)*zz31*yy21
     5     +ri(22)*yz31*yz21
c      (pz px/py py)
               w(76) =
     1     (ri(16)*xx31+ri(17)*zz31)*xx22+ri(18)*xx31*yyzz22
     2     +ri(19)*zz31*zz22
     3     +ri(20)*(xy31*xy22+xz31*xz22)
     4     +ri(21)*zz31*yy22
     5     +ri(22)*yz31*yz22
c     (pz px/pz s)
               w(77)=x(3)*(ri(8)*xx31+ri(9)*zz31)
     1           +ri(10)*(         +z(3)*xz31)
c     (pz px/pz px)
               w(78) =
     1      (ri(16)*xx31+ri(17)*zz31)*xx31
     2     +(ri(18)*xx31+ri(19)*zz31)*zz31
     3     +ri(20)*(xy31*xy31+xz31*xz31)
     4     +ri(22)*yz31*yz31
c      (pz px/pz py)
               w(79) =
     1      (ri(16)*xx31+ri(17)*zz31)*xx32
     2     +(ri(18)*xx31+ri(19)*zz31)*zz32
     3     +ri(20)*(xy31*xy32+xz31*xz32)
     4     +ri(22)*yz31*yz32
c      (pz px/pz pz)
               w(80) =
     1      (ri(16)*xx31+ri(17)*zz31)*xx33
     2     +(ri(18)*xx31+ri(19)*zz31)*zz33
     3     +ri(20)*xz31*xz33
c     (pz py/s s)
               w(81)=ri(3)*xx32+ri(4)*zz32
c     (pz py/px s)
               w(82)=x(1)*(ri(8)*xx32+ri(9)*zz32)
     1           +ri(10)*(y(1)*xy32+z(1)*xz32)
c      (pz py/px px)
               w(83) =
     1     (ri(16)*xx32+ri(17)*zz32)*xx11+ri(18)*xx32*yyzz11
     2     +ri(19)*zz32*zz11
     3     +ri(20)*(xy32*xy11+xz32*xz11)
     4     +ri(21)*zz32*yy11
     5     +ri(22)*yz32*yz11
c     (pz py/py s)
               w(84)=x(2)*(ri(8)*xx32+ri(9)*zz32)
     1           +ri(10)*(y(2)*xy32+z(2)*xz32)
c      (pz py/py px)
               w(85) =
     1     (ri(16)*xx32+ri(17)*zz32)*xx21+ri(18)*xx32*yyzz21
     2     +ri(19)*zz32*zz21
     3     +ri(20)*(xy32*xy21+xz32*xz21)
     4     +ri(21)*zz32*yy21
     5     +ri(22)*yz32*yz21
c      (pz py/py py)
               w(86) =
     1     (ri(16)*xx32+ri(17)*zz32)*xx22+ri(18)*xx32*yyzz22
     2     +ri(19)*zz32*zz22
     3     +ri(20)*(xy32*xy22+xz32*xz22)
     4     +ri(21)*zz32*yy22
     5     +ri(22)*yz32*yz22
c     (pz py/pz s)
               w(87)=x(3)*(ri(8)*xx32+ri(9)*zz32)
     1           +ri(10)*(         +z(3)*xz32)
c      (pz py/pz px)
               w(88) =
     1      (ri(16)*xx32+ri(17)*zz32)*xx31
     2     +(ri(18)*xx32+ri(19)*zz32)*zz31
     3     +ri(20)*(xy32*xy31+xz32*xz31)
     4     +ri(22)*yz32*yz31
c      (pz py/pz py)
               w(89) =
     1      (ri(16)*xx32+ri(17)*zz32)*xx32
     2     +(ri(18)*xx32+ri(19)*zz32)*zz32
     3     +ri(20)*(xy32*xy32+xz32*xz32)
     4     +ri(22)*yz32*yz32
c       (pz py/pz pz)
               w(90) =
     1      (ri(16)*xx32+ri(17)*zz32)*xx33
     2     +(ri(18)*xx32+ri(19)*zz32)*zz33
     3     +ri(20)*xz32*xz33
c     (pz pz/s s)
               w(91)=ri(3)*xx33+ri(4)*zz33
c     (pz pz/px s)
               w(92)=x(1)*(ri(8)*xx33+ri(9)*zz33)
     1           +ri(10)*(          z(1)*xz33)
c       (pz pz/px px)
               w(93) =
     1     (ri(16)*xx33+ri(17)*zz33)*xx11+ri(18)*xx33*yyzz11
     2     +ri(19)*zz33*zz11
     3     +ri(20)*xz33*xz11
     4     +ri(21)*zz33*yy11
c     (pz pz/py s)
               w(94)=x(2)*(ri(8)*xx33+ri(9)*zz33)
     1           +ri(10)*(         +z(2)*xz33)
c       (pz pz/py px)
               w(95) =
     1     (ri(16)*xx33+ri(17)*zz33)*xx21+ri(18)*xx33*yyzz21
     2     +ri(19)*zz33*zz21
     3     +ri(20)*xz33*xz21
     4     +ri(21)*zz33*yy21
c       (pz pz/py py)
               w(96) =
     1     (ri(16)*xx33+ri(17)*zz33)*xx22+ri(18)*xx33*yyzz22
     2     +ri(19)*zz33*zz22
     3     +ri(20)*xz33*xz22
     4     +ri(21)*zz33*yy22
c     (pz pz/pz s)
               w(97)=x(3)*(ri(8)*xx33+ri(9)*zz33)
     1           +ri(10)*(         +z(3)*xz33)
c       (pz pz/pz px)
               w(98) =
     1      (ri(16)*xx33+ri(17)*zz33)*xx31
     2     +(ri(18)*xx33+ri(19)*zz33)*zz31
     3     +ri(20)*xz33*xz31
c       (pz pz/pz py)
               w(99) =
     1      (ri(16)*xx33+ri(17)*zz33)*xx32
     2     +(ri(18)*xx33+ri(19)*zz33)*zz32
     3     +ri(20)*xz33*xz32
c       (pz pz/pz pz)
               w(100) =
     1      (ri(16)*xx33+ri(17)*zz33)*xx33
     2     +(ri(18)*xx33+ri(19)*zz33)*zz33
     3     +ri(20)*xz33*xz33
               ki = 100
            else
c     (px s/s s)
               w(2)=ri(2)*x(1)
c     (px px/s s)
               w(3)=ri(3)*xx11+ri(4)*yyzz11
c     (py s/s s)
               w(4)=ri(2)*x(2)
c     (py px/s s)
               w(5)=ri(3)*xx21+ri(4)*yyzz21
c     (py py/s s)
               w(6)=ri(3)*xx22+ri(4)*yyzz22
c     (pz s/ss)
               w(7)=ri(2)*x(3)
c     (pz px/s s)
               w(8)=ri(3)*xx31+ri(4)*zz31
c     (pz py/s s)
               w(9)=ri(3)*xx32+ri(4)*zz32
c     (pz pz/s s)
               w(10)=ri(3)*xx33+ri(4)*zz33
               ki = 10
            end if
         end if
c
c *** now rotate the nuclear attraction integrals.
c *** the storage of the nuclear attraction integrals  core(kl/ij) is
c     (ss/)=1,   (so/)=2,   (oo/)=3,   (pp/)=4
c
         e1b(1)=-css1
         if(natorb(ni).eq.4) then
            e1b(2) = -csp1 *x(1)
            e1b(3) = -cpps1*xx11-cppp1*yyzz11
            e1b(4) = -csp1 *x(2)
            e1b(5) = -cpps1*xx21-cppp1*yyzz21
            e1b(6) = -cpps1*xx22-cppp1*yyzz22
            e1b(7) = -csp1 *x(3)
            e1b(8) = -cpps1*xx31-cppp1*zz31
            e1b(9) = -cpps1*xx32-cppp1*zz32
            e1b(10)= -cpps1*xx33-cppp1*zz33
         end if
         e2a(1)=-css2
         if(natorb(nj).eq.4) then
            e2a(2) = -csp2 *x(1)
            e2a(3) = -cpps2*xx11-cppp2*yyzz11
            e2a(4) = -csp2 *x(2)
            e2a(5) = -cpps2*xx21-cppp2*yyzz21
            e2a(6) = -cpps2*xx22-cppp2*yyzz22
            e2a(7) = -csp2 *x(3)
            e2a(8) = -cpps2*xx31-cppp2*zz31
            e2a(9) = -cpps2*xx32-cppp2*zz32
            e2a(10)= -cpps2*xx33-cppp2*zz33
         end if
         if(dabs(tore(ni)).gt.20.d0.and.dabs(tore(nj)).gt.20.d0) then
c sparkle-sparkle interaction
            enuc=0.d0
            return
         elseif (rij.lt.1.d0.and.natorb(ni)*natorb(nj).eq.0) then
            enuc=0.d0
            return
         endif
         scale = dexp(-alp(ni)*rij)+dexp(-alp(nj)*rij)
c
         if (ni.eq.24.and.nj.eq.24) then
            scale = dexp(-alptm(ni)*rij)+dexp(-alptm(nj)*rij)
         endif
c
         nt=ni+nj
         if(nt.eq.8.or.nt.eq.9) then
            if(ni.eq.7.or.ni.eq.8) scale=scale+(rij-1.d0)*
     +          dexp(-alp(ni)*rij)
            if(nj.eq.7.or.nj.eq.8) scale=scale+(rij-1.d0)*
     +          dexp(-alp(nj)*rij)
         endif
         enuc = tore(ni)*tore(nj)*gam
         scale=dabs(scale*enuc)
         if(itype.eq.2.and.(ni.eq.5.or.nj.eq.5))then
c
c   load in am1 boron gaussians
c
            nk=ni+nj-5
c   nk is the atomic number of the non-boron atom
            nl=1
            if(nk.eq.1)nl=2
            if(nk.eq.6)nl=3
            if(nk.eq.9.or.nk.eq.17.or.nk.eq.35.or.nk.eq.53)nl=4
            do 30 i=1,3
               fn1(5,i)=boron1(i,nl)
               fn2(5,i)=boron2(i,nl)
   30       fn3(5,i)=boron3(i,nl)
         endif
         if(itype.eq.2.or.itype.eq.3) then
            do 40 ig=1,10
               if(dabs(fn1(ni,ig)).gt.0.d0) then
                  ax = fn2(ni,ig)*(rij-fn3(ni,ig))**2
                  if(ax .le. 25.d0) then
                     scale=scale +tore(ni)*tore(nj)/rij*
     +               fn1(ni,ig)*dexp(-ax)
                  endif
               endif
               if(dabs(fn1(nj,ig)).gt.0.d0) then
                  ax = fn2(nj,ig)*(rij-fn3(nj,ig))**2
                  if(ax .le. 25.d0) then
                     scale=scale +tore(ni)*tore(nj)/rij*
     +               fn1(nj,ig)*dexp(-ax)
                  endif
               endif
   40       continue
         endif
         enuc=enuc+scale
c
         if(natorb(ni)*natorb(nj).eq.0)ki=0
         kr=kr+ki
c
c
      endif
      return
      end
      subroutine moprdm(ostop)
      implicit REAL (a-h, o-z)
_IF(ipsc,tools)
      logical ostop,oroot
_ELSE
      logical ostop
_ENDIF
INCLUDE(common/sizes)
c
c module to read in geometry file, output it to the user,
c and check the data to see if it is reasonable.
c exit if necessary.
c
c
c
c  on exit natoms    = number of atoms plus dummy atoms (if any).
c          keywrd    = keywords to control calculation
c          koment    = comment card
c          title     = title card
c          labels    = array of atomic labels including dummy atoms.
c          geo       = array of internal coordinates.
c          lopt      = flags for optimization of molecule
c          na        = array of labels of atoms, bond lengths.
c          nb        = array of labels of atoms, bond angles.
c          nc        = array of labels of atoms, dihedral angles.
c          latom     = label of atom of reaction coordinate.
c          lparam    = rc: 1 for length, 2 for angle, and 3 for dihedral
c          react(200)= reaction coordinate parameters
c          loc(1,i)  = label of atom to be optimized.
c          loc(2,i)  = 1 for length, 2 for angle, and 3 for dihedral.
c          nvar      = number of parameters to be optimized.
c          xparam    = starting value of parameters to be optimized.
c
************************************************************************
c *** input the trial geometry  \ie.  kgeom=0\
c   label(i) = the atomic number of atom\i\.
c            = 99, then the i-th atom is a dummy atom used only to
c              simplify the definition of the molecular geometry.
c   geo(1,i) = the internuclear separation \in angstroms\ between atoms
c              na(i) and (i).
c   geo(2,i) = the angle nb(i):na(i):(i) input in degrees; stored in
c              radians.
c   geo(3,i) = the angle between the vectors nc(i):nb(i) and na(i):(i)
c              input in degrees - stored in radians.
c  lopt(j,i) = -1 if geo(j,i) is the reaction coordinate.
c            = +1 if geo(j,i) is a parameter to be optimized
c            =  0 otherwise.
c *** note:    much of this data is not included for the first 3 atoms.
c     atom1  input labels(1) only.
c     atom2  input labels(2) and geo(1,2) separation between atoms 1+2
c     atom3  input labels(3), geo(1,3)    separation between atoms 2+3
c              and geo(2,3)              angle atom1 : atom2 : atom3
c
************************************************************************
c
      dimension lopt(3,numatm)
      character keywrd*241, koment*81, title*81, line*80, banner*80
      character keys(80)*1, space*1, space2*2, ch*1, ch2*2
      character elemnt*2, idate*24, getmop*80
      common / readme / ird
      common /keywrd/ keywrd
      common /titles/ koment,title
      common /geovar/ nvar, loc(2,maxpar), idumy, xparam(maxpar)
      common /path/ latom,lparam,react(200)
      common /mesh/ latom1, lpara1, latom2, lpara2
      common /elemts/ elemnt(107)
      common /okmany/ isok
      common /istope/ ams(107)
      common /cmpg/ geo(3,numatm)
      common /numcal/ numcal
      common/iofile/mfgr,mfgw
      common /geokst/ natoms,labels(numatm),
     1na(numatm),nb(numatm),nc(numatm)
      common /geosym/ ndep, locpar(maxpar), idepfn(maxpar),
     1                      locdep(maxpar)
      logical int, aigeo, isok
      save space, space2, ireact, int
      dimension coord(3,numatm),value(40)
      equivalence (keys(1),keywrd)
      data space, space2/' ','  '/
      convtr=2.d0*dasin(1.d0)/180.d0
      aigeo=.false.
   10 continue
c
      call gettxt
      if(index(keywrd,'echo').ne.0)then
_IF(ipsc,tools)
        if(oroot()) then
_ENDIF
         rewind ird
         isok=.false.
         do 50 i=1,1000
            read(ird,'(a)',end=60)keywrd
            do 20 j=80,2,-1
   20       if(keywrd(j:j).ne.' ')goto 30
            j=1
   30       do 40 k=1,j
   40       if(ichar(keywrd(k:k)).lt.32)keywrd(k:k)='*'
            write(mfgw,'(1x,a)')keywrd(1:j)
   50    continue
   60    continue
         rewind ird
         call gettxt
_IF(ipsc,tools)
        endif
_ENDIF
      endif
      if(index(keywrd,'echo').ne.0)write(mfgw,'(''1'')')
      if(keywrd(1:1) .ne. space) then
         ch=keywrd(1:1)
         keywrd(1:1)=space
         do 70 i=2,239
            ch2=keywrd(i:i)
            keywrd(i:i)=ch
            ch=ch2
            if(keywrd(i+1:i+2) .eq. space2) then
               keywrd(i+1:i+1)=ch
               goto 80
            endif
   70    continue
         ch2=keywrd(240:240)
         keywrd(240:240)=ch
         keywrd(241:241)=ch2
   80    continue
      endif
      if(koment(1:1) .ne. space) then
         ch=koment(1:1)
         koment(1:1)=space
         do 90 i=2,79
            ch2=koment(i:i)
            koment(i:i)=ch
            ch=ch2
            if(koment(i+1:i+2) .eq. space2) then
               koment(i+1:i+1)=ch
               goto 100
            endif
   90    continue
         ch2=koment(80:80)
         koment(80:80)=ch
         koment(81:81)=ch2
  100    continue
      endif
      if(title(1:1) .ne. space) then
         ch=title(1:1)
         title(1:1)=space
         do 110 i=2,79
            ch2=title(i:i)
            title(i:i)=ch
            ch=ch2
            if(title(i+1:i+2) .eq. space2) then
               title(i+1:i+1)=ch
               goto 120
            endif
  110    continue
         ch2=title(80:80)
         title(80:80)=ch
         title(81:81)=ch2
  120    continue
      endif
      do 121 i=1,200
  121 react(i)=0.d0
      latom=0
      lparam=0
      if(index(keywrd,'oldgeo').eq.0) then
         nvar=0
         ndep=0
         if(aigeo.or.index(keywrd,'aigin').ne.0)then
            call getgeg(ird,labels,geo,lopt,na,nb,nc,ams,natoms,int)
         else
            call getgeo(ird,labels,geo,lopt,na,nb,nc,ams,natoms,int)
            if(natoms.lt.0)then
               rewind ird
               if(numcal.ne.1)then
                  write(mfgw,'(//,a)')
     + '   gaussian input requires stand-alone job'
                  write(mfgw,'(/,a)')'   or keyword "aigin"'
                  go to 1000
               endif
               aigeo=.true.
               goto 10
            endif
         endif
         if(natoms.eq.0)go to 1000
      else
         degree=90.d0/dasin(1.d0)
         do 130 i=1,natoms
            do 130 j=2,3
  130    geo(j,i)=geo(j,i)*degree
      endif
      if(index(keywrd,'force').ne.0 .and. labels(natoms).eq.107) then
      do 131 i=1,na(natoms)
      if(labels(i).eq.99)then
      write(mfgw,'(a)')' no dummy atoms allowed before translation'
      write(mfgw,'(a)')' atom in a force calculation'
      go to 1000
      endif
  131 continue
      endif
c
c
c output file to unit 6
c
c    write header
      idate=' '
      call gtnv('mopacdate',idate)
      write(mfgw,'(1x,15(''*****''),''****'')')
c
c     change the following line to suit local environment, if desired
c
      banner=' '
      write(mfgw,'(a)')banner
c
c    the banner does not appear anywhere else.
c
      write(mfgw,'(1x,79(''*''))')
      line='   mndo'
      if(index(keywrd,'mindo') .ne. 0) line='mindo/3'
      if(index(keywrd,'am1')   .ne. 0) line='    am1'
      if(index(keywrd,'pm3')   .ne. 0) line='    pm3'
      write(mfgw,
     +   '(/29x,a,'' calculation results'',28x,///1x,15(''*****'')
     1,''****'' )')line(:7)
      write(mfgw,'('' *'',10x,''mopac:  version '',f5.2,
     115x,''calc''''d. '',a)') verson, idate
c
c convert angles to radians
      do 140 j=2,3
c$doit vbest
         do 140 i=1,natoms
            geo(j,i) = geo(j,i) * convtr
  140 continue
c
c check data
c
      do 150 i=1,natoms
         if (labels(i) .le. 0 ) then
            write(mfgw,
     +    '('' atomic number of '',i3,'' ?'')') labels(i)
            if(i.eq.1) then
               write(mfgw,'(a)')' this was the first atom'
            else
               write(mfgw,'(a)')
     + '    geometry up to, but not including, the'//' faulty atom'
               natoms=i-1
               call geout(6)
            endif
            go to 1000
         endif
         if (  na(i).ge.i.or. nb(i).ge.i.or. nc(i).ge.i
     1  .or. (na(i).eq.nb(i))   .and. i.gt.1
     2  .or. (na(i).eq.nc(i).or.nb(i).eq.nc(i))  .and. i.gt.2
     3  .or.  na(i)*nb(i)*nc(i).eq.0  .and. i.gt.3) then
            write(mfgw,
     +  '('' atom number '',i3,'' is ill-defined'')') i
            if(i.eq.1)go to 1000
            write(mfgw,'(/,''  geometry read in'',/)')
            call geout(6)
            go to 1000
         endif
  150 continue
c
c write keywords back to user as feedback
      call wrtkey(keywrd)
      write(mfgw,
     +    '(1x,14(''*****''),''*'',i3.3,''by'',i3.3)')maxhev,maxlit
c
c fill in geo matrix if needed
      if(index(keywrd,'oldgeo').eq.0.and.index(keywrd,'sym') .ne. 0
     1.and. ndep.eq.0) call gtsymm
      if(ndep.ne.0) call mopsym()
c
c initialize flags for optimize and path
      iflag = 0
      latom = 0
      numat=0
      if(nvar.ne.0)then
         numat=natoms
      else
         do 180 i=1,natoms
            if(labels(i).ne.99.and.labels(i).ne.107)numat=numat+1
            do 180 j=1,3
               if (lopt(j,i) ) 160, 180, 170
c    flag for path
  160          convrt=1.d0
               if ( iflag .ne. 0 ) then
                  if(index(keywrd,'step1').ne.0)then
                     lpara1=lparam
                     latom1=latom
                     lpara2=j
                     latom2=i
                     latom=0
                     iflag=0
                     goto 180
                  else
                     write(mfgw,
     + '('' only one reaction coordinate permitted'')')
                     go to 1000
                  endif
               endif
               latom  = i
               lparam = j
               if(j.gt.1) convrt=0.01745329252d00
               react(1)  = geo(j,i)
               ireact=1
               iflag = 1
               go to 180
c    flag for optimize
  170          nvar = nvar + 1
               loc(1,nvar) = i
               loc(2,nvar) = j
               xparam(nvar)   = geo(j,i)
  180    continue
      endif
c read in path values
      if(iflag.eq.0) go to 220
      if(index(keywrd,'nllsq').ne.0)then
         write(mfgw,'(a)')' nllsq used with reaction path; '//
     1'this option is not allowed'
         go to 1000
      endif
      if(index(keywrd,'sigma').ne.0)then
         write(mfgw,'(a)')' sigma used with reaction path; '//
     1'this option is not allowed'
         go to 1000
      endif
      if(index(keywrd,'step')+index(keywrd,'points').ne.0)then
         step=reada(keywrd,index(keywrd,'step=')+5)
         npts=reada(keywrd,index(keywrd,'point=')+6)
         if(npts.gt.200)then
            write(mfgw,
     +  '(///,''    only two hundred points allowed in react'',
     +  ''ion coordinate'')')
            go to 1000
         endif
         if(lparam.eq.1.and.step.le.0)then
            write(mfgw,'(///,
     + ''    step for bond length should be set positive '',
     + ''to prevent two atoms collapse'')')
            go to 1000
         endif
         go to 220
      endif
  190 read(ird,'(a)',end=210) line
      call nuchar(line,value,nreact)
      if(nreact.eq.0)goto 210
      do 200 i=1,nreact
         ij=ireact+i
         if(ij.gt.200)then
         write(mfgw,'(///,''    only two hundred points allowed in react
     1ion'','' coordinate'')')
            go to 1000
         endif
         react(ij)=value(i)*convrt
         if(dabs(react(ij)-react(ij-1)).lt.1.d-5)then
            dum1 = react(ij)/convrt
            dum2 = react(ij-1)/convrt
            write(mfgw,'(///,'' two adjacent points are identical:  '',
     1 f7.3,2x,f7.3,/,'' this is not allowed in a path calculation'')')
     2 dum1,dum2
            go to 1000
         endif
  200 continue
      ireact=ireact+nreact
      go to 190
  210 continue
      degree=1.d0
      if(lparam.gt.1)degree=90.d0/dasin(1.d0)
      if(ireact.le.1) then
      write(mfgw,'(//10x,'' no points supplied for reaction path'')')
      write(mfgw,'(//10x,'' geometry as read in is as follows'')')
         call geout(1)
         go to 1000
      else
         write(mfgw,'(//10x,'' points on reaction coordinate'')')
         write(mfgw,'(10x,8f8.2)')(react(i)*degree,i=1,ireact)
      endif
      iend=ireact+1
      react(iend)=-1.d12
c
c output geometry as feedback
c
  220 call wrttxt(mfgw)
      if(index(keywrd,'nolog').eq.0)then
_IF(ipsc,tools)
       if(oroot()) then
_ENDIF
         open(unit=11, form='formatted', status='unknown',
     +file=getmop(5))
         call wrttxt(11)
_IF(ipsc,tools)
       endif
_ENDIF
      endif
      call geout(1)
      call gmetry(geo,coord)
      if (index(keywrd,'noxyz') .eq. 0) then
         if(index(keywrd,'0scf').ne.0)then
c
c  write out cartesian coordinates for use as a data-set
c
         write(mfgw,'(a)')'   geometry in cartesian coordinate format'
            call wrttxt(mfgw)
            j=0
            do 230 i=1,natoms
               if(labels(i).ne.99)then
                  j=j+1
                  write(mfgw,'(2x,a,3(f19.13,i3))')
     1    elemnt(labels(i)),(coord(k,j),1,k=1,3)
               endif



  230       continue
         else


            write(mfgw,'(//10x,''cartesian coordinates '',/)')
            write(mfgw,'(4x,''no.'',7x,''atom'',9x,''x'',
     1  9x,''y'',9x,''z'',/)')
            l=0
            do 240 i=1,natoms
               if(labels(i) .eq. 99.or.labels(i).eq.107) goto 240
               l=l+1
               write(mfgw,'(i6,8x,a2,4x,3f10.4)')
     1  l,elemnt(labels(i)),(coord(j,l),j=1,3)
  240       continue
         endif
      endif
      if(   index(keywrd,' xyz') .ne. 0 )then
         if( nvar .ne. 0 .and.
     1 int.and.(ndep .ne. 0 .or.  nvar.lt.3*numat-6)) then
            if(ndep.ne.0)
     1write(mfgw,
     + '(//10x,'' internal coordinates read in, and symmetry''
     2,/10x,'' specified, but calculation to be run in cartesian ''
     3,''coordinates'')')
            if(nvar.lt.3*numat-6)
     1write(mfgw,
     +  '(//10x,'' internal coordinates read in, and'',
     2'' calculation '',/10x,''to be run in cartesian coordinates, '',
     3/10x,''but not all coordinates marked for optimisation'')')
         write(mfgw,'(//10x,'' this involves a logicallly absurd choice'
     1',/10x,'' so the calculation is terminated at this point'')')
            go to 1000
         endif
         sumx=0.d0
         sumy=0.d0
         sumz=0.d0
         do 250 j=1,numat
            sumx=sumx+coord(1,j)
            sumy=sumy+coord(2,j)
  250    sumz=sumz+coord(3,j)
         sumx=sumx/numat
         sumy=sumy/numat
         sumz=sumz/numat
c geometry fix added by stuart green 10.4.91
         if(index(keywrd,'fix') .ne. 0) then
            write(mfgw,'(//10x,''geometry fix.'',/)')
            do 255 j=1,numat
               geo(1,j)=coord(1,j)
               geo(2,j)=coord(2,j)
  255       geo(3,j)=coord(3,j)
         else
            do 260 j=1,numat
               geo(1,j)=coord(1,j)-sumx
               geo(2,j)=coord(2,j)-sumy
  260       geo(3,j)=coord(3,j)-sumz
         endif
c ----
         na(1)=99
         j=0
         nvar=0
         do 280 i=1,natoms
            if(labels(i).ne.99)then
               j=j+1
               if(j.eq.1)then
                  k=0
               elseif(j.lt.4)then
                  k=min0(3,i-1)
               else
                  k=3
               endif
               do 270 l=1,k
                  nvar=nvar+1
                  loc(1,nvar)=j
                  loc(2,nvar)=l
  270          xparam(nvar)=geo(l,j)
               labels(j)=labels(i)
            endif
  280    continue
         natoms=numat
      else
         if(nvar.eq.0) return
         if( .not. int.and.(ndep .ne. 0 .or.  nvar.lt.3*numat-6)) then
            if(ndep.ne.0)
     1write(mfgw,'(//10x,
     +  '' cartesian coordinates read in, and symmetry''
     2,/10x,'' specified, but calculation to be run in internal ''
     3,''coordinates'')')
            if(nvar.lt.3*numat-6)
     1write(mfgw,'(//10x,'' cartesian coordinates read in, and'',
     2'' calculation '',/10x,''to be run in internal coordinates, '',
     3/10x,''but not all coordinates marked for optimisation'')')
         write(mfgw,'(//10x,''mopac, by default, uses internal coordinat
     1es'',/10x,''to specify cartesian coordinates use key-word :xyz:'')
     2')
         write(mfgw,'(10x,''your current choice of key-words involves''
     1,'' a logicallly'',/10x,''absurd choice so the calculation is'',
     2'' terminated at this point'')')
            go to 1000
         endif
      endif
      return
1000  ostop = .true.
      return
      end
      subroutine mopro(coord,i,j,ix,rij,del1,idx)
      implicit REAL (a-h,o-z)
      common /derivs/ ds(16),dg(22),dr(100),tdx(3),tdy(3),tdz(3)
      common /cmpex/  g(22),tx(3),ty(3),tz(3)
      dimension coord(3,25)
      xd=coord(1,i)-coord(1,j)
      yd=coord(2,i)-coord(2,j)
      zd=coord(3,i)-coord(3,j)
      rxy=dsqrt(xd*xd+yd*yd)
      ryz=dsqrt(yd*yd+zd*zd)
      rzx=dsqrt(zd*zd+xd*xd)
      do 10 ijk=1,3
         tx(ijk)=0.0d0
         ty(ijk)=0.0d0
         tz(ijk)=0.0d0
         tdx(ijk)=0.0d0
         tdy(ijk)=0.0d0
         tdz(ijk)=0.0d0
   10 continue
      if(rxy.lt.1.0d-4) then
c   molecular z axis is parallel to diatomic z axis
         tx(3)=1.0d0
         if(zd.lt.0.0d0) tx(3)=-1.0d0
         ty(2)=1.0d0
         tz(1)=tx(3)
         if(idx.eq.1) return
         if(ix.eq.1) tdx(1)=1.0d0/rij
         if(ix.eq.2) tdx(2)=1.0d0/rij
         if(ix.eq.1) tdz(3)=-1.0d0/rij
         if(ix.eq.2) tdy(3)=-tx(3)/rij
      elseif(ryz.lt.1.0d-4) then
c   molecular x axis is parallel to diatomic z axis
         tx(1)=1.0d0
         if(xd.lt.0.0d0) tx(1)=-1.0d0
         ty(2)=tx(1)
         tz(3)=1.0d0
         if(idx.eq.1) return
         if(ix.eq.2) tdx(2)=1.0d0/rij
         if(ix.eq.3) tdx(3)=1.0d0/rij
         if(ix.eq.2) tdy(1)=-1.0d0/rij
         if(ix.eq.3) tdz(1)=-tx(1)/rij
      elseif(rzx.lt.1.0d-4) then
c   molecular y axis is parallel to diatomic z axis
         tx(2)=1.0d0
         if(yd.lt.0.0d0) tx(2)=-1.0d0
         ty(1)=-tx(2)
         tz(3)=1.0d0
         if(idx.eq.1) return
         if(ix.eq.1) tdx(1)=1.0d0/rij
         if(ix.eq.3) tdx(3)=1.0d0/rij
         if(ix.eq.1) tdy(2)=1.0d0/rij
         if(ix.eq.3) tdz(2)=-tx(2)/rij
      else
         tx(1)=xd/rij
         tx(2)=yd/rij
         tx(3)=zd/rij
         tz(3)=rxy/rij
         ty(1)=-tx(2)*dsign(+1.0d0,tx(1))/tz(3)
         ty(2)=dabs(tx(1)/tz(3))
         ty(3)=0.0d0
         tz(1)=-tx(1)*tx(3)/tz(3)
         tz(2)=-tx(2)*tx(3)/tz(3)
         if(idx.eq.1) return
         term=del1/(rij*rij)
         if(ix.eq.1)then
            tdx(1)=1.0d0/rij-tx(1)*term
            tdx(2)=-tx(2)*term
            tdx(3)=-tx(3)*term
            tdz(3)=tx(1)/rxy-tz(3)*term
         elseif(ix.eq.2) then
            tdx(1)=-tx(1)*term
            tdx(2)=1.0d0/rij-tx(2)*term
            tdx(3)=-tx(3)*term
            tdz(3)=tx(2)/rxy-tz(3)*term
         elseif(ix.eq.3)then
            tdx(1)=-tx(1)*term
            tdx(2)=-tx(2)*term
            tdx(3)=1.0d0/rij-tx(3)*term
            tdz(3)=-tz(3)*term
         endif
         tdy(1)=-tdx(2)/tz(3)+tx(2)*tdz(3)/tz(3)**2
         if(tx(1).lt.0.0d0) tdy(1)=-tdy(1)
         tdy(2)=tdx(1)/tz(3)-tx(1)*tdz(3)/tz(3)**2
         if(tx(1).lt.0.0d0) tdy(2)=-tdy(2)
         tdy(3)=0.0d0
         tdz(1)=-tx(3)*tdx(1)/tz(3)-tx(1)*tdx(3)/tz(3)
     1 +tx(1)*tx(3)*tdz(3)/tz(3)**2
         tdz(2)=-tx(3)*tdx(2)/tz(3)-tx(2)*tdx(3)/tz(3)
     1 +tx(2)*tx(3)*tdz(3)/tz(3)**2
      endif
      return
      end
      subroutine mops(val,vec,n)
      COMPLEX      vec(n,*), sum
      REAL  val(*),x
      do 30 i=1,n
         x=1.d9
         do 10 j=i,n
            if(val(j).lt.x) then
               k=j
               x=val(j)
            endif
   10    continue
         do 20 j=1,n
            sum=vec(j,k)
            vec(j,k)=vec(j,i)
   20    vec(j,i)=sum
         val(k)=val(i)
         val(i)=x
   30 continue
      return
      end
      subroutine mopsrc(xparam,alpha,sig,nvar,gmin,okf, funct)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      dimension xparam(*), sig(*)
************************************************************************
*
* search performs a line search for powsq. it minimizes the norm of
*        the gradient vector in the direction sig.
*
* on input  xparam = current point in nvar dimensional space.
*           alpha  = step size (in fact alpha is calculated in search).
*           sig    = search direction vector.
*           nvar   = number of parameters in sig (& xparam)
*
* on output xparam = parameters of minimum.
*           alpha  = distance to minimum.
*           gmin   = gradient norm at minimum.
*           okf    = function was improved.
************************************************************************
      common /sigma1/ gnext, amin, anext
      common /sigma2/  gnext1(maxpar), gmin1(maxpar)
      common/keywrd/ keywrd
      common /numcal/ numcal
      common/iofile/mfgr,mfgw
      dimension grad(maxpar),xref(maxpar), gref(maxpar), xmin1(maxpar)
      save debug, g, xmaxm, tiny, looks, tolerg
      character*241 keywrd
      logical debug, okf, nopr
      save icalcn
      data icalcn/0/
      if (icalcn.ne.numcal) then
         icalcn=numcal
c
c    tolg   = criterion for exit by relative change in gradient.
c
         debug=(index(keywrd,'linmin') .ne. 0)
         nopr=( .not. debug)
         looks=0
         okf=.true.
         tiny=0.1d0
         tolerg=0.02d0
         if(nvar .eq. 1)timy=0.d0
         g=100.d0
         xmaxm=2.d0
         alpha=0.1d0
      endif
      anext1=0.d0
      do 10 i=1,nvar
         gref(i)  =gmin1(i)
         gnext1(i)=gmin1(i)
         xmin1(i) =xparam(i)
   10 xref(i)  =xparam(i)
      if(dabs(alpha) .gt. 0.2d0)alpha=dsign(0.2d0,alpha)
      if(debug) then
         write(mfgw,'('' search direction vector'')')
         write(mfgw,'(6f12.6)')(sig(i),i=1,nvar)
         write(mfgw,'('' initial gradient vector'')')
         write(mfgw,'(6f12.6)')(gmin1(i),i=1,nvar)
      endif
      gb=ddot(nvar,gmin1,1,gref,1)
      if(debug) write(mfgw,
     + '('' gradient at start of search:'',f16.6)')    dsqrt(gb)
      gstore=gb
      amin=0.d0
      gminn=1.d9
c
c
      ta=0.d0
      ga=gb
      gb=1.d9
      itrys=0
      goto 30
   20 sum=ga/(ga-gb)
      itrys=itrys+1
      if(dabs(sum) .gt. 3.d0) sum=dsign(3.d0,sum)
      alpha=(tb-ta)*sum+ta
c
c         xparam is the geometry of the predicted minimum along the line
c
   30 continue
      do 40 i=1,nvar
   40 xparam(i)=xref(i)+alpha*sig(i)
c
c         calculate gradient norm and gradients at the predicted minimum
c
      if(itrys.eq.1)then
         do 50 i=1,nvar
   50    grad(i)=0.d0
      endif
      call compfg (xparam, .true., funct, .true., grad, .true.)
      looks=looks+1
c
c          g is the projection of the gradient along sig.
c
      g=ddot(nvar,gref,1,grad,1)
      gtot=dsqrt(ddot(nvar,grad,1,grad,1))
      if( .not. nopr)
     1write(mfgw,
     +  '('' looks'',i3,'' alpha ='',f12.6,'' gradient'',f12.3,
     2'' g  ='',f16.6)')
     3looks,alpha,dsqrt(ddot(nvar,grad,1,grad,1)),g
      if(gtot .lt. gminn) then
         gminn=gtot
         if(dabs(amin-alpha) .gt.1.d-2) then
*
* we can move anext to a point near, but not too near, amin, so that the
* second derivativeswillberealistic(d2e/dx2=(gnext1-gmin1)/(anext-amin))
*
            anext=amin
            do 60 i=1,nvar
   60       gnext1(i)=gmin1(i)
         endif
         amin=alpha
         do 70 i=1,nvar
            if(gminn.lt.gmin) xmin1(i)=xparam(i)
   70    gmin1(i)=grad(i)
         if(gmin.gt.gminn)gmin=gminn
      endif
      if(itrys .gt. 8) goto 80
      if (dabs(g/gstore).lt.tiny .or. dabs(g) .lt. tolerg) go to 80
      if(dabs(g) .lt. dmax1(dabs(ga),dabs(gb)) .or.
     1     ga*gb .gt. 0.d0 .and. g*ga .lt. 0.d0) then
c
c   g is an improvement on ga or gb.
c
         if(dabs(gb) .lt. dabs(ga))then
            ta=alpha
            ga=g
            go to 20
         else
            tb=alpha
            gb=g
            go to 20
         endif
      else
c#         write(6,'(//10x,'' failed in search, search continuing'')')
         goto 80
      endif
   80 lnstop=4
      gminn=dsqrt(ddot(nvar,gmin1,1,gmin1,1))
      do 90 i=1,nvar
   90 xparam(i)=xmin1(i)
      if(debug) then
         write(mfgw,'('' at exit from search'')')
         write(mfgw,'('' xparam'',6f12.6)')(xparam(i),i=1,nvar)
         write(mfgw,'('' gnext1'',6f12.6)')(gnext1(i),i=1,nvar)
         write(mfgw,'('' gmin1 '',6f12.6)')(gmin1(i),i=1,nvar)
         write(mfgw,'('' amin, anext,gmin'',4f12.6)')
     1    amin,anext,gmin
      endif
      if(gminn.gt.gmin)then
         do 100 i=1,nvar
  100    xparam(i)=xref(i)
      endif
      return
c
      end
      subroutine mopsym
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      common /cmpg/ geo(3,numatm)
      common /geosym/ ndep, locpar(maxpar), idepfn(maxpar),
     1         locdep(maxpar)
c**********************************************************************
c
c  symtry computes the bond lengths and angles that are functions of
c         other bond lengths and angles.
c
c on input geo     = known internal coordinates
c          ndep    = number of dependency functions.
c          idepfn  = array of dependency functions.
c          locdep  = array of labels of dependent atoms.
c          locpar  = array of labels of reference atoms.
c
c  on output the array "geo" is filled
c***********************************************************************
c
c     now compute the dependent parameters.
c
      do 10 i=1,ndep
         call haddon (value,locn,idepfn(i),locpar(i),geo)
         j=locdep(i)
   10 geo(locn,j)=value
      return
      end
      subroutine mopth
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      common /path/ latom,lparam,react(200)
      common /geovar/ nvar, loc(2,maxpar), idumy, xparam(maxpar)
      common /keywrd/ keywrd
      common /timem/ time0
      common /cmpg/ geo(3,numatm)
      common /alparm/ alparm(3,maxpar),x0, x1, x2, iloop
      common/iofile/mfgr,mfgw
************************************************************************
*
*   path follows a reaction coordinate.   the reaction coordinate is on
*        atom latom, and is a distance if lparam=1,
*                           an angle   if lparam=2,
*                           an dihedralif lparam=3.
*
************************************************************************
      dimension gd(maxpar),xlast(maxpar),mdfp(20),xdfp(20)
      character*241 keywrd
      character*10 type(3)
      save type, gd, xlast, mdfp, xdfp
      data type / 'angstroms ','degrees   ','degrees   '/
      iloop=1
      if(index(keywrd,'restar') .ne. 0) then
         mdfp(9)=0
         call dfpsav(totime,xparam,gd,xlast,funct1,mdfp,xdfp)
         write(mfgw,'(//10x,'' restarting at point'',i3)')iloop
      endif
      if(iloop.gt.1) goto 10
      write(mfgw,'(''  about to enter flepo from path'')')
      time0=secmop()
      call flepo(xparam,nvar,funct)
      write(mfgw,
     +  '(''  optimized values of parameters, initial point'')')
      call writmo(time0,funct)
      time0=secmop()
   10 continue
      if(iloop.gt.2) goto 40
      geo(lparam,latom)=react(2)
      if(iloop.eq.1) then
         x0=react(1)
         x1=x0
         x2=react(2)
_IF(ipsc,tools)
         if(x2.lt. -100.d0) call pend
_ELSE
         if(x2.lt. -100.d0) stop
_ENDIF
         do 20 i=1,nvar
            alparm(2,i)=xparam(i)
   20    alparm(1,i)=xparam(i)
         iloop=2
      endif
      call flepo(xparam,nvar,funct)
      rnord=react(2)
      if(lparam.gt.1) rnord=rnord*57.29577951d0
      write(mfgw,
     +  '(1x,16(''*****'')//17x,''reaction coordinate = ''
     1,f12.4,2x,a10,19x//1x,16(''*****''))')rnord,type(lparam)
      call writmo(time0,funct)
      time0=secmop()
      do 30 i=1,nvar
   30 alparm(3,i)=xparam(i)
c
c   now for the main interpolation route
c
      if(iloop.eq.2)iloop=3
   40 continue
      lpr=iloop
      do 110 iloop = lpr,100
c
         if(react(iloop).lt. -100.d0) return
c
         rnord=react(iloop)
         if(lparam.gt.1) rnord=rnord*57.29577951d0
         write(mfgw,
     + '(1x,16(''*****'')//19x,''reaction coordinate = ''
     1,f12.4,2x,a10,19x//1x,16(''*****''))')rnord,type(lparam)
c
         x3=react(iloop)
         c3=(x0**2-x1**2)*(x1-x2)-(x1**2-x2**2)*(x0-x1)
c      write(mfgw,'(''   c3:'',f13.7)')c3
         if (dabs(c3) .lt. 1.d-8) then
c
c    we use a linear interpolation
c
            cc1=0.d0
            cc2=0.d0
         else
c    we do a quadratic interpolation
c
            cc1=(x1-x2)/c3
            cc2=(x0-x1)/c3
         endif
         cb1=1.d0/(x1-x2)
         cb2=(x1**2-x2**2)*cb1
c
c    now to calculate the interpolated coordinates
c
         do 50 i=1,nvar
            delf0=alparm(1,i)-alparm(2,i)
            delf1=alparm(2,i)-alparm(3,i)
            aconst = cc1*delf0-cc2*delf1
            bconst = cb1*delf1-aconst*cb2
            cconst = alparm(3,i) - bconst*x2 - aconst*x2**2
            xparam(i)=cconst+bconst*x3+aconst*x3**2
            alparm(1,i)=alparm(2,i)
   50    alparm(2,i)=alparm(3,i)
c
c   now to check that the guessed geometry is not too absurd
c
         do 60 i=1,nvar
   60    if(dabs(xparam(i)-alparm(3,i)) .gt. 0.2) goto 70
         goto 90
   70    write(mfgw,
     + '('' geometry too unstable for extrapolation to be used
     1''/ ,'' - the last geometry is being used to start the next''
     2,'' calculation'')')
         do 80 i=1,nvar
   80    xparam(i)=alparm(3,i)
   90    continue
         x0=x1
         x1=x2
         x2=x3
         geo(lparam,latom)=react(iloop)
         call flepo(xparam,nvar,funct)
         call writmo(time0,funct)
         time0=secmop()
         do 100 i=1,nvar
  100    alparm(3,i)=xparam(i)
  110 continue
      end
      subroutine moptho(a,b,c,linear,sym,wt,vibs,nvibs,escf)
      implicit REAL (a-h,o-z)
      dimension vibs(*)
      logical linear
      character keywrd*241, koment*81, title*81, tmpkey*241
      common /keywrd/ keywrd
      common /titles/ koment,title
      common/iofile/mfgr,mfgw
c
c
c   thermo calculates the various thermodynamic quantities for a
c   specified temperature given the vibrational frequencies, moments of
c   inertia, molecular weight and symmetry number.
c
c   reference: g.herzberg molecular spectra and molecular structure
c              vol 2, chap. 5
c
c   ----    table of symmetry numbers    ----
c
c        c1 ci cs     1      d2 d2d d2h  4       c(inf)v   1
c        c2 c2v c2h   2      d3 d3d d3h  6       d(inf)h   2
c        c3 c3v c3h   3      d4 d4d d4h  8       t td     12
c        c4 c4v c4h   4      d6 d6d d6h  12      oh       24
c        c6 c6v c6h   6      s6          3
c
c
c   program limitations:  the equations used are appropriate to the
c   high temperature limit and will begin to be inadequate at tempera-
c   tures below about 100 k.  secondly this program is only appropriate
c   in the case of molecules in which there is no free rotation
c
c
c
c
*******************************************************************
*
*  the following constants are now defined:
*          pi  = circumference to diameter of a circle
*          r   = gas constant in calories/mole
*          h   = planck's constant in erg-seconds
*          ak  = boltzmann constant in erg/degree
*          ac  = speed of light in cm/sec
*******************************************************************
      save pi, r, h, ak, ac
      dimension trange(300)
      data pi /3.14159d0 /
      data r/1.98726d0/
      data h/6.626d-27/
      data ak/1.3807d-16/
      data ac/2.99776d+10/
*******************************************************************
      it1=200
      it2=400
      istep=10
      tmpkey=keywrd
      i=index(tmpkey,'thermo(')
      if(i.ne.0) then
c
c   erase all text from tmpkey except thermo data
c
         tmpkey(:i)=' '
         tmpkey(index(tmpkey,')'):)=' '
         it1=reada(tmpkey,i)
         if(it1.lt.100) then
         write(mfgw,'(//10x,''temperature range starts too low,'',
     1'' lower bound is reset to 30k'')')
            it1=100
         endif
         i=index(tmpkey,',')
         if(i.ne.0) then
            tmpkey(i:i)=' '
            it2=reada(tmpkey,i)
            if(it2.lt.it1) then
               it2=it1+200
               istep=10
               goto 10
            endif
            i=index(tmpkey,',')
            if(i.ne.0) then
               tmpkey(i:i)=' '
               istep=reada(tmpkey,i)
               if(istep.lt.1)istep=1
            else
               istep=(it2-it1)/20
               if(istep.eq.0)istep=1
               if(istep.ge.2.and. istep.lt.5)istep=2
               if(istep.ge.5.and. istep.lt.10)istep=5
               if(istep.ge.10.and. istep.lt.20)istep=10
               if(istep.gt.20.and. istep.lt.50)istep=20
               if(istep.gt.50.and. istep.lt.100)istep=50
               if(istep.gt.100)istep=100
            endif
         else
            it2=it1+200
         endif
      endif
   10 continue
      write(mfgw,'(//,a)')title
      write(mfgw,'(a)')koment
      if(linear) then
         write(mfgw,'(//10x,''molecule is linear'')')
      else
         write(mfgw,'(//10x,''molecule is not linear'')')
      endif
      write(mfgw,
     + '(/10x,''there are'',i3,'' genuine vibrations in this '',
     1''system'')')nvibs
      write(mfgw,20)
   20 format(10x,'this thermodynamics calculation is limited to',/
     110x,'molecules which have no internal rotations'//)
      write(mfgw,'(//20x,''calculated thermodynamic properties'')')
      write(mfgw,'(42x,''*'')')
      write(mfgw,'(''   temp. (k)   partition function   h.o.f.'',
     1''    enthalpy   heat capacity  entropy'')')
      write(mfgw,
     +  '(  ''                                    kcal/mol'',
     1''   cal/mole    cal/k/mol   cal/k/mol'',/)')
      do 30 i=1,nvibs
   30 vibs(i)=dabs(vibs(i))
      ilim=1
      do 40 itemp=it1,it2,istep
         ilim=ilim+1
   40 trange(ilim)=itemp
      trange(1)=298.d0
      do 80 ir=1,ilim
         itemp=trange(ir)
         t=itemp
c   ***   initialise some variables   ***
         c1=h*ac/ak/t
         qv=1.0d0
         hv=0.0d0
         e0=0.0d0
         cpv=0.0d0
         sv1=0.0d0
         sv2=0.0d0
c   ***   construct the frequency dependent parts of partition function
         do 50 i=1,nvibs
            wi=vibs(i)
            ewj=dexp(-wi*c1)
            qv=qv/(1-ewj)
            hv=hv+wi*ewj/(1-ewj)
            e0=e0+wi
            cpv=cpv+wi*wi*ewj/(1-ewj)/(1-ewj)
            sv1=sv1+log(1.0d0-ewj)
   50    sv2=sv2+wi*ewj/(1-ewj)
c   ***   finish calculation of vibrational parts   ***
         hv=hv*r*h*ac/ak
         e0=e0*1.4295d0
         cpv=cpv*r*c1*c1
         sv=sv2*r*c1-r*sv1
c   ***   now calculate the rotational parts  (first linear molecules
         if(.not.linear) goto 60
         qr=1/(c1*a*sym)
         hr=r*t
         cpr=r
         sr=r*(log(t*ak/(h*ac*a*sym)))+r
         goto 70
   60    qr=dsqrt(pi/(a*b*c*c1*c1*c1))/sym
         hr=3.0d0*r*t/2.0d0
         cpr=3.0d0*r/2.0d0
         sr=0.5d0*r*(3.d0*log(t*ak/(h*ac))
     1-2.d0*log(sym)+log(pi/(a*b*c))+3.d0)
   70    continue
c   ***   calculate internal contributions   ***
         qint=qv*qr
         hint=hv+hr
         cpint=cpv+cpr
         sint=sv+sr
c   ***   construct translation contributions   ***
         qtr=(dsqrt(2.d0*pi*wt*t*ak*1.6606d-24)/h)**3
         htr=5.0d0*r*t/2.0d0
         cptr=5.0d0*r/2.0d0
         str=2.2868d0*(5.0d0*log10(t)+3.0d0*log10(wt))-2.3135d0
c   ***   construct totals   ***
         cptot=cptr+cpint
         stot=str+sint
         htot=htr+hint
c   ***   output section   ***
         if(ir.eq.1)then
            h298=htot
         else
            write(mfgw,'(/,i7,''  vib.'',g18.4
     1           ,13x,3f11.5        )')itemp,qv,  hv,  cpv,  sv
            write(mfgw,'(7x,''  rot.'',g13.3
     1           ,16x,3f11.3        )')      qr,  hr,  cpr,  sr
            write(mfgw,'(7x,''  int.'',g13.3
     1           ,16x,3f11.3        )')      qint,hint,cpint,sint
            write(mfgw,'(7x,''  tra.'',g13.3
     1           ,16x,3f11.3)')
     2                                      qtr, htr, cptr, str
            write(mfgw,'(7x,''  tot.'',13x,f17.3,f11.4,2f11.4)')
     1                     escf+(htot-h298)/1000.d0,htot,cptot,stot
         endif
   80 continue
      write(mfgw,
     + '(/3x,'' * note: heats of formation are relative to the'',
     1/12x,'' elements in their standard state at 298k'')')
      end
      subroutine moptim(nout,tim)
c
c     convert the time from seconds to days, hours, minutes, and seconds
c
      implicit REAL (a-h,o-z)
c
      REAL  mins, minphr
c
c
      data hrspd /24.0d0/, minphr /60.0d0/
      data secpd /86400.0d0/, secphr /3600.0d0/, secpmi /60.0d0/
c
      days = tim / secpd
      idays = idint(days)
      hours = (days - dfloat(idays)) * hrspd
      ihours = idint(hours)
      mins = (hours - dfloat(ihours)) * minphr
      imins = idint(mins)
      secs = (mins - dfloat(imins)) * secpmi
c
      if (idays .gt. 1) then
         write (nout,10) idays,ihours,imins,secs
      else if (idays .eq. 1) then
         write (nout,20) idays,ihours,imins,secs
      else if (ihours .gt. 0) then
         write (nout,30) ihours,imins,secs
      else if (imins .gt. 0) then
         write (nout,40) imins,secs
      else
         write (nout,50) secs
      end if
c
   10 format (10x,'computation time = ',i2,1x,'days',2x,i2,1x,'hours',
     1        1x,i2,1x,'minutes and',1x,f7.3,1x,'seconds')
   20 format (10x,'computation time = ',i2,1x,'day',2x,i2,1x,'hours',
     1        1x,i2,1x,'minutes and',1x,f7.3,1x,'seconds')
   30 format (10x,'computation time = 'i2,1x,'hours',
     1        1x,i2,1x,'minutes and',1x,f7.3,1x,'seconds')
   40 format (10x,'computation time = ',i2,1x,'minutes and',
     1        1x,f7.3,1x,'seconds')
   50 format (10x,'computation time = ',f7.3,1x,'seconds')
      end
      subroutine mopmat (a,b,nc,nr,ndim)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      dimension a(ndim,ndim), b(ndim)
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),
     1                nlast(numatm), norbs, nelecs,nalpha,nbeta,
     2                nclose,nopen,ndumy,fract
      common /elemts/ elemnt(107)
      common/iofile/mfgr,mfgw
c**********************************************************************
c
c      matout prints a square matrix of eigenvectors and eigenvalues
c
c    on input a contains the matrix to be printed.
c             b contains the eigenvalues.
c             nc number of molecular orbitals to be printed.
c             nr is the size of the square array to be printed.
c             ndim is the actual size of the square array "a".
c             nfirst and nlast contain atom orbital counters.
c             nat = array of atomic numbers of atoms.
c
c
c***********************************************************************
      character*2 elemnt, atorbs(9), itext(maxorb), jtext(maxorb)
      dimension natom(maxorb)
      save atorbs
      data atorbs/' s','px','py','pz','x2','xz','z2','yz','xy'/
      if(numat.eq.0)goto 30
      if(nlast(numat).ne.nr) goto 30
      do 20 i=1,numat
         jlo=nfirst(i)
         jhi=nlast(i)
         l=nat(i)
         k=0
         do 10 j=jlo,jhi
            k=k+1
            itext(j)=atorbs(k)
            jtext(j)=elemnt(l)
            natom(j)=i
   10    continue
   20 continue
      goto 50
   30 continue
      nr=iabs(nr)
      do 40 i=1,nr
         itext(i)='  '
         jtext(i)='  '
   40 natom(i)=i
   50 continue
      ka=1
      kc=6
   60 kb=min0(kc,nc)
      write (mfgw,100) (i,i=ka,kb)
      if(b(1).ne.0.d0)write (mfgw,110) (b(i),i=ka,kb)
      write (mfgw,120)
      la=1
      lc=40
   70 lb=min0(lc,nr)
      do 80 i=la,lb
         if(itext(i).eq.' s')write(mfgw,120)
         write (mfgw,130) itext(i),jtext(i),natom(i),(a(i,j),j=ka,kb)
   80 continue
      if (lb.eq.nr) go to 90
      la=lc+1
      lc=lc+40
      write (mfgw,140)
      go to 70
   90 if (kb.eq.nc) return
      ka=kc+1
      kc=kc+6
      if (nr.gt.25) write (mfgw,140)
      go to 60
c
  100 format (////,3x,9h root no.,i5,9i12)
  110 format (/8x,10f12.5)
  120 format (2h  )
  130 format (2(1x,a2),i4,f10.5,10f12.5)
  140 format (1h1)
c
      end
      subroutine mopupd(iparam, ielmnt, param, mode,kfn)
      implicit REAL (a-h,o-z)
************************************************************************
*
*  update mopupd the common blocks which hold all the parameters for
*         running mndo.
*         iparam refers to the type of parameter,
*         ielmnt refers to the element,
*         param is the value of the parameter, and
*         if mode = 1 then a common block is updated,
*         if mode = 2 then a datum is extracted from the common block.
*
************************************************************************
      common /mndo/
     +    ussm(107), uppm(107), uddm(107), zsm(107),zpm(107),
     1zdm(107), betasm(107), betapm(107), betadm(107), alpm(107),
     2eisolm(107), ddm(107), qqm(107), amm(107), adm(107), aqm(107)
     3,gssm(107),gspm(107),gppm(107),gp2m(107),hspm(107), polvom(107)
      common /expont/ zs(107),zp(107),zd(107)
      common /cmporb/ natorb(107)
      common /betas/ betas(107),betap(107),betad(107)
      common /vsips/ vs(107),vp(107),vd(107)
      common/iofile/mfgr,mfgw
      common /cmpone/ uss(107),upp(107),udd(107)
      common /multip/ dd(107),qq(107),am(107),ad(107),aq(107)
      common /twoele/ gss(107),gsp(107),gpp(107),gp2(107),hsp(107)
     7                ,gsd(107),gpd(107),gdd(107)
      common /alpha/ alp(107)
      common /ideas/ guess1(107,10), guess2(107,10), guess3(107,10)
      common /cmpga/ fn1(107),fn2(107)
      goto
     1(10,20,30,40,50,60,70,80,90,100,110,120,130,140,150,160,170,180,
     2190,200,210,220,230,240,250),iparam
   10 uss (ielmnt)=param
      ussm(ielmnt)=param
      return
   20 upp (ielmnt)=param
      uppm(ielmnt)=param
      return
   30 udd (ielmnt)=param
      uddm(ielmnt)=param
      return
   40 zs (ielmnt)=param
      zsm(ielmnt)=param
      return
   50 zp (ielmnt)=param
      zpm(ielmnt)=param
      return
   60 zd (ielmnt)=param
      zdm(ielmnt)=param
      return
   70 betas (ielmnt)=param
      betasm(ielmnt)=param
      return
   80 betap (ielmnt)=param
      betapm(ielmnt)=param
      return
   90 betad (ielmnt)=param
      betadm(ielmnt)=param
      return
  100 gss (ielmnt)=param
      gssm(ielmnt)=param
      return
  110 gsp (ielmnt)=param
      gspm(ielmnt)=param
      return
  120 gpp (ielmnt)=param
      gppm(ielmnt)=param
      return
  130 gp2 (ielmnt)=param
      gp2m(ielmnt)=param
      return
  140 hsp (ielmnt)=param
      hspm(ielmnt)=param
      return
  150 return
  160 return
  170 return
  180 alp (ielmnt)=param
      alpm(ielmnt)=param
      return
  190 return
  200 return
  210 return
  220 guess1(ielmnt,kfn)=param
      return
  230 guess2(ielmnt,kfn)=param
      return
  240 guess3(ielmnt,kfn)=param
      return
  250 natorb(ielmnt)=param
      i=idint(param+0.5d0)
      if(i.ne.9.and.i.ne.4.and.i.ne.1)then
      write(mfgw,'(///10x,'' unacceptable value for no. of orbitals'',
     1'' on atom'')')
_IF(ipsc,tools)
         call pend
_ELSE
         stop
_ENDIF
      endif
      end
      subroutine mopx(c,n,mdim,nocc,ifill)
      implicit  REAL  (a-h,o-z)
INCLUDE(common/sizes)
      dimension c(mdim,mdim)
c******************************************************************
c
c        swap ensures that a named molecular orbital ifill is filled
c on input
c          c = eigenvectors in a mdim*mdim matrix
c          n = number of orbitals
c          nocc = number of occupied orbitals
c          ifill = filled orbital
c******************************************************************
      common /swap0/ psi(maxorb), stdpsi(maxorb)
      common/iofile/mfgr,mfgw
      if(ifill.gt.0) goto 20
c
c     we now define the filled orbital
c
      ifill=-ifill
      do 10 i=1,n
         stdpsi(i)=c(i,ifill)
   10 psi(i)=c(i,ifill)
      return
   20 continue
c
c     first find the location of ifill
c
      sum=0.d0
      do 30 i=1,n
   30 sum=sum+psi(i)*c(i,ifill)
      if(dabs(sum).gt.0.7071d0) goto 90
c
c     ifill has moved!
c
      summax=0.d0
      do 50 ifill=1,n
         sum=0.d0
         do 40 i=1,n
   40    sum=sum+stdpsi(i)*c(i,ifill)
         sum=dabs(sum)
         if(sum.gt.summax)jfill=ifill
         if(sum.gt.summax)summax=sum
         if(sum.gt.0.7071d0) goto 90
   50 continue
      do 70 ifill=1,n
         sum=0.d0
         do 60 i=1,n
   60    sum=sum+psi(i)*c(i,ifill)
         sum=dabs(sum)
         if(sum.gt.summax)jfill=ifill
         if(sum.gt.summax)summax=sum
         if(sum.gt.0.7071d0) goto 90
   70 continue
      write(mfgw,80)summax,jfill
   80 format(/,' caution !!! sum in swap very small, summax =',f10.5,
     1' jfill=',i3)
      ifill=jfill
   90 continue
      if(ifill.le.nocc) return
c
c    its empty, so swap it with the highest filled
c
      do 100 i=1,n
         x=c(i,nocc)
         c(i,nocc)=c(i,ifill)
         c(i,ifill)=x
  100 continue
      return
      end
      subroutine mopxyz(xyz,numat,na,nb,nc,degree,geo)
      implicit REAL (a-h,o-z)
      dimension xyz(3,*), na(*), nb(*), nc(*), geo(3,*)
***********************************************************************
*
* mopxyz works out the internal coordinates of a molecule.
*        the "rules" for the connectivity are as follows:
*        atom i is defined as being at a distance from the nearest
*        atom j, atom j already having been defined.
*        atom i makes an angle with atom j and the atom k, which has
*        already been defined, and is the nearest atom to j
*        atom i makes a dihedral angle with atoms j, k, and l. l having
*        been defined and is the nearest atom to k, and j, k and l
*        have a contained angle in the range 15 to 165 degrees,
*        if possible.
*
*        if(na(2).eq.1 then the original connectivity is used.
*
*        note that geo and xyz must not be the same in the call.
*
*   on input xyz    = cartesian array of numat atoms
*            degree = 1 if angles are to be in radians
*            degree = 57.29578 if angles are to be in degrees
*
***********************************************************************
      common /geook/ igeook
      common /numcal/ numcal
      save icalcn
      data icalcn/0/
      igeook=99
      nai1=0
      nai2=0
      if(.not.(icalcn.ne.numcal).and.na(2).eq.-1)then
         na(2)=1
         do 10 i=2,numat
            j=na(i)
            if(i.gt.3)call dihed(xyz,i,j,nb(i),nc(i),geo(3,i))
            if(i.gt.2)call bangle(xyz,i,j,nb(i),geo(2,i))
            geo(1,i)=dsqrt((xyz(1,i)-xyz(1,j))**2+
     1          (xyz(2,i)-xyz(2,j))**2+
     2          (xyz(3,i)-xyz(3,j))**2)
   10    continue
      else
         if(na(2).eq.-1)icalcn=numcal
         do 30 i=1,numat
            na(i)=2
            nb(i)=3
            nc(i)=4
            im1=i-1
            if(im1.eq.0)goto 30
            sum=1.d30
            do 20 j=1,im1
               r=(xyz(1,i)-xyz(1,j))**2+
     1          (xyz(2,i)-xyz(2,j))**2+
     2          (xyz(3,i)-xyz(3,j))**2
               if(r.lt.sum.and.na(j).ne.j.and.nb(j).ne.j) then
                  sum=r
                  k=j
               endif
   20       continue
c
c   atom i is nearest to atom k
c
            na(i)=k
            if(i.gt.2)nb(i)=na(k)
            if(i.gt.3)nc(i)=nb(k)
c
c   find any atom to relate to na(i)
c
   30    continue
      endif
      na(1)=0
      nb(1)=0
      nc(1)=0
      nb(2)=0
      nc(2)=0
      nc(3)=0
      call xyzgeo(xyz,numat,na,nb,nc,degree,geo)
      return
      end
      subroutine mpcbds(bondab,numat,natms2)
c
c  this routine is called from subroutine bonds(p). it writes out
c  the bond indices to the sybyl output file assigned to lun 16.
c  added by vic l. (29july86).
c
      REAL  bondab(natms2)
      common/iofile/mfgr,mfgw
      ithree = 3
      write(16,'(i4)',err=20) ithree
      do 10 i = 1,numat
         inds = i*(i-1)/2 + 1
         indf = inds + i -1
   10 write(16,'(10f8.4)',err=20)(bondab(j),j=inds,indf)
      return
   20 write(mfgw,'(a)')' error writing bond indices output'
      return
      end
      subroutine mpcpop(c,icok)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
c
c this routine calculates the total mulliken populations on the
c   atoms by summing the diagonal elements from the  mulliken
c   population analysis.
c
      common / molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),
     1                nlast(numatm), norbs, nelecs,nalpha,nbeta,
     2                nclose,nopen,ndumy,fract
      common /corec/ core(107)
      common/iofile/mfgr,mfgw
      dimension c(morb2),pop(numatm),chrg(numatm)
      write(16,'(i4,5x'' mulliken population and charge'')',err=40)icok
c
c icok = 1 ==> print populations
c icok = 0 ==> keyword mulliken = .f.
c         no population analysis performed
c
      if (icok.ne.0) then
         do 20 i = 1,numat
            if = nfirst(i)
            il = nlast(i)
            sum = 0.0d0
            pop(i) = 0.0d0
            chrg(i) = 0.0d0
            do 10 j = if,il
c
c    diagonal element of mulliken matrix
c
               sum = sum + c((j*(j+1))/2)
   10       continue
            k = nat(i)
c
c    mulliken population for i'th atom
c
            pop(i) = sum
            chrg(i) = core(k) - pop(i)
   20    continue
         write(mfgw,'(///10x,''mulliken populations and charges'')')
         do 30 j = 1,numat
            write(mfgw,60) j, pop(j), chrg(j)
            write(16,70,err=40) pop(j), chrg(j)
   30    continue
      endif
      return
   40 write(mfgw,'(a)') 
     + 'error writing sybyl mulliken population output'
      return
c  50 format(//,5x,'atom',8x,'population',6x,'charge')
   60 format(5x,i4,4x,f11.6,6x,f11.6)
   70 format(2f12.6)
      end
      subroutine mpcsyb(numat,coord,chr,icok,eigs,nclose,funct
     1                       ,eionis,kchrge,dip)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      common/iofile/mfgr,mfgw
      dimension coord(3, numat), chr(numat),eigs(maxorb)
c  write out the charge flag and number of atoms
      write(16,'(2i4)', err=30) icok,numat
c  write out the coordinates and charges
      do 10 i=1, numat
         write(16,'(4f12.6)', err=30) (coord(j, i), j=1, 3), chr(i)
   10 continue
      i1 = max0(1,nclose - 1)
      i2 = min0(maxorb,nclose + 2)
c
c  write out the 2 highest and 2 lowest orbital energies
c
      write(16,20,err=30)(eigs(j),j=i1,i2),nclose
   20 format(4f12.6,2x,i4,2x,'homos,lumos,# of occupied mos')
c
c  write out the heat of formation and ionisation potential
c
      write(16,'(2f12.6,4x,''hf and ip'')',err=30) funct,eionis
c
c  write out the dipole moment
c
      if(kchrge.ne.0) dip = 0.0d0
      write(16, '(i4,f10.3,''  charge,dip.moment'')', err=30)
     1kchrge, dip
      return
   30 write(mfgw,'(a)') 'error writing sybyl mopac output'
      return
      end
      subroutine mtxm (a,nar,b,nbr,c,ncc)
      implicit REAL (a-h,o-z)
c     matrix product c(nar,ncc) = (a(nbr,nar))' * b(nbr,ncc)
c     all matrices rectangular , packed.
      dimension a(nbr,nar),b(nbr,ncc),c(nar,ncc)
      do 20 j=1,ncc
         do 10 i=1,nar
   10    c(i,j)=0.d0
         do 20 k=1,nbr
            do 20 i=1,nar
   20 c(i,j)=c(i,j)+a(k,i)*b(k,j)
      return
      end
      subroutine mtxmc (a,nar,b,nbr,c)
      implicit REAL (a-h,o-z)
c     matrix product c(nar,nar) = (a(nbr,nar))' * b(nbr,nar)
c     a and b rectangular , packed,
c     c lower left triangle only, packed in canonical order.
      dimension a(nbr,nar),b(nbr,nar),c(*)
c  note ... this is the best version on cray 1.
      l=1
      do 10 i=1,nar
         call mxm (a(1,i),1,b,nbr,c(l),i)
   10 l=l+i
      return
      end
      subroutine mullik(c,h,f,norbs,vecs,store)
      implicit REAL (a-h,o-z)
_IF(ipsc,tools)
      logical oroot
_ENDIF
INCLUDE(common/sizes)
INCLUDE(../m4/common/utilc)
      dimension c(*), h(*), vecs(*), store(*), f(*)
**********************************************************************
*
*  mullik does a mulliken population analysis
* on input     c      =  square array of eigenvectors.
*              h      =  packed array of one-electron matrix
*              f      =  workstore of size at least norbs*norbs
*              vecs   =  workstore of size at least norbs*norbs
*              store  =  workstore of size at least (norbs*(norbs+1))/2
*
**********************************************************************
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),
     2                nlast(numatm), norbx, nelecs,nalpha,nbeta,
     3                nclose,nopen,ndumy,fract
      common /keywrd/ keywrd
      common/iofile/mfgr,mfgw
      common /betas/ betas(107),betap(107),betad(107)
      common /cmpg/ geo(3,numatm)
      common /expont/ zs(107),zp(107),zd(107)
      character keywrd*241, getmop*80
      logical graph
**********************************************************************
*
*  first, re-calculate the overlap matrix
*
**********************************************************************
      dimension eigs(maxorb), ifact(maxorb), xyz(3,numatm)
      graph=(index(keywrd,'graph').ne.0)
      do 10 i=1,norbs
   10 ifact(i)=(i*(i-1))/2
      ifact(norbs+1)=(norbs*(norbs+1))/2
      do 50 i=1,numat
         if=nfirst(i)
         il=nlast(i)
         im1=i-1
         bi=betas(nat(i))
         do 50 k=if,il
            ii=(k*(k-1))/2
            do 30 j=1,im1
               jf=nfirst(j)
               jl=nlast(j)
               bj=betas(nat(j))
               do 20 jj=jf,jl
                  ij=ii+jj
                  h(ij)=2.d0*h(ij)/(bi+bj)     +1.d-14
c  the  +1.d-14 is to prevent possible errors in the diagonalization.
                  store(ij)=h(ij)
   20          bj=betap(nat(j))
   30       continue
            do 40 jj=if,k
               ij=ii+jj
               store(ij)=0.d0
   40       h(ij)=0.d0
   50 bi=betap(nat(i))
      do 60 i=1,norbs
         store(ifact(i+1))=1.d0
   60 h(ifact(i+1))=1.d0
      call rsp(h,norbs,norbs,eigs,vecs)
      do 70 i=1,norbs
   70 eigs(i)=1.d0/dsqrt(dabs(eigs(i)))
      ij=0
      do 90 i=1,norbs
         do 90 j=1,i
            ij=ij+1
            sum=0.d0
            do 80 k=1,norbs
   80       sum=sum+vecs(i+(k-1)*norbs)*eigs(k)
     1                *vecs(j+(k-1)*norbs)
            f(i+(j-1)*norbs)=sum
   90 f(j+(i-1)*norbs)=sum
      if (graph) then
         call gmetry(geo,xyz)
*
* write to disk the following data for graphics calculation, in order:
*
*      number of atoms, orbital, electrons
*      all atomic coordinates
*      orbital counters
*      orbital exponents, s, p, and d, and atomic numbers
*      eigenvectors (m.o.s not re-normalized)
*      inverse-square root of the overlap matrix.
*
_IF(ipsc,tools)
       if(oroot().and.odumpm) then
_ELSE
       if(odumpm) then
_ENDIF
      open(unit=13,file=getmop(7),form='unformatted',
     +status='new',err=31)
      goto 32
  31  open(unit=13,file=getmop(7),status='old',
     +form='unformatted')
  32  continue
         write(13)numat,norbs,nelecs,((xyz(i,j),j=1,numat),i=1,3)
         write(13)(nlast(i),nfirst(i),i=1,numat)
         write(13)(zs(nat(i)),i=1,numat),(zp(nat(i)),i=1,numat),
     1         (zd(nat(i)),i=1,numat),(nat(i),i=1,numat)
         linear=norbs*norbs
         write(13)(c(i),i=1,linear)
         write(13)(f(i),i=1,linear)
       endif
          if(index(keywrd,'mullik').eq.0)return
      endif
*
* otherwise perform mulliken analysis
*
      call mult(c,f,vecs,norbs)
      i=-1
      call densit(vecs,norbs,norbs,nclose,nopen,fract,c,2)
      linear=(norbs*(norbs+1))/2
      do 100 i=1,linear
  100 c(i)=c(i)*store(i)
      summ=0.d0
      do 130 i=1,norbs
         sum=0
         do 110 j=1,i
  110    sum=sum+c(ifact(i)+j)
         do 120 j=i+1,norbs
  120    sum=sum+c(ifact(j)+i)
         summ=summ+sum
  130 c(ifact(i+1))=sum
      call vecprt(c,norbs)
      return
      end
      subroutine mult(c,s,vecs,n)
      implicit REAL (a-h,o-z)
      dimension c(n,*), s(n,*), vecs(n,*)
***********************************************************************
*
*   mult is used in the mulliken analysis only. it performs the
*        operation:-
*                                   vecs=back-transformed eigenvectors
*        vecs  =  c*s               c   =un-back-transformed vectors
*                                   s   =1/sqrt(overlap matrix)
*
***********************************************************************
      do 20 i=1,n
         do 20 j=1,n
            sum=0.d0
            do 10 k=1,n
   10       sum=sum+c(k,i)*s(j,k)
   20 vecs(j,i)=sum
      return
      end
_IF1()     subroutine mxm(a,nar,b,nbr,c,ncc)
_IF1()     implicit REAL (a-h,o-z)
_IF1()c    rectangular matrix product c=a*b.
_IF1()c    each matrix is entirely fullfilled and packed.
_IF1()c    simulate routine on cray (same name and calling sequence).
_IF1()     dimension a(nar,nbr),b(nbr,ncc),c(nar,ncc)
_IF1()     do 20 j=1,ncc
_IF1()        do 10 i=1,nar
_IF1()  10    c(i,j)=0.d0
_IF1()        do 20 k=1,nbr
_IF1()           do 20 i=1,nar
_IF1()  20 c(i,j)=c(i,j)+a(i,k)*b(k,j)
_IF1()     return
_IF1()     end
      function myword(keywrd,testwd)
      logical myword
      character keywrd*(*), testwd*(*)
      myword=.false.
   10 j=index(keywrd,testwd)
      if(j.ne.0)then
   20    if(keywrd(j:j).ne.' ')goto 30
         j=j+1
         goto 20
   30    myword=.true.
         do 60 k=j,241
            if(keywrd(k:k).eq.'='.or.keywrd(k:k).eq.' ') then
c
c     check for attached '=' sign
c
               j=k
               if(keywrd(j:j).eq.'=')goto 50
c
c     check for separated '=' sign
c
               do 40 j=k+1,241
                  if(keywrd(j:j).eq.'=') goto 50
   40          if(keywrd(j:j).ne.' ')goto 10
c
c    there is no '=' sign associated with this keyword
c
               goto 10
   50          keywrd(j:j)=' '
c
c   there must be a number after the '=' sign, somewhere
c
               goto 20
            endif
   60    keywrd(k:k)=' '
      endif
      return
      end
      subroutine naicap(isc,is,ip,npr,nc,ipe,ipx,icd)
      implicit REAL  (a-h,o-z)
_IF(ipsc,tools)
      logical oroot
_ENDIF
c***********************************************************************
c     this routine evaluates (p|p) nuclear attraction integrals over
c
c     a sto-ng basis set.
c     written by b.h. besler at ford scientific research labs in
c     sept. 1989
c
c     on input:  ic = loop index of the gaussian
c                icd = contraction depth of basis set
c                iesp = loop index of the esp point
c                is = number os s primitives
c                ipe = index of last px primitive
c                ipx = number of px primitives
c                is = number os s primitives
c                isc = number of contracted
c                npr = number of primitives
c                nc = number of contracted functions
c
c
c     for more info see: obara&saika j.chem.phys. 1986,84,3963.
c***********************************************************************
INCLUDE(../m4/common/utilc)
INCLUDE(common/sizes)
      REAL  nai,nai1,nai2
      character*241 keywrd
      character*80 getmop
      common /keywrd/ keywrd
      common/espf/ al((numatm+4)**2),a(numatm,numatm),b(numatm),
     1q(numatm+4),cespm(maxorb,maxorb)
      common /indx/ indc(maxorb)
      common /densty/ p(mpack),pa(mpack),pb(mpack)
      common /potesp/ xc,yc,zc,espnuc,espele,nesp
      common /abc/    co(3,numatm),ian(numatm),natom
      common /work1/
     +    potpt(3,mesp), es(mesp), esp(mesp), work1d(2*mesp)
      common /expont/ zs(107),zp(107),zd(107)
      common /sto6g/  allc(6,5,2),allz(6,5,2)
      common /espc/ cc(maxpr),cen(maxpr,3),iam(maxpr,2),ind(maxpr),
     1ex(maxpr),espi(maxorb,maxorb),fv(0:8,821),
     2fac(0:7),dex(-1:96),tf(0:2),
     3temp(maxpr),itemp(maxpr),ovl(maxorb,maxorb),exsr(maxpr,6)
      common/x/ dx(maxpr),dy(maxpr),dz(maxpr),f1(maxpr,6),f2(maxpr,6),
     1td(maxpr),ce(maxpr,6),u(maxpr,6),exs(maxpr,6),expn(maxpr,6),
     2nai(maxpr,6),ewcx(maxpr,6),ewcy(maxpr,6),ewcz(maxpr,6),f0(maxpr,6)
     3,nai1(maxpr,6),nai2(maxpr,6)
      common/fp/ pf0(maxhes),pf1(maxhes),pf2(maxhes),id(maxpar),
     1pexs(maxhes),pce(maxhes),pexpn(maxhes),ptd(maxhes),
     2pewcx(maxhes),pewcy(maxhes),pewcz(maxhes),ird(maxhes)
      common/iofile/mfgr,mfgw
      data bohr/0.529167d0/
c     set number of equally spaced dumps
      idn=10
c
      idc=0
      write(mfgw,*)
      ipx2=2*ipx
      pi=4.d0*datan(1.d0)
      np=is+1
c     setup index array
      do 10 i=np,ipe
         ird(i)=i-is
         ird(i+ipx)=i-is
         ird(i+ipx2)=i-is
   10 continue
c
c     calculate quantities invariant with esp point for
c     (p|p) esp integrals
c
c *** il=l
      l=0
      do 30 i=np,ipe
         do 20 j=i,ipe
            l=l+1
            ptd(l)=(cen(i,1)-cen(j,1))**2+(cen(i,2)-cen(j,2))**2+
     1(cen(i,3)-cen(j,3))**2
            pexs(l)=1.d0/(ex(i)+ex(j))
            pce(l)=ex(i)*ex(j)*pexs(l)
            pexpn(l)=dexp(-pce(l)*ptd(l))
            pewcx(l)=(ex(i)*cen(i,1)+ex(j)*cen(j,1))*pexs(l)
            pewcy(l)=(ex(i)*cen(i,2)+ex(j)*cen(j,2))*pexs(l)
            pewcz(l)=(ex(i)*cen(i,3)+ex(j)*cen(j,3))*pexs(l)
   20    continue
c
c     set up other index array for packed symmetric array
c     storage
c
         id(i-is)=l-ipx
   30 continue
c
c     read in restart information if this is a restart
c
      if(index(keywrd,'esprst') .ne. 0) then
_IF(ipsc,tools)
       if(oroot()) then
_ENDIF
         open(unit=15,file=getmop(13),status='unknown'
     1,form='unformatted')
         read(15) jstart,iesps
         if(jstart .ne. isc*2) then
            iesps=0
            close(15)
            goto 50
         endif
         do 40 i=1,nesp
            read(15) es(i)
   40    continue
         close(15)
         idc=dfloat(iesps)/dfloat(nesp)*10
_IF(ipsc,tools)
        else
         write(mfgw,*)' restarts not available in esprst'
         call pend
        endif
_ENDIF
      else
         iesps=0
      endif
   50 continue
c
c     loop over esp probe points
c
      do 250 iesp=iesps+1,nesp
         potp1=potpt(1,iesp)/bohr
         potp2=potpt(2,iesp)/bohr
         potp3=potpt(3,iesp)/bohr
c     calculate quantity u
c
         l=0
         do 60 i=np,ipe
            do 60 j=i,ipe
               l=l+1
               ptd(l)=((pewcx(l)-potp1)**2+(pewcy(l)-potp2)**2+
     1      (pewcz(l)-potp3)**2)/pexs(l)
               pce(l)=dsqrt(pi/ptd(l))
   60    continue
c
c     calculate f0, f1, and f2(u) using taylor series
c     or asymptotic expansion
c
         il=l
         l=0
         do 100 i=1,il
            if(ptd(i) .le. tf(0)) then
               iref=dnint(ptd(i)*20.d0)
               ref=0.05d0*iref
               res=ptd(i)-ref
               term=1.d0
               pf0(i)=0.d0
               do 70 k=0,6
                  f=fv(k,iref+1)
                  ts=f*term*fac(k)
                  term=-term*res
                  pf0(i)=pf0(i)+ts
   70          continue
            else
               pf0(i)=pce(i)*0.5d0
            endif
            if(ptd(i) .le. tf(1)) then
               iref=dnint(ptd(i)*20.d0)
               ref=0.05d0*iref
               res=ptd(i)-ref
               term1=1.d0
               pf1(i)=0.d0
               do 80 k=0,6
                  fi=fv(k+1,iref+1)
                  ts1=fi*term1*fac(k)
                  term1=-term1*res
                  pf1(i)=pf1(i)+ts1
   80          continue
            else
               pf1(i)=pce(i)*0.25d0/ptd(i)
            endif
            if(ptd(i) .le. tf(2)) then
               iref=dnint(ptd(i)*20.d0)
               ref=0.05d0*iref
               res=ptd(i)-ref
               term2=1.d0
               pf2(i)=0.d0
               do 90 k=0,6
                  fii=fv(k+2,iref+1)
                  ts2=fii*term2*fac(k)
                  term2=-term2*res
                  pf2(i)=pf2(i)+ts2
   90          continue
            else
               pf2(i)=pce(i)*0.375d0/(ptd(i)*ptd(i))
            endif
  100    continue
c
c     calculate (s||s) type integrals
c
         do 110 i=1,il
            pf0(i)=2.d0*pi*pexs(i)*pexpn(i)*pf0(i)
            ptd(i)=pf0(i)
            pf1(i)=2.d0*pi*pexs(i)*pexpn(i)*pf1(i)
            pf2(i)=2.d0*pi*pexs(i)*pexpn(i)*pf2(i)
  110    continue
c
         do 230 ic=isc+1,nc
            ipr=ic*icd-icd+1
            istart=ipr
            do 200 j=1,icd
c
c     calculate (p||s) esp integrals
c
               if((iam(ipr,1) .eq. 1) .and. (is .ne. ip)) then
                  do 150 i=istart,npr
                     in=ipr+j-1
                     ir=ird(i)+id(ird(in))
                     ir2=id(ird(i))+ird(in)
                     if(ir2 .le. ir ) ir=ir2
                     go to (120,130,140),iam(in,2)
  120                nai2(i,j)=(pewcx(ir)-cen(in,1))*pf1(ir)-pf2(ir)*
     1      (pewcx(ir)-potp1)
                     nai(i,j)=(pewcx(ir)-cen(in,1))*pf0(ir)-pf1(ir)*
     1      (pewcx(ir)-potp1)
                     go to 150
  130                nai2(i,j)=(pewcy(ir)-cen(in,2))*pf1(ir)-pf2(ir)*
     1      (pewcy(ir)-potp2)
                     nai(i,j)=(pewcy(ir)-cen(in,2))*pf0(ir)-pf1(ir)*
     1      (pewcy(ir)-potp2)
                     go to 150
  140                nai2(i,j)=(pewcz(ir)-cen(in,3))*pf1(ir)-pf2(ir)*
     1      (pewcz(ir)-potp3)
                     nai(i,j)=(pewcz(ir)-cen(in,3))*pf0(ir)-pf1(ir)*
     1      (pewcz(ir)-potp3)
  150             continue
               endif
c
c     calculate (p||p) esp integrals
c
               if((iam(ipr,1) .eq. 1) .and. (is .ne. ip)) then
                  do 190 i=istart,npr
                     in=ipr+j-1
                     ir=ird(i)+id(ird(in))
                     ir2=id(ird(i))+ird(in)
                     if(ir2 .le. ir ) ir=ir2
                     go to (160,170,180),iam(i,2)
  160                nai(i,j)=(pewcx(ir)-cen(i,1))*nai(i,j)-(pewcx(ir)-p
     1otp1)*      nai2(i,j)
                     if(iam(in,2) .eq. iam(i,2)) nai(i,j)=nai(i,j)+pexs(
     1ir)*      0.5d0*(ptd(ir)-pf1(ir))
                     go to 190
  170                nai(i,j)=(pewcy(ir)-cen(i,2))*nai(i,j)-(pewcy(ir)-p
     1otp2)*      nai2(i,j)
                     if(iam(in,2) .eq. iam(i,2)) nai(i,j)=nai(i,j)+pexs(
     1ir)*      0.5d0*(ptd(ir)-pf1(ir))
                     go to 190
  180                nai(i,j)=(pewcz(ir)-cen(i,3))*nai(i,j)-(pewcz(ir)-p
     1otp3)*      nai2(i,j)
                     if(iam(in,2) .eq. iam(i,2)) nai(i,j)=nai(i,j)+pexs(
     1ir)*      0.5d0*(ptd(ir)-pf1(ir))
  190             continue
               endif
  200       continue
c
c     form integrals over contracted functions
c
            ips=ic*icd-icd+1
            do 220 i=ic,nc
               jps=i*icd-icd+1
               espi(i,ic)=0.d0
               do 210 j=jps,jps+icd-1
                  do 210 k=ips,ips+icd-1
                     espi(i,ic)=espi(i,ic)+cc(j)*cc(k)*nai(j,k-ips+1)
  210          continue
               es(iesp)=es(iesp)+2.d0*cespm(indc(i),indc(ic))*espi(i,ic)
  220       continue
            es(iesp)=es(iesp)-cespm(indc(ic),indc(ic))*espi(ic,ic)
  230    continue
c
c     write out restart information every nesp/10 points
c
_IF(ipsc,tools)
         if(mod(iesp,nesp/idn) .eq. 0 .and. oroot() .and. odumpm) then
_ELSE
         if(mod(iesp,nesp/idn) .eq. 0 .and. odumpm) then
_ENDIF
            open(unit=15,file=getmop(13),status='unknown',
     1form='unformatted')
            jstart=isc*2
            write(15) jstart,iesp
            do 240 i=1,nesp
               write(15) es(i)
  240       continue
            close(15)
            idc=idc+1
            write(mfgw,'(a,f6.2,a)')
     1'naicap dumped: ',100.d0/idn*idc,' percent complete'
         endif
  250 continue
      return
      end
      subroutine naicas(isc,is,ip,npr,nc,ipe,ipx,icd)
      implicit REAL (a-h,o-z)
_IF(ipsc,tools)
      logical oroot
_ENDIF
c***********************************************************************
c
c     this routine evaluates (s|s) , (s|p) type nuclear attraction
c     integrals for a sto-ng basis set
c     written by b.h. besler at ford scientific research labs in
c     december 1989.
c
c     on input:  ic = loop index of the gaussian
c                iesp = loop index of the esp point
c                ipe = index of last px primitive
c                ipx = number of px primitives
c                is = number os s orbitals
c                isc = number of contracted s orbitals
c                ip = number of p orbitals
c                npr = number of primitives
c                nc = number of contracted functions
c
c
c     for more info see: obara&saika j.chem.phys. 1986,84,3963.
c***********************************************************************
INCLUDE(common/sizes)
INCLUDE(../m4/common/utilc)
      REAL  nai,nai1,nai2
      character*241 keywrd
      character*80 getmop
      common/keywrd/ keywrd
      common/espf/ al((numatm+4)**2),a(numatm,numatm),b(numatm),
     1q(numatm+4),cespm(maxorb,maxorb)
      common /indx/ indc(maxorb)
      common /densty/ p(mpack),pa(mpack),pb(mpack)
      common /potesp/ xc,yc,zc,espnuc,espele,nesp
      common /abc/    co(3,numatm),ian(numatm),natom
      common /work1/
     +    potpt(3,mesp), es(mesp), esp(mesp), work1d(2*mesp)
      common /expont/ zs(107),zp(107),zd(107)
      common /sto6g/  allc(6,5,2),allz(6,5,2)
      common /espc/ cc(maxpr),cen(maxpr,3),iam(maxpr,2),ind(maxpr),
     1ex(maxpr),espi(maxorb,maxorb),fv(0:8,821),
     2fac(0:7),dex(-1:96),tf(0:2),
     3temp(maxpr),itemp(maxpr),ovl(maxorb,maxorb),exsr(maxpr,6)
      common/x/ dx(maxpr),dy(maxpr),dz(maxpr),f1(maxpr,6),f2(maxpr,6),
     1td(maxpr),ce(maxpr,6),u(maxpr,6),exs(maxpr,6),expn(maxpr,6),
     2nai(maxpr,6),ewcx(maxpr,6),ewcy(maxpr,6),ewcz(maxpr,6),f0(maxpr,6)
     3,nai1(maxpr,6),nai2(maxpr,6)
      common/iofile/mfgr,mfgw
      data bohr/0.529167d0/
c
c     calculate distance arrays
c
      write(mfgw,*)
      pi=4.d0*datan(1.d0)
      ipx2=2*ipx
c     if this is a restart run, read in restart info
      if(index(keywrd,'esprst') .ne. 0) then
_IF(ipsc,tools)
       if(oroot()) then
_ENDIF
         open(unit=15,file=getmop(13),status='old'
     1,form='unformatted')
         read(15) jstart,iesps
         if(jstart .eq. isc*2) then
            close(15)
            return
         endif
         do 10 i=1,nesp
            read(15) es(i)
   10    continue
         close(15)
c
         jstart=jstart+1
_IF(ipsc,tools)
       else
        write(mfgw,*)' restarts not available in naicas'
        call pend
       endif
_ENDIF
      else
         jstart=1
      endif
      np=is+1
      do 200 ic=jstart,isc
         ipr=ic*icd-icd+1
         istart=ipr
         do 20 i=istart,ipe
            dx(i)=cen(ipr,1)-cen(i,1)
            dy(i)=cen(ipr,2)-cen(i,2)
            dz(i)=cen(ipr,3)-cen(i,3)
            td(i)=dx(i)**2+dy(i)**2+dz(i)**2
   20    continue
c
c     calculate exponent sum
c
         do 30 i=istart,ipe
            do 30 j=1,icd
               exsr(i,j)=ex(ipr+j-1)+ex(i)
               exs(i,j)=1.d0/exsr(i,j)
               ce(i,j)=ex(ipr+j-1)*ex(i)*exs(i,j)
               expn(i,j)=dexp(-ce(i,j)*td(i))
   30    continue
c
c     calculate exponent weighted centers
c
         do 40 i=istart,ipe
            do 40 j=1,icd
               ewcx(i,j)=(ex(i)*cen(i,1)+ex(ipr+j-1)
     1*cen(ipr+j-1,1))*exs(i,j)
               ewcy(i,j)=(ex(i)*cen(i,2)+ex(ipr+j-1)
     1*cen(ipr+j-1,2))*exs(i,j)
               ewcz(i,j)=(ex(i)*cen(i,3)+ex(ipr+j-1)
     1*cen(ipr+j-1,3))*exs(i,j)
   40    continue
c
c     begin loop over esp points
c
         do 180 iesp=1,nesp
            potp1=potpt(1,iesp)/bohr
            potp2=potpt(2,iesp)/bohr
            potp3=potpt(3,iesp)/bohr
c
c     begin loop over components of contracted function ic
c
            do 150 j=1,icd
c
c     calculate distance between exponent weighted and probe point
c
               do 50 i=istart,ipe
                  u(i,j)=((ewcx(i,j)-potp1)**2+(ewcy(i,j)-potp2)**2+
     1      (ewcz(i,j)-potp3)**2)*exsr(i,j)
                  nai(i,j)=dsqrt(pi/u(i,j))
   50          continue
c
c     calculate esp integrals
c
               do 70 i=istart,ipe
                  if(u(i,j) .le. tf(0)) then
                     iref=dnint(u(i,j)*20.d0)
                     ref=0.05d0*iref
                     res=u(i,j)-ref
                     term=1.d0
                     f0(i,j)=0.d0
                     do 60 k=0,6
                        f=fv(k,iref+1)
                        ts=f*term*fac(k)
                        term=-term*res
                        f0(i,j)=f0(i,j)+ts
   60                continue
                  else
                     f0(i,j)=nai(i,j)*0.5d0
                  endif
   70          continue
               do 90 i=np,ipe
                  if(u(i,j) .le. tf(1)) then
                     iref=dnint(u(i,j)*20.d0)
                     ref=0.05d0*iref
                     res=u(i,j)-ref
                     term1=1.d0
                     f1(i,j)=0.d0
                     do 80 k=0,6
                        fi=fv(k+1,iref+1)
                        ts1=fi*term1*fac(k)
                        term1=-term1*res
                        f1(i,j)=f1(i,j)+ts1
   80                continue
                  else
                     f1(i,j)=nai(i,j)*0.25d0/u(i,j)
                  endif
   90          continue
               do 100 i=istart,is
  100          u(i,j)=2.d0*pi*exs(i,j)*expn(i,j)*f0(i,j)
               np=is+1
               do 110 i=np,ipe
                  nai(i,j)=2.d0*pi*exs(i,j)*expn(i,j)*f0(i,j)
                  nai1(i,j)=2.d0*pi*exs(i,j)*expn(i,j)*f1(i,j)
  110          continue
c
c     calculate (s||p) esp integrals
c
               if((iam(ipr,1) .eq. 0) .and. (is .ne. ip)) then
                  do 120 i=np,ipe
  120             u(i,j)=(ewcx(i,j)-cen(i,1))*nai(i,j)
     1-(ewcx(i,j)-potp1)*nai1(i,j)
                  do 130 i=ipe+1,ipe+1+ipx
  130             u(i,j)=(ewcy(i-ipx,j)-cen(i-ipx,2))*nai(i-ipx,j)
     1-(ewcy(i-ipx,j)-potp2)*nai1(i-ipx,j)
                  do 140 i=ipe+1+ipx,npr
  140             u(i,j)=(ewcz(i-ipx2,j)-cen(i-ipx2,3))*nai(i-ipx2,j)
     1-(ewcz(i-ipx2,j)-potp3)*nai1(i-ipx2,j)
               endif
  150       continue
            ips=ic*icd-icd+1
            do 170 i=ic,nc
               jps=i*icd-icd+1
               espi(i,ic)=0.d0
               do 160 j=jps,jps+icd-1
                  do 160 k=ips,ips+icd-1
                     espi(i,ic)=espi(i,ic)+cc(j)*cc(k)*u(j,k-ips+1)
  160          continue
               es(iesp)=es(iesp)+2.d0*cespm(indc(i),indc(ic))*espi(i,ic)
  170       continue
            es(iesp)=es(iesp)-cespm(indc(ic),indc(ic))*espi(ic,ic)
  180    continue
c     write out restart information
         if(odumpm) then
         open(unit=15,file=getmop(13),status='unknown'
     1,form='unformatted')
         iesps=0
         write(15) ic,iesps
         do 190 i=1,nesp
            write(15) es(i)
  190    continue
         close(15)
         endif
c
         write(mfgw,'(a,f6.2,a)')
     1'naicas dumped: ',100.d0/isc*ic,' percent complete'
  200 continue
      return
      end
      subroutine nllsq(x,n)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      common /keywrd/ keywrd
      character*241 keywrd
      dimension x(*)
      common /mesage/ iflepo,iiter
      common/iofile/mfgr,mfgw
************************************************************************
*
*  nllsq is a non-derivative, nonlinear least-squares minimizer. it uses
*        bartel's procedure to minimize a function which is a sum of
*        squares.
*
*    on input n    = number of unknowns
*             x    = parameters of function to be minimized.
*
*    on exit  x    = optimized parameters.
*
*    the function to be minimized is "compfg". compfg must have the
*    calling sequence
*                  call compfg(xparam,.true.,escf,.true.,efs,.true.)
*                  ssq=dot(efs,efs,n)
*    where   efs  is a vector which  compfg  fills with the n individual
*                 components of the error function at the point x
*            ssq is the value of the sum of the  efs  squared.
*    in this formulation of nllsq m and n are the same.
*    the precise definitions of these two quantities is:
*
*     n = number of parameters to be optimized.
*     m = number of reference functions. m must be greater then, or
*         equal to, n
************************************************************************
c     q = orthogonal matrix   (m by m)
c     r = right-triangular matrix   (m by n)
c     mxcnt(1) = max allow overall fun evals
c     mxcnt(2) = max allow no of fnc evals per lin search
c     tols1 = relative tolerance on x overall
c     tols2 = absolute tolerance on x overall
c     tols5 = relative tolerance on x for linear searches
c     tols6 = absolute tolerance on x for linear searches
c     iprint = print switch
c     nrst = number of cycles between sidesteps
c     **********
      common /timem/ time0
      common /nllsqi/ ncount
      common /numscf/ nscf
      dimension y(maxpar), efs(maxpar), p(maxpar)
      common /last/ last
      common /timdmp/ tleft, tdump
      common /nllcom/ q(maxpar,maxpar),r(maxpar,maxpar*2)
      common /nllco2/ dddum(6),efslst(maxpar),xlast(maxpar),iiium(7)
      logical middle, resfil, minprt, log
      save space, chdot, zero, nine
      character space*1, chdot*1, zero*1, nine*1
      equivalence ( iiium(2), icyc),(iiium(3), irst),
     1(iiium(4),jrst),
     2(dddum(2),alf), (dddum(3),ssq),(dddum(4), pn)
      data space,chdot,zero,nine /' ','.','0','9'/
      middle=(index(keywrd,'restart') .ne. 0)
      log=(index(keywrd,'nolog') .eq. 0)
      iflepo=10
c*
      m=n
c*
      tol2=4.d-1
      if(index(keywrd,'gnorm') .ne. 0) then
         tol2=reada(keywrd,index(keywrd,'gnorm'))
         if(tol2.lt.0.01d0.and.index(keywrd,' let').eq.0)then
         write(mfgw,'(/,a)')'  gnorm has been set too low, reset to 0
     1.01'
            tol2=0.01d0
         endif
      endif
      last=0
      tols1=1.d-12
      tols2=1.d-10
      tols5=1.d-6
      tols6=1.d-3
      iprint=-1
      nrst=4
      ymaxst=1.d0
      tlast=tleft
      minprt=.true.
      resfil=.false.
      tleft=tleft-secmop()+time0
c     **********
c     set up counters and switches
c     **********
      nto=n/6
      ifrtl=0
      nrem=n-(nto*6)
      irepet=0
      nsst=0
c *** if(ixso.eq.0) ixso=n
      ixso=n
      np1 = n+1
      np2 = n+2
      icyc = 0
      irst = 0
      jrst = 1
      eps =tols5
      t = tols6
c     **********
c     get starting-point function value
c     set up estimate of initial line step
c     **********
      if(middle) then
         call parsav(0,n,m)
         nscf=iiium(1)
         close(13)
         ncount=iiium(5)
         do 10 i=1,n
   10    x(i)=xlast(i)
         time1=secmop()
         if(index(keywrd,'1scf') .ne. 0) then
            iflepo=13
            last=1
            return
         endif
         goto 60
      endif
      call compfg(x,.true.,escf,.true.,efslst,.true.)
      ssq=ddot(n,efslst,1,efslst,1)
      ncount = 1
      do 40 i=1,m
         do 30 j=1,n
            r(i,j) = 0.0d0
            if (i .eq. j)  r(i,j)=1.0d0
   30    continue
         do 40 j=i,m
            q(i,j) = 0.0d0
            q(j,i) = 0.0d0
            if (i .eq. j)  q(i,i)=1.0d0
   40 continue
      temp = 0.0d0
      do 50 i=1,n
   50 temp = temp+x(i)**2
      alf = 100.0d0*(eps*dsqrt(temp)+t)
c     **********
c     main loop
c     **********
      time1=secmop()
   60 continue
c     **********
c     update counters and test for printing this cycle
c     **********
      ifrtl=ifrtl+1
      icyc = icyc+1
      irst = irst+1
c     **********
c     set  prt,  the levenberg-marquardt parameter.
c     **********
      prt = dsqrt(ssq)
c     **********
c     if a sidestep is to be taken, go to 31
c     **********
      if (irst .ge. nrst)  go to 210
c     **********
c     solve the system    q*r*p = -efslst    in the least-squares sense
c     **********
      nsst=0
      do 80 i=1,m
         temp = 0.0d0
         do 70 j=1,m
   70    temp = temp-q(j,i)*efslst(j)
   80 efs(i) = temp
      do 90 j=1,n
         jj = np1-j
         do 90 i=1,j
            ii = np2-i
   90 r(ii,jj) = r(i,j)
      do 160 i=1,n
         i1 = i+1
         y(i) = prt
         efsss=0.0d0
         if (i .ge. n)  go to 110
         do 100 j=i1,n
  100    y(j) = 0.0d0
  110    continue
         do 150 j=i,n
            ii = np2-j
            jj = np1-j
            if (dabs(y(j)) .lt. dabs(r(ii,jj)))  go to 120
            temp = y(j)*dsqrt(1.0d0+(r(ii,jj)/y(j))**2)
            go to 130
  120       temp = r(ii,jj)*dsqrt(1.0d0+(y(j)/r(ii,jj))**2)
  130       continue
            sin = r(ii,jj)/temp
            cos = y(j)/temp
            r(ii,jj) = temp
            temp = efs(j)
            efs(j)=sin*temp+cos*efsss
            efsss=sin*efsss-cos*temp
            if (j .ge. n)  go to 160
            j1 = j+1
            do 140 k=j1,n
               jj = np1-k
               temp = r(ii,jj)
               r(ii,jj) = sin*temp+cos*y(k)
  140       y(k) = sin*y(k)-cos*temp
  150    continue
  160 continue
      p(n) = efs(n)/r(2,1)
      i = n
  170 i = i-1
      if (i)  200,200,180
  180 temp = efs(i)
      k = i+1
      ii = np2-i
      do 190 j=k,n
         jj = np1-j
  190 temp = temp-r(ii,jj)*p(j)
      jj = np1-i
      p(i) = temp/r(ii,jj)
      go to 170
  200 continue
      go to 230
c     **********
c     sidestep section
c     **********
  210 jrst = jrst+1
      nsst=nsst+1
      if(nsst.ge.ixso) go to 670
      if (jrst .gt. n)  jrst=2
      irst = 0
c     **********
c     production of a vector orthogonal to the last p-vector
c     **********
      work = pn*(dabs(p(1))+pn)
      temp = p(jrst)
      p(1) = temp*(p(1)+dsign(pn,p(1)))
      do 220 i=2,n
  220 p(i) = temp*p(i)
      p(jrst) = p(jrst)-work
c     **********
c     compute norm and norm-square of the p-vector
c     **********
  230 pnlast = pn
      pn=0.d0
      pn2 = 0.0d0
      do 240 i=1,n
         pn=pn+dabs(p(i))
  240 pn2 = pn2+p(i)**2
      if(pn.lt.1.d-20) then
      write(mfgw,'('' system does not appear to be optimizable.'',/
     1,'' this can happen if (a) it was optimized to begin with'',/
     2,'' or                 (b) it is neither a ground nor a'',
     3'' transition state'')')
         call geout(1)
_IF(ipsc,tools)         
         call pend
_ELSE
         stop
_ENDIF
      endif
      if(pn2.lt.1.d-20)pn2=1.d-20
      pn = dsqrt(pn2)
      if(alf.gt.1.d20)alf=1.d20
      if(icyc .gt. 1) then
         alf=alf*1.d-20*pnlast/pn
         if(alf.gt.1.d10)        alf=1.d10
         alf=alf*1.d20
      endif
      ttmp=alf*pn
      if(ttmp.lt.0.0001d0) alf=0.001d0/pn
c     **********
c     printing section
c     **********
c#      write(6,501)tleft,icyc,ssq
      do 250 i=1,n
         efs(i)=x(i)
  250 continue
c     **********
c     perform line-minimization from point x in direction p or -p
c     **********
      ssqlst = ssq
      do 260 i=1,n
         efs(i)=0.d0
  260 xlast(i)=x(i)
      call locmin(m,x,n,p,ssq,alf,efs,ierr,escf)
      if(ssqlst .lt. ssq ) then
         if(ierr .eq. 0)      ssq=ssqlst
         do 270 i=1,n
  270    x(i)=xlast(i)
         irst=nrst
         pn=pnlast
         time2=time1
         time1=secmop()
         tcycle=time1-time2
         tleft=tleft-tcycle
         if(tleft .gt. tcycle*2) go to 60
         goto 630
      endif
      irepet=0
c     **********
c     produce the vector   r*p
c     **********
      do 290 i=1,n
         temp = 0.0d0
         do 280 j=i,n
  280    temp = temp+r(i,j)*p(j)
  290 y(i) = temp
c     **********
c     produce the vector ...
c                  y  =    (efs-efslst-alf*q*r*p)/(alf*(normsquare(p))
c     compute norm of this vector as well
c     **********
      work = alf*pn2
      yn = 0.0d0
      do 310 i=1,m
         temp = 0.0d0
         do 300 j=1,n
  300    temp = temp+q(i,j)*y(j)
         temp = (efs(i)-efslst(i)-alf*temp)
         efslst(i) = efs(i)
         yn = yn+temp**2
  310 efs(i) = temp/work
      yn = dsqrt(yn)/work
c     **********
c     the broyden update   new matrix = old matrix + y*(p-trans)
c     has been formed.  it is now necessary to update the  qr decomp.
c     first let    y = (q-trans)*y.
c     **********
      do 330 i=1,m
         temp = 0.0d0
         do 320 j=1,m
  320    temp = temp+q(j,i)*efs(j)
  330 y(i) = temp
c     **********
c     reduce the vector y to a multiple of the first unit vector using
c     a householder transformation for components n+1 through m and
c     elementary rotations for the first n+1 components.  apply all
c     transformations transposed on the right to the matrix q, and
c     apply the rotations on the left to the matrix r.
c     this gives    (q*(v-trans))*((v*r) + (v*y)*(p-trans)),    where
c     v is the composite of the transformations.  the matrix
c     ((v*r) + (v*y)*(p-trans))    is upper hessenberg.
c     **********
      if (m .le. np1)  go to 390
c
c the next three lines were inserted to try to get round overflow bugs.
c
      const=1.d-12
      do 340 i=np1,m
  340 const=dmax1(dabs(y(np1)),const)
      ytail = 0.0d0
      do 350 i=np1,m
  350 ytail = ytail+(y(i)/const)**2
      ytail = dsqrt(ytail)*const
      bet = (1.0d25/ytail)/(ytail+dabs(y(np1)))
      y(np1) = dsign(ytail+dabs(y(np1)),y(np1))
      do 380 i=1,m
         tmp = 0.0d0
         do 360 j=np1,m
  360    tmp = tmp+q(i,j)*y(j)*1.d-25
         tmp = bet*tmp
         do 370 j=np1,m
  370    q(i,j) = q(i,j)-tmp*y(j)
  380 continue
      y(np1) = ytail
      i = np1
      go to 400
  390 continue
      i = m
  400 continue
  410 j = i
      i = i-1
      if (i)  480,480,420
  420 if (y(j))  430,410,430
  430 if (dabs(y(i)) .lt. dabs(y(j)))  go to 440
      temp = dabs(y(i))*dsqrt(1.0d0+(y(j)/y(i))**2)
      go to 450
  440 temp = dabs(y(j))*dsqrt(1.0d0+(y(i)/y(j))**2)
  450 cos = y(i)/temp
      sin = y(j)/temp
      y(i) = temp
      do 460 k=1,m
         temp = cos*q(k,i)+sin*q(k,j)
         work = -sin*q(k,i)+cos*q(k,j)
         q(k,i) = temp
  460 q(k,j) = work
      if (i .gt. n)  go to 410
      r(j,i) = -sin*r(i,i)
      r(i,i) = cos*r(i,i)
      if (j .gt. n)  go to 410
      do 470 k=j,n
         temp = cos*r(i,k)+sin*r(j,k)
         work = -sin*r(i,k)+cos*r(j,k)
         r(i,k) = temp
  470 r(j,k) = work
      go to 410
  480 continue
c     **********
c     reduce the upper-hessenberg matrix to upper-triangular form
c     using elementary rotations.  apply the same rotations, transposed,
c     on the right to the matrix  q.
c     **********
      do 490 k=1,n
  490 r(1,k) = r(1,k)+yn*p(k)
      jend = np1
      if (m .eq. n)  jend=n
      do 560 j=2,jend
         i = j-1
         if (r(j,i))  500,560,500
  500    if (dabs(r(i,i)) .lt. dabs(r(j,i)))  go to 510
         temp = dabs(r(i,i))*dsqrt(1.0d0+(r(j,i)/r(i,i))**2)
         go to 520
  510    temp = dabs(r(j,i))*dsqrt(1.0d0+(r(i,i)/r(j,i))**2)
  520    cos = r(i,i)/temp
         sin = r(j,i)/temp
         r(i,i) = temp
         if (j .gt. n)  go to 540
         do 530 k=j,n
            temp = cos*r(i,k)+sin*r(j,k)
            work = -sin*r(i,k)+cos*r(j,k)
            r(i,k) = temp
  530    r(j,k) = work
  540    do 550 k=1,m
            temp = cos*q(k,i)+sin*q(k,j)
            work = -sin*q(k,i)+cos*q(k,j)
            q(k,i) = temp
  550    q(k,j) = work
  560 continue
c     **********
c     check the stopping criteria
c     **********
      temp = 0.0d0
      do 570 i=1,n
  570 temp = temp+x(i)**2
      tolx = tols1*dsqrt(temp)+tols2
      if (dsqrt(alf*pn2) .le. tolx)  go to 650
      if(ssq.ge.2.d0*n) go to 590
      do 580 i=1,n
c*****
c     the stopping criterion is that no individual gradient be
c         greater than tol2
c*****
         if(dabs(efslst(i)).ge.tol2) go to 590
  580 continue
c#      write(6,730) ssq
      go to 660
  590 continue
      time2=time1
      time1=secmop()
      tcycle=time1-time2
      tleft=tleft-tcycle
      if(resfil)then
         write(mfgw,600)tleft,dsqrt(ssq),escf
  600    format('  restart file written,  time left:',f9.1,
     1' grad.:',f10.3,' heat:',g14.7)
         resfil=.false.
      else
         if(minprt) write(mfgw,610)icyc,dmin1(tcycle,9999.99d0),
     1dmin1(tleft,9999999.9d0),dmin1(dsqrt(ssq),999999.999d0),escf
         if(log) write(11,610)icyc,dmin1(tcycle,9999.99d0),
     1dmin1(tleft,9999999.9d0),dmin1(dsqrt(ssq),999999.999d0),escf
  610    format(' cycle:',i5,' time:',f6.1,' time left:',f9.1,
     1' grad.:',f10.3,' heat:',g14.7)
      endif
      if(tlast-tleft.gt.tdump)then
         tlast=tleft
         resfil=.true.
         do 620 i=1,n
  620    xlast(i)=x(i)
         iiium(1)=nscf
         call parsav(2,n,m)
      endif
      if(tleft .gt. tcycle*2) go to 60
  630 iiium(5)=ncount
      do 640 i=1,n
  640 xlast(i)=x(i)
      iiium(1)=nscf
      call parsav(1,n,m)
      iflepo=-1
      return
  650 write (mfgw,760)  ncount
      goto 870
  660 write (mfgw,770)  ncount
      goto 870
  670 continue
      write(mfgw,680) ixso
  680 format(1h ,5x,'attempt to go downhill is unsuccessful after',i5,5x
     1,'orthogonal searches')
      goto 870
c#  730 format(1h ,'final gradient =',f15.7)
c#  690 format(1h ,3x,'alf =',e12.4)
c#  700 format(1h ,3x,'ncount =',i5)
c#  710 format(3x,'time left:',f7.1,' cycle',i5,3x,'gnorm squared is'
c#     1,f13.5)
c#  720 format(4(5x,'x(',i2,') = ',e15.8))
c#  730 format(4(5x,'p(',i2,') = ',e15.8))
c#  740 format(5x,'r-matrix diagonal entries ...')
c#  750 format(6e13.3)
  760 format('0test on x satisfied, number of function calls = ',i5)
  770 format('0test on ssq satisfied, number of function calls = ',i5)
c#  780 format(' ///// next cycle is a side-step along the ',i2,
c#     1  '-th normal to p')
c#  790 format('0allowed number of function calls exceeded.'/
c#     1  ' number of function calls was ',i5)
c#  800 format('  l.-m. parameter = ',e15.7,
c#     1  '   sumsquares change = ',e15.7)
c#  810 format(1h )
c#  820 format(1h )
c#  830 format(1h ,3x,'i',7x,i2,9(10x,i2))
c#  840 format(1h ,1x,'x(i)',1x,f10.5,2x,9(f10.5,2x))
c#  850 format(1h ,1x,'g(i)',1x,f10.5,2x,9(f10.5,2x))
c#  860 format(1h ,1x,'p(i)',1x,f10.5,2x,9(f10.5,2x))
  870 last=1
      return
      end
      subroutine nuchar(line,value,nvalue)
      implicit REAL (a-h,o-z)
************************************************************************
*
*   nuchar  determins and returns the real values of all numbers
*           found in 'line'. all connected substrings are assumed
*           to contain numbers
*   on entry line    = character string
*   on exit  value   = array of nvalue real values
*
************************************************************************
      dimension value(40),istart(40)
      character*80 line
      character*1 tab,comma,space
      logical leadsp
      save comma, space
      data comma,space/',',' '/
      tab=char(9)
*
* clean out tabs and commas
*
      do 10 i=1,80
   10 if(line(i:i).eq.tab.or.line(i:i).eq.comma)line(i:i)=space
*
* find initial digit of all numbers, check for leading spaces followed
*     by a character
*
      leadsp=.true.
      nvalue=0
      do 20 i=1,80
         if (leadsp.and.line(i:i).ne.space) then
            nvalue=nvalue+1
            istart(nvalue)=i
         endif
         leadsp=(line(i:i).eq.space)
   20 continue
*
* fill number array
*
      do 30 i=1,nvalue
         value(i)=reada(line,istart(i))
   30 continue
      return
      end
      subroutine osinv (a,n,d)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      dimension a(*)
************************************************************************
*
*    osinv inverts a general square matrix of order up to maxorb. see
*          dimension statements below.
*
*   on input       a = general square matrix stored linearly.
*                  n = dimension of matrix a.
*                  d = variable, not defined on input.
*
*   on output      a = inverse of original a.
*                  d = determinant of original a, unless a was singular,
*                      in which case d = 0.0
*
************************************************************************
      dimension l(maxorb), m(maxorb)
************************************************************************
*
*    if the value of tol given here is unsuitable, it can be changed.
      tol=1.d-8
*
*
************************************************************************
      d=1.0d0
      nk=-n
      do 180 k=1,n
         nk=nk+n
         l(k)=k
         m(k)=k
         kk=nk+k
         biga=a(kk)
         do 20 j=k,n
            iz=n*(j-1)
            do 20 i=k,n
               ij=iz+i
c
c     10 follows
c
               if (dabs(biga)-dabs(a(ij))) 10,20,20
   10          biga=a(ij)
               l(k)=i
               m(k)=j
   20    continue
         j=l(k)
         if (j-k) 50,50,30
   30    ki=k-n
         do 40 i=1,n
            ki=ki+n
            holo=-a(ki)
            ji=ki-k+j
            a(ki)=a(ji)
   40    a(ji)=holo
   50    i=m(k)
         if (i-k) 80,80,60
   60    jp=n*(i-1)
         do 70 j=1,n
            jk=nk+j
            ji=jp+j
            holo=-a(jk)
            a(jk)=a(ji)
   70    a(ji)=holo
   80    if (dabs(biga)-tol) 90,100,100
   90    d=0.0d0
         return
  100    do 120 i=1,n
            if (i-k) 110,120,110
  110       ik=nk+i
            a(ik)=a(ik)/(-biga)
  120    continue
         do 150 i=1,n
            ik=nk+i
            ij=i-n
            do 150 j=1,n
               ij=ij+n
               if (i-k) 130,150,130
  130          if (j-k) 140,150,140
  140          kj=ij-i+k
               a(ij)=a(ik)*a(kj)+a(ij)
  150    continue
         kj=k-n
         do 170 j=1,n
            kj=kj+n
            if (j-k) 160,170,160
  160       a(kj)=a(kj)/biga
  170    continue
         d=dmin1(d*biga,1.d10)
         a(kk)=1.0d0/biga
  180 continue
      k=n
  190 k=k-1
      if (k) 260,260,200
  200 i=l(k)
      if (i-k) 230,230,210
  210 jq=n*(k-1)
      jr=n*(i-1)
      do 220 j=1,n
         jk=jq+j
         holo=a(jk)
         ji=jr+j
         a(jk)=-a(ji)
  220 a(ji)=holo
  230 j=m(k)
      if (j-k) 190,190,240
  240 ki=k-n
      do 250 i=1,n
         ki=ki+n
         holo=a(ki)
         ji=ki+j-k
         a(ki)=-a(ji)
  250 a(ji)=holo
      go to 190
  260 return
c
      end
      subroutine overlp(newmod,nvar)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      common /fmatrx/oldf(maxpar),d(maxpar),vmode(maxpar),
     1u(maxpar,maxpar),dd,mode,nstep,negreq,iprnt
      common/iofile/mfgr,mfgw
c
c  on the first step simply determine which mode to follow
c
      if(nstep.eq.1) then
c
         if(mode.gt.nvar)then
         write(mfgw,*)'error!! mode is larger than nvar',mode
_IF(ipsc,tools)
            call pend
_ELSE
            stop
_ENDIF
         endif
c
         it=mode
         write(mfgw,40) mode
c
      else
c
c  on subsequent steps determine which hessian eigenvector has
c  the greatest overlap with the mode we are following
c
         it=1
         tovlp=ddot(nvar,u(1,1),1,vmode,1)
         tovlp=dabs(tovlp)
         do 10 i=2,nvar
            ovlp=ddot(nvar,u(1,i),1,vmode,1)
            ovlp=dabs(ovlp)
            if(ovlp.gt.tovlp) then
               tovlp=ovlp
               it=i
            endif
   10    continue
c
         write(mfgw,30) tovlp
      endif
c
c  save the eigenvector in vmode
c
      do 20 i=1,nvar
         vmode(i)=u(i,it)
   20 continue
c
      newmod=it
      return
c
   30 format(5x,'overlap of current mode with previous mode is ',f12.6)
c
   40 format(5x,'hessian mode following switched on'/
     1     '     following mode ',i3)
c
      end
      subroutine ovlp(ic,iesp,is,ip,npr,nc,icd)
      implicit REAL (a-h,o-z)
c***********************************************************************
c
c     ovlp calculates the overlap integrals for a sto-6g basis set.
c     the resulting integrals are used in the deorthogonalization
c     process.
c     the code was written by b.h.besler and k.m.merz in feb. 1989
c     at ucsf.
c
c     on input:  ic = loop index
c                iesp = loop index
c                is = number of s orbitals
c                ip = number of p orbitals
c                npr = number of primitives
c                nc = number of contracted functions
c
c     on output: ovl is filled with the overlap integral value
c
c     for further info see: obara & saika j.chem.phys. 1986,84,3963
c***********************************************************************
      REAL  nai,nai1,nai2
INCLUDE(common/sizes)
      common /densty/ p(mpack),pa(mpack),pb(mpack)
      common /potesp/ xc,yc,zc,espnuc,espele,nesp
      common /abc/    co(3,numatm),ian(numatm),natom
      common /work1/
     +    potpt(3,mesp), es(mesp), esp(mesp), work1d(2*mesp)
      common /expont/ zs(107),zp(107),zd(107)
      common /sto6g/  allc(6,5,2),allz(6,5,2)
      common /espc/ cc(maxpr),cen(maxpr,3),iam(maxpr,2),ind(maxpr),
     1ex(maxpr),espi(maxorb,maxorb),fv(0:8,821),
     2fac(0:7),dex(-1:96),tf(0:2),
     3temp(maxpr),itemp(maxpr),ovl(maxorb,maxorb),xdmy(maxpr*6)
      common/x/ dx(maxpr),dy(maxpr),dz(maxpr),f1(maxpr,6),f2(maxpr,6),
     1td(maxpr),ce(maxpr,6),u(maxpr,6),exs(maxpr,6),expn(maxpr,6),
     2nai(maxpr,6),ewcx(maxpr,6),ewcy(maxpr,6),ewcz(maxpr,6),f0(maxpr,6)
     3,nai1(maxpr,6),nai2(maxpr,6)
      data bohr/0.529167d0/
c
c     calculate distance arrays
c
      pi=4.d0*datan(1.d0)
      ipr=ic*icd-icd+1
      istart=ipr
      do 10 i=istart,npr
         dx(i)=cen(ipr,1)-cen(i,1)
         dy(i)=cen(ipr,2)-cen(i,2)
         dz(i)=cen(ipr,3)-cen(i,3)
         td(i)=dx(i)**2+dy(i)**2+dz(i)**2
   10 continue
c
c     calculate exponent sum
c
      do 20 i=istart,npr
         do 20 j=1,icd
            exs(i,j)=1.d0/(ex(ipr+j-1)+ex(i))
            ce(i,j)=ex(ipr+j-1)*ex(i)*exs(i,j)
   20 continue
c
c     calculate exponent weighted centers
c
      do 30 i=istart,npr
         do 30 j=1,icd
            ewcx(i,j)=(ex(i)*cen(i,1)+ex(ipr+j-1)
     1*cen(ipr+j-1,1))*exs(i,j)
            ewcy(i,j)=(ex(i)*cen(i,2)+ex(ipr+j-1)
     1*cen(ipr+j-1,2))*exs(i,j)
            ewcz(i,j)=(ex(i)*cen(i,3)+ex(ipr+j-1)
     1*cen(ipr+j-1,3))*exs(i,j)
   30 continue
      do 40 i=1,npr
         do 40 j=1,icd
            expn(i,j)=dexp(-ce(i,j)*td(i))
            nai(i,j)=(pi*exs(i,j))**1.5d0*expn(i,j)
            expn(i,j)=nai(i,j)
   40 continue
c
c     calculate (s||p) esp integrals
c
      if((iam(ipr,1) .eq. 0) .and. (is .ne. ip)) then
         np=is+1
         do 80 i=np,npr
            do 80 j=1,icd
               go to (50,60,70),iam(i,2)
   50          nai(i,j)=(ewcx(i,j)-cen(i,1))*expn(i,j)
               go to 80
   60          nai(i,j)=(ewcy(i,j)-cen(i,2))*expn(i,j)
               go to 80
   70          nai(i,j)=(ewcz(i,j)-cen(i,3))*expn(i,j)
   80    continue
      endif
c
c     calculate (p||s) esp integrals
c
      if((iam(ipr,1) .eq. 1) .and. (is .ne. ip)) then
         np=is+1
         do 120 i=       istart,npr
            do 120 j=1,icd
               go to (90,100,110),iam(ipr+j-1,2)
   90          nai(i,j)=(ewcx(i,j)-cen(ipr+j-1,1))*expn(i,j)
               go to 120
  100          nai(i,j)=(ewcy(i,j)-cen(ipr+j-1,2))*expn(i,j)
               go to 120
  110          nai(i,j)=(ewcz(i,j)-cen(ipr+j-1,3))*expn(i,j)
  120    continue
      endif
c
c     calculate (p||p) esp integrals
c
      if((iam(ipr,1) .eq. 1) .and. (is .ne. ip)) then
         do 160 i=istart,npr
            do 160 j=1,icd
               go to (130,140,150),iam(i,2)
  130          nai(i,j)=(ewcx(i,j)-cen(i,1))*nai(i,j)
               if(iam(ipr+j-1,2) .eq. iam(i,2))
     1nai(i,j)=nai(i,j)+exs(i,j)*0.5d0
     2      *expn(i,j)
               go to 160
  140          nai(i,j)=(ewcy(i,j)-cen(i,2))*nai(i,j)
               if(iam(ipr+j-1,2) .eq. iam(i,2))
     1nai(i,j)=nai(i,j)+exs(i,j)*0.5d0
     2      *expn(i,j)
               go to 160
  150          nai(i,j)=(ewcz(i,j)-cen(i,3))*nai(i,j)
               if(iam(ipr+j-1,2) .eq. iam(i,2))
     1nai(i,j)=nai(i,j)+exs(i,j)*0.5d0
     2      *expn(i,j)
  160    continue
      endif
      ips=ic*icd-icd+1
      do 180 i=ic,nc
         jps=i*icd-icd+1
         ovl(ic,i)=0.d0
         do 170 j=jps,jps+icd-1
            do 170 k=ips,ips+icd-1
               ovl(ic,i)=ovl(ic,i)+cc(j)*cc(k)*nai(j,k-ips+1)
  170    continue
         ovl(i,ic)=ovl(ic,i)
  180 continue
      return
      end
      subroutine parsav(mode,n,m)
      implicit REAL (a-h,o-z)
_IF(ipsc,tools)
      logical oroot
_ENDIF
INCLUDE(common/sizes)
INCLUDE(../m4/common/utilc)
**********************************************************************
*
*   parsav saves and restores data used in nllsq gradient minimization.
*
*    if mode is 0 data are restored, if 1 then saved.
*
**********************************************************************
      common /densty/ p(mpack), pa(mpack), pb(mpack)
      common/iofile/mfgr,mfgw
      common /alparm/ alparm(3,maxpar),x0, x1, x2, iloop
      common /keywrd/ keywrd
      common /elemts/ elemnt(107)
      common /errfn/ errfn(maxpar), aicorr(maxpar)
      common /geosym/ ndep,locpar(maxpar),idepfn(maxpar),
     1                     locdep(maxpar)
      common /geokst/ natoms,labels(numatm),
     1                na(numatm),nb(numatm),nc(numatm)
      common /cmpg/ geo(3,numatm)
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),
     1                nlast(numatm), norbs, nelecs,nalpha,nbeta,
     2                nclose,nopen,ndumy,fract
      common /nllcom/ q(maxpar,maxpar),r(maxpar,maxpar*2)
      common /nllco2/ dddum(6),efslst(maxpar),xlast(maxpar),iiium(7)
      common /geovar/ nvar,loc(2,maxpar), jdumy, dumy(maxpar)
      common /locvar/ locvar(2,maxpar)
      common /valvar/ valvar(maxpar),numvar
      dimension coord(3,numatm)
      character elemnt*2, keywrd*241, getmop*80
      latom=0
      lparam=0
_IF(ipsc,tools)
      if(oroot().and.odumpm) then
_ELSE
      if(odumpm) then
_ENDIF
      open(unit=9,file=getmop(3),
     +     status='unknown',form='unformatted')
      rewind 9
      open(unit=10,file=getmop(4),
     +     status='unknown',form='unformatted')
      rewind 10
      endif
      if(mode.ne.0) goto 10
*
*  mode=0: retrieve data from disk.
*
_IF(ipsc,tools)
      if(oroot()) then
_ENDIF
      read(9,end=30,err=30)iiium,dddum,efslst,n,(xlast(i),i=1,n),m
      read(9)((q(j,i),j=1,m),i=1,m)
      read(9)((r(j,i),j=1,n),i=1,n)
      read(9)(valvar(i),i=1,n)
      if(index(keywrd,'aider').ne.0) read(9)(aicorr(i),i=1,n)
_IF(ipsc,tools)
      else
      write(mfgw,*)' restarts not available in parsav'
      go to 21
      endif
_ENDIF
      return
   10 continue
      if(mode.eq.1)then
      write(mfgw,'(//10x,'' **** time up ****'')')
      write(mfgw,'(//10x,'' current values of geometric variables'',//)'
     1)
         if(na(1) .eq. 99) then
c
c  convert from cartesian coordinates to internal
c
            do 20 i=1,natoms
               do 20 j=1,3
   20       coord(j,i)=geo(j,i)
            call mopxyz(coord,numat,na,nb,nc,1.d0,geo)
         endif
         call geout(6)
         write(mfgw,'(//10x,
     1''to restart calculation use the keyword "restart".'')')
      endif
_IF(ipsc,tools)
      if(oroot().and.odumpm) then
_ELSE
      if(odumpm) then
_ENDIF
      write(9)iiium,dddum,efslst,n,(xlast(i),i=1,n),m
      write(9)((q(j,i),j=1,m),i=1,m)
      write(9)((r(j,i),j=1,n),i=1,n)
      write(9)(valvar(i),i=1,n)
      if(index(keywrd,'aider').ne.0) write(9)(aicorr(i),i=1,n)
c*****
c     the density matrix is required by iter upon restart .
c
      linear=(norbs*(norbs+1))/2
      write(10)(pa(i),i=1,linear)
      if(nalpha.ne.0)write(10)(pb(i),i=1,linear)
c*****
      close(9)
      close(10)
      endif
      return
   30 write(mfgw,'(//10x,''no restart file exists!'')')
_IF(ipsc,tools)
   21 call pend
_ELSE
      stop
_ENDIF
      end
      subroutine partxy(c34,pq34)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      dimension c34(*),pq34(*)
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),
     1                nlast(numatm), norbs, nelecs,nalpha,nbeta,
     2                nclose,nopen,ndumy,fract
      common /wmatrc/ wj(n2elec), wk(n2elec)
      common /twoele/ gss(107),gsp(107),gpp(107),gp2(107),hsp(107)
     2               ,gsd(107),gpd(107),gdd(107)
      common /keywrd/ keywrd
      common /numcal/ numcal
      dimension w(n2elec*2)
      equivalence (w,wj)
      REAL  wj, wk
      character*241 keywrd
c------------------------------------------------------------------
c
c    partxy works out  in mndo formalism the first 2-indices transfo.
c          required in the computation of 2-electrons repulsion over m.o
c  input
c     c34   : vector of the current charge distribution between two m.o.
c  output
c     pq34(pq) : <p(1),q(1)|c3(2),c4(2)> where p ,q  are a.o.
c                                          and c3,c4 are m.o.
c                p and q run in canonical order over the a.o belonging
c                to an atom 'a' only (basic assumption of mndo scheme)
c                and 'a' runs over the atoms of the system.
c     d.l. (dewar group) 1986
c----------------------------------------------------------------------
      dimension ld(9),ptot(numatm), nb(0:8), indx(numatm)
      data ld /0,2,5,9,14,20,27,35,44/
      data nb /1,0,0,10,0,0,0,0,45/
      save icalcn
      data icalcn/0/
      if(numcal.ne.icalcn)then
         icalcn=numcal
         indx(1)=1
         do 10 i=2,numat
   10    indx(i)=indx(i-1)+nb(nlast(i-1)-nfirst(i-1))
      endif
c     ij    : pointer of canonical packed location of couple ij.
c     kk    : pointer of supporting atom, sparkles skipped out.
c     ipqrs : current entry point in the <pq|rs> file.
      kk=0
      ipqrs=1
      ij=0
      ijold=0
c
c     loop over outer atom a, sparkles excluded.
c     ------------------------------------------
      nband=1
      kr=1
      ls=0
      do 30 ii=1,numat
         ia=nfirst(ii)
         ib=nmidle(ii)
         ic=nlast (ii)
         if(ic.lt.ia) go to 30
         kk=kk+1
         ls=ls+nband
         nband=nb(ic-ia)
         ij=ij+nband
c
c     pq34(ij) = <ij|kl> * c34(kl)  , 1-centre contributions.
         izn=nat(ii)
c     block ss
         ptot(kk)=c34(ls)
         pq34(ls)=c34(ls)*gss(izn)*0.25d0
         if(ib.gt.ia) then
c        block sp and pp
            hpp=0.5d0*(gpp(izn)-gp2(izn))
            lx=ls+ld(2)
            ly=ls+ld(3)
            lz=ls+ld(4)
            pp=c34(lx)+c34(ly)+c34(lz)
            pq34(ls+1)=hsp(izn)*c34(ls+1)
            pq34(lx  )=gpp(izn)*c34(lx  )*0.25d0
            pq34(ls+3)=hsp(izn)*c34(ls+3)
            pq34(ls+4)=hpp     *c34(ls+4)
            pq34(ly  )=gpp(izn)*c34(ly  )*0.25d0
            pq34(ls+6)=hsp(izn)*c34(ls+6)
            pq34(ls+7)=hpp     *c34(ls+7)
            pq34(ls+8)=hpp     *c34(ls+8)
            pq34(lz  )=gpp(izn)*c34(lz  )*0.25d0
            gspss=     gsp(izn)*c34(ls  )*0.25d0
            pq34(ls)=pq34(ls)+gsp(izn)*pp*0.25d0
            pq34(lx)=pq34(lx)+gp2(izn)*(c34(ly)+c34(lz))*0.25d0+gspss
            pq34(ly)=pq34(ly)+gp2(izn)*(c34(lz)+c34(lx))*0.25d0+gspss
            pq34(lz)=pq34(lz)+gp2(izn)*(c34(lx)+c34(ly))*0.25d0+gspss
            ptot(kk)=ptot(kk)+pp
            if(ic.gt.ib) then
c           block sd, pd and dd
c           --- waiting for 'd' parameters ---
c               take care : diagonal elements of c34 are doubled.
            endif
         endif
         if(kk.gt.1)then
c
c        loop over charge distribution of inner atoms  b < a .
c        -----------------------------------------------------
c        pq34(ij)=<ij|kl>*c34(kl) 2-centres contributions.
c
            jband=1
            js=0
            do 20 jj=1,ii-1
               js=js+jband
               jband=nb(nlast(jj)-nfirst(jj))
c
c   nband and jband are either 1 or 10
c
               call formxy
     1(w(kr), kr, pq34(ls), pq34(js), c34(ls), nband, c34(js), jband)
   20       ipqrs=ipqrs+ijold
         endif
         ijold=ij
   30 continue
      return
      end
      subroutine pathk
      implicit REAL (a-h,o-z)
_IF(ipsc,tools)
      logical oroot
_ENDIF
INCLUDE(common/sizes)
************************************************************************
*
*                written by manyin yi, aug 1989.
*       restartable reaction_path calulation.
*       the number of path_step and step value are read in through
*       keyword point and step.
*       the reaction profile is archived.
*
************************************************************************
      common /cmpg/ geo(3,numatm)
      common /geovar/ nvar,loc(2,maxpar), idumy, xparam(maxpar)
      common /gradnt/ grad(maxpar),gnorm
      common /gravec/ cosine
      common /path/ latom, lparam, react(200)
      common /pparam/ currt
      common /kloop/ kloop
      common /profilm/ profil
      common /keywrd/ keywrd
      common/iofile/mfgr,mfgw
      dimension gd(maxpar),xlast(maxpar),mdfp(20),xdfp(20)
      dimension profil(200)
      character keywrd*241, getmop*80
      step=reada(keywrd,index(keywrd,'step')+5)
      npts=reada(keywrd,index(keywrd,'point')+6)
c
c  the smallest value in the path is
c      react(1) degree or geo(lparam,latom) radians
c
      degree=180.d0/3.14159265359d0
      if(lparam.ne.1)step=step/degree
c
c  now to sweep through the path
c
      if(lparam.ne.1) then
         c1=degree
      else
         c1=1.d0
      endif
c
      kloop=1
      cputot=0.0d0
      currt=geo(lparam,latom)
      profil(1)=0.d0
      if (index(keywrd,'restart').ne.0) then
         mdfp(9)=0
         call dfpsav(cputot,xparam,gd,xlast,escf,mdfp,xdfp)
      write(mfgw,'(//10x,'' restarting at point '',i3)') kloop
      endif
c
      geo(lparam,latom)=currt
      do 10 iloop=kloop,npts
         cpu1=secmop()
         currt=geo(lparam,latom)
         call flepo(xparam, nvar, escf)
         kloop=kloop+1
         cpu2=secmop()
         cpu3=cpu2-cpu1
         cputot=cputot+cpu3
         profil(iloop)=escf
         write(mfgw,'(/''          variable        function'')')
         write(mfgw,
     +  '('' :'',f16.5,f16.6)')geo(lparam,latom)*c1,escf
         call geout(6)
         geo(lparam,latom)=geo(lparam,latom)+step
   10 continue
      do 20 i=2,npts
   20 react(i)=react(i-1)+step*c1
      write(mfgw,'(/16x,''points on reaction path '',
     1          /16x,''and corresponding heats'',//)')
_IF(ipsc,tools)
      if(oroot()) then
_ENDIF
      open(unit=12,form='formatted',file=getmop(6),
     +             status='unknown')
      write(12,30)
      call wrttxt(12)
   30 format(' archive file for path calculation'/
     1 'a profil of coordinates - heats'/)
      write(12,'(/'' total cpu time in flepo : '',f10.3/)') cputot
c
      l=npts/8
      m=npts - l*8
      if (l.lt.1) go to 50
      do 40 k=0,l-1
         write(mfgw,'(8f7.2)') (react(i),i=k*8+1,k*8+8)
         write(mfgw,'(8f7.2,/)') (profil(i),i=k*8+1,k*8+8)
         write(12,'(8f7.2)') (react(i),i=k*8+1,k*8+8)
   40 write(12,'(8f7.2,/)') (profil(i),i=k*8+1,k*8+8)
   50 if (m.gt.0) then
         write(mfgw,'(8f7.2)') (react(i),i=l*8+1,l*8+m)
         write(mfgw,'(8f7.2,/)') (profil(i),i=l*8+1,l*8+m)
         write(12,'(8f7.2)') (react(i),i=l*8+1,l*8+m)
         write(12,'(8f7.2,/)') (profil(i),i=l*8+1,l*8+m)
      endif
_IF(ipsc,tools)
      endif
_ENDIF
      return
      end
      subroutine pdgrid
c
c     routine to calculate williams surface
c
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      dimension vderw(53),dist(100)
      dimension xmin(3),xmax(3),coord(3,numatm)
      common /cmpg/   geo(3,numatm)
      common /geokst/ natoms,labels(numatm), nabc(3*numatm)
c
      common /abc/    co(3,numatm),ian(numatm),natom
      common /work1/    potpt(3,mesp), work1d(4*mesp)
      common /potesp/ xc,yc,zc,espnuc,espele,nesp
      common/iofile/mfgr,mfgw
c
      data vderw/53*0.0d0/
      vderw(1)=2.4d0
      vderw(5)=3.0d0
      vderw(6)=2.9d0
      vderw(7)=2.7d0
      vderw(8)=2.6d0
      vderw(9)=2.55d0
      vderw(15)=3.1d0
      vderw(16)=3.05d0
      vderw(17)=3.0d0
      vderw(35)=3.15d0
      vderw(53)=3.35d0
      shell=1.2d0
      nesp=0
      grdd=0.8d0
      closer=0.d0
c     check if vderw is defined for all atoms
c
c     convert internal to cartesian coordinates
c
      call gmetry(geo,coord)
c
c     strip coordinates and atom label for dummies (i.e. 99)
c
      icntr = 0
      do 20 i=1,natoms
         do 10 j=1,3
   10    co(j,i) = coord(j,i)
         if(labels(i) .eq. 99) goto 20
         icntr = icntr + 1
         ian(icntr) = labels(i)
   20 continue
      natom=icntr
c
      do 30 i=1,natom
         j=ian(i)
         if (vderw(j).eq.0.0d0) go to 40
   30 continue
      go to 50
   40 continue
      write(mfgw,*) 'van der waals'' radius not defined for atom',i
      write(mfgw,*) 'in williams surface routine pdgrid!'
_IF(ipsc,tools)
      call pend
_ELSE
      stop
_ENDIF
c     now create limits for a box
   50 do 100 ix = 1,3
         xmin(ix)= 100000.0d0
         xmax(ix)=-100000.0d0
         do 90 ia = 1,natom
            if (co(ix,ia)-xmin(ix))60,70,70
   60       xmin(ix)=co(ix,ia)
   70       if (co(ix,ia)-xmax(ix))90,90,80
   80       xmax(ix)=co(ix,ia)
   90    continue
  100 continue
c     add (or subtract) the maximum vderw plus shell
      vdmax=0.0d0
      do 110 i=1,53
         if (vderw(i).gt.vdmax) vdmax=vderw(i)
  110 continue
      do 120 i=1,3
         xmin(i)=xmin(i)-vdmax-shell
  120 xmax(i)=xmax(i)+vdmax+shell
c step grid back from zero to find starting points
      xstart=0.0d0
  130 xstart=xstart-grdd
      if (xstart.gt.xmin(1)) go to 130
      ystart=0.0d0
  140 ystart=ystart-grdd
      if (ystart.gt.xmin(2)) go to 140
      zstart=0.0d0
  150 zstart=zstart-grdd
      if (zstart.gt.xmin(3)) go to 150
      npnt=0
      zgrdd=zstart
  160 ygrdd=ystart
  170 xgrdd=xstart
  180 do 190 l=1,natom
         jz=ian(l)
         dist(l)=dsqrt((co(1,l)-xgrdd)**2+(co(2,l)-ygrdd)**2+
     1 (co(3,l)-zgrdd)**2)
c     reject grid point if any atom is too close
         if(dist(l).lt.(vderw(jz)-closer)) go to 220
  190 continue
c but at least one atom must be close enough
      do 200 l=1,natom
         jz=ian(l)
         if(dist(l).gt.(vderw(jz)+shell)) go to 200
         go to 210
  200 continue
      go to 220
  210 npnt=npnt+1
      nesp=nesp+1
      potpt(1,nesp)=xgrdd
      potpt(2,nesp)=ygrdd
      potpt(3,nesp)=zgrdd
  220 xgrdd=xgrdd+grdd
      if (xgrdd.le.xmax(1)) go to 180
      ygrdd=ygrdd+grdd
      if (ygrdd.le.xmax(2)) go to 170
      zgrdd=zgrdd+grdd
      if (zgrdd.le.xmax(3)) go to 160
      return
      end
      subroutine perm(iperm,nels,nmos,maxmos,nperms)
      dimension iperm(maxmos,60), iadd(20), nel(20)
      common/iofile/mfgr,mfgw
************************************************************************
*
*  perm permutes nels entities among nmos locations. the entities and
*       locations are each indistinguishable. the pauli exclusion
*       principle is followed. the number of states produced is given
*       by nmos!/(nels!*(nmos-nels)!).
* on input: nels  = number of indistinguishable entities
*           nmos  = number of indistinguishable locations
*
* on output iperm = array of permutations, a 0 indicates no entity,
*                   a 1 indicates an entity.
*           nperm = number of permutations.
*
************************************************************************
      if(nels.gt.nmos)then
      write(mfgw,'('' number of particles,'',i3,'' greater than no. '',
     1''of states,'',i3)')nels,nmos
         nperms=0
         return
      endif
      nperms=1
      do 10 i=1,20
   10 nel(i)=1000
      do 20 i=1,nels
   20 nel(i)=1
      do 50 i12=1-12+nels,nmos,nel(12)
         iadd(12)=i12
         do 50 i11=i12+1,nmos,nel(11)
            iadd(11)=i11
            do 50 i10=i11+1,nmos,nel(10)
               iadd(10)=i10
               do 50 i9=i10+1,nmos,nel(9)
                  iadd(9)=i9
                  do 50 i8=i9+1,nmos,nel(8)
                     iadd(8)=i8
                     do 50 i7=i8+1,nmos,nel(7)
                        iadd(7)=i7
                        do 50 i6=i7+1,nmos,nel(6)
                           iadd(6)=i6
                           do 50 i5=i6+1,nmos,nel(5)
                              iadd(5)=i5
                              do 50 i4=i5+1,nmos,nel(4)
                                 iadd(4)=i4
                                 do 50 i3=i4+1,nmos,nel(3)
                                    iadd(3)=i3
                                    do 50 i2=i3+1,nmos,nel(2)
                                       iadd(2)=i2
                                       do 50 i1=i2+1,nmos,nel(1)
                                          iadd(1)=i1
                                          do 30 j=1,nmos
   30                                     iperm(j,nperms)=0
                                          do 40 j=1,nels
   40                                     iperm(iadd(j),nperms)=1
                                          nperms=nperms+1
                                          if(nperms.gt.61)then
                                          write(mfgw,'('' number of perm
     1utations too great, limit 60'')')
                                             goto 60
                                          endif
   50 continue
   60 nperms=nperms-1
      return
      end
      subroutine polar
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
c**********************************************************************
c
c   polar sets up the calculation of the molecular electric response
c   properties by ffhpol.
c
c**********************************************************************
      character*2 elemnt
      common /titles/ koment,title
      common /polvol/ polvol(107)
      common /keywrd/ keywrd
      common /geokst/ natoms,labels(numatm),
     1                na(numatm),nb(numatm),nc(numatm)
      common /geovar/ nvar,loc(2,maxpar),idumy,xparam(maxpar)
      common /scftyp/ emin,limscf
      common /timem/ time0
      common /elemts/ elemnt(107)
      common /corec/ core(107)
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),
     1                nlast(numatm), norbs, nelecs,nalpha,nbeta,
     2                nclose,nopen,ndumy,fract
      common /geosym/ ndep, locpar(maxpar), idepfn(maxpar),
     1                    locdep(maxpar)
      common /cmpg/ geo(3,numatm)
      common /last/ last
      common /coord/ coord(3,numatm)
      common /euler/ tvec(3,3),idtvec
      common /scrach/ rxyz(mpack),xdumy(maxpar**2-mpack)
      common/iofile/mfgr,mfgw
      dimension grad(maxpar),rotvec(3,3),dipvec(3),
     1          tempv(3,3)
      character  keywrd*241, type*7, koment*81, title*81
      logical let, limscf
      type=' mndo  '
      limscf=.false.
      let=(index(keywrd,'let').ne.0)
      if(index(keywrd,'mindo') .ne. 0) type='mindo/3'
      if(index(keywrd,'am1') .ne. 0)    type='  am1  '
      write (mfgw,10)
   10 format ('1',20('*'),' finite-field polarizabilities ',
     1        20('*'),//,
     2      '    the f-f method is performed using both an energy',/,
     3      '    and dipole moment expansion.  these results are',/,
     4      '    listed below as "e4" and "dip", respectively.')
      call gmetry(geo,coord)
c
c  orient the molecule with the moments of inertia.
c  this is done to ensure a unique, reproduceable set of directions.
c  if let is specified, the input orientation will be used.
c
      if (.not.let) then
         mass = 1.0d00
         call axis (coord,numat,a,b,c,sumw,mass,rotvec)
         write (mfgw,20)
   20    format (/' rotation matrix for orientation of molecule:'/)
         do 40 i = 1,3
            write (mfgw,30) (rotvec(i,j),j=1,3)
   30       format (5x,3f12.6)
   40    continue
c
c  rotate atoms
c
         do 70 i = 1,numat
            do 60 j = 1,3
               sum = 0.0d00
               do 50 k = 1,3
                  sum = sum + coord(k,i)*rotvec(k,j)
   50          continue
               geo(j,i) = sum
   60       continue
   70    continue
         do 90 i = 1,numat
            do 80 j = 1,3
               coord(j,i) = geo(j,i)
   80       continue
   90    continue
         write(mfgw,'(//10x,''cartesian coordinates '',/)')
         write(mfgw,'(4x,''no.'',7x,''atom'',9x,''x'',
     1  9x,''y'',9x,''z'',/)')
         l=0
         do 100 i=1,numat
            if(nat(i).eq.99.or.nat(i).eq.107) goto 100
            l=l+1
            write(mfgw,'(i6,8x,a2,4x,3f10.4)')
     1           l,elemnt(nat(i)),(coord(j,l),j=1,3)
  100    continue
c
c  if polymer, rotate tvec
c  (beware:  the polymer sections may not work yet)
c
         if (idtvec.gt.0) then
            do 130 i = 1,idtvec
               do 120 j = 1,3
                  sum = 0.0d00
                  do 110 k = 1,3
                     sum = sum + tvec(k,i)*rotvec(k,j)
  110             continue
                  tempv(j,i) = sum
  120          continue
  130       continue
            do 150 i = 1,3
               do 140 j = 1,idtvec
                  tvec(i,j) = tempv(i,j)
  140          continue
  150       continue
            write (mfgw,160) ((tvec(j,i),j=1,3),i=1,idtvec)
  160       format (/' new translation vector:'/,
     1           ' ',3(3f15.5))
         endif
      endif
c
      last=1
      na(1)=99
c
c  set up the variables in xparam and loc, these are in cartesian
c  coordinates.
c
      ndep=0
      numat=0
      sumx=0.d0
      sumy=0.d0
      sumz=0.d0
      do 180 i=1,natoms
         if((labels(i).ne.99).and.(labels(i).ne.107)) then
            numat=numat+1
            labels(numat)=labels(i)
            sumx=sumx+coord(1,numat)
            sumy=sumy+coord(2,numat)
            sumz=sumz+coord(3,numat)
            do 170 j=1,3
  170       geo(j,numat)=coord(j,numat)
         endif
  180 continue
      sumx=sumx/numat
      sumy=sumy/numat
      sumz=sumz/numat
      summax=0.d0
      atpol=0.d0
      do 190 i=1,numat
         if (labels(i).ne.107) then
            atpol=atpol+polvol(labels(i))
         endif
         geo(1,i)=geo(1,i)-sumx
         if(summax.lt.dabs(geo(1,i))) summax=dabs(geo(1,i))
         geo(2,i)=geo(2,i)-sumy
         if(summax.lt.dabs(geo(2,i))) summax=dabs(geo(2,i))
         geo(3,i)=geo(3,i)-sumz
         if(summax.lt.dabs(geo(3,i))) summax=dabs(geo(3,i))
  190 continue
c
      nvar=0
      natoms = numat
      call compfg(geo, .true., heat0, .true., grad, .false.)
      write (mfgw,200) heat0
  200 format (//' energy of "reoriented" system without field:',
     1        f20.10)
c
      call ffhpol (heat0,atpol,dipvec)
c
      return
      end
      subroutine potcal
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
c***********************************************************************
c
c     this routine calculates the total electrostatic potential
c     the nuclear contribution is evaluated by nucpot
c     the electronic contribution is evaluated by elesp
c     espfit fits the quantum potential to a classical point charge
c     model.
c     this routine was written by b.h.besler and k.m.merz in feb.
c     1989 at ucsf
c
c***********************************************************************
      common /keywrd/ keywrd
      common/iofile/mfgr,mfgw
      common /corec/ tore(107)
      common /elemts/ elemnt(107)
      common /densty/ p(mpack),pa(mpack),pb(mpack)
      common /potesp/ xc,yc,zc,espnuc,espele,nesp
      common /work1/
     +    potpt(3,mesp), es(mesp), esp(mesp), work1d(2*mesp)
      common /abc/    co(3,numatm),ian(numatm),natom
      common /dipsto/ ux,uy,uz,ch(numatm)
      common /espf/  al((numatm+4)**2),a(numatm,numatm),b(numatm),
     1q(numatm+4),qsc(numatm+4),cf, espfd(maxorb**2-numatm-5)
      character*241 keywrd
      character *2  elemnt
      logical debug,cequiv(numatm,numatm)
c
c     debug printing - results in copious output
c
      debug = (index(keywrd,'debug') .ne. 0)
c
c
      call elesp
c
c     don't bother fitting quantum potential to points for sybcnt
      if(index(keywrd,'sybcnt') .ne. 0) then
      write(mfgw,'(//12x,''sybyl contouring data written'',/)')
      write(mfgw,'(//12x,''use espgrid to convert .grd file.'',/)')
         return
      endif
c
c
      bohr = 0.529167d00
c
c     now fit the electrostatic potential
c
      write(mfgw,'(//12x,''electrostatic potential charges'',/)')
      iz=0
      if(index(keywrd,'charge=') .ne. 0) iz=reada(keywrd,index(keywrd,
     1'charge='))
c
c     dipolar constraints if desired
c
      if(index(keywrd,'dipole') .ne. 0) then
         idip = 1
         if(iz .ne. 0)then
            idip = 0
            write(mfgw,'(/12x,''  dipole constraints not used'')')
            write(mfgw,'(12x,''        charged molecule'',/)')
         endif
      else
         idip = 0
      endif
      if (idip .eq. 1) then
         write(mfgw,'(/12x,''dipole constraints will be used'',/)')
      endif
c
c     get x,y,z dipole components if desired
c
      if(index(keywrd,'dipx=') .ne. 0) then
         dx = reada(keywrd,index(keywrd,'dipx='))
      else
         dx = ux
      endif
      if(index(keywrd,'dipy=') .ne. 0) then
         dy = reada(keywrd,index(keywrd,'dipy='))
      else
         dy = uy
      endif
      if(index(keywrd,'dipz=') .ne. 0) then
         dz = reada(keywrd,index(keywrd,'dipz='))
      else
         dz = uz
      endif
      call espfit(idip,natom,nesp,iz,esp,potpt,co,dx,dy,dz,rms,rrms)
c
c     write out our results to channel 6
c     the charges are scaled to reproduce 6-31g* charges for mndo only
c     am1 and mindo/3 charges are not scaled due to the low coorelation
c     coefficient. see besler,merz,kollman in j. comput. chem.
c     (in press)
c
      if((index(keywrd,'am1') .ne. 0) .or.
     1(index(keywrd,'mindo') .ne. 0) .or.
     2(index(keywrd,'pm3') .ne. 0))then
         write(mfgw,'(15x,''atom no.    type    charge'')')
         do 10 i=1,natom
         write(mfgw,'(17x,i2,9x,a2,1x,f10.4)')i,elemnt(ian(i)),q(i)
   10    continue
c     writes out esp charges to mmod file
      open(unit=32,status='unknown',form='formatted')
      do 11 i=1,natom
      write (32,'(f10.5)')q(i)
   11 continue
      else
c
c     mndo calculation-scale the charges. test for slope keyword
c
         if(index(keywrd,'slope=') .ne. 0) then
            slope = reada(keywrd,index(keywrd,'slope='))
         else
            slope = 1.422d0
         endif
         do 20 i=1,natom
            qsc(i) = slope*q(i)
   20    continue
         write(mfgw,
     +  '(7x,''atom no.    type    charge   scaled charge'')')
         do 30 i=1,natom
            write(mfgw,
     +  '(9x,i2,9x,a2,1x,f10.4,2x,f10.4)')i,elemnt(ian(i
     1)),   q(i),qsc(i)
   30    continue
      endif
      write(mfgw,
     +  '(/12x,a,4x,i6)') 'the number of points is:',nesp
      write(mfgw,
     +  '(12x,a,4x,f9.4)') 'the rms deviation is:',rms
      write(mfgw,
     + '(12x,a,3x,f9.4)') 'the rrms deviation is:',rrms
c
c     calculate dipole moment if neutral molecule
c
      if (iz .ne. 0) then
         go to 60
      else
         write(mfgw,40)
   40    format (//5x,'dipole moment evaluated from '
     1,'the point charges',/)
         do 50 i=1,natom
            dipx=dipx+co(1,i)*q(i)/bohr
            dipy=dipy+co(2,i)*q(i)/bohr
            dipz=dipz+co(3,i)*q(i)/bohr
   50    continue
         dip=dsqrt(dipx**2+dipy**2+dipz**2)
         write(mfgw,
     +  '(12x,'' x        y        z       total'')')
         write(mfgw,
     +  '(8x,4f9.4)')dipx*cf,dipy*cf,dipz*cf,dip*cf
      endif
   60 continue
c     determine which charges should be equivalent by symmetry and
c     average them if desired
      if(index(keywrd,'symavg') .ne. 0) then
         do 70 i=1,natom
            do 70 j=1,natom
               cequiv(i,j)=.false.
               if(dabs(abs(ch(i))-dabs(ch(j))) .lt. 1.d-5)  
     +              cequiv(i,j)=.true.
   70    continue
         do 90 i=1,natom
            ieq=0
            qsc(i)=0.d0
            do 80 j=1,natom
               if(cequiv(i,j)) then
                  qsc(i)=qsc(i)+dabs(q(j))
                  ieq=ieq+1
               endif
   80       continue
            ch(i)=q(i)/dabs(q(i))*qsc(i)/ieq
   90    continue
      write(mfgw,*) ' '
      write(mfgw,*)'   electrostatic potential charges averaged for'
      write(mfgw,*)'   symmetry equivalent atoms'
      write(mfgw,*) ' '
         if((index(keywrd,'am1') .ne. 0) .or.
     1(index(keywrd,'mindo') .ne. 0) .or.
     2(index(keywrd,'pm3') .ne. 0))then
         write(mfgw,'(7x,''atom no.    type    charge'')')
            do 100 i=1,natom
            write(mfgw,'(9x,i2,9x,a2,1x,f10.4)')i,elemnt(ian(i)),
     1   ch(i)
  100       continue
         else
         write(mfgw,'(7x,''atom no.    type    charge   scaled charge'')
     1')
            do 110 i=1,natom
            write(mfgw,'(9x,i2,9x,a2,1x,f10.4,2x,f10.4)')i,elemnt(ia
     1n(i)),   ch(i),ch(i)*slope
  110       continue
         endif
      endif
      return
      end
      subroutine powsav(hess, grad, xparam, pmat, iloop, bmat, ipow)
      implicit REAL (a-h,o-z)
_IF(ipsc,tools)
      logical oroot
_ENDIF
INCLUDE(common/sizes)
INCLUDE(../m4/common/utilc)
      dimension hess(maxpar,*),grad(*),bmat(maxpar,*),ipow(9),
     1 xparam(*), pmat(*)
**********************************************************************
*
* powsav stores and restores data used in the sigma geometry
*        optimisation.
*
*  on input hess   = hessian matrix, partial or whole.
*           grad   = gradients.
*           xparam = current state of parameters.
*           iloop  = index of hessian, or flag of point reached so-far.
*           bmat   = "b" matrix!
*           ipow   = indices and flags.
*           ipow(9)= 0 for restore, 1 for dump
*
**********************************************************************
      common /geovar/ nvar,loc(2,maxpar), idumy, dumy(maxpar)
      common /errfn/ errfn(maxpar), aicorr(maxpar)
      common /elemts/ elemnt(107)
      common /geosym/ ndep,locpar(maxpar),idepfn(maxpar),
     1                     locdep(maxpar)
      common /geokst/ natoms,labels(numatm),
     1                na(numatm),nb(numatm),nc(numatm)
      common /cmpg/ geo(3,numatm)
      common /locvar/ locvar(2,maxpar)
      common /keywrd/ keywrd
      common /valvar/ valvar(maxpar),numvar
      dimension coord(3,numatm)
      character elemnt*2, keywrd*241, getmop*80
      common /densty/ p(mpack), pa(mpack), pb(mpack)
      common /alparm/ alparm(3,maxpar),x0, x1, x2, jloop
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),
     1                nlast(numatm), norbs, nelecs,nalpha,nbeta,
     2                nclose,nopen,ndumy,fract
      common /path/ latom,lparam,react(200)
      common/iofile/mfgr,mfgw
_IF(ipsc,tools)
      if(oroot().and.odumpm) then
_ELSE
      if(odumpm) then
_ENDIF
      open(unit=9,file=getmop(3),
     +     status='unknown',form='unformatted')
      rewind 9
      open(unit=10,file=getmop(4),
     +     status='unknown',form='unformatted')
      rewind 10
      endif
      ir=9
      if(ipow(9) .ne. 0) then
         if(ipow(9) .eq. 1) then
         write(mfgw,'(//10x,''- - - - - - - time up - - - - - - -'',//)'
     1)
         write(mfgw,'(//10x,'' - the calculation is being dumped to disk
     1'',/10x,''   restart it using the key-word "restart"'')')
            funct1=dsqrt(ddot(nvar,grad,1,grad,1))
         write(mfgw,'(//10x,''current value of gradient norm =''
     1  ,f12.6)')funct1
            do 10 i=1,nvar
               k=loc(1,i)
               l=loc(2,i)
   10       geo(l,k)=xparam(i)
         write(mfgw,'(/10x,''current value of geometry'',/)')
            degree=57.29577951d0
            if(na(1) .eq. 99) then
c
c  convert from cartesian coordinates to internal
c
               do 20 i=1,natoms
                  do 20 j=1,3
   20          coord(j,i)=geo(j,i)
               call mopxyz(coord,numat,na,nb,nc,1.d0,geo)
            endif
            call geout(6)
         endif
_IF(ipsc,tools)
         if(oroot().and.odumpm) then
_ELSE
         if(odumpm) then
_ENDIF
         write(ir)ipow,iloop
         write(ir)(xparam(i),i=1,nvar)
         write(ir)(  grad(i),i=1,nvar)
         write(ir)((hess(j,i),j=1,nvar),i=1,nvar)
         write(ir)((bmat(j,i),j=1,nvar),i=1,nvar)
         linear=(nvar*(nvar+1))/2
         write(ir)(pmat(i),i=1,linear)
         if(index(keywrd,'aider').ne.0) write(ir)(aicorr(i),i=1,nvar)
         linear=(norbs*(norbs+1))/2
         write(10)(pa(i),i=1,linear)
         if(nalpha.ne.0)write(10)(pb(i),i=1,linear)
         if(latom .ne. 0) then
            write(ir)((alparm(j,i),j=1,3),i=1,nvar)
            write(ir)jloop,x0, x1, x2
         endif
         close (9)
         close (10)
         endif
         return
      else
         write(mfgw,'(//10x,'' restoring data from disk''/)')
_IF(ipsc,tools)
         if(oroot()) then
_ENDIF
         read(ir)ipow,iloop
         read(ir)(xparam(i),i=1,nvar)
         read(ir)(  grad(i),i=1,nvar)
         read(ir)((hess(j,i),j=1,nvar),i=1,nvar)
         read(ir)((bmat(j,i),j=1,nvar),i=1,nvar)
         funct1=dsqrt(ddot(nvar,grad,1,grad,1))
         write(mfgw,'(10x,''function ='',f13.6//)')funct1
         linear=(nvar*(nvar+1))/2
         read(ir)(pmat(i),i=1,linear)
         if(index(keywrd,'aider').ne.0) read(ir)(aicorr(i),i=1,nvar)
         linear=(norbs*(norbs+1))/2
         read(10)(pa(i),i=1,linear)
         if(nalpha.ne.0)read(10)(pb(i),i=1,linear)
         if(latom.ne.0) then
            read(ir)((alparm(j,i),j=1,3),i=1,nvar)
            read(ir)jloop,x0, x1, x2
            iloop=iloop+1
         endif
         iloop=iloop+1
_IF(ipsc,tools)
         else
         write(mfgw,*)' restart not available in powsav'
         call pend
         endif
_ENDIF
         return
      endif
      end
      subroutine powsq(xparam, nvar, funct)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      dimension xparam(*)
      common /mesage/ iflepo,iscf
**********************************************************************
*
*   powsq optimizes the geometry by minimising the gradient norm.
*         thus both ground and transition state geometries can be
*         calculated. it is roughly equivalent to flepo, flepo minimizes
*         the energy, powsq minimizes the gradient norm.
*
*  on entry xparam = values of parameters to be optimized.
*           nvar   = number of parameters to be optimized.
*
*  on exit  xparam = optimized parameters.
*           funct  = heat of formation in kcals.
*
**********************************************************************
c        *****  routine performs  a least squares minimization  *****
c        *****  of a function which is a sum of squares.        *****
c        *****  initially written by j.w. mciver jr. at suny/   *****
c        *****  buffalo, summer 1971.  rewritten and modified   *****
c        *****  by a.k. at suny buffalo and the university of   *****
c        *****  texas.  december 1973                           *****
c
      common /geovar/ ndum,loc(2,maxpar), idumy, xaram(maxpar)
      common /cmpg/ geo(3,numatm)
      common /last/ last
      common /keywrd/ keywrd
      common /timem/ time0
      common /numscf/ nscf
      common /geosym/ ndep, locpar(maxpar), idepfn(maxpar),
     1                 locdep(maxpar)
      common /gradnt/ grad(maxpar),gnfina
      common /timdmp/ tleft, tdump
      common /geokst/ natoms,labels(numatm),
     1                na(numatm),nb(numatm),nc(numatm)
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),
     1                nlast(numatm), norbs, nelecs,nalpha,nbeta,
     2                nclose,nopen,ndumy,fract
      common /numcal/ numcal
      common/iofile/mfgr,mfgw
      common /sigma1/ gnext, amin, anext
      common /sigma2/ gnext1(maxpar), gmin1(maxpar)
      common /nllcom/ hess(maxpar,maxpar),bmat(maxpar,maxpar),
     1pmat(maxpar*maxpar)
      common /scrach/ pvec
      dimension ipow(9), sig(maxpar),
     1          e1(maxpar), e2(maxpar),
     2          p(maxpar), work(maxpar),
     3          pvec(maxpar*maxpar), eig(maxpar), q(maxpar)
      logical debug, restrt, times, okf, rough, scf1, resfil, log
      character*241 keywrd
      save icalcn,restrt,log,scf1,icyc,times,resfil,tol2,rho2,xinc
      data  icalcn /0/
      if(icalcn.ne.numcal) then
         icalcn=numcal
         restrt=(index(keywrd,'restart') .ne. 0)
         log=(index(keywrd,'nolog') .eq. 0)
         scf1=(index(keywrd,'1scf') .ne. 0)
         rough=.false.
         time1=secmop()
         time2=time1
         icyc=0
         times=(index(keywrd,'time') .ne. 0)
         tlast=tleft
         resfil=.false.
         step=0.02d0
         last=0
         iloop=1
         xinc=0.00529167d0
         rho2=1.d-4
         tol2=4.d-1
         if(index(keywrd,'prec') .ne. 0) tol2=1.d-2
         if(index(keywrd,'gnorm') .ne. 0) then
            tol2=reada(keywrd,index(keywrd,'gnorm'))
            if(tol2.lt.0.01d0.and.index(keywrd,' let').eq.0)then
            write(mfgw,'(/,a)')'  gnorm has been set too low, reset to 0
     1.01'
               tol2=0.01d0
            endif
         endif
         debug = (index(keywrd,'powsq') .ne. 0)
         if(restrt) then
c
c   restore stored data
c
            ipow(9)=0
            call powsav(hess,gmin1,xparam,pmat,iloop,bmat,ipow)
            if(scf1) goto 390
            nscf=ipow(8)
            do 10 i=1,nvar
               grad(i)=gmin1(i)
   10       gnext1(i)=gmin1(i)
            write(mfgw,'('' xparam'',6f10.6)')(xparam(i),i=1,nvar)
            if(iloop .gt. 0) then
c#               iloop=iloop+1
               write(mfgw,'(//10x,'' restarting at point'',i3)')iloop
            else
               write(mfgw,'(//10x,''restarting in optimisation'',
     1         '' routines'')')
            endif
         endif
*
*   definitions:   nvar   = number of geometric variables = 3*numat-6
*
      endif
      nvar=iabs(nvar)
      if(debug) then
      write(mfgw,'('' xparam'')')
      write(mfgw,'(5(2i3,f10.4))')(loc(1,i),loc(2,i),xparam(i),i=1,nvar)
      endif
      if( .not. restrt) then
         do 20 i=1,nvar
   20    grad(i)=0.d0
         call compfg(xparam, .true., funct, .true., grad, .true.)
      endif
      if(debug) then
         write(mfgw,'('' starting gradients'')')
         write(mfgw,'(3x,8f9.4)')(grad(i),i=1,nvar)
      endif
      gmin=dsqrt(ddot(nvar,grad,1,grad,1))
      glast=gmin
      do 30 i=1,nvar
         gnext1(i)=grad(i)
         gmin1(i)=gnext1(i)
   30 continue
c
c    now to calculate the hessian matrix.
c
      if(iloop.lt.0) goto 140
c
c   check that hessian has not already been calculated.
c
      ilpr=iloop
      do 50 iloop=ilpr,nvar
         time1=secmop()
         xparam(iloop)=xparam(iloop) + xinc
         call compfg(xparam, .true., funct, .true., grad, .true.)
         if(scf1) goto 390
         if(debug)write(mfgw,'(i3,12(8f9.4,/3x))')
     1    iloop,(grad(if),if=1,nvar)
         grad(iloop)=grad(iloop)+1.d-5
         xparam(iloop)=xparam(iloop) - xinc
         do 40 j=1,nvar
   40    hess(iloop,j)=-(grad(j)-gnext1(j))/xinc
         time2=secmop()
         tstep=time2-time1
         if(times)write(mfgw,
     +  '('' time for step:'',f8.2,'' left'',f8.2)') tstep, tleft
         if(tlast-tleft.gt.tdump)then
            tlast=tleft
            resfil=.true.
            ipow(9)=2
            i=iloop
            ipow(8)=nscf
            call powsav(hess,gmin1,xparam,pmat,i,bmat,ipow)
         endif
         if( tleft .lt. tstep*2.d0) then
c
c  store results to date.
c
            ipow(9)=1
            i=iloop
            ipow(8)=nscf
            call powsav(hess,gmin1,xparam,pmat,i,bmat,ipow)
_IF(ipsc,tools)
            call pend
_ELSE
            stop
_ENDIF
         endif
   50 continue
c        *****  scale -hessian- matrix                           *****
      if( debug) then
         write(mfgw,'(//10x,''un-normalized hessian matrix'')')
         do 60 i=1,nvar
   60    write(mfgw,'(8f10.4)')(hess(j,i),j=1,nvar)
      endif
      do 80 i=1,nvar
         sum = 0.0d0
         do 70 j=1,nvar
   70    sum = sum+hess(i,j)**2
   80 work(i) = 1.0d0/dsqrt(sum)
      do 90 i=1,nvar
         do 90 j=1,nvar
   90 hess(i,j) = hess(i,j)*work(i)
      if( debug) then
         write(mfgw,'(//10x,''hessian matrix'')')
         do 100 i=1,nvar
  100    write(mfgw,'(8f10.4)')(hess(j,i),j=1,nvar)
      endif
c        *****  initialize b matirx                        *****
      do 120 i=1,nvar
         do 110 j=1,nvar
  110    bmat(i,j) = 0.0d0
  120 bmat(i,i) = work(i)*2.d0
************************************************************************
*
*  this is the start of the big loop to optimize the geometry
*
************************************************************************
      iloop=-99
      tstep=tstep*4
  130 continue
      if(tlast-tleft.gt.tdump)then
         tlast=tleft
         resfil=.true.
         ipow(9)=2
         i=iloop
         ipow(8)=nscf
         call powsav(hess,gmin1,xparam,pmat,i,bmat,ipow)
      endif
      if( tleft .lt. tstep*2.d0) then
c
c  store results to date.
c
         ipow(9)=1
         i=iloop
         ipow(8)=nscf
         call powsav(hess,gmin1,xparam,pmat,i,bmat,ipow)
         iflepo=-1
         return
      endif
  140 continue
c        *****  form-a- dagger-a- in pa slong with -p-     *****
      ij=0
      do 160 j=1,nvar
         do 160 i=1,j
            ij=ij+1
            sum = 0.0d0
            do 150 k=1,nvar
  150       sum = sum + hess(i,k)*hess(j,k)
  160 pmat(ij) = sum
      do 180 i=1,nvar
         sum = 0.0d0
         do 170 k=1,nvar
  170    sum = sum-hess(i,k)*gmin1(k)
  180 p(i) = -sum
      l=0
      if(debug) then
         write(mfgw,'(/10x,''p matrix in powsq'')')
         call vecprt(pmat,nvar)
      endif
      call rsp(pmat,nvar,nvar,eig,pvec)
c        *****  check for zero eigenvalue                  *****
c#      write(6,'(''  eigs in powsq:'')')
c#      write(6,'(6f13.8)')(eig(i),i=1,nvar)
      if(eig(1).lt.rho2) go to 240
      indc = 2
c        *****  if matrix is not singular form inverse     *****
c        *****  by back transforming the eigenvectors      *****
      ij=0
      do 200 i=1,nvar
         do 200 j=1,i
            ij=ij+1
            sum = 0.0d0
            do 190 k=1,nvar
  190       sum = sum+pvec((k-1)*nvar+j)*pvec((k-1)*nvar+i)/eig(k)
  200 pmat(ij) = sum
c        *****  find -q- vector                            *****
      l=0
      il=l+1
      l=il+i-1
      do 230 i=1,nvar
         sum = 0.0d0
         do 210 k=1,i
            ik=(i*(i-1))/2+k
  210    sum = sum+pmat(ik)*p(k)
         ip1=i+1
         do 220 k=ip1,nvar
            ik=(k*(k-1))/2+i
  220    sum=sum+pmat(ik)*p(k)
  230 q(i) = sum
      go to 260
  240 continue
c        *****  take  -q- vector as eigenvector of zero     *****
c        *****  eigenvalue                                 *****
      do 250 i=1,nvar
  250 q(i) = pvec(i)
  260 continue
c        *****  find search direction                      *****
      do 270 i=1,nvar
         sig(i) = 0.0d0
         do 270 j=1,nvar
  270 sig(i) = sig(i) + q(j)*bmat(i,j)
c        *****  do a one dimensional search                *****
      if (debug) then
         write(mfgw,'('' search vector'')')
         write(mfgw,'(8f10.5)')(sig(i),i=1,nvar)
      endif
      call mopsrc(xparam,alpha,sig,nvar,gmin,okf,funct)
      if( nvar .eq. 1) goto 390
c
c  first we attempt to optimize geometry using search.
c  if this does not work, then switch to linmin, which always works,
c  but is twice as slow as search.
c
      rough=  (   .not.  okf)
      rmx = 0.0d0
      do 280 k=1,nvar
         rt = dabs(gmin1(k))
         if(rt.gt.rmx)rmx = rt
  280 continue
      if(rmx.lt.tol2) go to 390
c        *****  two step estimation of derivatives         *****
      do 290 k=1,nvar
  290 e1(k) = (gmin1(k)-gnext1(k))/(amin-anext)
      rmu = ddot(nvar,e1,1,gmin1,1)/
     +      ddot(nvar,gmin1,1,gmin1,1)
      do 300 k=1,nvar
  300 e2(k) = e1(k) - rmu*gmin1(k)
c        *****  scale -e2- and -sig-                       *****
      sk = 1.0d0/dsqrt(ddot(nvar,e2,1,e2,1))
      do 310 k=1,nvar
  310 sig(k) = sk*sig(k)
      do 320 k=1,nvar
  320 e2(k) = sk*e2(k)
c        *****  find index of replacement direction        *****
      pmax = -1.0d+20
      do 330 i=1,nvar
         if(dabs(p(i)*q(i)).le.pmax) go to 330
         pmax = dabs(p(i)*q(i))
         id = i
  330 continue
c        *****  replace appropriate direction and derivative ***
      do 340 k=1,nvar
  340 hess(id,k) = -e2(k)
c        *****  replace starting point                     *****
      do 350 k=1,nvar
  350 bmat(k,id) = sig(k)/0.529167d0
      do 360 k=1,nvar
  360 gnext1(k) = gmin1(k)
      glast = gmin
      indc = 1
      time1=time2
      time2=secmop()
      tleft=tleft-time2+time0
      tstep=time2-time1
      icyc=icyc+1
      if(resfil)then
         write(mfgw,370)dmin1(tleft,9999999.9d0),
     1dmin1(gmin,999999.999d0),funct
         if(log)write(11,370)dmin1(tleft,9999999.9d0),
     1dmin1(gmin,999999.999d0),funct
  370    format('  restart file written,  time left:',f9.1,
     1' grad.:',f10.3,' heat:',g14.7)
         resfil=.false.
      else
         write(mfgw,380)icyc,dmin1(tstep,9999.99d0),
     1dmin1(tleft,9999999.9d0),dmin1(gmin,999999.999d0),funct
         if(log)write(11,380)icyc,dmin1(tstep,9999.99d0),
     1dmin1(tleft,9999999.9d0),dmin1(gmin,999999.999d0),funct
  380    format(' cycle:',i5,' time:',f6.1,' time left:',f9.1,
     1' grad.:',f10.3,' heat:',g14.7)
      endif
      if(times)write(mfgw,
     + '('' time for step:'',f8.2,'' left'',f8.2)')tstep, tleft
      go to 130
  390 continue
      do 400 i=1,nvar
  400 grad(i)=0.d0
      last=1
      call compfg(xparam, .true., funct, .true., grad, .true.)
      do 410 i=1,nvar
  410 grad(i)=gmin1(i)
      gnfina=dsqrt(ddot(nvar,grad,1,grad,1))
      iflepo=11
      if(scf1)iflepo=13
      return
      end
      subroutine prtdrc(escf,deltt,xparam,ref,ekin,gtot,etot,velo0,nvar)
      implicit REAL (a-h,o-z)
      dimension xparam(*), velo0(*), ref(*)
*********************************************************************
*
*    prtdrc prepares to print the geometry etc. for points in a drc
*    or irc
*    calculation.
*    on input  escf   = heat of formation for the current point
*              deltt  = change in time, previous to current point
*              xparam = current cartesian geometry
*              ekin   = current kinetic energy
*              gtot   = total gradient norm in irc calc'n.
*              velo0  = current velocity
*              nvar   = number of variables = 3 * number of atoms.
*
********************************************************************
INCLUDE(common/sizes)
      common /keywrd/ keywrd
      common /numcal/ numcal
      common/iofile/mfgr,mfgw
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),
     1                nlast(numatm), norbs, nelecs,nalpha,nbeta,
     2                nclose,nopen,ndumy,xract
      common /geokst/ natoms,labels(numatm),
     1                na(numatm),nb(numatm),nc(numatm)
      common /drccom/  mcoprt(2,maxpar), ncoprt, parmax
      common /corec/ core(107)
      common /atmass/ atmass(numatm)
      common /densty/ p(mpack),pa(mpack),pb(mpack)
      common /fmatrx/ allxyz(3,maxpar),allvel(3,maxpar),parref(maxpar),
     1xyz3(3,maxpar),vel3(3,maxpar), allgeo(3,maxpar), geo3(3,maxpar),
     2 dummy(maxpar**2+1-16*maxpar), idumy(4)
      dimension escf3(3),ekin3(3), gtot3(3), charge(numatm), xold3(3),
     1geo(3*numatm), vref(maxpar), vref0(maxpar), tsteps(100), etot3(3),
     2xtot3(3)
      save first1, refscf, cotype
      logical first1, turn, parmax, ldrc, goturn
      character*241 keywrd, text1*3, text2*2,  cotype(3)*2
      save icalcn,goturn,iloop,turn
      data icalcn/0/
      data first1/.true./,refscf/0.d0/
      data cotype/'bl','ba','di'/
      if (icalcn.ne.numcal) then
         icalcn=numcal
         sqrt2=dsqrt(2.d0)
         do 10 i=1,nvar
   10    parref(i)=xparam(i)
         etot=escf+ekin
         tlast=0.d0
         goturn=.false.
         sum=0.d0
         do 20 i=1,nvar
            sum=sum+velo0(i)**2
            vref0(i)=velo0(i)
   20    vref(i)=velo0(i)
         ione=1
         ldrc=(sum.gt.1.d0)
         iloop=1
         oldt=-100.d0
         told1=0.0d0
c
c       determine type of print: time, energy or geometry priority
c       or print all points
c
         stept=0.d0
         steph=0.d0
         stepx=0.d0
         if(index(keywrd,' t-prio').ne.0)then
            if(index(keywrd,' t-priority=').ne.0)then
               stept=reada(keywrd,index(keywrd,'t-prio')+5)
            else
               stept=0.1d0
            endif
            tref=-1.d-6
            write(mfgw,'(/,'' time priority, interval ='',f4.1,
     1'' femtoseconds'',/)')stept
         elseif(index(keywrd,' h-prio').ne.0)then
            if(index(keywrd,' h-priority=').ne.0)then
               steph=reada(keywrd,index(keywrd,'h-prio')+5)
            else
               steph=0.1d0
            endif
            write(mfgw,'(/,'' kinetic energy priority, step ='',f5.2,
     1'' kcal/mole'',/)')steph
         elseif(index(keywrd,' x-prio').ne.0)then
            if(index(keywrd,' x-priority=').ne.0)then
               stepx=reada(keywrd,index(keywrd,'x-prio')+5)
            else
               stepx=0.05d0
            endif
            write(mfgw,'(/,'' geometry priority, step ='',f5.2,
     1'' angstroms'',/)')stepx
         endif
         if(index(keywrd,' restart').ne.0.and.index(keywrd,'irc=').eq.0)
     1 then
            read(9,*)(parref(i),i=1,nvar)
            read(9,*)(ref(i),i=1,nvar)
            read(9,*)(vref0(i),i=1,nvar)
            read(9,*)(vref(i),i=1,nvar)
            read(9,*)(allgeo(3,i),i=1,nvar)
            read(9,*)(allgeo(2,i),i=1,nvar)
            read(9,*)(allgeo(1,i),i=1,nvar)
            read(9,*)(allvel(3,i),i=1,nvar)
            read(9,*)(allvel(2,i),i=1,nvar)
            read(9,*)(allvel(1,i),i=1,nvar)
            read(9,*)(allxyz(3,i),i=1,nvar)
            read(9,*)(allxyz(2,i),i=1,nvar)
            read(9,*)(allxyz(1,i),i=1,nvar)
            read(9,*)iloop,ldrc,ione,etot1,etot0,escf1,escf0,ekin1,ekin0
     1,told2,told1,gtot1,gtot0,xold2,xold1,xold0,totime,jloop,etot,refx
     2,xtot1,xtot0
         endif
      endif
      if(escf.lt.-1.d8) then
         write(9,*)(parref(i),i=1,nvar)
         write(9,*)(ref(i),i=1,nvar)
         write(9,*)(vref0(i),i=1,nvar)
         write(9,*)(vref(i),i=1,nvar)
         write(9,*)(allgeo(3,i),i=1,nvar)
         write(9,*)(allgeo(2,i),i=1,nvar)
         write(9,*)(allgeo(1,i),i=1,nvar)
         write(9,*)(allvel(3,i),i=1,nvar)
         write(9,*)(allvel(2,i),i=1,nvar)
         write(9,*)(allvel(1,i),i=1,nvar)
         write(9,*)(allxyz(3,i),i=1,nvar)
         write(9,*)(allxyz(2,i),i=1,nvar)
         write(9,*)(allxyz(1,i),i=1,nvar)
         write(9,*)iloop,ldrc,ione,etot1,etot0,escf1,escf0,ekin1,ekin0,
     1told2,told1,gtot1,gtot0,xold2,xold1,xold0,totime,jloop,etot,refx
     2,xtot1,xtot0
         return
      endif
      call chrge(p,charge)
      do 30 i=1,numat
         l=nat(i)
   30 charge(i)=core(l) - charge(i)
      deltat=deltt*1.d15
      na(2)=-1
      call mopxyz(xparam,numat,na,nb,nc,57.29577951d0,geo)
      na(1)=99
      if(iloop.eq.1)then
         etot1=etot0
         etot0=etot
         escf1=escf
         escf0=escf
         ekin1=ekin
         ekin0=ekin
         do 40 j=1,3
c$doit vbest
            do 40 i=1,nvar
               allgeo(j,i)=geo(i)
               allxyz(j,i)=xparam(i)
   40    allvel(j,i)=velo0(i)
      else
         do 50 i=1,nvar
            allgeo(3,i)=allgeo(2,i)
            allgeo(2,i)=allgeo(1,i)
            allgeo(1,i)=geo(i)
            allxyz(3,i)=allxyz(2,i)
            allxyz(2,i)=allxyz(1,i)
            allxyz(1,i)=xparam(i)
            allvel(3,i)=allvel(2,i)
            allvel(2,i)=allvel(1,i)
   50    allvel(1,i)=velo0(i)
      endif
c
c  form quadratic expression for position and velocity w.r.t. time.
c
      t1=dmax1(told2,0.02d0)
      t2=dmax1(told1,0.02d0)+t1
      do 60 i=1,nvar
         call quadr(allgeo(3,i),allgeo(2,i),allgeo(1,i),t1,t2,
     1geo3(1,i),geo3(2,i),geo3(3,i))
c
****************************************************
*                                                  *
*    quadr calculates the a, b and c in the equns. *
*                                                  *
*     a                   =   f0                   *
*     a + b.x0 + c.x0**2  =   f1                   *
*     a + b.x2 + c.x2**2  =   f2                   *
* given the argument list (f0,f1,f2, x1,x2, a,b,c) *
*                                                  *
****************************************************
         call quadr(allxyz(3,i),allxyz(2,i),allxyz(1,i),t1,t2,
     1xyz3(1,i),xyz3(2,i),xyz3(3,i))
         call quadr(allvel(3,i),allvel(2,i),allvel(1,i),t1,t2,
     1vel3(1,i),vel3(2,i),vel3(3,i))
   60 continue
      etot2=etot1
      etot1=etot0
      etot0=etot
      call quadr(etot2,etot1,etot0,t1,t2,etot3(1),etot3(2),
     1etot3(3))
      ekin2=ekin1
      ekin1=ekin0
      ekin0=ekin
      call quadr(ekin2,ekin1,ekin0,t1,t2,ekin3(1),ekin3(2),
     1ekin3(3))
      escf2=escf1
      escf1=escf0
      escf0=escf
      call quadr(escf2,escf1,escf0,t1,t2,escf3(1),escf3(2),
     1escf3(3))
      gtot2=gtot1
      gtot1=gtot0
      gtot0=gtot
      call quadr(gtot2,gtot1,gtot0,t1,t2,gtot3(1),gtot3(2),
     1gtot3(3))
      xtot2=xtot1
      xtot1=xtot0
      xold2=xold2+xold1
      xold1=xold0
c
c   calculate change in geometry
c
      xold0=0.d0
      l=0
      xtot0=0.d0
      sum1=0.d0
      do 80 i=1,numat
         sum=0.d0
         sum1=0.d0
c$doit asis
         do 70 j=1,3
            l=l+1
            sum1=sum1+(allxyz(1,l)-ref(l))**2
   70    sum=sum+(allxyz(2,l)-allxyz(1,l))**2
         xold0=xold0+dsqrt(sum)
   80 xtot0=xtot0+dsqrt(sum1)
      call quadr(xtot2,xtot1,xtot0,t1,t2,
     1xtot3(1),xtot3(2),xtot3(3))
      call quadr(xold2,xold2+xold1,xold2+xold1+xold0,t1,t2,
     1xold3(1),xold3(2),xold3(3))
***********************************************************************
*   go through the criteria for deciding whether or not to print this *
*   point.  if yes, then also calculate the exact point as a fraction *
*   between the last point and the current point                      *
***********************************************************************
c   nfract is the number of points to be printed in the current domain
***********************************************************************
      if(iloop.lt.3) goto 170
      fract=-10.0d0
      nfract=1
      if(steph.ne.0) then
c
c   criterion for printing results  is a change in heat of formation =
c   -change in kinetic energy
c
         if(refscf.eq.0.d0) then
            i=escf2/steph
            refscf=i*steph
         endif
         dh=dabs(escf1-refscf)
         if(dh.gt.steph)then
            steph=dsign(steph,escf1-refscf)
            nfract=dabs(dh/steph)
            cc=escf3(1)
            bb=escf3(2)
            aa=escf3(3)
************************************************
* programmers! - be very careful if you change *
* this following section.  there is numerical  *
* instability if dabs(bb/aa) is very large. near*
* inflection points aa changes sign.       jjps*
************************************************
            if(dabs(bb/aa).gt.30.0d0)then
c
c   use linear interpolation
c
               do 90 i=1,nfract
   90          tsteps(i)=-(cc-(refscf+i*steph))/bb
            else
c
c  use quadratic interpolation
c
               do 100 i=1,nfract
                  c1=cc-(refscf+i*steph)
  100          tsteps(i)=(-bb+dsign(dsqrt(bb*bb-4.d0*(aa*c1)),bb))/
     +                   (2.d0*aa)
            endif
            fract=-.1d0
            refscf=refscf+nfract*steph
         endif
      elseif(stept.ne.0.d0) then
c
c   criterion for printing results is a change in time.
c
         if(dabs(totime+told2-tref).gt.stept)then
            fincr=stept
            i=totime/stept
            fract=i*stept-totime
            i=(told2+totime)/stept
            j=totime/stept
            nfract=i-j+ ione
            ione=0
            do 110 i=1,nfract
  110       tsteps(i)=fract+i*stept
            tref=tref+nfract*stept
         endif
      elseif(stepx.ne.0.d0) then
c
c   criterion for printing results is a change in geometry.
c
         if(xold2+xold1-refx.gt.stepx)then
            nfract=(xold2+xold1-refx)/stepx
            cc=xold3(1)
            bb=xold3(2)
            aa=xold3(3)
            if(dabs(bb/aa).gt.30.0d0)then
c
c   use linear interpolation
c
               do 120 i=1,nfract
  120          tsteps(i)=-(cc-(refx+i*stepx))/bb
            else
c
c  use quadratic interpolation
c
               do 130 i=1,nfract
                  c1=cc-(refx+i*stepx)
  130          tsteps(i)=(-bb+dsign(dsqrt(bb*bb-4.d0*(aa*c1)),bb))/
     +                   (2.d0*aa)
            endif
            refx=refx+nfract*stepx
            fract=-.10d0
         endif
      else
c
c   print every point.
c
         fract=0.0d0
      endif
      if(fract.lt.-9.d0)goto 170
      turn=(turn.or.dabs(fract-1.d0).gt.1.d-6)
c
c  loop over all points in current domain
c
      if(fract.eq.0.d0.and.nfract.eq.1)then
         text1=' '
         text2=' '
         ii=0
         call drcout(xyz3,geo3,vel3,nvar,totime,escf3,ekin3,
     1gtot3,etot3,xtot3,iloop,charge,fract,text1,text2,ii,jloop)
         n=0
         do 140 i=1,ncoprt
            k=mcoprt(1,i)
            j=mcoprt(2,i)
            l=k*3-3+j
            if(dabs(geo3(3,l)).gt.1.d-20)
     +         fract=-geo3(2,l)/(geo3(3,l)*2.d0)
            if(fract.gt.0.d0.and.fract.lt.told2) then
               if(geo3(3,l).gt.0.d0)text1='min'
               if(geo3(3,l).lt.0.d0)text1='max'
               text2=cotype(j)
               if(n.eq.0)then
                  n=n+1
                  write(mfgw,'(/,20(''****''))')
               endif
               time=totime+fract
               call drcout(xyz3,geo3,vel3,nvar,time,escf3,ekin3,
     1gtot3,etot3,xtot3,iloop,charge,fract,text1,text2,k,jloop)
            endif
  140    continue
         if(n.ne.0)write(mfgw,'(/,20(''****''))')
         if(dabs(escf3(3)).gt.1.d-20)fract=-escf3(2)/(escf3(3)*2.d0)
         if(.not.goturn.and.fract.gt.0.d0.and.fract.lt.told2*1.04d0
     1.and. parmax) then
            goturn=.true.
            time=fract+totime
            if(escf3(3).gt.0.d0) then
               text1='min'
               if(ldrc) then
                  sum=ddot(nvar,velo0,1,vref,1)**2/
     +               (ddot(nvar,velo0,1,velo0,1)*
     1                ddot(nvar,vref,1,vref,1)+1.d-10)
                 sum1=ddot(nvar,velo0,1,vref0,1)**2/
     +               (ddot(nvar,velo0,1,velo0,1)*
     1                ddot(nvar,vref0,1,vref0,1)+1.d-10)
                  if(sum1.gt.0.1d0.and.dabs(sum1-1.d0).gt.1.d-6)
     1write(mfgw,'(/,a,f8.5,a,f8.5,a,g12.3,a)')' coef. of v(0)
     2=',sum1,'   last v(0)',sum,'   half-life =',
     3-0.6931472d0*time/log(sum1),' femtosecs'
               endif
               write(mfgw,'(//,a,f11.3,a)')' half-cycle time ='
     1,time-tlast,' femtoseconds'
               tlast=time
               do 150 i=1,nvar
  150          vref(i)=velo0(i)
            endif
            if(escf3(3).lt.0.d0)text1='max'
            text2=' '
            call drcout(xyz3,geo3,vel3,nvar,time,escf3,ekin3,
     1gtot3,etot3,xtot3,iloop,charge,fract,text1,text2,0,jloop)
         else
            goturn=.false.
         endif
      else
         do 160 i=1,nfract
            time=totime+tsteps(i)
            text1=' '
            text2=' '
c#           write(6,'(a,4f12.4)')' kinetic energy, point',ekin3,tsteps(
            call drcout(xyz3,geo3,vel3,nvar,time,escf3,ekin3,
     1gtot3,etot3,xtot3,iloop,charge,tsteps(i),text1,text2,0,jloop)
  160    continue
      endif
  170 continue
c
c buffer total time to 3 points back!
c
      totime=totime+told2
      told2=told1
      told1=deltat
      iloop=iloop+1
      return
      end
      subroutine pulay(f,p,n,fppf,fock,emat,lfock,nfock,msize,start,pl)
      implicit REAL (a-h,o-z)
      dimension f(*), p(*), fppf(*), fock(*)
      logical start
************************************************************************
*
*   pulay uses dr. peter pulay's method for convergence.
*         a mathematical description can be found in
*         "p. pulay, j. comp. chem. 3, 556 (1982).
*
* arguments:-
*         on input f      = fock matrix, packed, lower half triangle.
*                  p      = density matrix, packed, lower half triangle.
*                  n      = number of orbitals.
*                  fppf   = workstore of size msize, contents will be
*                           overwritten.
*                  fock   =      "       "              "         "
*                  emat   = workstore of at least 15**2 elements.
*                  start  = logical, = true to start pulay.
*                  pl     = undefined element.
*      on output   f      = "best" fock matrix, = linear combination
*                           of known fock matrices.
*                  start  = false
*                  pl     = measure of non-self-consistency
*                         = [f*p] = f*p - p*f.
*
************************************************************************
      common /keywrd/ keywrd
      common /numcal/ numcal
      common/iofile/mfgr,mfgw
      dimension emat(20,20), evec(1000), coeffs(20)
      character*241 keywrd
      logical  debug
*     save icalcn,maxlim,debug,mfock
******
      save
******
      data icalcn/0/
      if (icalcn.ne.numcal) then
         icalcn=numcal
         maxlim=6
         debug=(index(keywrd,'debugpulay') .ne.0)
      endif
      if(start) then
         linear=(n*(n+1))/2
         mfock=msize/linear
         if(mfock.gt.maxlim)mfock=maxlim
         if(debug)
     1    write(mfgw,'('' maximum size:'',i5)')mfock
         nfock=1
         lfock=1
         start=.false.
      else
         if(nfock.lt.mfock)      nfock=nfock+1
         if(lfock.ne.mfock)then
            lfock=lfock+1
         else
            lfock=1
         endif
      endif
      lbase=(lfock-1)*linear
*
*   first, store fock matrix for future reference.
*
      do 10 i=1,linear
   10 fock((i-1)*mfock+lfock)=f(i)
*
*   now form /fock*density-density*fock/, and store this in fppf
*
      call mamult(p,f,fppf(lbase+1),n,0.d0)
      call mamult(f,p,fppf(lbase+1),n,-1.d0)
*
*   fppf now contains the result of fp - pf.
*
      nfock1=nfock+1
      do 20 i=1,nfock
         emat(nfock1,i)=-1.d0
         emat(i,nfock1)=-1.d0
         emat(lfock,i)=
     +     ddot(linear,fppf((i-1)*linear+1),1,fppf(lbase+1),1)
   20 emat(i,lfock)=emat(lfock,i)
      pl=emat(lfock,lfock)/linear
      emat(nfock1,nfock1)=0.d0
      const=1.d0/emat(lfock,lfock)
      do 30 i=1,nfock
         do 30 j=1,nfock
   30 emat(i,j)=emat(i,j)*const
      if(debug) then
         write(mfgw,'('' emat'')')
         do 40 i=1,nfock1
   40    write(mfgw,'(6e13.6)')(emat(j,i),j=1,nfock1)
      endif
      l=0
      do 50 i=1,nfock1
         do 50 j=1,nfock1
            l=l+1
   50 evec(l)=emat(i,j)
      const=1.d0/const
      do 60 i=1,nfock
         do 60 j=1,nfock
   60 emat(i,j)=emat(i,j)*const
*********************************************************************
*   the matrix emat should have form
*
*      |<e(1)*e(1)>  <e(1)*e(2)> ...   -1.0|
*      |<e(2)*e(1)>  <e(2)*e(2)> ...   -1.0|
*      |<e(3)*e(1)>  <e(3)*e(2)> ...   -1.0|
*      |<e(4)*e(1)>  <e(4)*e(2)> ...   -1.0|
*      |     .            .      ...     . |
*      |   -1.0         -1.0     ...    0. |
*
*   where <e(i)*e(j)> is the scalar product of [f*p] for iteration i
*   times [f*p] for iteration j.
*
*********************************************************************
      call osinv(evec,nfock1,d)
      if(dabs(d).lt.1.d-6)then
         start=.true.
         return
      endif
      if(nfock.lt.2) return
      il=nfock*nfock1
      do 70 i=1,nfock
   70 coeffs(i)=-evec(i+il)
      if(debug) then
         write(mfgw,'('' evec'')')
         write(mfgw,'(6f12.6)')(coeffs(i),i=1,nfock)
         write(mfgw,'(''    lagrangian multiplier (error) =''
     1             ,f13.6)')evec(nfock1*nfock1)
      endif
      do 90 i=1,linear
         sum=0
         l=0
         ii=(i-1)*mfock
         do 80 j=1,nfock
   80    sum=sum+coeffs(j)*fock(j+ii)
   90 f(i)=sum
      return
      end
      subroutine quadr(f0,f1,f2, x1,x2, a,b,c)
      implicit REAL (a-h,o-z)
****************************************************
*                                                  *
*    quadr calculates the a, b and c in the equns. *
*                                                  *
*     a                   =   f0                   *
*     a + b.x0 + c.x0**2  =   f1                   *
*     a + b.x2 + c.x2**2  =   f2                   *
*                                                  *
****************************************************
      c=(x2*(f1-f0)-x1*(f2-f0))/(x2*x1**2-x1*x2**2)
      b=(f1-f0-c*x1**2)/x1
      a=f0
      return
      end
      subroutine react1(escf)
      implicit REAL (a-h,o-z)
      REAL  pastor, pbstor
INCLUDE(common/sizes)
      common /cmpg/ geo(3,numatm)
      dimension geoa(3,numatm), geovec(3,numatm),
     1          pastor(mpack),
     2          pbstor(mpack), xold(maxpar), grold(maxpar)
      common /geokst/ natoms,labels(numatm),
     1                na(numatm), nb(numatm), nc(numatm)
      common /densty/ p(mpack),pa(mpack),pb(mpack)
      common /geosym/ ndep,locpar(maxpar),idepfn(maxpar),locdep(maxpar)
      common /geovar/ nvar,loc(2,maxpar), idumy, xparam(maxpar)
      common /gradnt/ grad(maxpar),gnorm
      common /istope/ ams(107)
      common /gravec/ cosine
      common /keywrd/ keywrd
      common /mesage/ iflepo,iscf
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),
     2                nlast(numatm), norbs, nelecs,nalpha,nbeta,
     3                nclose,nopen,ndumy,fract
      common /reactn/ step, geoa, geovec,calcst
      common/iofile/mfgr,mfgw
      logical gradnt, finish, xyz, int, gok(2)
      save gradnt, finish, xyz,int, gok
************************************************************************
*
*  react1 determines the transition state of a chemical reaction.
*
*   react works by using two systems simultaneously, the heats of
*   formation of both are calculated, then the more stable one
*   is moved in the direction of the other. after a step the
*   energies are compared, and the now lower-energy form is moved
*   in the direction of the higher-energy form. this is repeated
*   until the saddle point is reached.
*
*   if one form is moved 3 times in succession, then the higher energy
*   form is re-optimized without shortening the distance between the two
*   forms. this reduces the chance of being caught on the side of a
*   transition state.
*
************************************************************************
      dimension idum1(numatm), idum2(numatm), xstore(maxpar),
     1idum3(numatm), coord(3,numatm), irot(2,3)
      dimension idummy(3*numatm)
      save irot
      character*241 keywrd
      equivalence (idummy,coord)
      data irot/1,2,1,3,2,3/
      gold=0.d0
      linear=0
      iflag=1
      gok(1)=.false.
      gok(2)=.false.
      xyz=(index(keywrd,' xyz') .ne. 0)
      gradnt=(index(keywrd,'grad') .ne. 0)
      i=(index(keywrd,' bar'))
      stepmx=0.15d0
      if(i.ne.0) stepmx=reada(keywrd,i)
      maxstp=1000
c
c    read in the second geometry.
c
      if(xyz) then
         call getgeo(5,labels,geoa,loc,na,nb,nc,ams,natoms,int)
      else
         call getgeo(5,idum1,geoa,idummy,
     1         idum1,idum2,idum3,ams,natoms,int)
c
c  if internal coordinates are to be used, check the connectivity
c
         l=0
         do 10 i=1,natoms
            if(idum1(i).ne.na(i))then
               l=l+1
            if(l.eq.1)write(mfgw,'(10x,''errors detected in connectivity
     1'')')
            write(mfgw,'(a,i3,a,i3,a,i3,a)')' for atom',i,' the bond lab
     1els are different:      ',idum1(i),' and',na(i)
            endif
            if(idum2(i).ne.nb(i))then
               l=l+1
            if(l.eq.1)write(mfgw,'(10x,''errors detected in connectivity
     1'')')
            write(mfgw,'(a,i3,a,i3,a,i3,a)')' for atom',i,' the bond ang
     1le labels are different:',idum2(i),' and',nb(i)
            endif
            if(idum3(i).ne.nc(i))then
               l=l+1
            if(l.eq.1)write(mfgw,'(10x,''errors detected in connectivity
     1'')')
            write(mfgw,'(a,i3,a,i3,a,i3,a)')' for atom',i,' the dihedral
     1 labels are different:  ',idum3(i),' and',nc(i)
            endif
   10    continue
         if(l.ne.0)write(mfgw,
     +  '(10x,a)')' correct before resubmission'
         if(l.ne.0) then
_IF(ipsc,tools)
          call pend
_ELSE
          stop
_ENDIF
         endif
      endif
      time0= secmop()
c
c  swap first and second geometries around
c  so that geout can output data on second geometry.
c
      numat2=0
      do 20 i=1,natoms
         if(labels(i).ne.99) numat2=numat2+1
         x=geoa(1,i)
         geoa(1,i)=geo(1,i)
         geo(1,i)=x
         x=geoa(2,i)*0.0174532925d0
         geoa(2,i)=geo(2,i)
         geo(2,i)=x
         x=geoa(3,i)*0.0174532925d0
         geoa(3,i)=geo(3,i)
         geo(3,i)=x
   20 continue
      if(numat2.ne.numat) then
      write(mfgw,'(//10x,'' number of atoms in second system is '',
     1''incorrect'',/)')
      write(mfgw,'('' number of atoms in first  system ='',i4)')numat
      write(mfgw,'('' number of atoms in second system ='',i4)')numat2
         goto 280
      endif
      write(mfgw,'(//10x,'' geometry of second system'',/)')
      if(ndep.ne.0) call mopsym()
      call geout(1)
c
c     convert to cartesian, if necessary
c
      if(   xyz   )then
         call gmetry(geo,coord)
         sumx=0.d0
         sumy=0.d0
         sumz=0.d0
         do 30 j=1,numat
            sumx=sumx+coord(1,j)
            sumy=sumy+coord(2,j)
   30    sumz=sumz+coord(3,j)
         sumx=sumx/numat
         sumy=sumy/numat
         sumz=sumz/numat
         do 40 j=1,numat
            geo(1,j)=coord(1,j)-sumx
            geo(2,j)=coord(2,j)-sumy
   40    geo(3,j)=coord(3,j)-sumz
         write(mfgw,
     +  '(//,''  cartesian geometry of first system'',//)')
         write(mfgw,'(3f14.5)')((geo(j,i),j=1,3),i=1,numat)
         sumx=0.d0
         sumy=0.d0
         sumz=0.d0
         do 50 j=1,numat
            sumx=sumx+geoa(1,j)
            sumy=sumy+geoa(2,j)
   50    sumz=sumz+geoa(3,j)
         sum=0.d0
         sumx=sumx/numat
         sumy=sumy/numat
         sumz=sumz/numat
         do 60 j=1,numat
            geoa(1,j)=geoa(1,j)-sumx
            geoa(2,j)=geoa(2,j)-sumy
            geoa(3,j)=geoa(3,j)-sumz
            sum=sum+(geo(1,j)-geoa(1,j))**2
     1           +(geo(2,j)-geoa(2,j))**2
     2           +(geo(3,j)-geoa(3,j))**2
   60    continue
         do 110 l=3,1,-1
c
c     docking is done in steps of 16, 4, and 1 degrees at a time.
c
            ca=dcos(4.d0**(l-1)*0.01745329d0)
            sa=dsqrt(dabs(1.d0-ca**2))
            do 100 j=1,3
               ir=irot(1,j)
               jr=irot(2,j)
               do 90 i=1,10
                  summ=0.d0
                  do 70 k=1,numat
                     x         = ca*geoa(ir,k)+sa*geoa(jr,k)
                     geoa(jr,k)=-sa*geoa(ir,k)+ca*geoa(jr,k)
                     geoa(ir,k)=x
                     summ=summ+(geo(1,k)-geoa(1,k))**2
     1                         +(geo(2,k)-geoa(2,k))**2
     2                         +(geo(3,k)-geoa(3,k))**2
   70             continue
                  if(summ.gt.sum) then
                     if(i.gt.1)then
                        sa=-sa
                        do 80 k=1,numat
                           x         = ca*geoa(ir,k)+sa*geoa(jr,k)
                           geoa(jr,k)=-sa*geoa(ir,k)+ca*geoa(jr,k)
                           geoa(ir,k)=x
   80                   continue
                        goto 100
                     endif
                     sa=-sa
                  endif
   90          sum=summ
  100       continue
  110    continue
         write(mfgw,
     +  '(//,''  cartesian geometry of second system'',//)')
         write(mfgw,'(3f14.5)')((geoa(j,i),j=1,3),i=1,numat)
         write(mfgw,'(//,''   "distance":'',f13.6)')sum
         write(mfgw,'(//,''  reaction coordinate vector'',//)')
         write(mfgw,
     +  '(3f14.5)')((geoa(j,i)-geo(j,i),j=1,3),i=1,numat)
         na(1)=99
         j=0
         nvar=0
         do 130 i=1,natoms
            if(labels(i).ne.99)then
               j=j+1
               do 120 k=1,3
                  nvar=nvar+1
                  loc(2,nvar)=k
  120          loc(1,nvar)=j
               labels(j)=labels(i)
            endif
  130    continue
         natoms=numat
      endif
c
c   xparam holds the variable parameters for geometry in geo
c   xold   holds the variable parameters for geometry in geoa
c
      if(nvar.eq.0)then
         write(mfgw,
     + '(///10x,''there are no variables in the saddle'',
     1'' calculation!'')')
_IF(ipsc,tools)
         call pend
_ELSE
         stop
_ENDIF
      endif
      sum=0.d0
      do 140 i=1,nvar
         grold(i)=1.d0
         xparam(i)=geo(loc(2,i),loc(1,i))
         xold(i)=geoa(loc(2,i),loc(1,i))
  140 sum=sum+(xparam(i)-xold(i))**2
      step0=dsqrt(sum)
      if(step0.lt.1.d-5)then
      write(mfgw,'(//,3(5x,a,/))')' both geometries are identical',
     1' a saddle calculation involves a reactant and a product',
     2' these must be different geometries'
_IF(ipsc,tools)
         call pend
_ELSE
         stop
_ENDIF
      endif
      one=1.d0
      dell=0.1d0
      eold=-2000.d0
      time1=secmop()
      swop=0.0d0
      do 240 iloop=1,maxstp
         write(mfgw,'('' '',40(''*+''))')
c
c   this method of calculating 'step' is quite arbitary, and needs
c   to be improved by intelligent guesswork!
c
         if (gnorm.lt.1.d-3)gnorm=1.d-3
         step=dmin1(swop,0.5d0, 6.d0/gnorm, dell,stepmx*step0+0.005d0)
         step=dmin1(0.2d0,step/step0)*step0
         swop=swop+1.d0
         dell=dell+0.1d0
         write(mfgw,'(''  bar shortened by'',f12.7,'' percent'')')
     1step/step0*100.d0
         step0=step0-step
         if(step0.lt.0.01d0) goto 250
         step=step0
         do 150 i=1,nvar
  150    xstore(i)=xparam(i)
         call flepo(xparam, nvar, escf)
         if(linear.eq.0)then
            linear=(norbs*(norbs+1))/2
            do 160 i=1,linear
               pastor(i)=pa(i)
  160       pbstor(i)=pb(i)
         endif
         do 170 i=1,nvar
  170    xparam(i)=geo(loc(2,i),loc(1,i))
         if(iflag.eq.1)then
         write(mfgw,'(//10x,''for point'',i3,'' second structure'')')ilo
     1op
         else
         write(mfgw,'(//10x,''for point'',i3,'' first  structure'')')ilo
     1op
         endif
         write(mfgw,'('' distance a - b  '',f12.6)')step
c
c   now to calculate the "correct" gradients, switch off 'step'.
c
         step=0.d0
         do 180 i=1,nvar
  180    grad(i)=grold(i)
         call compfg (xparam, .true., funct1,.true.,grad,.true.)
         do 190 i=1,nvar
  190    grold(i)=grad(i)
         if (gradnt) then
            write(mfgw,'(''  actual gradients of this point'')')
            write(mfgw,'(8f10.4)')(grad(i),i=1,nvar)
         endif
         write(mfgw,'('' heat            '',f12.6)')funct1
         gnorm=dsqrt(ddot(nvar,grad,1,grad,1))
         write(mfgw,'('' gradient norm   '',f12.6)')gnorm
         cosine=cosine*one
         write(mfgw,'('' direction cosine'',f12.6)')cosine
         call geout(6)
         if(swop.gt.2.9d0 .or. iloop .gt. 3 .and. cosine .lt. 0.d0
     1  .or. escf .gt. eold)
     2  then
            if(swop.gt.2.9d0)then
               swop=0.d0
            else
               swop=0.5d0
            endif
c
c   swap reactant and product around
c
            finish=(gok(1).and.gok(2) .and. cosine .lt. 0.d0)
            if(finish) then
            write(mfgw,'(//10x,'' both systems are on the same side of t
     1he '',''transition state -'',/10x,'' geometries of the systems'',
     2'' on each side of the t.s. are as follows'')')
               do 200 i=1,nvar
  200          xparam(i)=xstore(i)
               call compfg (xparam, .true., funct1,.true.,grad,.true.)
            write(mfgw,'(//10x,'' geometry on one side of the transition
     1'','' state'')')
               call writmo(time0,funct1)
            endif
            time2=secmop()
            write(mfgw,'('' time='',f9.2)')time2-time1
            time1=time2
            write(mfgw,'(''  reactants and products swapped around'')')
            iflag=1-iflag
            one=-1.d0
            eold=escf
            sum=gold
            gold=gnorm
            i=1.7d0+one*0.5d0
            if(gnorm.gt.10.d0)gok(i)=.true.
            gnorm=sum
            do 210 i=1,natoms
               do 210 j=1,3
                  x=geo(j,i)
                  geo(j,i)=geoa(j,i)
  210       geoa(j,i)=x
            do 220 i=1,nvar
               x=xold(i)
               xold(i)=xparam(i)
  220       xparam(i)=x
c
c
c    swap around the density matrices.
c
            do 230 i=1,linear
               x=pastor(i)
               pastor(i)=pa(i)
               pa(i)=x
               x=pbstor(i)
               pbstor(i)=pb(i)
               pb(i)=x
               p(i)=pa(i)+pb(i)
  230       continue
            if(finish) goto 250
         else
            one=1.d0
         endif
  240 continue
  250 continue
      write(mfgw,'('' at end of reaction'')')
      gold=dsqrt(ddot(nvar,grad,1,grad,1))
      call compfg (xparam, .true., funct1,.true.,grad,.true.)
      gnorm=dsqrt(ddot(nvar,grad,1,grad,1))
      do 260 i=1,nvar
  260 grold(i)=xparam(i)
      call writmo(time0,funct1)
*
* the geometries have (a) been optimized correctly, or
*                     (b) both ended up on the same side of the t.s.
*
*  transition state lies between the two geometries
*
      c1=gold/(gold+gnorm)
      c2=1.d0-c1
      write(mfgw,
     + '('' best estimate geometry of the transition state'')')
      write(mfgw,'(//10x,'' c1='',f8.3,''c2='',f8.3)')c1,c2
      do 270 i=1,nvar
  270 xparam(i)=c1*grold(i)+c2*xold(i)
      step=0.d0
      call compfg (xparam, .true., funct1,.true.,grad,.true.)
      call writmo(time0,funct1)
  280 return
      end
      function reada(string,istart)
c     fortran function to extract number from string
c
      REAL  digit,reada
      character string*(*)
      logical defalt,expnnt
c
c     define ascii values of numeric field characters
      i0=ichar('0')
      i9=ichar('9')
      idot=ichar('.')
      ineg=ichar('-')
      ipos=ichar('+')
      icapd=ichar('d')
      icape=ichar('e')
      ismld=ichar('d')
      ismle=ichar('e')
c
      l=len(string)
c
c     find the start of the numeric field
      do 10 i=istart,l
         iadd=0
         n=ichar(string(i:i))
c
c       signal start of numeric field if digit found
         if(n.ge.i0.and.n.le.i9)goto 20
c
c       account for consecutive signs [- and(or) +]
         if(n.eq.ineg.or.n.eq.ipos)then
            iadd=iadd+1
            if(i+iadd.gt.l)goto 50
            n=ichar(string(i+iadd:i+iadd))
            if(n.ge.i0.and.n.le.i9)goto 20
         endif
c
c       account for consecutive decimal points (.)
         if(n.eq.idot)then
            iadd=iadd+1
            if(i+iadd.gt.l)goto 50
            n=ichar(string(i+iadd:i+iadd))
            if(n.ge.i0.and.n.le.i9)goto 20
         endif
   10 continue
      goto 50
c
c     find the end of the numeric field
   20 expnnt=.false.
      do 30 j=i+1,l
         iadd=0
         n=ichar(string(j:j))
c
c       continue search for end if digit found
         if(n.ge.i0.and.n.le.i9)goto 30
c
c       continue search for end if sign found and expnnt true
         if(n.eq.ineg.or.n.eq.ipos)then
            if(.not.expnnt)goto 40
            iadd=iadd+1
            if(j+iadd.gt.l)goto 40
            n=ichar(string(j+iadd:j+iadd))
            if(n.ge.i0.and.n.le.i9)goto 30
         endif
         if(n.eq.idot)then
            iadd=iadd+1
            if(j+iadd.gt.l)goto 40
            n=ichar(string(j+iadd:j+iadd))
            if(n.ge.i0.and.n.le.i9)goto 30
            if(n.eq.icape.or.n.eq.ismle.or.n.eq.icapd.or.n.eq.ismld)
     1    goto 30
         endif
         if(n.eq.icape.or.n.eq.ismle.or.n.eq.icapd.or.n.eq.ismld)then
            if(expnnt)goto 40
            expnnt=.true.
            goto 30
         endif
         goto 40
   30 continue
      j=l+1
   40 n=ichar(string(j-1:j-1))
      if(n.eq.icape.or.n.eq.ismle.or.n.eq.icapd.or.n.eq.ismld)j=j-1
c
c     found the end of the numeric field (it runs 'i' thru 'j-1')
      n=0
      n=n+index(string(i:j-1),'e')
      n=n+index(string(i:j-1),'e')
      n=n+index(string(i:j-1),'d')
      n=n+index(string(i:j-1),'d')
      if(n.eq.0)then
         reada=digit(string(i:j-1),1)
      else
         reada=digit(string(:i+n-2),i)*1.d1**digit(string(:j-1),i+n)
      endif
      defalt=.false.
      return
c
c     default value returned because no numeric field found
   50 reada=0.d0
      defalt=.true.
      return
      end
      subroutine refer
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      common /refs/ allref(107,4)
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),
     3                nlast(numatm), norbs, nelecs,nalpha,nbeta,
     4                nclose,nopen,ndumy,fract
      common /keywrd/ keywrd
      common/iofile/mfgr,mfgw
      logical allok, elemns(107), mixok, mix
      save mix
      character keywrd*241, allref*80
      data mix/.false./
      mixok=(index(keywrd,'parasok').ne.0)
      do 10 i=1,102
   10 elemns(i)=.false.
      if(index(keywrd,'pm3').ne.0)then
         mode=4
      elseif(index(keywrd,'am1').ne.0)then
         mode=3
      elseif(index(keywrd,'mindo').ne.0)then
         mode=2
      else
         mode=1
      endif
      allref(99,mode)=' dummy atoms are used; these do not affect '
     1//'the calculation'
      allref(100,mode)=' '
      do 20 i=1,numat
         j=nat(i)
   20 elemns(j)=.true.
      allok=.true.
      do 30 i=1,102
         if(elemns(i))then
            if(i.lt.99.and..not.mix.and.mode.eq.3)
     1mix=(index(allref(i,3),'mndo').ne.0)
            if(allref(i,mode)(1:1).ne.' ')then
            write(mfgw,'(a,i3)')' data are not available for element no.
     1',i
               allok=.false.
            else
               write(mfgw,'(a)')allref(i,mode)
            endif
         endif
   30 continue
      if(mix.and..not.mixok)then
         write(mfgw,40)
     1  'some elements have been specified for which only mndo',
     2  'parameters are available.  such mixtures of methods are',
     3  'very risky and have not been fully tested.  if you feel',
     4  'the risk is worth while - check the manual first - then',
     5  'specify "parasok" in the keywords'
_IF(ipsc,tools)
         call pend
_ELSE
         stop
_ENDIF
      endif
      if(allok)return
      write(mfgw,40)
     1 'some elements have been specified for which',
     2 'no parameters are available.  calculation stopped.'
_IF(ipsc,tools)
      call pend
_ELSE
      stop
_ENDIF
   40 format(/////10x,a,4(/10x,a))
      end
      subroutine reppp(ni,nj,rij,ri,core)
c***********************************************************************
c
c..vector version written by ernest r. davidson, indiana university
c
c
c  reppp calculates the two-electron repulsion integrals and the
c       nuclear attraction integrals.
c
c     on input rij     = interatomic distance
c              ni      = atom number of first atom
c              nj      = atom number of second atom
c    (ref)     add     = array of gamma, or two-electron one-center,
c                        integrals.
c    (ref)     tore    = array of nuclear charges of the elements
c    (ref)     dd      = array of dipole charge separations
c    (ref)     qq      = array of quadrupole charge separations
c
c     the common blocks are initialized in block-data, and never changed
c
c    on output ri      = array of two-electron repulsion integrals
c              core    = 4 x 2 array of electron-core attraction
c                        integrals
c
c
c *** this routine computes the two-centre repulsion integrals and the
c *** nuclear attraction integrals.
c *** the two-centre repulsion integrals (over local coordinates) are
c *** stored as follows (where p-sigma = o,  and p-pi = p and p* )
c     (ss/ss)=1,   (so/ss)=2,   (oo/ss)=3,   (pp/ss)=4,   (ss/os)=5,
c     (so/so)=6,   (sp/sp)=7,   (oo/so)=8,   (pp/so)=9,   (po/sp)=10,
c     (ss/oo)=11,  (ss/pp)=12,  (so/oo)=13,  (so/pp)=14,  (sp/op)=15,
c     (oo/oo)=16,  (pp/oo)=17,  (oo/pp)=18,  (pp/pp)=19,  (po/po)=20,
c     (pp/p*p*)=21,   (p*p/p*p)=22.
c *** the storage of the nuclear attraction integrals  core(kl/ij) is
c     (ss/)=1,   (so/)=2,   (oo/)=3,   (pp/)=4
c     where ij=1 if the orbitals centred on atom i,  =2 if on atom j.
c *** ni and nj are the atomic numbers of the two elements.
c
c***********************************************************************
      implicit REAL (a-h,o-z)
      logical si,sj
      common /multip/ dd(107),qq(107),add(107,3)
      common /corec/ tore(107)
      common /cmporb/ natorb(107)
      dimension ri(22),core(4,2)
      dimension arg(72),sqr(72)
      data  td/2.d00/
      data pp/0.5d00/
      data a0/0.529167d0/ ,ev/27.21d0/, ev1/13.605d0/, ev2/6.8025d0/,
     1 ev3/3.40125d0/, ev4/1.700625d0/
c
c     atomic units are used in the calculation,
c     final results are converted to ev
c
      r=rij/a0
c
      si = (natorb(ni).ge.3)
      sj = (natorb(nj).ge.3)
c
      if ((.not.si) .and. (.not.sj)) then
c
c     hydrogen - hydrogen  (ss/ss)
c
         aee = pp/add(ni,1) + pp/add(nj,1)
         aee = aee * aee
         ri(1) = ev/dsqrt(r*r+aee)
         core(1,1 )= tore(nj)*ri(1)
         core(1,2) = tore(ni)*ri(1)
c
      else if (si .and. (.not.sj)) then
c
c     heavy atom - hydrogen
c
         aee = pp/add(ni,1) + pp/add(nj,1)
         aee = aee * aee
         da=dd(ni)
         qa=qq(ni) * td
         ade = pp/add(ni,2) + pp/add(nj,1)
         ade = ade * ade
         aqe = pp/add(ni,3) + pp/add(nj,1)
         aqe = aqe * aqe
         rsq = r*r
         arg(1) = rsq + aee
         xxx = r+da
         arg(2) = xxx*xxx + ade
         xxx = r-da
         arg(3) = xxx*xxx + ade
         xxx = r+qa
         arg(4) = xxx*xxx + aqe
         xxx = r-qa
         arg(5) = xxx*xxx + aqe
         arg(6) = rsq + aqe
         arg(7) = arg(6) + qa*qa
c$doit asis
         do 10 i = 1,7
            sqr(i) = dsqrt(arg(i))
   10    continue
         ee = ev/sqr(1)
         ri(1) = ee
         ri(2) = ev1/sqr(2) - ev1/sqr(3)
         ri(3) = ee + ev2/sqr(4) + ev2/sqr(5) - ev1/sqr(6)
         ri(4) = ee + ev1/sqr(7) - ev1/sqr(6)
         core(1,1) = tore(nj)*ri(1)
         core(1,2) = tore(ni)*ri(1)
         core(2,1) = tore(nj)*ri(2)
         core(3,1) = tore(nj)*ri(3)
         core(4,1) = tore(nj)*ri(4)
c
      else if ((.not.si).and.sj) then
c
c     hydrogen - heavy atom
c
         aee = pp/add(ni,1) + pp/add(nj,1)
         aee = aee * aee
         db=dd(nj)
         qb=qq(nj) * td
         aed = pp/add(ni,1) + pp/add(nj,2)
         aed = aed * aed
         aeq = pp/add(ni,1) + pp/add(nj,3)
         aeq = aeq * aeq
         rsq = r*r
         arg(1) = rsq + aee
         xxx = r-db
         arg(2) = xxx*xxx + aed
         xxx = r+db
         arg(3) = xxx*xxx + aed
         xxx = r-qb
         arg(4) = xxx*xxx + aeq
         xxx = r+qb
         arg(5) = xxx*xxx + aeq
         arg(6) = rsq + aeq
         arg(7) = arg(6) + qb*qb
c$doit asis
         do 20 i = 1,7
            sqr(i) = dsqrt(arg(i))
   20    continue
         ee = ev/sqr(1)
         ri(1) = ee
         ri(5) = ev1/sqr(2)  - ev1/sqr(3)
         ri(11) = ee + ev2/sqr(4) + ev2/sqr(5) - ev1/sqr(6)
         ri(12) = ee + ev1/sqr(7) - ev1/sqr(6)
         core(1,1) = tore(nj)*ri(1)
         core(1,2) = tore(ni)*ri(1)
         core(2,2) = tore(ni)*ri(5)
         core(3,2) = tore(ni)*ri(11)
         core(4,2) = tore(ni)*ri(12)
c
      else
c
c     heavy atom - heavy atom
c
c     define charge separations.
         da=dd(ni)
         db=dd(nj)
         qa=qq(ni) * td
         qb=qq(nj) * td
c
         aee = pp/add(ni,1) + pp/add(nj,1)
         aee = aee * aee
c
         ade = pp/add(ni,2) + pp/add(nj,1)
         ade = ade * ade
         aqe = pp/add(ni,3) + pp/add(nj,1)
         aqe = aqe * aqe
         aed = pp/add(ni,1) + pp/add(nj,2)
         aed = aed * aed
         aeq = pp/add(ni,1) + pp/add(nj,3)
         aeq = aeq * aeq
         axx = pp/add(ni,2) + pp/add(nj,2)
         axx = axx * axx
         adq = pp/add(ni,2) + pp/add(nj,3)
         adq = adq * adq
         aqd = pp/add(ni,3) + pp/add(nj,2)
         aqd = aqd * aqd
         aqq = pp/add(ni,3) + pp/add(nj,3)
         aqq = aqq * aqq
         rsq = r * r
         arg(1) = rsq + aee
         xxx = r + da
         arg(2) = xxx * xxx + ade
         xxx = r - da
         arg(3) = xxx*xxx + ade
         xxx = r - qa
         arg(4) = xxx*xxx + aqe
         xxx = r + qa
         arg(5) = xxx*xxx + aqe
         arg(6) = rsq + aqe
         arg(7) = arg(6) + qa*qa
         xxx = r-db
         arg(8) = xxx*xxx + aed
         xxx = r+db
         arg(9) = xxx*xxx + aed
         xxx = r - qb
         arg(10) = xxx*xxx + aeq
         xxx = r + qb
         arg(11) = xxx*xxx + aeq
         arg(12) = rsq + aeq
         arg(13) = arg(12) + qb*qb
         xxx = da-db
         arg(14) = rsq + axx + xxx*xxx
         xxx = da+db
         arg(15) = rsq + axx + xxx*xxx
         xxx = r + da - db
         arg(16) = xxx*xxx + axx
         xxx = r - da + db
         arg(17) = xxx*xxx + axx
         xxx = r - da - db
         arg(18) = xxx*xxx + axx
         xxx = r + da + db
         arg(19) = xxx*xxx + axx
         xxx = r + da
         arg(20) = xxx*xxx + adq
         arg(21) = arg(20) + qb*qb
         xxx = r - da
         arg(22) = xxx*xxx + adq
         arg(23) = arg(22) + qb*qb
         xxx = r - db
         arg(24) = xxx*xxx + aqd
         arg(25) = arg(24) + qa*qa
         xxx = r + db
         arg(26) = xxx*xxx + aqd
         arg(27) = arg(26) + qa*qa
         xxx = r + da - qb
         arg(28) = xxx*xxx + adq
         xxx = r - da - qb
         arg(29) = xxx*xxx + adq
         xxx = r + da + qb
         arg(30) = xxx*xxx + adq
         xxx = r - da + qb
         arg(31) = xxx*xxx + adq
         xxx = r + qa - db
         arg(32) = xxx*xxx + aqd
         xxx = r + qa + db
         arg(33) = xxx*xxx + aqd
         xxx = r - qa - db
         arg(34) = xxx*xxx + aqd
         xxx = r - qa + db
         arg(35) = xxx*xxx + aqd
         arg(36) = rsq + aqq
         xxx = qa - qb
         arg(37) = arg(36) + xxx*xxx
         xxx = qa + qb
         arg(38) = arg(36) + xxx*xxx
         arg(39) = arg(36) + qa*qa
         arg(40) = arg(36) + qb*qb
         arg(41) = arg(39) + qb*qb
         xxx = r - qb
         arg(42) = xxx*xxx + aqq
         arg(43) = arg(42) + qa*qa
         xxx = r + qb
         arg(44) = xxx*xxx + aqq
         arg(45) = arg(44) + qa*qa
         xxx = r + qa
         arg(46) = xxx*xxx + aqq
         arg(47) = arg(46) + qb*qb
         xxx = r - qa
         arg(48) = xxx*xxx + aqq
         arg(49) = arg(48) + qb*qb
         xxx = r + qa - qb
         arg(50) = xxx*xxx + aqq
         xxx = r + qa + qb
         arg(51) = xxx*xxx + aqq
         xxx = r - qa - qb
         arg(52) = xxx*xxx + aqq
         xxx = r - qa + qb
         arg(53) = xxx*xxx + aqq
         qa=qq(ni)
         qb=qq(nj)
         xxx = da - qb
         xxx = xxx*xxx
         yyy = r - qb
         yyy = yyy*yyy
         zzz = da + qb
         zzz = zzz*zzz
         www = r + qb
         www = www*www
         arg(54) = xxx + yyy + adq
         arg(55) = xxx + www + adq
         arg(56) = zzz + yyy + adq
         arg(57) = zzz + www + adq
         xxx = qa - db
         xxx = xxx*xxx
         yyy = qa + db
         yyy = yyy*yyy
         zzz = r + qa
         zzz = zzz*zzz
         www = r - qa
         www = www*www
         arg(58) = zzz + xxx + aqd
         arg(59) = www + xxx + aqd
         arg(60) = zzz + yyy + aqd
         arg(61) = www + yyy + aqd
         xxx = qa - qb
         xxx = xxx*xxx
         arg(62) = arg(36) + td*xxx
         yyy = qa + qb
         yyy = yyy*yyy
         arg(63) = arg(36) + td*yyy
         arg(64) = arg(36) + td*(qa*qa+qb*qb)
         zzz = r + qa - qb
         zzz = zzz*zzz
         arg(65) = zzz + xxx + aqq
         arg(66) = zzz + yyy + aqq
         zzz = r + qa + qb
         zzz = zzz*zzz
         arg(67) = zzz + xxx + aqq
         arg(68) = zzz + yyy + aqq
         zzz = r - qa - qb
         zzz = zzz*zzz
         arg(69) = zzz + xxx + aqq
         arg(70) = zzz + yyy + aqq
         zzz = r - qa + qb
         zzz = zzz*zzz
         arg(71) = zzz + xxx + aqq
         arg(72) = zzz + yyy + aqq
         do 30 i = 1,72
            sqr(i) = dsqrt(arg(i))
   30    continue
         ee = ev/sqr(1)
         dze = -ev1/sqr(2) + ev1/sqr(3)
         qzze = ev2/sqr(4) + ev2/sqr(5) - ev1/sqr(6)
         qxxe = ev1/sqr(7) - ev1/sqr(6)
         edz = - ev1/sqr(8) + ev1/sqr(9)
         eqzz  = ev2/sqr(10) + ev2/sqr(11) - ev1/sqr(12)
         eqxx  = ev1/sqr(13) - ev1/sqr(12)
         dxdx  = ev1/sqr(14) - ev1/sqr(15)
         dzdz  = ev2/sqr(16) + ev2/sqr(17) - ev2/sqr(18) - ev2/sqr(19)
         dzqxx =  ev2/sqr(20) - ev2/sqr(21) - ev2/sqr(22) + ev2/sqr(23)
         qxxdz =  ev2/sqr(24) - ev2/sqr(25) - ev2/sqr(26) + ev2/sqr(27)
         dzqzz = -ev3/sqr(28) + ev3/sqr(29) - ev3/sqr(30) + ev3/sqr(31)
     1       - ev2/sqr(22) + ev2/sqr(20)
         qzzdz = -ev3/sqr(32) + ev3/sqr(33) - ev3/sqr(34) + ev3/sqr(35)
     1       + ev2/sqr(24) - ev2/sqr(26)
         qxxqxx = ev3/sqr(37) + ev3/sqr(38) - ev2/sqr(39) - ev2/sqr(40)
     1       + ev2/sqr(36)
         qxxqyy = ev2/sqr(41) - ev2/sqr(39) - ev2/sqr(40) + ev2/sqr(36)
         qxxqzz = ev3/sqr(43) + ev3/sqr(45) - ev3/sqr(42) - ev3/sqr(44)
     1       - ev2/sqr(39) + ev2/sqr(36)
         qzzqxx = ev3/sqr(47) + ev3/sqr(49) - ev3/sqr(46) - ev3/sqr(48)
     1       - ev2/sqr(40) + ev2/sqr(36)
         qzzqzz = ev4/sqr(50) + ev4/sqr(51) + ev4/sqr(52) + ev4/sqr(53)
     1       - ev3/sqr(48) - ev3/sqr(46) - ev3/sqr(42) - ev3/sqr(44)
     2       + ev2/sqr(36)
         dxqxz = -ev2/sqr(54) + ev2/sqr(55) + ev2/sqr(56) - ev2/sqr(57)
         qxzdx = -ev2/sqr(58) + ev2/sqr(59) + ev2/sqr(60) - ev2/sqr(61)
         qxyqxy = ev2/sqr(62) + ev2/sqr(63) - ev1/sqr(64)
         qxzqxz = ev3/sqr(65) - ev3/sqr(67) - ev3/sqr(69) + ev3/sqr(71)
     1       - ev3/sqr(66) + ev3/sqr(68) + ev3/sqr(70) - ev3/sqr(72)
         ri(1) = ee
         ri(2) = -dze
         ri(3) = ee + qzze
         ri(4) = ee + qxxe
         ri(5) = -edz
         ri(6) = dzdz
         ri(7) = dxdx
         ri(8) = -edz -qzzdz
         ri(9) = -edz -qxxdz
         ri(10) = -qxzdx
         ri(11) =  ee + eqzz
         ri(12) =  ee + eqxx
         ri(13) = -dze -dzqzz
         ri(14) = -dze -dzqxx
         ri(15) = -dxqxz
         ri(16) = ee +eqzz +qzze +qzzqzz
         ri(17) = ee +eqzz +qxxe +qxxqzz
         ri(18) = ee +eqxx +qzze +qzzqxx
         ri(19) = ee +eqxx +qxxe +qxxqxx
         ri(20) = qxzqxz
         ri(21) = ee +eqxx +qxxe +qxxqyy
         ri(22) = pp * (qxxqxx -qxxqyy)
c
c     calculate core-electron attractions.
c
         core(1,1) = tore(nj)*ri(1)
         core(2,1) = tore(nj)*ri(2)
         core(3,1) = tore(nj)*ri(3)
         core(4,1) = tore(nj)*ri(4)
         core(1,2) = tore(ni)*ri(1)
         core(2,2) = tore(ni)*ri(5)
         core(3,2) = tore(ni)*ri(11)
         core(4,2) = tore(ni)*ri(12)
c
      end if
c
      return
c
      end
      subroutine rsp(a,n,matz,w,z)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      dimension a(*),  w(n), z(n,n)
*******************************************************************
*
*   eispack diagonalization routines: to find the eigenvalues and
*           eigenvectors (if desired) of a real symmetric packed matrix.
* on input-      n  is the order of the matrix  a,
*                a  contains the lower triangle of the real*8  symmetric
*                   packed matrix stored row-wise,
*             matz  is an integer variable set equal to zero if only
*                   eigenvalues are desired,  otherwise it is set to
*                   any non-zero integer for both eigenvalues and
*                   eigenvectors.
* on output-     w  contains the eigenvalues in ascending order,
*                z  contains the eigenvectors if matz is not zero,
*
*******************************************************************
* this routine was chosen as being the most reliable. (jjps)
c     questions and comments should be directed to b. s. garbow,
c     applied mathematics division, argonne national laboratory
c
c     ------------------------------------------------------------------
c
      dimension fv1(maxhev*4+maxlit*3),fv2(maxhev*4+maxlit*3)
      save first, eps, eta, nv
      logical first
      data first /.true./
      if (first) then
         first=.false.
         call epseta(eps,eta)
      endif
      nv=(n*(n+1))/2
      nm=n
      call  tred3(n,nv,a,w,fv1,fv2,eps,eps)
      if (matz .ne. 0) go to 10
c     ********** find eigenvalues only **********
      call  mtqlrt(n,w,fv2,ierr,eps)
      go to 40
c     ********** find both eigenvalues and eigenvectors **********
   10 do 30    i = 1, n
c
         do 20    j = 1, n
            z(j,i)=0.0d0
   20    continue
c
         z(i,i)=1.0d0
   30 continue
c
      call  mtql2(nm,n,w,fv1,z,ierr,eps)
      if (ierr .ne. 0) go to 40
      call  trbak3(nm,n,nv,a,n,z,eps)
c     ********** last card of rsp **********
   40 return
      end
_IF1()      subroutine daxpy(n,a,x,ix,y,iy)
_IF1()      implicit REAL (a-h,o-z)
_IF1()c     vector increment y=y+a*x with x & y vectors of length n, a scalar.
_IF1()c     ix step of x, iy step of y.
_IF1()c     simulate routine on cray (same name and calling sequence).
_IF1()      dimension x(*),y(*)
_IF1()      i=1
_IF1()      do 10 j=1,iy*(n-1)+1,iy
_IF1()         y(j)=y(j)+a*x(i)
_IF1()   10 i=i+ix
_IF1()      return
_IF1()      end
      subroutine schmib(u,n,ndim)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
c
c     same as schmidt but works from right to left.
c
      dimension u(ndim,ndim)
      save zero, small, one
      data zero,small,one/0.0d0,0.01d0,1.0d0/
      n1=n+1
      ii=0
      do 110 k=1,n
         k1=k-1
c
c     normalize kth column vector
c
         dot = zero
         do 10 i=1,n
   10    dot=dot+u(i,n1-k)*u(i,n1-k)
         if(dot.eq.zero) go to 100
         scale=one/dsqrt(dot)
         do 20 i=1,n
   20    u(i,n1-k)=scale*u(i,n1-k)
   30    if(k1.eq.0) go to 110
         npass=0
c
c     project out k-1 previous orthonormal vectors from kth vector
c
   40    npass=npass+1
         do 70 j=1,k1
            dot=zero
            do 50 i=1,n
   50       dot=dot+u(i,n1-j)*u(i,n1-k)
            do 60 i=1,n
   60       u(i,n1-k)=u(i,n1-k)-dot*u(i,n1-j)
   70    continue
c
c     second normalization (after projection)
c     if kth vector is small but not zero then normalize
c     and project again to control round-off errors.
c
         dot=zero
         do 80 i=1,n
   80    dot=dot+u(i,n1-k)*u(i,n1-k)
         if(dot.eq.zero) go to 100
         if(dot.lt.small.and.npass.gt.2) go to 100
         scale=one/dsqrt(dot)
         do 90 i=1,n
   90    u(i,n1-k)=scale*u(i,n1-k)
         if(dot.lt.small) go to 40
         go to 110
c
c     replace linearly dependent kth vector by a unit vector.
c
  100    ii=ii+1
c     if(ii.gt.n) stop
         u(ii,n1-k)=one
         go to 30
  110 continue
      return
      end
      subroutine schmit(u,n,ndim)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      dimension u(ndim,ndim)
      save zero, small, one
      data zero,small,one/0.0d0,0.01d0,1.0d0/
      ii=0
      do 110 k=1,n
         k1=k-1
c
c     normalize kth column vector
c
         dot = zero
         do 10 i=1,n
   10    dot=dot+u(i,k)*u(i,k)
         if(dot.eq.zero) go to 100
         scale=one/dsqrt(dot)
         do 20 i=1,n
   20    u(i,k)=scale*u(i,k)
   30    if(k1.eq.0) go to 110
         npass=0
c
c     project out k-1 previous orthonormal vectors from kth vector
c
   40    npass=npass+1
         do 70 j=1,k1
            dot=zero
            do 50 i=1,n
   50       dot=dot+u(i,j)*u(i,k)
            do 60 i=1,n
   60       u(i,k)=u(i,k)-dot*u(i,j)
   70    continue
c
c     second normalization (after projection)
c     if kth vector is small but not zero then normalize
c     and project again to control round-off errors.
c
         dot=zero
         do 80 i=1,n
   80    dot=dot+u(i,k)*u(i,k)
         if(dot.eq.zero) go to 100
         if(dot.lt.small.and.npass.gt.2) go to 100
         scale=one/dsqrt(dot)
         do 90 i=1,n
   90    u(i,k)=scale*u(i,k)
         if(dot.lt.small) go to 40
         go to 110
c
c     replace linearly dependent kth vector by a unit vector.
c
  100    ii=ii+1
c     if(ii.gt.n) stop
         u(ii,k)=one
         go to 30
  110 continue
      return
      end
_IF1()      subroutine scopy (n,x,ix,y,iy)
_IF1()      implicit REAL (a-h,o-z)
_IF1()c     copy vector x, step ix onto vector y, step iy, n elements.
_IF1()c     simulate routine on cray (same name and calling sequence).
_IF1()      dimension x(*),y(*)
_IF1()      i=1
_IF1()      do 10 j=1,iy*(n-1)+1,iy
_IF1()         y(j)=x(i)
_IF1()   10 i=i+ix
_IF1()      return
_IF1()      end
_IF1()      function sdot (n,x,ix,y,iy)
_IF1()      implicit REAL (a-h,o-z)
_IF1()      dimension x(*),y(*)
_IF1()c     sdot=dot product of vector x, step ix, by vector y, step iy,
_IF1()c     n elements.
_IF1()c     simulate routine on cray (same name and calling sequence).
_IF1()      j=1
_IF1()      sdot=0.d0
_IF1()      do 10 i=1,(n-1)*ix+1,ix
_IF1()         sdot=sdot+x(i)*y(j)
_IF1()   10 j=j+iy
_IF1()      return
_IF1()      end
      function secmop()
_IF(ipsc,tools)
      REAL  secmop, cpulft, shut
_ELSE
      REAL  secmop, cpu ,cpulft, shut
_ENDIF
      common/iofile/mfgr,mfgw
c******************************************************
c
c   secmop, on exit, contains the number of cpu seconds
c   since the start of the calculation.
c
c******************************************************
_IFN(ipsc,tools)
      logical setok
      character*1 x
      character*80 getmop
      data setok   /  .true.    /, shut/0.d0/
*     print *, 'calling timclk'
      call timclk(cpu)
*     print *, 'returned from timclk, cpu = ', cpu
***********************************************************************
*
*   now to see if a file logically called shutdown exists, if it does
*   then increment cpu time by 1,000,000 seconds.
*
************************************************************************
      open(unit=4, file=getmop(14),status='unknown')
c      open(unit=4, file='shutdown',status='unknown')
      read(4,'(a)',end=10, err=10)x
*
*          file exists, therefore increment time
*
      shut=1.0d6
      if( setok) then
       write(mfgw,'(///10x,''****   job stopped by operator   ****'')')
       setok=.false.
      endif
   10 continue
      close (4,status='delete')
      secmop=cpu+shut
_ELSE
      secmop=cpulft(1)
_ENDIF
      return
      end
      subroutine set (s1,s2,na,nb,rab,nbond,ii)
      implicit REAL (a-h,o-z)
      common /cmops/ a(7),b(7),sa,sb,factor,isp,ips
c***********************************************************************
c
c     set is part of the overlap calculation, called by overlp.
c         it calls aintgs and bintgs
c
c***********************************************************************
      if (na.gt.nb) go to 10
      isp=1
      ips=2
      sa=s1
      sb=s2
      goto 20
   10 isp=2
      ips=1
      sa=s2
      sb=s1
   20 j=ii+2
      if (ii.gt.3) j=j-1
      alpha=0.5d00*rab*(sa+sb)
      beta=0.5d00*rab*(sb-sa)
      jcall=j-1
      call aintgs (alpha,jcall)
      call bintgs (beta,jcall)
      return
c
      end
      subroutine setup3
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      common /natype/ nztype(107),mtype(30),ltype
      common /sto6g/ allc(6,5,2),allz(6,5,2)
c     set-up the stewart's sto-3g expansions
c     from j. chem. phys. 52 431.
c                                            1s
      allz(1,1,1) =2.227660584d00
      allz(2,1,1) =4.057711562d-01
      allz(3,1,1) =1.098175104d-01
c
      allc(1,1,1) =1.543289673d-01
      allc(2,1,1) =5.353281423d-01
      allc(3,1,1) =4.446345422d-01
c                                      2s
      allz(1,2,1) =2.581578398d00
      allz(2,2,1) =1.567622104d-01
      allz(3,2,1) =6.018332272d-02
c
      allc(1,2,1) =-5.994474934d-02
      allc(2,2,1) =5.960385398d-01
      allc(3,2,1) =4.581786291d-01
c                                     2p
      allz(1,2,2) =9.192379002d-01
      allz(2,2,2) =2.359194503d-01
      allz(3,2,2) =8.009805746d-02
c
      allc(1,2,2) =1.623948553d-01
      allc(2,2,2) =5.661708862d-01
      allc(3,2,2) =4.223071752d-01
c                                      3s
      allz(1,3,1) =5.641487709d-01
      allz(2,3,1) =6.924421391d-02
      allz(3,3,1) =3.269529097d-02
c
      allc(1,3,1) =-1.782577972d-01
      allc(2,3,1) =8.612761663d-01
      allc(3,3,1) =2.261841969d-01
c                                     3p
      allz(1,3,2) =2.692880368d00
      allz(2,3,2) =1.489359592d-01
      allz(3,3,2) =5.739585040d-02
c
      allc(1,3,2) =-1.061945788d-02
      allc(2,3,2) =5.218564264d-01
      allc(3,3,2) =5.450015143d-01
c                                      4s
      allz(1,4,1) =2.267938753d-01
      allz(2,4,1) =4.448178019d-02
      allz(3,4,1) =2.195294664d-02
c
      allc(1,4,1) =-3.349048323d-01
      allc(2,4,1) =1.056744667d00
      allc(3,4,1) =1.256661680d-01
c                                     4p
      allz(1,4,2) =4.859692220d-01
      allz(2,4,2) =7.430216918d-02
      allz(3,4,2) =3.653340923d-02
c
      allc(1,4,2) =-6.147823411d-02
      allc(2,4,2) =6.604172234d-01
      allc(3,4,2) =3.932639495d-01
c                                      5s
      allz(1,5,1) =1.080198458d-01
      allz(2,5,1) =4.408119382d-02
      allz(3,5,1) =2.610811810d-02
c
      allc(1,5,1) =-6.617401158d-01
      allc(2,5,1) =7.467595004d-01
      allc(3,5,1) =7.146490945d-01
c                                     5p
      allz(1,5,2) =2.127482317d-01
      allz(2,5,2) =4.729648620d-02
      allz(3,5,2) =2.604865324d-02
c
      allc(1,5,2) =-1.389529695d-01
      allc(2,5,2) =8.076691064d-01
      allc(3,5,2) =2.726029342d-01
c
      return
      end
      subroutine setupg
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      common /expont/ zs(107),zp(107),zd(107)
      common /natype/ nztype(107),mtype(30),ltype
      common /temp/  cc(60,6),zz(60,6)
      common /sto6g/ allc(6,5,2),allz(6,5,2)
      common/iofile/mfgr,mfgw
c     set-up the stewart's sto-6g expansions
c                                            1s
      allz(1,1,1) =2.310303149d01
      allz(2,1,1) =4.235915534d00
      allz(3,1,1) =1.185056519d00
      allz(4,1,1) =4.070988982d-01
      allz(5,1,1) =1.580884151d-01
      allz(6,1,1) =6.510953954d-02
c
      allc(1,1,1) =9.163596280d-03
      allc(2,1,1) =4.936149294d-02
      allc(3,1,1) =1.685383049d-01
      allc(4,1,1) =3.705627997d-01
      allc(5,1,1) =4.164915298d-01
      allc(6,1,1) =1.303340841d-01
c                                      2s
      allz(1,2,1) =2.768496241d01
      allz(2,2,1) =5.077140627d00
      allz(3,2,1) =1.426786050d00
      allz(4,2,1) =2.040335729d-01
      allz(5,2,1) =9.260298399d-02
      allz(6,2,1) =4.416183978d-02
c
      allc(1,2,1) =-4.151277819d-03
      allc(2,2,1) =-2.067024148d-02
      allc(3,2,1) =-5.150303337d-02
      allc(4,2,1) =3.346271174d-01
      allc(5,2,1) =5.621061301d-01
      allc(6,2,1) =1.712994697d-01
c                                     2p
      allz(1,2,2) =5.868285913d00
      allz(2,2,2) =1.530329631d00
      allz(3,2,2) =5.475665231d-01
      allz(4,2,2) =2.288932733d-01
      allz(5,2,2) =1.046655969d-01
      allz(6,2,2) =4.948220127d-02
c
      allc(1,2,2) =7.924233646d-03
      allc(2,2,2) =5.144104825d-02
      allc(3,2,2) =1.898400060d-01
      allc(4,2,2) =4.049863191d-01
      allc(5,2,2) =4.012362861d-01
      allc(6,2,2) =1.051855189d-01
c                                      3s
      allz(1,3,1) =3.273031938d00
      allz(2,3,1) =9.200611311d-01
      allz(3,3,1) =3.593349765d-01
      allz(4,3,1) =8.636686991d-02
      allz(5,3,1) =4.797373812d-02
      allz(6,3,1) =2.724741144d-02
      allc(1,3,1) =-6.775596947d-03
      allc(2,3,1) =-5.639325779d-02
      allc(3,3,1) =-1.587856086d-01
      allc(4,3,1) =5.534527651d-01
      allc(5,3,1) =5.015351020d-01
      allc(6,3,1) =7.223633674d-02
c                                     3p
      allz(1,3,2) =5.077973607d00
      allz(2,3,2) =1.340786940d00
      allz(3,3,2) =2.248434849d-01
      allz(4,3,2) =1.131741848d-01
      allz(5,3,2) =6.076408893d-02
      allz(6,3,2) =3.315424265d-02
      allc(1,3,2) =-3.329929840d-03
      allc(2,3,2) =-1.419488340d-02
      allc(3,3,2) =1.639395770d-01
      allc(4,3,2) =4.485358256d-01
      allc(5,3,2) =3.908813050d-01
      allc(6,3,2) =7.411456232d-02
c                                     4s
      allz(1,4,1) = 1.365346 d+00
      allz(2,4,1) = 4.393213 d-01
      allz(3,4,1) = 1.877069 d-01
      allz(4,4,1) = 9.360270 d-02
      allz(5,4,1) = 5.052263 d-02
      allz(6,4,1) = 2.809354 d-02
      allc(1,4,1) = 3.775056 d-03
      allc(2,4,1) =-5.585965 d-02
      allc(3,4,1) =-3.192946 d-01
      allc(4,4,1) =-2.764780 d-02
      allc(5,4,1) = 9.049199 d-01
      allc(6,4,1) = 3.406258 d-01
c                                   4p
      allc(1,4,2) =-7.052075 d-03
      allc(2,4,2) =-5.259505 d-02
      allc(3,4,2) =-3.773450 d-02
      allc(4,4,2) = 3.874773 d-01
      allc(5,4,2) = 5.791672 d-01
      allc(6,4,2) = 1.221817 d-01
      allz(1,4,2) = 1.365346 d+00
      allz(2,4,2) = 4.393213 d-01
      allz(3,4,2) = 1.877069 d-01
      allz(4,4,2) = 9.360270 d-02
      allz(5,4,2) = 5.052263 d-02
      allz(6,4,2) = 2.809354 d-02
c                                     5s
      allz(1,5,1) = 7.701420258d-01
      allz(2,5,1) = 2.756268915d-01
      allz(3,5,1) = 1.301847480d-01
      allz(4,5,1) = 6.953441940d-02
      allz(5,5,1) = 4.002545502d-02
      allz(6,5,1) = 2.348388309d-02
      allc(1,5,1) = 1.267447151d-02
      allc(2,5,1) = 3.266734789d-03
      allc(3,5,1) =-4.307553999d-01
      allc(4,5,1) =-3.231998963d-01
      allc(5,5,1) = 1.104322879d+00
      allc(6,5,1) = 4.368498703d-01
c                                      5p
      allz(1,5,2) = 7.701420258d-01
      allz(2,5,2) = 2.756268915d-01
      allz(3,5,2) = 1.301847480d-01
      allz(4,5,2) = 6.953441940d-02
      allz(5,5,2) = 4.002545502d-02
      allz(6,5,2) = 2.348388309d-02
      allc(1,5,2) =-1.105673292d-03
      allc(2,5,2) =-6.243132446d-02
      allc(3,5,2) =-1.628476766d-01
      allc(4,5,2) = 3.210328714d-01
      allc(5,5,2) = 6.964579592d-01
      allc(6,5,2) = 1.493146125d-01
      do 30 i=1,10
         if(mtype(i).eq.0)goto 30
         ni=mtype(i)
         xi=zs(ni)
         ia=i*4-3
         ib=ia+3
         if(ni.lt.2) then
            nqn=1
         elseif(ni.lt.10)then
            nqn=2
         elseif(ni.lt.18)then
            nqn=3
         elseif(ni.lt.36)then
            nqn=4
         elseif(ni.lt.54)then
            nqn=5
         else
            write(mfgw,*)' no gaussians available'
_IF(ipsc,tools)
            call pend
_ELSE
            stop
_ENDIF
         endif
         do 20 k=ia,ib
            l=1
            if(k.gt.ia) l=2
            if(k.gt.ia) xi=zp(ni)
            do 10 j=1,6
               cc(k,j)=allc(j,nqn,l)
   10       zz(k,j)=allz(j,nqn,l)*xi**2
   20    continue
   30 continue
      return
      end
      subroutine solrot (ni,nj,xi,xj,wj,wk,kr,e1b,e2a,enuc,cutoff)
      implicit REAL (a-h,o-z)
      dimension xi(3), xj(3), wj(100), wk(100), e1b(10), e2a(10)
************************************************************************
*
*   solrot forms the two-electron two-atom j and k integral strings.
*          on exit wj = "j"-type integrals
*                  wk = "k"-type integrals
*
*      for molecules, wj = wk.
************************************************************************
      common /euler/ tvec(3,3), id
      common /ucell/ l1l,l2l,l3l,l1u,l2u,l3u
      common /numcal/ numcal
      dimension wsum(100), wbits(100), lims(3,2), xjuc(3), e1bits(10),
     1e2bits(10), wmax(100)
      save icalcn
      equivalence (l1l,lims(1,1))
      data icalcn/0/
      if(icalcn.ne.numcal)then
         icalcn=numcal
c$doit asis
         do 10 i=1,id
            lims(i,1)=-1
   10    lims(i,2)= 1
c$doit asis
         do 20 i=id+1,3
            lims(i,1)=0
   20    lims(i,2)=0
      endif
      one=1.d0
      if(xi(1).eq.xj(1) .and. xi(2).eq.xj(2) .and. xi(3).eq. xj(3))
     1one=0.5d0
      do 30 i=1,100
         wmax(i)=0.d0
         wsum(i)=0.d0
   30 wbits(i)=0.d0
      nequal=1
      do 40 i=1,10
         e1b(i)=0.d0
   40 e2a(i)=0.d0
      enuc=0.d0
      do 90 i=l1l,l1u
         do 90 j=l2l,l2u
            do 90 k=l3l,l3u
c$doit asis
               do 50 l=1,3
   50          xjuc(l)=xj(l)+tvec(l,1)*i+tvec(l,2)*j+tvec(l,3)*k
               kb=1
               call moprat(ni,nj,xi,xjuc,wbits,kb,e1bits,e2bits,enubit,
     +  cutoff)
               kb=kb-1
               do 60 ii=1,kb
   60          wsum(ii)=wsum(ii)+wbits(ii)
               if(wmax(1).lt.wbits(1))then
                  do 70 ii=1,kb
   70             wmax(ii)=wbits(ii)
               endif
               do 80 ii=1,10
                  e1b(ii)=e1b(ii)+e1bits(ii)
   80          e2a(ii)=e2a(ii)+e2bits(ii)
               enuc=enuc+enubit*one
   90 continue
      if(one.lt.0.9d0) then
         do 100 i=1,kb
  100    wmax(i)=0.d0
      endif
      do 110 i=1,kb
         wk(i)=wmax(i)
  110 wj(i)=wsum(i)
      kr=kb+kr
      return
      end
      subroutine space(mreset, mset, xparam, grad, heat, nvar,
     1xset, gset, eset, frst)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      dimension xparam(nvar), grad(nvar)
      dimension xset(mreset*nvar),gset(mreset*nvar), eset(mreset)
      logical frst
      save nreset
c
c     update parameter and gradient subspace
c
      if(frst)then
         nreset=min0(nvar/2,mreset)
         frst=.false.
         mset=0
      endif
c
      if (mset .eq. nreset) then
         do 10 i=1,mset-1
            mi = nvar*(i-1)
            ni = nvar*i
            eset(i)=eset(i+1)
            do 10 k=1,nvar
               xset(mi+k) = xset(ni+k)
   10    gset(mi+k) = gset(ni+k)
         mset=nreset-1
      endif
c
c     store the current point
c
      do 20 k=1,nvar
         nmk = nvar*mset+k
         xset(nmk) = xparam(k)
   20 gset(nmk) = grad(k)
      mset=mset+1
      eset(mset)=heat
c
      return
      end
      subroutine spline
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      logical skip1,skip2
c
c     fit f(x) by a cubic spline given values of the function
c     and its first derivative at n pnts.
c     subroutine returns values of xmin,fmin, and dfmin
c     and may reorder the data.
c     calling program supplies all other values in the
c     common block.
c     xlow and xhigh set limits on the interval within which
c     to search.  subroutine may further reduce this interval.
c
      common/fit/n,idum2,xlow,xhigh,xmin,fmin,dfmin,x(12),f(12),df(12)
      save close, big, huge, ustep, dstep
      data close, big, huge, ustep, dstep/
     + 1.0d-8,500.0d0,1.0d+10,1.0d0,2.0d0/
c
c     subroutine assumes that the first n-1 data pnts have been
c     previously ordered,  x(i).lt.x(i+1) for i=1,2,...,n-2
c     now move nth point to its proper place.
c
      xmin=x(n)
      fmin=f(n)
      dfmin=df(n)
      n1=n-1
      k=n1
   10 if(x(k).lt.xmin) go to 20
      x(k+1)=x(k)
      f(k+1)=f(k)
      df(k+1)=df(k)
      k=k-1
      if(k.gt.0) go to 10
   20 x(k+1)=xmin
      f(k+1)=fmin
      df(k+1)=dfmin
c
c     define the interval within which we trust the spline fit.
c     ustep =  up hill step size factor
c     dstep = down hill step size factor
c
      if(df(1).gt.0.0d0) step=dstep
      if(df(1).le.0.0d0) step=ustep
      xstart=x(1)-step*(x(2)-x(1))
      xstart=dmax1(xstart,xlow)
      if(df(n).gt.0.0d0) step=ustep
      if(df(n).le.0.0d0) step=dstep
      xstop=x(n)+step*(x(n)-x(n1))
      xstop=dmin1(xstop,xhigh)
c
c     search for minimum
c
      do 110 k=1,n1
         skip1=k.ne.1
         skip2=k.ne.n1
         if(f(k).ge.fmin) go to 30
         xmin=x(k)
         fmin=f(k)
         dfmin=df(k)
   30    dx=x(k+1)-x(k)
c
c     skip interval if pnts are too close together
c
         if(dx.le.close) go to 110
         x1=0.0d0
         if(k.eq.1) x1=xstart-x(1)
         x2=dx
         if(k.eq.n1) x2=xstop-x(n1)
c
c     (a,b,c)=coef of (cubic,quadratic,linear) terms
c
         dum=(f(k+1)-f(k))/dx
         a=(df(k)+df(k+1)-dum-dum)/(dx*dx)
         b=(dum+dum+dum-df(k)-df(k)-df(k+1))/dx
         c=df(k)
c
c     xk = x-x(k) at the minimum within the kth subinterval
c     test for pathological cases.
c
         bb=b*b
         ac3=(a+a+a)*c
         if(bb.lt.ac3) go to 90
         if( b.gt.0.0d0) go to 40
         if(dabs(b).gt.huge*dabs(a)) go to 90
         go to 50
   40    if(bb.gt.big*dabs(ac3)) go to 60
c
c     well behaved cubic
c
   50    xk=(-b+dsqrt(bb-ac3))/(a+a+a)
         go to 70
c
c     cubic is dominated by quadratic term
c
   60    r=ac3/bb
         xk=-(((0.0390d0*r+0.0625d0)*r+0.125d0)*r+0.5d0)*c/b
   70    if(xk.lt.x1.or.xk.gt.x2) go to 90
   80    fm=((a*xk+b)*xk+c)*xk+f(k)
         if(fm.gt.fmin) go to 90
         xmin=xk+x(k)
         fmin=fm
         dfmin=((a+a+a)*xk+b+b)*xk+c
c
c     extrapolate to end of interval if k=1 and/or k=n1
c
   90    if(skip1) go to 100
         skip1=.true.
         xk=x1
         go to 80
  100    if(skip2) go to 110
         skip2=.true.
         xk=x2
         go to 80
  110 continue
      return
      end
      function ss(na,nb,la1,lb1,m1,ua,ub,r1)
      implicit REAL (a-h,o-z)
      logical first
      dimension fa(0:13),aff(0:2,0:2,0:2),af(0:19),bf(0:19),
     1bi(0:12,0:12)
      save aff, fa, bi, first
      data first /.true./
      data aff/27*0.d0/
      data fa/1.d0,1.d0,2.d0,6.d0,24.d0,120.d0,720.d0,5040.d0,40320.d0,
     1362880.d0,3628800.d0,39916800.d0,479001600.d0,6227020800.d0/
      m=m1-1
      lb=lb1-1
      la=la1-1
      r=r1/0.529167d0
      if(first) then
         first=.false.
c
c           initialise some constants
c
c                  binomials
c
         do 10 i=0,12
            bi(i,0)=1.d0
            bi(i,i)=1.d0
   10    continue
         do 20 i=0,11
            i1=i-1
            do 20 j=0,i1
               bi(i+1,j+1)=bi(i,j+1)+bi(i,j)
   20    continue
         aff(0,0,0)=1.d0
         aff(1,0,0)=1.d0
         aff(1,1,0)=1.d0
         aff(2,0,0)=1.5d0
         aff(2,1,0)=1.73205d0
         aff(2,2,0)=1.224745d0
         aff(2,0,2)=-0.5d0
      endif
      p=(ua+ub)*r*0.5d0
      b=(ua-ub)*r*0.5d0
      ex=dexp(b)
      quo=1/p
      af(0)=quo*dexp(-p)
      do 30 n=1,19
         af(n)=n*quo*af(n-1)+af(0)
   30 continue
      call bfn(b,bf)
      sum=0.d0
      lam1=la-m
      lbm1=lb-m
c
c          start of overlap calculation proper
c
      do 50 i=0,lam1,2
         ia=na+i-la
         ic=la-i-m
         do 50 j=0,lbm1,2
            ib=nb+j-lb
            id=lb-j-m
            sum1=0.d0
            iab=ia+ib
            do 40 k1=0,ia
               do 40 k2=0,ib
                  do 40 k3=0,ic
                     do 40 k4=0,id
                        do 40 k5=0,m
                           iaf=iab-k1-k2+k3+k4+2*k5
                           do 40 k6=0,m
                              ibf=k1+k2+k3+k4+2*k6
                              jx=(-1)**(m+k2+k4+k5+k6)
                              sum1=sum1+bi(id,k4)*
     1bi(m,k5)*bi(ic,k3)*bi(ib,k2)*bi(ia,k1)*
     2bi(m,k6)*jx*af(iaf)*bf(ibf)
   40       continue
            sum=sum+sum1*aff(la,m,i)*aff(lb,m,j)
   50 continue
      ss=sum*r**(na+nb+1)*ua**na*ub**nb/(2.d0**(m+1))*
     1   dsqrt(ua*ub/(fa(na+na)*fa(nb+nb))*((la+la+1)*(lb+lb+1)))
      return
      end
      subroutine supdot(s,h,g,n,ig)
      implicit REAL (a-h,o-z)
c     (s)=(h)*(g) with  h  in packed form (canonical order).
c     ig is the increment for the vector g.
      dimension s(*),h(*),g(*)
c     cray-1 version
ccc      k=1
ccc      l=1
ccc      do 10 i=1,n
ccc      s(i)=sdot(i,h(k),1,g,ig,i)
ccc      if(i.gt.1) then
ccc         l=l+ig
ccc         call saxpy(i-1,g(l),h(k),1,s,1)
ccc      endif
ccc   10 k=k+i
ccc      return
ccc      end
c     scalar version ok with ig=1 only.
      k=0
      do 20 i=1,n
         sum=0.d0
         do 10 j=1,i
   10    sum=sum+g(j)*h(k+j)
         s(i)=sum
   20 k=k+i
      if (n.eq.1) return
      k=1
      do 40 i=2,n
         gi=g(i)
         do 30 j=1,i-1
   30    s(j)=s(j)+h(k+j)*gi
   40 k=k+i
      return
      end
      subroutine surfac(scale,dens,ipt)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
c***********************************************************************
c
c      this routine calculates the molecular surface of a molecule
c      given the coordinates of its atoms.  van der waals' radii for
c      the atoms and the probe radius must also be specified.
c
c      on input    scale = initial van der waals' scale factor
c                  dens  = density of points per unit area
c
c      this routine was lifted from michael connolly's surface
c      program for ucsf graphics system by u.chandra singh and
c      p.a.kollman and modified for use in quest. k.m.merz
c      adapted and cleaned up this program for use in ampac/mopac
c      in feb. 1989 at ucsf.
c
c***********************************************************************
      common /cmpg/   geo(3,numatm)
      common /geokst/ natoms,labels(numatm),
     1                na(numatm),nb(numatm),nc(numatm)
      common /keywrd/ keywrd
c
      common /abc/    co(3,numatm),ian(numatm),natom
      common /work1/    potpt(3,mesp), pad1(2*mesp), rad(mesp),
     1ias(mesp)
      common /potesp/ xc,yc,zc,espnuc,espele,nesp
      common/iofile/mfgr,mfgw
c
      character*241 keywrd
c
c     cartesian coordinate and atom labels
c
      dimension coord(3,numatm),vander(100)
      dimension con(3,1000)
c
c     neighbor arrays
c
c     this same dimension for the maximum number of neighbors
c     is used to dimension arrays in the function collidm
c
      dimension inbr(200),cnbr(3,200),rnbr(200)
      logical snbr(200),mnbr(200)
c
c     arrays for all atoms
c
c     iatom, jatom and katom coordinates
c
      dimension ci(3), ieldat(56), temp0(3)
c
c     geometric construction vectors
c
      dimension cw(3,2)
c
c     logical variables
c
      logical si
c
c     logical functions
c
      logical collidm
c
c     data for vander vall radii
c
      character marker*3, markss*3, mynam*3, ieldat*4, namatm*4
      data vander/1.20d0,1.20d0,1.37d0,1.45d0,1.45d0,1.50d0,1.50d0,
     1            1.40d0,1.35d0,1.30d0,1.57d0,1.36d0,1.24d0,1.17d0,
     2            1.80d0,1.75d0,1.70d0,17*0.0d0,2.3d0,65*0.0d0/
      data marker/'a  '/,markss/'ss0'/,mynam/'uc '/
c
      data ieldat/'  bq','  h ','  he','  li','  be','  b ',
     1            '  c ','  n ','  o ','  f ','  ne','  na',
     2            '  mg','  al','  si','  p ','  s ','  cl',
     3            '  ar','  k ','  ca','  sc','  ti','  v ',
     4            '  cr','  mn','  fe','  co','  ni','  cu',
     5            '  zn','  ga','  ge','  as','  se','  br',
     6            '  kr','  rb','  sr','   y','  zr','  nb',
     7            '  mo','  tc','  ru','  rh','  pd','  ag',
     8            '  cd','  in','  sn','  sb','  te','   i',
     9            '   x','  cs'/
      pi=4.d0*datan(1.d0)
c     insert van der waal radii for zinc
      vander(30)=1.00d0
c
c     convert internal to cartesian coordinates
c
      call gmetry(geo,coord)
c
c     strip coordinates and atom label for dummies (i.e. 99)
c
      icntr = 0
      do 20 i=1,natoms
         do 10 j=1,3
   10    co(j,i) = coord(j,i)
         if(labels(i) .eq. 99) goto 20
         icntr = icntr + 1
         ian(icntr) = labels(i)
   20 continue
c
c     only van der waals' type surface is generated
c
      iop = 1
      rw =0.0d0
      natom = icntr
      den = dens
      do 30 i=1,natom
         ipoint = ian(i)
         rad(i) = vander(ipoint)*scale
         if (rad(i) .lt. 0.01d0) then
         write(mfgw,'(t2,''van der waals'''' radius for atom '',i3,
     1         '' is zero, supply a value in subroutine surfac)''
     2         )')
         endif
         ias(i) = 2
   30 continue
c
c     big loop for each atom
c
      do 110 iatom = 1, natom
         if (ias(iatom) .eq. 0) go to 110
c
c     transfer values from large arrays to iatom variables
c
         namatm =ieldat(ian(iatom)+1)
         ri = rad(iatom)
         si = ias(iatom) .eq. 2
         do 40 k = 1,3
            ci(k) = co(k,iatom)
   40    continue
c
c     gather the neighboring atoms of iatom
c
         nnbr = 0
         do 60 jatom = 1, natom
            if (iatom .eq. jatom .or. ias(jatom) .eq. 0) go to 60
            d2 = dist2m(ci,co(1,jatom))
            if (d2 .ge. (2*rw+ri+rad(jatom)) ** 2) go to 60
c
c     we have a new neighbor
c     transfer atom coordinates, radius and surface request number
c
            nnbr = nnbr + 1
            if (nnbr .gt. 200)then
            write (mfgw,'(''error'',2x,''too many neighbors:'',i5)')nnbr
_IF(ipsc,tools)
               call pend
_ELSE
               stop
_ENDIF
            endif
            inbr(nnbr) = jatom
            do 50 k = 1,3
               cnbr(k,nnbr) = co(k,jatom)
   50       continue
            rnbr(nnbr) = rad(jatom)
            snbr(nnbr) = ias(jatom) .eq. 2
   60    continue
c
c     contact surface
c
         if (.not. si) go to 110
         ncon = (4 * pi * ri ** 2) * den
         if (ncon .gt. 1000) ncon = 1000
c
c     this call may decrease ncon somewhat
c
         if ( ncon .eq. 0) then
            write(mfgw,'(t2,''vector length of zero in surfac'')')
_IF(ipsc,tools)
            call pend
_ELSE
            stop
_ENDIF
         endif
         call genunm(con,ncon)
         area = (4 * pi * ri ** 2) / ncon
c
c     contact probe placement loop
c
         do 100 i = 1,ncon
            do 70 k = 1,3
               cw(k,1) = ci(k) + (ri + rw) * con(k,i)
   70       continue
c
c     check for collision with neighboring atoms
c
            if (collidm(cw(1,1),rw,cnbr,rnbr,mnbr,nnbr,1,
     1      jnbr,knbr)) go to 100
            do 80 kk=1,3
               temp0(kk) =ci(kk)+ri*con(kk,i)
   80       continue
c
c     store point in potpt and increment nesp
c
            nesp = nesp + 1
            if (nesp .gt. mesp) then
               write(mfgw,90)
   90          format(/'error - to many points generated in surfac')
            write(mfgw,'(''    reduce nsurf, scale, den, or scincr'')')
_IF(ipsc,tools)
               call pend
_ELSE
               stop
_ENDIF
            endif
            potpt(1,nesp) = temp0(1)
            potpt(2,nesp) = temp0(2)
            potpt(3,nesp) = temp0(3)
  100    continue
  110 continue
      return
      end
      subroutine sybgrid
c
c     plagerised williams surface routine
c     with definable grid and shell size
c
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      dimension vderw(53),dist(100)
      dimension xmin(3),xmax(3),coord(3,numatm)
      character*241 keywrd
      common /cmpg/   geo(3,numatm)
      common /geokst/ natoms,labels(numatm), nabc(3*numatm)
c
      common /abc/    co(3,numatm),ian(numatm),natom
      common /work1/    potpt(3,mesp), work1d(4*mesp)
      common /keywrd/ keywrd
      common /potesp/ xc,yc,zc,espnuc,espele,nesp
      common/iofile/mfgr,mfgw
c
      data vderw/53*0.0d0/
      if(index(keywrd,'vdwsf=') .ne. 0) then
         vdwsf = reada(keywrd,index(keywrd,'vdwsf='))
      else
         vdwsf=1.0d0
      endif
      vderw(1)=1.08d0 * vdwsf
      vderw(5)=1.5d0 * vdwsf
      vderw(6)=1.53d0 * vdwsf
      vderw(7)=1.48d0 * vdwsf
      vderw(8)=1.36d0 * vdwsf
      vderw(9)=1.30d0 * vdwsf
      vderw(14)=2.10d0 * vdwsf
      vderw(15)=1.75d0 * vdwsf
      vderw(16)=1.70d0 * vdwsf
      vderw(17)=1.65d0 * vdwsf
      vderw(35)=1.80d0 * vdwsf
      vderw(50)=1.80d0 * vdwsf
      vderw(53)=2.05d0 * vdwsf
      if(index(keywrd,'grid=') .ne. 0) then
         grdd = reada(keywrd,index(keywrd,'grid='))
      else
         grdd=1.0d0
      endif
      if(index(keywrd,'shell=') .ne. 0) then
         shell = reada(keywrd,index(keywrd,'shell='))
      else
         shell=6.0d0
      endif
c      grdd = grdd * bohr
c      shell = shell * bohr
      nesp=0
      closer=0.d0
c     check if vderw is defined for all atoms
c
c     convert internal to cartesian coordinates
c
      call gmetry(geo,coord)
c
c     strip coordinates and atom label for dummies (i.e. 99)
c
      icntr = 0
      do 20 i=1,natoms
         do 10 j=1,3
   10       co(j,i) = coord(j,i)
         if(labels(i) .eq. 99) goto 20
         icntr = icntr + 1
         ian(icntr) = labels(i)
   20 continue
      natom=icntr
c
      do 30 i=1,natom
         j=ian(i)
         if (vderw(j).eq.0.0d0) go to 40
   30 continue
      go to 50
   40 continue
      write(mfgw,*) 'van der waals'' radius not defined for atom',i
      write(mfgw,*) 'in williams surface routine pdgrid!'
_IF(ipsc,tools)
      call pend
_ELSE
      stop
_ENDIF
c     now create limits for a box
   50 do 100 ix = 1,3
         xmin(ix)= 100000.0d0
         xmax(ix)=-100000.0d0
         do 90 ia = 1,natom
            if (co(ix,ia)-xmin(ix))60,70,70
   60       xmin(ix)=co(ix,ia)
   70       if (co(ix,ia)-xmax(ix))90,90,80
   80       xmax(ix)=co(ix,ia)
   90    continue
  100 continue
c     add (or subtract) the maximum vderw plus shell
      vdmax=0.0d0
      do 110 i=1,53
         if (vderw(i).gt.vdmax) vdmax=vderw(i)
  110 continue
      do 120 i=1,3
         xmin(i)=xmin(i)-vdmax-shell
  120 xmax(i)=xmax(i)+vdmax+shell
c step grid back from zero to find starting points
      xstart=0.0d0
  130 xstart=xstart-grdd
      if (xstart.gt.xmin(1)) go to 130
      ystart=0.0d0
  140 ystart=ystart-grdd
      if (ystart.gt.xmin(2)) go to 140
      zstart=0.0d0
  150 zstart=zstart-grdd
      if (zstart.gt.xmin(3)) go to 150
      npnt=0
      zgrdd=zstart
  160 ygrdd=ystart
  170 xgrdd=xstart
  180 do 190 l=1,natom
         jz=ian(l)
         dist(l)=dsqrt((co(1,l)-xgrdd)**2+(co(2,l)-ygrdd)**2+
     1 (co(3,l)-zgrdd)**2)
c     reject grid point if any atom is too close
         if(dist(l).lt.(vderw(jz)-closer)) go to 220
  190 continue
c but at least one atom must be close enough
      do 200 l=1,natom
         jz=ian(l)
         if(dist(l).gt.(vderw(jz)+shell)) go to 200
         go to 210
  200 continue
      go to 220
  210 npnt=npnt+1
      nesp=nesp+1
      potpt(1,nesp)=xgrdd
      potpt(2,nesp)=ygrdd
      potpt(3,nesp)=zgrdd
  220 xgrdd=xgrdd+grdd
      if (xgrdd.le.xmax(1)) go to 180
      ygrdd=ygrdd+grdd
      if (ygrdd.le.xmax(2)) go to 170
      zgrdd=zgrdd+grdd
      if (zgrdd.le.xmax(3)) go to 160
      return
      end
      subroutine timclk(secs)
      implicit  REAL  (a-h,o-z)      
_IFN(ipsc)
_IFN(rs6000)
_IFN1(k)      real *4  etime, dum, tarray(2)
_IF1(k)      REAL tarray(2)
c for convex etc :-
cjvl      dum = etime(tarray)
cjvl      secs = tarray(1)
      secs = cpulft(1)
_ELSE
c for cdc, ibm rs6000, iris :-
      secs = mclock () / 100.d0
_ENDIF
_ELSE
      logical first
      data first/.true./
      save first,slast
c
      if(first) then
         first = .false.
         slast = dclock()
         secs = 0.0d0
      else
         xtemp = dclock()
         secs = xtemp - slast
         slast = xtemp
      endif
_ENDIF
      return
      end
      subroutine timop(a)
      implicit REAL (a-h,o-z)
      common/iofile/mfgr,mfgw
      character*(*) a
      logical first
      data first/.true./
      if(first)then
c
c  define the zero of time
c
         t0=secmop()
         t1=t0
         first=.false.
      endif
c
c   the act of calling this routine costs 0.026 seconds
c
      t0=t0+0.026d0
      t2=secmop()
      if(index(a,'bef').eq.0.and.a.ne.' ')then
         write(mfgw,'(2x,a,a,f7.2,a,f8.2)')
     1a,' interval:',t2-t1,' integral:',t2-t0
      else
         write(mfgw,'(40x,''time lost:'',f7.2)')t2-t1
      endif
      t1=t2+0.026d0
      return
      end
      subroutine mtql2(nm,n,d,e,z,ierr,eps)
      implicit REAL (a-h,o-z)
c               ===== processed by augment, version 4n =====
c     approved for vax 11/780 on may 6,1980.  j.d.neece
c               ----- local variables -----
c               ----- global variables -----
      dimension d(n), e(n), z(nm,n)
c               ----- supporting package functions -----
c               ===== translated program =====
c
c
c     this routine is a translation of the algol procedure tql2,
c     num. math. 11, 293-306(1968) by bowdler, martin, reinsch, and
c     wilkinson.
c     handbook for auto. comp., vol.ii-linear algebra, 227-240(1971).
c
c     this routine finds the eigenvalues and eigenvectors
c     of a symmetric tridiagonal matrix by the ql method.
c     the eigenvectors of a full symmetric matrix can also
c     be found if  tred2  has been used to reduce this
c     full matrix to tridiagonal form.
c
c     on input-
c
c        nm must be set to the row dimension of two-dimensional
c          array parameters as declared in the calling program
c          dimension statement,
c
c        n is the order of the matrix,
c
c        d contains the diagonal elements of the input matrix,
c
c        e contains the subdiagonal elements of the input matrix
c          in its last n-1 positions.  e(1) is arbitrary,
c
c        z contains the transformation matrix produced in the
c          reduction by  tred2, if performed.  if the eigenvectors
c          of the tridiagonal matrix are desired, z must contain
c          the identity matrix.
c
c      on output-
c
c        d contains the eigenvalues in ascending order.  if an
c          error exit is made, the eigenvalues are correct but
c          unordered for indices 1,2,...,ierr-1,
c
c        e has been destroyed,
c
c        z contains orthonormal eigenvectors of the symmetric
c          tridiagonal (or full) matrix.  if an error exit is made,
c          z contains the eigenvectors associated with the stored
c          eigenvalues,
c
c        ierr is set to
c          zero       for normal return,
c          j          if the j-th eigenvalue has not been
c                     determined after 30 iterations.
c
c     questions and comments should be directed to b. s. garbow,
c     applied mathematics division, argonne national laboratory
c
c     ------------------------------------------------------------------
c
c
      ierr = 0
      if (n .eq. 1) go to 160
c
      do 10   i = 2, n
   10 e(i-1) = e(i)
c
      f=0.0d0
      b=0.0d0
      e(n)=0.0d0
c
      do 110   l = 1, n
         j = 0
         h=eps*(dabs(d(l))+dabs(e(l)))
         if (b .lt. h) b=h
c     ********** look for small sub-diagonal element **********
         do 20   m = l, n
            if (dabs(e(m)).le.b)  go to 30
c     ********** e(n) is always zero, so there is no exit
c                through the bottom of the loop **********
   20    continue
c
   30    if (m .eq. l) go to 100
   40    if (j .eq. 30) go to 150
         j = j + 1
c     ********** form shift **********
         l1 = l + 1
         g = d(l)
         p=(d(l1)-g)/(2.0d0*e(l))
         r=dsqrt(p*p+1.0d0)
         d(l)=e(l)/(p+dsign(r,p))
         h = g - d(l)
c
         do 50   i = l1, n
   50    d(i) = d(i) - h
c
         f = f + h
c     ********** ql transformation **********
         p = d(m)
         c=1.0d0
         s=0.0d0
         mml = m - l
c     ********** for i=m-1 step -1 until l do -- **********
         do 90   ii = 1, mml
            i = m - ii
            g = c * e(i)
            h = c * p
            if (dabs(p).lt.dabs(e(i)))  go to 60
            c = e(i) / p
            r=dsqrt(c*c+1.0d0)
            e(i+1) = s * p * r
            s = c / r
            c=1.0d0/r
            go to 70
   60       c = p / e(i)
            r=dsqrt(c*c+1.0d0)
            e(i+1) = s * e(i) * r
            s=1.0d0/r
            c = c * s
   70       p = c * d(i) - s * g
            d(i+1) = h + s * (c * g + s * d(i))
c     ********** form vector **********
            do 80   k = 1, n
               h = z(k,i+1)
               z(k,i+1) = s * z(k,i) + c * h
               z(k,i) = c * z(k,i) - s * h
   80       continue
c
   90    continue
c
         e(l) = s * p
         d(l) = c * p
         if (dabs(e(l)).gt.b)  go to 40
  100    d(l) = d(l) + f
  110 continue
c     ********** order eigenvalues and eigenvectors **********
      do 140   ii = 2, n
         i = ii - 1
         k = i
         p = d(i)
c
         do 120   j = ii, n
            if (d(j) .ge. p) go to 120
            k = j
            p = d(j)
  120    continue
c
         if (k .eq. i) go to 140
         d(k) = d(i)
         d(i) = p
c
         do 130   j = 1, n
            p = z(j,i)
            z(j,i) = z(j,k)
            z(j,k) = p
  130    continue
c
  140 continue
c
      go to 160
c     ********** set error -- no convergence to an
c                eigenvalue after 30 iterations **********
  150 ierr = l
  160 return
c     ********** last card of mtql2 **********
      end
      subroutine mtqlrt(n,d,e2,ierr,eps)
      implicit REAL (a-h,o-z)
c               ===== processed by augment, version 4n =====
c     approved for vax 11/780 on may 6,1980.  j.d.neece
c               ----- local variables -----
c               ----- global variables -----
      dimension d(n), e2(n)
c               ----- supporting package functions -----
c               ===== translated program =====
c
c
c     this routine is a translation of the algol procedure tqlrat,
c     algorithm 464, comm. acm 16, 689(1973) by reinsch.
c
c     this routine finds the eigenvalues of a symmetric
c     tridiagonal matrix by the rational ql method.
c
c     on input-
c
c        n is the order of the matrix,
c
c        d contains the diagonal elements of the input matrix,
c
c        e2 contains the squares of the subdiagonal elements of the
c          input matrix in its last n-1 positions.  e2(1) is arbitrary.
c
c      on output-
c
c        d contains the eigenvalues in ascending order.  if an
c          error exit is made, the eigenvalues are correct and
c          ordered for indices 1,2,...ierr-1, but may not be
c          the smallest eigenvalues,
c
c        e2 has been destroyed,
c
c        ierr is set to
c          zero       for normal return,
c          j          if the j-th eigenvalue has not been
c                     determined after 30 iterations.
c
c     questions and comments should be directed to b. s. garbow,
c     applied mathematics division, argonne national laboratory
c
c     ------------------------------------------------------------------
c
c
      ierr = 0
      if (n .eq. 1) go to 140
c
      do 10   i = 2, n
   10 e2(i-1) = e2(i)
c
      f=0.0d0
      b=0.0d0
      e2(n)=0.0d0
c
      do 120   l = 1, n
         j = 0
         h=eps*(dabs(d(l))+dsqrt(e2(l)))
         if (b .gt. h) go to 20
         b = h
         c = b * b
c     ********** look for small squared sub-diagonal element **********
   20    do 30   m = l, n
            if (e2(m) .le. c) go to 40
c     ********** e2(n) is always zero, so there is no exit
c                through the bottom of the loop **********
   30    continue
c
   40    if (m .eq. l) go to 80
   50    if (j .eq. 30) go to 130
         j = j + 1
c     ********** form shift **********
         l1 = l + 1
         s=dsqrt(e2(l))
         g = d(l)
         p=(d(l1)-g)/(2.0d0*s)
         r=dsqrt(p*p+1.0d0)
         d(l)=s/(p+dsign(r,p))
         h = g - d(l)
c
         do 60   i = l1, n
   60    d(i) = d(i) - h
c
         f = f + h
c     ********** rational ql transformation **********
         g = d(m)
         if (g.eq.0.0d0) g=b
         h = g
         s=0.0d0
         mml = m - l
c     ********** for i=m-1 step -1 until l do -- **********
         do 70   ii = 1, mml
            i = m - ii
            p = g * h
            r = p + e2(i)
            e2(i+1) = s * r
            s = e2(i) / r
            d(i+1) = h + s * (h + d(i))
            g = d(i) - e2(i) / g
            if (g.eq.0.0d0) g=b
            h = g * p / r
   70    continue
c
         e2(l) = s * g
         d(l) = h
c     ********** guard against underflow in convergence test **********
         if (h.eq.0.0d0)  go to 80
         if (dabs(e2(l)).le.dabs(c/h))  go to 80
         e2(l) = h * e2(l)
         if (e2(l).ne.0.0d0)  go to 50
   80    p = d(l) + f
c     ********** order eigenvalues **********
         if (l .eq. 1) go to 100
c     ********** for i=l step -1 until 2 do -- **********
         do 90   ii = 2, l
            i = l + 2 - ii
            if (p .ge. d(i-1)) go to 110
            d(i) = d(i-1)
   90    continue
c
  100    i = 1
  110    d(i) = p
  120 continue
c
      go to 140
c     ********** set error -- no convergence to an
c                eigenvalue after 30 iterations **********
  130 ierr = l
  140 return
c     ********** last card of mtqlrt **********
      end
      subroutine trbak3(nm,n,nv,a,m,z,eps)
      implicit REAL (a-h,o-z)
c               ===== processed by augment, version 4n =====
c     approved for vax 11/780 on may 6,1980.  j.d.neece
c               ----- local variables -----
c               ----- global variables -----
      dimension a(nv), z(nm,m)
c               ===== translated program =====
c
c
c     this routine is a translation of the algol procedure trbak3,
c     num. math. 11, 181-195(1968) by martin, reinsch, and wilkinson.
c     handbook for auto. comp., vol.ii-linear algebra, 212-226(1971).
c
c     this routine forms the eigenvectors of a real symmetric
c     matrix by back transforming those of the corresponding
c     symmetric tridiagonal matrix determined by  tred3.
c
c     on input-
c
c        nm must be set to the row dimension of two-dimensional
c          array parameters as declared in the calling program
c          dimension statement,
c
c        n is the order of the matrix,
c
c        nv must be set to the dimension of the array parameter a
c          as declared in the calling program dimension statement,
c
c        a contains information about the orthogonal transformations
c          used in the reduction by  tred3  in its first
c          n*(n+1)/2 positions,
c
c        m is the number of eigenvectors to be back transformed,
c
c        z contains the eigenvectors to be back transformed
c          in its first m columns.
c
c     on output-
c
c        z contains the transformed eigenvectors
c          in its first m columns.
c
c     note that trbak3 preserves vector euclidean norms.
c
c     questions and comments should be directed to b. s. garbow,
c     applied mathematics division, argonne national laboratory
c
c     ------------------------------------------------------------------
c
      if (m .eq. 0) go to 50
      if (n .eq. 1) go to 50
c
      do 40   i = 2, n
         l = i - 1
         iz = (i * l) / 2
         ik = iz + i
         h = a(ik)
         if (h.eq.0.0d0)  go to 40
c
         do 30   j = 1, m
            s=0.0d0
            ik = iz
c
            do 10   k = 1, l
               ik = ik + 1
               s = s + a(ik) * z(k,j)
   10       continue
c     ********** double division avoids possible underflow **********
            s = (s / h) / h
            ik = iz
c
            do 20   k = 1, l
               ik = ik + 1
               z(k,j) = z(k,j) - s * a(ik)
   20       continue
c
   30    continue
c
   40 continue
c
   50 return
c     ********** last card of trbak3 **********
      end
      subroutine tred3(n,nv,a,d,e,e2,eps,eta)
      implicit REAL (a-h,o-z)
c               ===== processed by augment, version 4n =====
c     approved for vax 11/780 on may 6,1980.  j.d.neece
c               ----- local variables -----
c               ----- global variables -----
      dimension a(nv), d(n), e(n), e2(n)
c               ----- supporting package functions -----
c               ===== translated program =====
c
c
c     this routine is a translation of the algol procedure tred3,
c     num. math. 11, 181-195(1968) by martin, reinsch, and wilkinson.
c     handbook for auto. comp., vol.ii-linear algebra, 212-226(1971).
c
c     this routine reduces a real symmetric matrix, stored as
c     a one-dimensional array, to a symmetric tridiagonal matrix
c     using orthogonal similarity transformations.
c
c     on input-
c
c        n is the order of the matrix,
c
c        nv must be set to the dimension of the array parameter a
c          as declared in the calling program dimension statement,
c
c        a contains the lower triangle of the real symmetric
c          input matrix, stored row-wise as a one-dimensional
c          array, in its first n*(n+1)/2 positions.
c
c     on output-
c
c        a contains information about the orthogonal
c          transformations used in the reduction,
c
c        d contains the diagonal elements of the tridiagonal matrix,
c
c        e contains the subdiagonal elements of the tridiagonal
c          matrix in its last n-1 positions.  e(1) is set to zero,
c
c        e2 contains the squares of the corresponding elements of e.
c          e2 may coincide with e if the squares are not needed.
c
c     questions and comments should be directed to b. s. garbow,
c     applied mathematics division, argonne national laboratory
c
c     ------------------------------------------------------------------
c
c     ********** for i=n step -1 until 1 do -- **********
      tol=eta/eps
      do 100   ii = 1, n
         i = n + 1 - ii
         l = i - 1
         iz = ( i * l ) / 2
         h=0.0d0
         scale=0.0d0
         do 10   k = 1, l
            iz = iz + 1
            d(k) = a(iz)
            scale=scale+dabs( d(k) )
   10    continue
c
         if ( scale.ne.0.d0 ) go to 20
         e(i)=0.0d0
         e2(i)=0.0d0
         go to 90
c
   20    do 30   k = 1, l
            d(k) = d(k) / scale
            h = h + d(k) * d(k)
   30    continue
c
         e2(i) = scale * scale * h
         f = d(l)
         g=-dsign(dsqrt(h),f)
         e(i) = scale * g
         h = h - f * g
         d(l) = f - g
         a(iz) = scale * d(l)
         if (l .eq. 1) go to 90
         f=0.0d0
c
         do 70   j = 1, l
            g=0.0d0
            jk = (j * (j-1)) / 2
c     ********** form element of a*u **********
            k = 0
   40       k = k + 1
            jk = jk + 1
            g = g + a(jk) * d(k)
            if ( k .lt. j ) go to 40
            if ( k .eq. l ) go to 60
   50       jk = jk + k
            k = k + 1
            g = g + a(jk) * d(k)
            if ( k .lt. l ) go to 50
c     ********** form element of p **********
   60       continue
            e(j) = g / h
            f = f + e(j) * d(j)
   70    continue
c
         hh = f / (h + h)
         jk = 0
c     ********** form reduced a **********
         do 80   j = 1, l
            f = d(j)
            g = e(j) - hh * f
            e(j) = g
c
            do 80   k = 1, j
               jk = jk + 1
               a(jk) = a(jk) - f * e(k) - g * d(k)
   80    continue
c
   90    d(i) = a(iz+1)
         a(iz+1)=scale*dsqrt(h)
  100 continue
c
      return
c     ********** last card of tred3 **********
      end
      subroutine upcase(keywrd)
      character*80 keywrd
      icapa=ichar('a')
      ilowa=ichar('a')
      ilowz=ichar('z')
      do 10 i=1,80
         iline=ichar(keywrd(i:i))
         if(iline.ge.ilowa.and.iline.le.ilowz) then
            keywrd(i:i)=char(iline+icapa-ilowa)
         endif
   10 continue
      return
      end
      subroutine vecprt (a,numm)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      dimension  a(*)
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),
     1                nlast(numatm), norbs, nelecs,nalpha,nbeta,
     2                nclose,nopen,ndumy,fract
      common /elemts/ elemnt(107)
      common/iofile/mfgr,mfgw
c**********************************************************************
c
c  vecprt prints a lower-half triangle of a square matrix, the
c         lower-half triangle being stored in packed form in the
c         array "a"
c
c on input:
c      a      = array to be printed
c      numm   = size of array to be printed
c(ref) numat  = number of atoms in the molecule (this is needed to
c               decide if an atomic array or atomic orbital array is
c               to be printed
c(ref) nat    = list of atomic numbers
c(ref) nfirst = list of orbital counters
c(ref) nlast  = list of orbital counters
c
c  none of the arguments are altered by the call of vecprt
c
c*********************************************************************
      dimension natom(maxorb)
      character * 6 line(21)
      character*2 elemnt,atorbs(9), itext(maxorb), jtext(maxorb)
      save atorbs
      data atorbs/' s','px','py','pz','x2','xz','z2','yz','xy'/
      if(numat.ne.0.and.numat.eq.numm) then
c
c    print over atom count
c
         do 10 i=1,numat
            itext(i)='  '
            jtext(i)=elemnt(nat(i))
            natom(i)=i
   10    continue
      else
         if (numat.ne.0.and.nlast(numat) .eq. numm) then
            do 30 i=1,numat
               jlo=nfirst(i)
               jhi=nlast(i)
               l=nat(i)
               k=0
               do 20 j=jlo,jhi
                  k=k+1
                  itext(j)=atorbs(k)
                  jtext(j)=elemnt(l)
                  natom(j)=i
   20          continue
   30       continue
         else
            numb=iabs(numm)
            do 40 i=1,numb
               itext(i) = '  '
               jtext(i) = '  '
   40       natom(i)=i
         endif
      endif
      numb=iabs(numm)
      do 50 i=1,21
   50 line(i)='------'
      limit=(numb*(numb+1))/2
      kk=8
      na=1
   60 ll=0
      m=min0((numb+1-na),6)
      ma=2*m+1
      m=na+m-1
      write(mfgw,100)(itext(i),jtext(i),natom(i),i=na,m)
      write (mfgw,110) (line(k),k=1,ma)
      do 80 i=na,numb
         ll=ll+1
         k=(i*(i-1))/2
         l=min0((k+m),(k+i))
         k=k+na
         if ((kk+ll).le.50) go to 70
         write (mfgw,120)
         write (mfgw,100) (itext(n),jtext(n),natom(n),n=na,m)
         write (mfgw,110) (line(n),n=1,ma)
         kk=4
         ll=0
   70    write (mfgw,130) itext(i),jtext(i),natom(i),(a(n),n=k,l)
   80 continue
      if (l.ge.limit) go to 90
      kk=kk+ll+4
      na=m+1
      if ((kk+numb+1-na).le.50) go to 60
      kk=4
      write (mfgw,120)
      go to 60
   90 return
c
  100 format (1h0/13x,10(1x,a2,1x,a2,i3,2x))
  110 format (1h ,21a6)
  120 format (1h1)
  130 format (1h ,a2,1x,a2,i5,10f11.6)
c
      end
      subroutine writmo(time0,funct)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
INCLUDE(../m4/common/utilc)
      character keywrd*241
      REAL  meci
_IF(ipsc,tools)
      logical oroot
_ENDIF
      common /keywrd/ keywrd
      common /elemts/ elemnt(107)
      common /cmpg/ geo(3,numatm)
      common /geokst/ natoms,labels(numatm),
     1                na(numatm),nb(numatm),nc(numatm)
      common /hmatrx/ h(mpack)
      common /fokmat/ f(mpack), fb(mpack)
      common /vector/ c(morb2),eigs(maxorb),cbeta(morb2),eigb(maxorb)
      common /densty/ p(mpack),pa(mpack),pb(mpack)
      common /geosym/ ndep, locpar(maxpar), idepfn(maxpar),
     1                    locdep(maxpar)
      common / euler/ tvec(3,3), id
      common /rjks/ rjkab(nmeci,nmeci), rjkaa(nmeci,nmeci)
      common /errfn/ errfn(maxpar), aicorr(maxpar)
      common /work1/  fmat2d(npulay*4), sec(npulay*2), vec(npulay*2),
     1                alband(npulay*13)
      common /path/ latom,lparam,react(200)
      common /numcal/ numcal
      common/iofile/mfgr,mfgw
      common /numscf/ nscf
      common /wmatrc/ wj(n2elec), wk(n2elec)
      common /atheat/ atheat
      common /corec/ core(107)
      common /last/ last
      common /scrach/ rxyz(mpack), xdumy(maxpar**2-mpack)
      common /cimats/ engyci(3),vectci(9),eci(6)
      common /mesage/ iflepo,iiter
      common /atmass/ atmass(numatm)
      common /enuclr/ enuclr
      common /elect/ elect
      common /xyzgra/ dxyz(9*numatm)
      common /gradnt/ grad(maxpar), gnorm
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),
     1                nlast(numatm), norbs, nelecs,nalpha,nbeta,
     2                nclose,nopen,ndumy,fract
      common /geovar/ nvar, loc(2,maxpar), idumy, xparam(maxpar)
************************************************************************
*
*   write prints out most of the results.
*         it should not alter any parameters, so that it can be called
*         at any convenient time.
*
************************************************************************
      dimension q(maxorb), q2(maxorb), coord(3,numatm)
     1,iel1(107), nelemt(107), iel2(107)
      dimension w(n2elec), dumy(3)
      logical uhf, ci, singlt, triplt, excitd, prtgra, xyz, still
      character type(3)*11, idate*24, calcn(2)*5, gtype*13, grtype*14,
     1          flepo(16)*58, iter(2)*58, numbrs(11)*1, getmop*80
      character*2 elemnt, ielemt(20), spntyp*7, caltyp*7, namfil*80
      save icalcn, numbrs, calcn, type, flepo, iter
      equivalence (w,wj)
      REAL  wj, wk
      data icalcn/0/
      data type/'bond       ','angle      ','dihedral   '/
      data calcn /'     ','alpha'/
      data numbrs /'0','1','2','3','4','5','6','7','8','9',' '/
      data flepo(1),flepo(2),flepo(3)/
     1' 1scf was specified, so bfgs was not used                 ',
     2' gradients were initially acceptably small                ',
     3' herberts test was satisfied in bfgs                      '/
      data flepo(4),flepo(5),flepo(6)/
     1' the line minimization failed twice in a row.   take care!',
     2' bfgs failed due to counts exceeded. take care!           ',
     3' peters test was satisfied in bfgs optimization           '/
      data flepo(7),flepo(8),flepo(9)/
     1' this message should never appear, consult a programmer!! ',
     2' gradient test not passed, but further work not justified ',
     3' a failure has occurred, treat results with caution!!     '/
      data flepo(10),flepo(11),flepo(12)/
     1' geometry optimized using nllsq. gradient norm minimized  ',
     2' geometry optimized using powsq. gradient norm minimized  ',
     3' cycles exceeded, gradient not fully minimized in nllsq   '/
      data flepo(13),flepo(14),flepo(15)/
     1' 1scf run after restart.  geometry might not be optimized ',
     2' heat of formation minimized in one line search           ',
     3' geometry optimised using eigenvector following (ef).     '/
      data flepo(16)/
     1' ef-optimized geometry.  number of -ve roots incorrect    '/
      data iter/
     1' scf field was achieved                                   ',
     2'  ++++----**** failed to achieve scf. ****----++++        '/
c
c summary of results (note: this is in a routine so it
c          can be used by the path option)
      pi=3.141592653589d0
      if(icalcn.eq.0)namfil='**null**'
      idate=' '
      if(iflepo.eq.0) iflepo=7
      iuhf=min0(index(keywrd,' uhf'),1)+1
      prtgra=(index(keywrd,' grad').ne.0.and.nvar.gt.0)
      linear=(norbs*(norbs+1))/2
      xyz=(index(keywrd,' xyz') .ne. 0)
      singlt=(index(keywrd,' sing') .ne. 0)
      triplt=(index(keywrd,' trip') .ne. 0)
      excitd=(index(keywrd,' exci') .ne. 0)
      spntyp='ground '
      if(singlt) spntyp='singlet'
      if(triplt) spntyp='triplet'
      if(excitd) spntyp='excited'
      ci=(index(keywrd,' c.i.') .ne. 0)
      if(index(keywrd,' mindo') .ne. 0) then
         caltyp='mindo/3'
      elseif(index(keywrd,' am1') .ne. 0) then
         caltyp='  am1  '
      elseif(index(keywrd,' pm3') .ne. 0) then
         caltyp='  pm3  '
      else
         caltyp=' mndo  '
      endif
      uhf=(iuhf.eq.2)
      call gtnv('mopacdate',idate)
      degree=57.29577951d0
      if(na(1).eq.99)then
         degree=1.d0
         type(1)='cartesian x'
         type(2)='cartesian y'
         type(3)='cartesian z'
      endif
      gnorm=0.d0
      if(nvar.ne.0)gnorm=dsqrt(ddot(nvar,grad,1,grad,1))
      write(mfgw,'(/,'' ----'',15(''-----''))')
      call wrttxt(mfgw)
      write(mfgw,'(//4x,a58)')flepo(iflepo)
      iiter=max0(1,iiter)
      write(mfgw,'(4x,a58)')iter(iiter)
      write(mfgw,'(//30x,a7,''  calculation'')')caltyp
      write(mfgw,'(55x,''version '',f5.2)')verson
      write(mfgw,'(55x,a24)')idate
      if(iiter.eq.2)then
c
c   results are meaningless. don't print anything!
c
      write(mfgw,'(//,'' for some reason the scf calculation failed.'',/
     1,'' the results would be meaningless, so will not be printed.'')')
      write(mfgw,'('' try to find the reason for the failure by using ''
     1,''"pl".'',/,
     2'' check your geometry and also try using shift or pulay. '')')
         call geout(1)
_IF(ipsc,tools)
         call pend
_ELSE
         stop
_ENDIF
      endif
      write(mfgw,
     + '(////10x,''final heat of formation ='',f17.5,
     + '' kcal'')')funct
      if(latom.eq.0) write(mfgw,'(/)')
      write(mfgw,
     +  '(    10x,''total energy            ='',f17.5,'' ev''
     1)')elect+enuclr
      write(mfgw,
     +  '(    10x,''electronic energy       ='',f17.5,'' ev''
     1)')elect
      write(mfgw,
     +  '(    10x,''core-core repulsion     ='',f17.5,'' ev''
     1)')enuclr
      if(latom.eq.0) write(mfgw,'(1x)')
      prtgra=(prtgra .or. gnorm .gt. 2.d0)
      if(prtgra)
     1write(mfgw,
     + '(    10x,''gradient norm           ='',f17.5)')gnorm
      still=.true.
      if(latom.eq.0) then
      if(index(keywrd,' aider').ne.0) goto 45
      if(index(keywrd,'1scf').ne.0.and.index(keywrd,'grad').eq.0)goto 45
c
c   check that the cartesian coordinate gradient is also small
c
            if(ddot(3*numat,dxyz,1,dxyz,1).gt.dmax1(16.d0,4*gnorm**2)
     1.and.gnorm.lt.2.d0.and.nclose.eq.nopen.and.id.eq.0) then
            write(mfgw,'(a)')' warning -- geometry is not at a stationar
     1y point'
               still=.false.
            endif
  45  continue
      else
c
c   we need to calculate the reaction coordinate gradient.
c
         mvar=nvar
         loc11=loc(1,1)
         loc21=loc(2,1)
         nvar=1
         loc(1,1)=latom
         loc(2,1)=lparam
         xreact=geo(lparam,latom)
         call mopdv(geo,gcoord)
         nvar=mvar
         loc(1,1)=loc11
         loc(2,1)=loc21
         grtype=' kcal/angstrom'
         if(lparam.eq.1)then
         write(mfgw,'(    10x,''for reaction coordinate ='',f17.5
     1        ,'' angstroms'')')xreact
         else
            if(na(1).ne.99)grtype=' kcal/radian  '
         write(mfgw,'(    10x,''for reaction coordinate ='',f17.5
     1        ,'' degrees'')')xreact*degree
         endif
      write(mfgw,'(    10x,''reaction gradient       ='',f17.5,a14
     1    )')gcoord,grtype
      endif
      if(nalpha.gt.0)then
         eionis=-dmax1(eigs(nalpha), eigb(nbeta))
      elseif(nelecs.eq.1)then
         eionis=-eigs(1)
      elseif(nelecs.gt.1) then
         eionis=-dmax1(eigs(nclose), eigs(nopen))
      else
         eionis=0.d0
      endif
      nopn=nopen-nclose
c   correction to i.p. of doublets
      if(nopn.eq.1)then
         i=nclose*norbs+1
         eionis=eionis+0.5d0*rjkab(1,1)
      endif
      if(dabs(eionis).gt.1.d-5)
     1write(mfgw,
     +  '(       10x,''ionization potential    ='',f17.5)')eionis
      if( uhf ) then
         write(mfgw,
     + '(      10x,''no. of alpha electrons  ='',i11)')nalpha
         write(mfgw,
     + '(      10x,''no. of beta  electrons  ='',i11)')nbeta
      else
         write(mfgw,
     + '(      10x,''no. of filled levels    ='',i11)')nclose
         if(nopn.ne.0) then
         write(mfgw,'(   10x,''and no. of open levels  ='',i11)')nopn
         endif
      endif
      sumw=0
      do 10 i=1,numat
   10 sumw=sumw+atmass(i)
      if(sumw.gt.0.1d0)
     1write(mfgw,
     +  '(    10x,''molecular weight        ='',f11.3)')sumw
      if(latom.eq.0) write(mfgw,'(/)')
      write(mfgw,'(10x,''scf calculations  =   '',i14 )') nscf
      tim=secmop()-time0
      i=tim*0.000001d0
      tim=tim-i*1000000
      call moptim(6,tim)
      if( ndep .ne. 0 )call mopsym()
      do 20 i=1,nvar
   20 xparam(i)=geo(loc(2,i),loc(1,i))
      call gmetry(geo,coord)
      if(prtgra)then
      write(mfgw,'(///7x,''final  point  and  derivatives'',/)')
      write(mfgw,'(''   parameter     atom    type  ''
     1    ,''          value       gradient'')')
      endif
      sum=0.5d0
      do 30 i=1,numat
   30 sum=sum+core(nat(i))
      i=sum
      kchrge=i-nclose-nopen-nalpha-nbeta
c
c    write out the geometric variables
c
      if(prtgra) then
         do 40 i=1,nvar
            j=loc(2,i)
            k=loc(1,i)
            l=labels(k)
            xi=xparam(i)
            if(j.ne.1) xi=xi*degree
            if(j.eq.1.or.na(1).eq.99)then
               gtype='kcal/angstrom'
            else
               gtype='kcal/radian  '
            endif
   40    write(mfgw,'(i7,i11,1x,a2,4x,a11,f13.6,f13.6,2x,a13)')
     1i,k,elemnt(l),type(j),xi,grad(i),gtype
      endif
c
c     write out the geometry
c
      write(mfgw,'(///)')
      call geout(1)
      if (index(keywrd,' nointer') .eq. 0) then
c
c   write out the interatomic distances
c
         l=0
         do 50 i=1,numat
            do 50 j=1,i
               l=l+1
   50    rxyz(l)=dsqrt((coord(1,i)-coord(1,j))**2+
     1                         (coord(2,i)-coord(2,j))**2+
     2                         (coord(3,i)-coord(3,j))**2)
         write(mfgw,'(//10x,''  interatomic distances'')')
         call vecprt(rxyz,numat)
      endif
      do 60 i=1,norbs
   60 if(eigs(i).lt.-999.d0.or.eigs(i).gt.1000.d0)eigs(i)=0.d0
      do 70 i=1,norbs
   70 if(eigb(i).lt.-999.d0.or.eigb(i).gt.1000.d0)eigs(i)=0.d0
      if(isybyl.eq.1) then
_IF(ipsc,tools)
      if(oroot().and.odumpm) then
_ELSE
      if(odumpm) then
_ENDIF
c
c  the following open statements are non-standard.  if this causes
c  difficulty replace them with
c#      open(unit=16,file=getmop(8),status='new',err=31)
c#      goto 32
c#  31  open(unit=16,file=getmop(8),status='old')
c#      write(6,'(a)') 'error opening sybyl mopac output'
c#  32  continue
      open(unit=16,file=getmop(8),
_IFN(b)    + carriagecontrol='list',
     +status='new',err=31)
      goto 32
  31  open(unit=16,file=getmop(8),
_IFN(b)    +carriagecontrol='list',
     +status='old')
      write(mfgw,'(a)') 'error opening sybyl mopac output'
  32  continue
      endif
      endif
      if(norbs.gt.0)then
         if (index(keywrd,' vect') .ne. 0) then
         write(mfgw,'(//10x,a5,'' eigenvectors  '')')calcn(iuhf)
            call mopmat(c,eigs,norbs,norbs,norbs)
            if(uhf) then
               write(mfgw,'(//10x,'' beta eigenvectors  '')')
               call mopmat(cbeta,eigb,norbs,norbs,norbs)
            endif
         else
         write(mfgw,'(//10x,a5,''   eigenvalues'',/)')calcn(iuhf)
         write(mfgw,'(8f10.5)')(eigs(i),i=1,norbs)
            if(uhf) then
               write(mfgw,'(//10x,'' beta eigenvalues '')')
               write(mfgw,'(8f10.5)')(eigb(i),i=1,norbs)
            endif
         endif
      endif
      write(mfgw,'(//13x,'' net atomic charges and dipole '',
     1''contributions'',/)')
      write(mfgw,
     +  '(8x,'' atom no.   type          charge        atom''
     1,''  electron density'')')
      call chrge(p,q)
      do 80 i=1,numat
         l=nat(i)
         q2(i)=core(l) - q(i)
   80 write(mfgw,'(i12,9x,a2,4x,f13.4,f16.4)')
     1i,elemnt(l),q2(i),q(i)
      dip= dipmop(p,q2,coord,dumy,1)
      if (index(keywrd,' noxyz') .eq. 0) then
         write(mfgw,'(//10x,''cartesian coordinates '',/)')
         write(mfgw,'(4x,''no.'',7x,''atom'',15x,''x'',
     1  9x,''y'',9x,''z'',/)')
         write(mfgw,'(i6,8x,a2,14x,3f10.4)')
     1  (i,elemnt(nat(i)),(coord(j,i),j=1,3),i=1,numat)
      endif
      if(norbs.gt.0) then
         if (index(keywrd,' k=') .ne. 0)then
c
c  go into brillouin zone mode
c
            i=index(keywrd,' k=')
            step=reada(keywrd,i)
            mono3=nlast(nint(reada(keywrd(i:),index(keywrd(i:),','))))
         if(uhf)write(mfgw,'(a)')'  alpha bands'
            call brlzon(f, fmat2d, norbs, sec, vec, alband,mono3,step,2)
         if(uhf)then
         write(mfgw,'(a)')'  beta bands'
         call brlzon(fb, fmat2d, norbs, sec, vec, alband,mono3,step,2)
         endif
         endif
         if(isybyl.eq.1)then
            nfilld=max0(nclose,nalpha,nbeta)
            call mpcsyb(numat,coord,q2,1,eigs,nfilld,funct,eionis
     1                 ,kchrge,dip)
         endif
         if (index(keywrd,' fock') .ne. 0) then
            write(mfgw,'('' fock matrix is '')')
            call vecprt(f,norbs)
         endif
         if (index(keywrd,' dens') .ne. 0) then
            write(mfgw,'(//,20x,'' density matrix is '')')
            call vecprt(p,norbs)
         else
         write(mfgw,'(//10x,''atomic orbital electron populations'',/)')
         write(mfgw,'(8f10.5)')(p((i*(i+1))/2),i=1,norbs)
         endif
         if(index(keywrd,' pi') .ne. 0) then
            write(mfgw,'(//10x,''sigma-pi bond-order matrix'')')
            call denrot
         endif
         if(uhf) then
            sz=iabs(nalpha-nbeta)*0.5d0
            ss2=sz*sz
            l=0
            do 100 i=1,norbs
               do 90 j=1,i
                  l=l+1
                  pa(l)=pa(l)-pb(l)
   90          ss2=ss2+pa(l)**2
  100       ss2=ss2-0.5d0*pa(l)**2
            write(mfgw,'(//20x,''(sz)    ='',f10.6)')sz
            write(mfgw,'(  20x,''(s**2)  ='',f10.6)')ss2
            if(index(keywrd,' spin') .ne. 0) then
               write(mfgw,'(//10x,''spin density matrix'')')
               call vecprt(pa,norbs)
            else
            write(mfgw,'(//10x,''atomic orbital spin populations'',/)')
            write(mfgw,'(8f10.5)')(pa((i*(i+1))/2),i=1,norbs)
            endif
            if(index(keywrd,' hyperfine') .ne. 0) then
c
c  work out the hyperfine coupling constants.
c
            write(mfgw,'(//10x,''    hyperfine coupling coefficients'',/
     1)')
               j=(nalpha-1)*norbs
               do 110 k=1,numat
                  i=nfirst(k)
c#          write(6,'('' pa:'',f13.6,'' c('',i2,''+'',i3,''):'',
c#     +f13.5)')pa((i*(i+1))/2),i,j,c(i+j)
  110          q(k)=pa((i*(i+1))/2)*0.3333333d0+c(i+j)**2*0.66666666d0
               write(mfgw,'(5(2x,a2,i2,f9.5,1x))')
     1    (elemnt(nat(i)),i,q(i),i=1,numat)
            endif
            do 120 i=1,linear
  120       pa(i)=p(i)-pb(i)
         endif
         if (index(keywrd,' bonds') .ne. 0) then
            if(nbeta.eq.0)then
            write(mfgw,'(/10x,''bonding contribution of each m.o.'',/)')
               call molval(c,p,norbs,2.d0)
            else
            write(mfgw,'(/10x,''bonding contribution of each alpha m.o.'
     1',/)')
               call molval(c,p,norbs,1.d0)
            write(mfgw,'(/10x,''bonding contribution of each beta  m.o.'
     1',/)')
               call molval(c,p,norbs,1.d0)
            endif
            call bonds(p)
         endif
         i=nclose+nalpha
         if (index(keywrd,' local') .ne. 0) then
            call moplo(c,norbs,i,eigs)
            if(nbeta.ne.0)then
            write(mfgw,'(//10x,'' localized beta molecular orbitals'')')
               call moplo(cbeta,norbs,nbeta,eigb)
            endif
         endif
         if (index(keywrd,' 1ele') .ne. 0) then
            write(mfgw,'('' final one-electron matrix '')')
            call vecprt(h,norbs)
         endif
         if(index(keywrd,' enpart') .ne. 0)
     1call enpart(uhf,h,pa,pb,p,q,coord)
      endif
      do 130 i=1,107
  130 nelemt(i)=0
      do 140 i=1,numat
         igo=nat(i)
         if (igo.gt.107) go to 140
         nelemt(igo)=nelemt(igo)+1
  140 continue
      ichfor=0
      if (nelemt(6).eq.0) go to 150
      ichfor=1
      ielemt(1)=elemnt(6)
      nzs=nelemt(6)
      if (nzs.lt.10) then
         if (nzs.eq.1) then
            iel1(1)=11
         else
            iel1(1)=nzs+1
         endif
         iel2(1)=11
      else
         kfrst=nzs/10
         ksec=nzs-(10*kfrst)
         iel1(1)=kfrst+1
         iel2(1)=ksec+1
      endif
  150 nelemt(6)=0
      do 160 i=1,107
         if (nelemt(i).eq.0) go to 160
         ichfor=ichfor+1
         ielemt(ichfor)=elemnt(i)
         nzs=nelemt(i)
         if (nzs.lt.10) then
            if (nzs.eq.1) then
               iel1(ichfor)=11
            else
               iel1(ichfor)=nzs+1
            endif
            iel2(ichfor)=11
         else
            kfrst=nzs/10
            ksec=nzs-(10*kfrst)
            iel1(ichfor)=kfrst+1
            iel2(ichfor)=ksec+1
         endif
  160 continue
      if(index(keywrd,' denout') .ne. 0) then
_IF(ipsc,tools)
       if(oroot().and.odumpm) then
_ELSE
       if(odumpm) then
_ENDIF
         open(unit=10,file=getmop(4),
     +status='unknown',form='unformatted')
         rewind 10
         write(10)(pa(i),i=1,linear)
         if(uhf)write(10)(pb(i),i=1,linear)
         close (10)
       endif
      endif
      if((ci.or.nopen.ne.nclose.and.fract.ne.2.d0.and.fract.ne.0.d0
     1 .or.index(keywrd,' size').ne.0)
     2 .and. index(keywrd,' meci')+index(keywrd,' esr').ne.0)then
         write(mfgw,'(//10x,
     1''multi-electron configuration interaction calculation'',//)')
         last=3
         x=meci(eigs,c)
      endif
      if (index(keywrd,' mullik') +index(keywrd,' graph') .ne. 0) then
         if (index(keywrd,' mullik') .ne. 0)
     1   write(mfgw,'(/10x,'' mulliken population analysis'')')
         call mullik(c,h,f,norbs,p,rxyz)
         if (index(keywrd,' graph') .ne. 0)
     1   write(mfgw,'(/10x,'' data for graph written to disk'')')
      endif
c
c  note that the density, h and f matrices are corrupted by a
c  call to mullik.
      if(isybyl.eq.1) then
         if (index(keywrd,'mullik').eq.0) then
            call mpcpop(c,0)
         else
            call mpcpop(c,1)
         endif
         close(16)
      endif
      if(icalcn.ne.numcal)then
         if(namfil.eq.'**null**') then
         namfil=getmop(6)
         inam=ichar('a')
         jnam=inam
         jend=index(namfil,' ')
         iend=jend+1
         endif
  162    if(odumpm) close (12)
         if(odumpm) open(unit=12,file=namfil,status='new',err=163)
         goto 164
  163    namfil(iend:iend)=char(inam)
         namfil(jend:jend)=char(jnam)
         if(inam.eq.ichar('z'))then
         inam=inam-26
         jnam=jnam+1
         endif
         inam=inam+1
         goto 162
  164    if(odumpm) rewind 12
         icalcn=numcal
      endif
      iwrite=12
      if(.not.odumpm) go to 2000
  170 write(iwrite,'(//20x,'' summary of '',a7,
     1'' calculation'',/)')caltyp
      write(iwrite,'(60x,''version '',f5.2)')verson
      write (iwrite,180) (ielemt(i),numbrs(iel1(i)),numbrs(iel2(i))
     1,i=1,ichfor)
  180 format (//,1x,17(a2,a1,a1))
      write(iwrite,'(55x,a24)')idate
      call wrttxt(iwrite)
      write(iwrite,'(//4x,a58)')flepo(iflepo)
      write(iwrite,'(4x,a58)')iter(iiter)
      write(iwrite,'(//10x,''heat of formation       =''
     1,f17.6,'' kcal'')')funct
      write(iwrite,'(  10x,''electronic energy       =''
     1,f17.6,'' ev'')')elect
      write(iwrite,'(  10x,''core-core repulsion     =''
     1,f17.6,'' ev'')')enuclr
      if(prtgra)
     1write(iwrite,'(  10x,''gradient norm           =''
     2,f17.6)')gnorm
      if(latom.eq.0) then
         if(.not.still) write(iwrite,'(a)')
     1' warning -- geometry is not at a stationary point'
      else
         grtype=' kcal/angstrom'
         if(lparam.eq.1)then
            write(iwrite,'(    10x,''for reaction coordinate ='',f17.4
     1        ,'' angstroms'')')xreact
         else
            if(na(1).ne.99)grtype=' kcal/radian  '
            write(iwrite,'(    10x,''for reaction coordinate ='',f17.4
     1        ,'' degrees'')')xreact*degree
         endif
         write(iwrite,'(    10x,''reaction gradient       ='',f17.6,a14
     1    )')gcoord,grtype
      endif
      write(iwrite,'(  10x,''dipole                  =''
     1,f16.5, '' debye'')')dip
      if(uhf) then
         write(iwrite,'(  10x,''(sz)                    ='',f17.6)')sz
         write(iwrite,'(  10x,''(s**2)                  ='',f17.6)')ss2
         write(iwrite,'(  10x,''no. of alpha electrons  ='',i10)')nalpha
         write(iwrite,'(  10x,''no. of beta  electrons  ='',i10)')nbeta
      else
         write(iwrite,'(  10x,''no. of filled levels    ='',i10)')nclose
         nopn=nopen-nclose
         if(nopn.ne.0)
     1write(iwrite,'(  10x,''and no. of open levels  ='',i10)')nopn
      endif
      if(ci)
     1write(iwrite,'(  10x,''configuration interaction was used'')')
      if(kchrge.ne.0)
     1write(iwrite,'(  10x,''charge on system        ='',i10)')kchrge
      write(iwrite,'(  10x,''ionization potential    =''
     1,f17.6,'' ev'')')eionis
      write(iwrite,'(  10x,''molecular weight        ='',f14.3)')sumw
      write(iwrite,'(  10x,''scf calculations        =''
     1,i10)') nscf
      tim=secmop()-time0
      call moptim(iwrite,tim)
      write(iwrite,'(//10x,''final geometry obtained'',36x,''charge'')')
      call geout(iwrite)
      if(index(keywrd,' aigout').ne.0)then
         write(iwrite,'(//,a)')'  geometry in gaussian z-matrix style'
         call wrttxt(iwrite)
         call geoutg(iwrite,.false.)
      endif
      if(index(keywrd,' out=gamess').ne.0)then
        if(iwrite.ne.11) then
          write(iwrite,'(//10x,''cartesian coordinates '',/)')
          write(iwrite,*)'geometry mopac'
          do 2300 i=1,numat
2300      write(iwrite,2310)(coord(j,i),j=1,3),elemnt(nat(i))
2310      format( 10x,3f15.8,5x,a2)
          write(iwrite,*)'end'
        endif
         write(iwrite,'(//,a)')'  geometry in gamess z-matrix style'
         call wrttxt(iwrite)
         call geoutg(iwrite,.true.)
      endif
      if(iwrite.ne.11.and.index(keywrd,' nolog').eq.0)then
       if(index(keywrd,' out=gamess').ne.0 .and. 
     +   index(keywrd,' vect') .ne. 0) then
            write(iwrite,'(//10x,a5,'' eigenvectors  '')')calcn(iuhf)
            call moppun(c,eigs,norbs,norbs,norbs,iwrite)
            if(uhf) then
               write(iwrite,'(//10x,'' beta eigenvectors  '')')
               call moppun(cbeta,eigb,norbs,norbs,norbs,iwrite)
            endif
       endif
       iwrite=11
       goto 170
      endif
2000  nscf=0
      return
      end
      subroutine wrtkey(keywrd)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
INCLUDE(../m4/common/utilc)
      character*241 keywrd, allkey
***********************************************************************
*
*  wrtkey checks all key-words and prints those it recognizes.  if it
*  finds a word it does not recognize the program will be stopped.
*
***********************************************************************
      common /numcal/ numcal
      common /timdmp/ tleft, tdump
      common/iofile/mfgr,mfgw
      logical uhf, trip, birad, exci, ci, myword
      logical am1, mndo, mindo3, pm3
      character ch*1, chrono*7
      save am1, mndo, mindo3
      data am1, mndo, mindo3, pm3 /4*.false./
      allkey=keywrd
c    dummy if statement to remove ampersand and plus signs, if present
      if(myword(allkey(160:),' setup'))i=1
      if(myword(allkey,'&'))i=2
      if(myword(allkey,' +'))i=3
      if(myword(allkey,'author')) then
      write(mfgw,'(10x,'' mopac - a general molecular orbital package'',
     1/         ,10x,''   original version written in 1983'')')
      write(mfgw,'(10x,''     by james j. p. stewart at the'',/
     1         ,10x,''     university of texas at austin'',/
     2         ,10x,''          austin, texas, 78712'')')
      endif
      if (myword(allkey,'vect') ) write(mfgw,210)
      if (myword(allkey,' exte') ) then
         i=index(keywrd,' exte')
         j=index(keywrd(i:),'=')+i
         i=index(keywrd(j:),' ')+j-1
         write(mfgw,220)keywrd(j:i)
      endif
      maxgeo=0
      if (myword(allkey,' dens') ) write(mfgw,230)
      if (myword(allkey,'spin') ) write(mfgw,240)
      if (myword(allkey,' depvar') )
     1write(mfgw,250)reada(keywrd,index(keywrd,'depvar'))
      if (myword(allkey,' dep ') )write(mfgw,260)
      if (myword(allkey,'velo') )write(mfgw,270)
      if (myword(allkey,'times') )write(mfgw,280)
      if (myword(allkey,'parasok') ) write(mfgw,290)
      if (myword(allkey,'nodiis') ) write(mfgw,300)
c  *** following line added as noted
c  in qcpe bulletin vol. 11, no. 3, pp. 52-54 (1991).
      if (myword(allkey,'nothie') ) write(mfgw,305)
      if (myword(allkey,'bonds') ) write(mfgw,310)
      if (myword(allkey,' nodump') ) then
       write(mfgw,1275)
       odumpm = .false.
      endif
      if (myword(allkey,'geo-ok') ) write(mfgw,320)
      if (myword(allkey,'fock') ) write(mfgw,330)
      if (myword(allkey,'large') ) write(mfgw,340)
      if (myword(allkey,' k=') ) write(mfgw,350)
      if (myword(allkey,'nolog') ) write(mfgw,360)
      if (myword(allkey,'aigin') ) write(mfgw,370)
      if (myword(allkey,'in=gamess') ) write(mfgw,375)
      if (myword(allkey,'aigout') ) write(mfgw,380)
      if (myword(allkey,'out=gamess') ) write(mfgw,385)
      if (myword(allkey,'abinitio') ) write(mfgw,387)
      if (myword(allkey,'aider') ) write(mfgw,390)
      if (myword(allkey,' s1978') ) write(mfgw,400)
      if (myword(allkey,' si1978') ) write(mfgw,410)
      if (myword(allkey,' grap') ) write(mfgw,420)
      if (myword(allkey,'noanci') ) write(mfgw,440)
      if (myword(allkey,'1elec') ) write(mfgw,430)
      if (myword(allkey(:162),' setup') ) write(mfgw,470)
      if (myword(allkey,' nomm') ) write(mfgw,460)
      if (myword(allkey,' mmok') ) write(mfgw,480)
      if (myword(allkey,'interp') ) write(mfgw,490)
      if (myword(allkey,' esr') ) write(mfgw,450)
      if (myword(allkey,'dfp') ) write(mfgw,500)
      if (myword(allkey,'analyt') ) write(mfgw,510)
      if (myword(allkey,' meci') ) write(mfgw,520)
      if (myword(allkey,'local') ) write(mfgw,560)
      if (myword(allkey,'mullik') ) write(mfgw,570)
      if (myword(allkey,' xyz') ) write(mfgw,580)
      if (myword(allkey,' pi') ) write(mfgw,590)
      if (myword(allkey,'echo') ) write(mfgw,600)
      if (myword(allkey, 'sing') ) write(mfgw,910)
      if (myword(allkey, 'doub') ) write(mfgw,920)
      if (myword(allkey, 'quar') ) write(mfgw,940)
      if (myword(allkey, 'quin') ) write(mfgw,950)
      if (myword(allkey, 'sext') ) write(mfgw,960)
      if (myword(allkey,'h-prio') ) write(mfgw,610)
      if (myword(allkey,'x-prio') ) write(mfgw,620)
      if (myword(allkey,'t-prio') ) write(mfgw,630)
      if (myword(allkey,'compfg') ) write(mfgw,650)
      if (myword(allkey,'polar') ) write(mfgw,640)
      if (myword(allkey,'debug ') ) write(mfgw,660)
      if (myword(allkey,'restart') ) write(mfgw,670)
c
c     keywords added for esp mopac
c
      if (myword(allkey,'esp ') ) write(mfgw,680)
      if (myword(allkey,'nsurf') ) write(mfgw,690)
      if (myword(allkey,'scale') ) write(mfgw,700)
      if (myword(allkey,'scincr') ) write(mfgw,710)
      if (myword(allkey,'slope') ) write(mfgw,720)
      if (myword(allkey,'dipole') ) write(mfgw,730)
      if (myword(allkey,'dipx') ) write(mfgw,740)
      if (myword(allkey,'dipy') ) write(mfgw,750)
      if (myword(allkey,'dipz') ) write(mfgw,760)
      if (myword(allkey,'connolly') ) write(mfgw,770)
      if (myword(allkey,'esprst') ) write(mfgw,780)
      if (myword(allkey,' potwrt') ) write(mfgw,790)
      if (myword(allkey,'williams') ) write(mfgw,800)
      if (myword(allkey,'sybcnt') ) write(mfgw,805)
      if (myword(allkey,'grid=')) write(mfgw,806)
     1 reada(keywrd,index(keywrd,'grid='))
      if (myword(allkey,'shell=')) write(mfgw,807)
     1 reada(keywrd,index(keywrd,'shell='))
      if (myword(allkey,'vdwsf=')) write(mfgw,808)
     1 reada(keywrd,index(keywrd,'vdwsf='))
      if (myword(allkey,'symavg') ) write(mfgw,810)
      if (myword(allkey,'sto3g') ) write(mfgw,820)
      if (myword(allkey,'iupd')) then
         ii=nint(reada(keywrd,index(keywrd,'iupd=')))
         if (ii.eq.0) write(mfgw,90)
         if (ii.eq.1) write(mfgw,100)
         if (ii.eq.2) write(mfgw,110)
      endif
      if (myword(allkey,'hess')) then
         ii=nint(reada(keywrd,index(keywrd,'hess=')))
         if (ii.eq.0) write(mfgw,120)
         if (ii.eq.1) write(mfgw,130)
         if (ii.eq.2) write(mfgw,140)
         if (ii.eq.3) write(mfgw,150)
      endif
      if (myword(allkey,' mode')) write(mfgw,160)
     1 nint(reada(keywrd,index(keywrd,'mode=')))
      if (myword(allkey,' recalc')) write(mfgw,170)
     1 nint(reada(keywrd,index(keywrd,'recalc')))
      if (myword(allkey,' dmax')) write(mfgw,180)
     1 reada(keywrd,index(keywrd,'dmax='))
      if (myword(allkey,' ms=')) write(mfgw,190)
     1 nint(reada(keywrd,index(keywrd,' ms=')))
      if (myword(allkey,' prnt')) write(mfgw,200)
      if (myword(allkey,'irc=') ) then
      maxgeo=1
      write(mfgw,830)nint(reada(keywrd,index(keywrd,'irc=')))
      elseif (myword(allkey,'irc') ) then
         maxgeo=1
         write(mfgw,840)
      endif
      if (myword(allkey,'charge') ) write(mfgw,850)
     + nint(reada(keywrd,index(keywrd,'charge')))
      if (myword(allkey,'grad') ) write(mfgw,860)
      uhf=(myword(allkey,'uhf') )
      if(uhf)write(mfgw,870)
      birad=(myword(allkey,'birad') )
      if(birad)write(mfgw,890)
      exci=(myword(allkey,'excited') )
      if(exci) write(mfgw,900)
      trip=(myword(allkey,'trip') )
      if(trip)write(mfgw,930)
      if (myword(allkey,'sym') ) write(mfgw,970)
      if(myword(allkey,'open('))then
         i=index(keywrd,'open(')
         ielec=reada(keywrd,i)
         ilevel=reada(keywrd,i+7)
         write(mfgw,990)ielec,ilevel
      endif
      if(myword(allkey,'micros'))
     1write(mfgw,980)idint(reada(keywrd,index(keywrd,'micros')))
      if(myword(allkey,'drc='))then
         maxgeo=1
         write(mfgw,540)reada(keywrd,index(keywrd,'drc='))
      elseif (myword(allkey,' drc') ) then
         maxgeo=1
         write(mfgw,530)
      endif
      if(myword(allkey,'kine'))
     1write(mfgw,550)reada(keywrd,index(keywrd,'kine'))
      chrono='seconds'
      time=1
      if(myword(allkey,' t=')) then
         i=index(keywrd,' t=')
         tleft=reada(keywrd,i)
         do 10 j=i+3,241
            if( j.eq.241.or.keywrd(j+1:j+1).eq.' ') then
               ch=keywrd(j:j)
               if( ch .eq. 'm') chrono='minutes'
               if( ch .eq. 'm') time=60
               if( ch .eq. 'h') chrono='hours'
               if( ch .eq. 'h') time=3600
               if( ch .eq. 'd') chrono='days'
               if( ch .eq. 'd') time=86400
               goto 20
            endif
   10    continue
   20    continue
         if(tleft.lt.99999.9d0)then
            write(mfgw,1000)tleft,chrono
         else
            write(mfgw,1010)tleft,chrono
         endif
         tleft=tleft*time
      elseif(numcal.eq.1)then
         tleft=maxtim
         write(mfgw,1000)tleft,'seconds'
      else
         write(mfgw,1000)tleft,'seconds'
      endif
      time=1
      chrono='seconds'
      if(myword(allkey,' dump')) then
         i=index(keywrd,' dump')
         tdump=reada(keywrd,i)
         do 30 j=i+6,241
            if( j.eq.241.or.keywrd(j+1:j+1).eq.' ') then
               ch=keywrd(j:j)
               if( ch .eq. 'm') chrono='minutes'
               if( ch .eq. 'm') time=60.d0
               if( ch .eq. 'h') chrono='hours'
               if( ch .eq. 'h') time=3600.d0
               if( ch .eq. 'd') chrono='days'
               if( ch .eq. 'd') time=86400.d0
               goto 40
            endif
   30    continue
   40    continue
         if(tdump.lt.99999.9d0)then
            write(mfgw,1020)tdump,chrono
         else
            write(mfgw,1030)tdump,chrono
         endif
         tdump=tdump*time
      elseif(numcal.eq.1)then
         tdump=maxdmp
         write(mfgw,1020)tdump,'seconds'
      else
         write(mfgw,1020)tdump,'seconds'
      endif
      if (myword(allkey,'1scf') ) then
         write(mfgw,1040)
         if(index(keywrd,'restart').eq.0)maxgeo=maxgeo+1
      endif
      ci=myword(allkey,'c.i.')
      if (ci) then
         j=index(keywrd,'c.i.=(')
         if(j.ne.0)then
            atmp=reada(keywrd,index(keywrd,'c.i.=(')+7)
            btmp=reada(keywrd,index(keywrd,'c.i.=(')+5)
            write(mfgw,1060)idint(atmp),idint(btmp)
         else
         write(mfgw,1050)idint(reada(keywrd,index(keywrd,'c.i.')+5))
         endif
      endif
      if (myword(allkey,' force') ) then
         write(mfgw,1070)
         maxgeo=maxgeo+1
      endif
      if (myword(allkey,' ef')) then
         write(mfgw,70)
         maxgeo=maxgeo+1
      endif
      if (myword(allkey,' ts')) then
         write(mfgw,80)
         maxgeo=maxgeo+1
      endif
      method=0
      if (myword(allkey,'mindo') ) then
         write(mfgw,1080)
         mindo3=.true.
         method=1
      endif
      if (myword(allkey,'am1') ) then
         write(mfgw,1090)
         am1=.true.
         method=method+1
      endif
      if (myword(allkey,'pm3') ) then
         write(mfgw,1100)
         pm3=.true.
         method=method+1
      endif
      if (myword(allkey,'mndo') ) then
         mndo=.true.
         method=method+1
      endif
      if (myword(allkey,'oldgeo') ) write(mfgw,1120)
      if (myword(allkey,'prec') ) write(mfgw,1110)
      if (myword(allkey,'nointer') ) write(mfgw,1130)
      if (myword(allkey,'isotope') ) write(mfgw,1140)
      if (myword(allkey,'denout') ) write(mfgw,1150)
      if (myword(allkey,'shift') ) write(mfgw,1160)
     1 reada(keywrd,index(keywrd,'shift'))
      if (myword(allkey,'oldens') ) write(mfgw,1170)
      if (myword(allkey,'scfcrt') ) write(mfgw,1180)
     1 reada(keywrd,index(keywrd,'scfcrt'))
      if (myword(allkey,'enpart') ) write(mfgw,1190)
      if (myword(allkey,'noxyz') ) write(mfgw,1200)
      if (myword(allkey,'sigma') ) then
         write(mfgw,1210)
         maxgeo=maxgeo+1
      endif
      if (myword(allkey,'nllsq') ) then
         write(mfgw,1220)
         maxgeo=maxgeo+1
      endif
      if (myword(allkey,'root') ) write(mfgw,1230)
     1 nint(reada(keywrd,index(keywrd,'root')))
      if (myword(allkey,'trans=') ) then
         write(mfgw,1250)nint(reada(keywrd,index(keywrd,'trans=')))
      elseif (myword(allkey,'trans') ) then
         write(mfgw,1240)
      endif
      if (myword(allkey,'saddle') ) then
         write(mfgw,1260)
         maxgeo=maxgeo+1
      endif
      if (myword(allkey,' let') ) write(mfgw,1270)
      if (myword(allkey,'compfg') ) write(mfgw,1280)
      if (myword(allkey,'gnorm') ) write(mfgw,1290)
     1 reada(keywrd,index(keywrd,'gnorm'))
      if (myword(allkey,'pulay') ) write(mfgw,1300)
      if (myword(allkey,' step1')  )write(mfgw,1310)
     1 reada(keywrd,index(keywrd,'step1')+6)
      if (myword(allkey,' step2')  )write(mfgw,1320)
     1 reada(keywrd,index(keywrd,'step2')+6)
      if (myword(allkey,' step')  )write(mfgw,1500)
     1 reada(keywrd,index(keywrd,'step')+5)
      if (myword(allkey,' point1')  )then
         ip1=reada(keywrd,index(keywrd,'point1')+7)
         write(mfgw,1330) ip1
      endif
      if (myword(allkey,' point2')  )then
         ip2=reada(keywrd,index(keywrd,'point2')+7)
         write(mfgw,1340) ip2
      endif
      if (myword(allkey,' max') ) write(mfgw,1350)
      if (myword(allkey,' point')  )then
         ip=reada(keywrd,index(keywrd,'point')+6)
         write(mfgw,1510) ip
      endif
      if (myword(allkey,'bar') ) write(mfgw,1360)
     1 reada(keywrd,index(keywrd,'bar'))
      if (myword(allkey,'camp') ) write(mfgw,1370)
      if (myword(allkey,'king') ) write(mfgw,1370)
      if (myword(allkey,'eigs') ) write(mfgw,1380)
      if (myword(allkey,'eiginv') ) write(mfgw,1390)
      if (myword(allkey,'nonr') ) write(mfgw,1400)
      if (myword(allkey,'oride') ) write(mfgw,1410)
      if (myword(allkey,'hyperf') ) write(mfgw,1420)
      if (myword(allkey,' pl') ) write(mfgw,1430)
      if (myword(allkey,'fill') ) write(mfgw,1440)
     1 nint(reada(keywrd,index(keywrd,'fill')))
      if (myword(allkey,'itry') ) write(mfgw,1470)
     1 nint(reada(keywrd,index(keywrd,'itry')))
      if (myword(allkey,'0scf') ) write(mfgw,1490)
      if (myword(allkey,'fix') ) write(mfgw,1520)
      if(uhf)then
         if(birad.or.exci.or.ci)then
            write(mfgw,'(//10x,
     1'' uhf used with either birad, excited or c.i. '')')
            write(mfgw,1480)
            goto 60
         endif
      else
         if(exci.and. trip) then
            write(mfgw,'(//10x,'' excited used with triplet'')')
            write(mfgw,1480)
            goto 60
         endif
      endif
      if (index(keywrd,'t-prio').ne.0.and.
     1index(keywrd,'drc').eq.0) then
         write (mfgw,'(//10x,''t-prio and no drc'')')
         write (mfgw,1480)
         goto 60
      endif
      if ( method .gt. 1) then
         write(mfgw,'(//10x,
     1'' only one of mindo, mndo, am1 and pm3 allowed'')')
         write (mfgw,1480)
         goto 60
      endif
      if (myword(allkey,'thermo') )then
         write(mfgw,1450)
         if(myword(allkey,' rot')) then
            write(mfgw,1460)nint(reada(keywrd,index(keywrd,' rot')))
         else
            write(mfgw,'
     1    (//10x,'' you must supply the symmetry number "rot"'')')
_IF(ipsc,tools)
            call pend
_ELSE
            stop
_ENDIF
         endif
      endif
      if(maxgeo.gt.1)then
      write(mfgw,'(//10x,''more than one geometry option has been '',
     1''specified'',/10x,
     2''conflict must be resolved before job will run'')')
_IF(ipsc,tools)
         call pend
_ELSE
         stop
_ENDIF
      endif
      if(index(keywrd,'mullik').ne.0.and.uhf)then
      write(mfgw,'(a)')' mulliken population not available with uhf'
_IF(ipsc,tools)
         call pend
_ELSE
         stop
_ENDIF
      endif
      if(allkey.ne.' ')then
         j=0
         do 50 i=1,240
            if(allkey(i:i).ne.' '.or.allkey(i:i+1).ne.'  ')then
               j=j+1
               ch=allkey(i:i)
               allkey(j:j)=ch
            endif
   50    continue
         if(allkey(241:241).ne.' ')then
            j=j+1
            ch=allkey(241:241)
            allkey(j:j)=ch
         endif
         j=max0(1,j)
         l=index(keywrd,'debug')
         if(l.ne.0)then
         write(mfgw,'('' *  debug keywords used:  '',a)')allkey(:j)
         else
         write(mfgw,'(///10x,''unrecognized key-words: ('',a,'')'')')
     1allkey(:j)
         write(mfgw,'(///10x,''calculation stopped to avoid wasting time
     1.'')')
         write(mfgw,'(///10x,''if these are debug keywords, add the keyw
     1ord "debug"'')')
_IF(ipsc,tools)
            call pend
_ELSE
            stop
_ENDIF
         endif
      endif
      return
   60 write(mfgw,'(//10x,'' calculation abandoned, sorry!'')')
_IF(ipsc,tools)
      call pend
_ELSE
      stop
_ENDIF
c ***********************************************************
c ***********************************************************
   70 format(' *  ef       - use ef routine for minimum search')
   80 format(' *  ts       - use ef routine for ts search')
   90 format(' *  iupd=    - hessian will not be updated')
  100 format(' *  iupd=    - hessian will be updated using powell')
  110 format(' *  iupd=    - hessian will be updated using bfgs')
  120 format(' *  hess=    - diagonal hessian used as initial guess')
  130 format(' *  hess=    - initial hessian will be calculated')
  140 format(' *  hess=    - initial hessian read from disk')
  150 format(' *  hess=    - initial hessian read from input')
  160 format(' *  mode=    - follow hessian mode',i3,' toward ts')
  170 format(' *  recalc=  - do',i4,' cycles between hessian recalc')
  180 format(' *  dmax=    - take maximum stepsize of',f5.3,' ang/rad')
  190 format(' *  ms=      - in meci, magnetic component of spin =',i3)
  200 format(' *  prnt     - extra printing in ef routine')
c ***********************************************************
  210 format(' *  vectors  - final eigenvectors to be printed')
  220 format(' *  external - use atomic parameters from the following '
     1,'file',/15x,a)
  230 format(' *  density  - final density matrix to be printed')
  240 format(' *  spin     - final uhf spin matrix to be printed')
  250 format(' *  depvar=n - specified distance is',f7.4,
     1' times bond length')
  260 format(' *  dep      - output fortran code for block-data')
  270 format(' *  velocity - input starting velocities for drc')
  280 format(' *  times    - times of various stages to be printed')
  290 format(' *  parasok  - use some mndo parameters in an am1 calcula'
     1,'tion')
  300 format(' *  nodiis   - do not use gdiis geometry optimizer')
c  *** following line added as noted
c  in qcpe bulletin vol. 11, no. 3, pp. 52-54 (1991).
  305 format(' *  nothiel  - do not use thiel''s fstmin option')
  310 format(' *  bonds    - final bond-order matrix to be printed')
  320 format(' *  geo-ok   - override interatomic distance check')
  330 format(' *  fock     - last fock matrix to be printed')
  340 format(' *  large    - expanded output to be printed')
  350 format(' *   k=      - brillouin zone structure to be calculated')
  360 format(' *  nolog    - suppress log file trail, where possible')
  370 format(' *  aigin    - geometry must be in gaussian format')
  375 format(' *  in=gamess- geometry must be in gamess format')
  380 format(' *  aigout   - in arc file, include ab-initio geometry')
  385 format(' *  out=gamess - in arc file, include gamess geometry')
  387 format(' *  abinitio - mopac run + abinitio calculation')
  390 format(' *  aider    - read in ab initio derivatives')
  400 format(' *  s1978    - 1978 sulfur parameters to be used')
  410 format(' *  si1978   - 1978 silicon parameters to be used')
  420 format(' *  graph    - generate file for graphics')
  430 format(' *  1electron- final one-electron matrix to be printed')
  440 format(' *  noanci   - do not use analytical c.i. derivatives')
  450 format(' *  esr      - rhf spin density calculation requested')
  460 format(' *  nomm     - do not make mm correction to conh barrier')
  470 format(' *  setup    - extra keywords to be read from file setup')
  480 format(' *  mmok     - apply mm correction to conh barrier')
  490 format(' *  interp   - print details of camp-king converger')
  500 format(' *  dfp      - use davidon fletcher powell optimizer')
  510 format(' *  analyt   - use analytic derivatives ')
  520 format(' *  meci     - m.e.c.i. working to be printed')
  530 format(' *  drc      - dynamic reaction coordinate calculation')
  540 format(' *  drc=     - half-life for kinetic energy loss =',f9.2,
     1' * 10**(-15) seconds')
  550 format(' *  kinetic= - ',f9.3,' kcal kinetic energy added to drc')
  560 format(' *  localize - localized orbitals to be printed')
  570 format(' *  mullik   - the mulliken analysis to be performed')
  580 format(' *   xyz     - cartesian coordinate system to be used')
  590 format(' *   pi      - bonds matrix, split into sigma-pi-dell',
     1' components, to be printed')
  600 format(' *  echo     - all input data to be echoed before run')
  610 format(' *  h-prior  - heat of formation takes priority in drc')
  620 format(' *  x-prior  - geometry changes take priority in drc')
  630 format(' *  t-prior  - time takes priority in drc')
  640 format(' *  polar    - calculate first, second and third-order'
     1,' polarizabilities')
  650 format(' *  compfg   - print heat of formation calc''d in compfg')
  660 format(' *  debug    - debug option turned on')
  670 format(' *  restart  - calculation restarted')
c
c     keywords added for esp mopac
c
  680 format(' *  esp      - electrostatic potential calculation')
  690 format(' *  nsurf    - number of layers')
  700 format(' *  scale    - scaling factor for van der waals distance')
  710 format(' *  scincr   - increment between layers')
  720 format(' *  slope    - slope - used to scale mndo esp charges')
  730 format(' *  dipole   - fit the esp to the calculated dipole')
  740 format(' *  dipx     - x component of dipole to be fit')
  750 format(' *  dipy     - y component of dipole to be fit')
  760 format(' *  dipz     - z component of dipole to be fit')
  770 format(' *  connolly - use connolly surface')
  780 format(' *  esprst   - restart of electric potential calculation')
  790 format(' *  potwrt   - write out electric pot. data to file 21')
  800 format(' *  williams - use williams surface')
  805 format(' *  sybcnt   - generate grid of esp charges for sybyl')
  806 format(' *  grid     - grid size = ',f4.2,' angstroms')
  807 format(' *  shell    - shell thickness = ',f4.2,' angstroms')
  808 format(' *  vdwsf    - van der waals radii scaling factor = '
     1,f4.2)
  810 format(' *  symavg   - average symmetry equivalent esp charges')
  820 format(' *  sto3g    - deorthogonalize orbitals in sto-3g basis')
  830 format(' *  irc=n    - intrinsic reaction coordinate',i3,
     1' defined')
  840 format(' *  irc      - intrinsic reaction coordinate calculation')
  850 format(3(' *',/),' *',15x,'  charge on system =',i3,3(/,' *'))
  860 format(' *  gradients- all gradients to be printed')
  870 format(' *  uhf      - unrestricted hartree-fock calculation')
c#  880 format(' *  singlet  - state required must be a singlet')
  890 format(' *  biradical- system has two unpaired electrons')
  900 format(' *  excited  - first excited state is to be optimized')
  910 format(' *  singlet  - spin state defined as a singlet')
  920 format(' *  doublet  - spin state defined as a doublet')
  930 format(' *  triplet  - spin state defined as a triplet')
  940 format(' *  quartet  - spin state defined as a quartet')
  950 format(' *  quintet  - spin state defined as a quintet')
  960 format(' *  sextet   - spin state defined as a sextet')
  970 format(' *  symmetry - symmetry conditions to be imposed')
  980 format(' *  micros=n -',i4,' microstates to be supplied for c.i.')
  990 format(' *  open(n,n)- there are',i2,' electrons in',i2,' levels')
 1000 format(' *   t=      - a time of',f8.1,' ',a7,' requested')
 1010 format(' *   t=      - a time of',g11.3,' ',a7,' requested')
 1020 format(' *  dump=n   - restart file written every',f8.1,
     1' ',a7)
 1030 format(' *  dump=n   - restart file written every',g11.3,
     1' ',a7)
 1040 format(' *  1scf     - do 1 scf and then stop ')
 1050 format(' *  c.i.=n   -',i2,' m.o.s to be used in c.i.')
 1060 format(' * c.i.=(n,m)-',i2,' doubly filled levels used in a ',/
     1,      ' *             c.i. involving ',i2,' m.o.''s')
 1070 format(' *  force    - force calculation specified')
 1080 format(' *  mindo/3  - the mindo/3 hamiltonian to be used')
 1090 format(' *  am1      - the am1 hamiltonian to be used')
 1100 format(' *  pm3      - the pm3 hamiltonian to be used')
 1110 format(' *  precise  - criteria to be increased by 100 times')
 1120 format(' *  oldgeo   - previous geometry to be used')
 1130 format(' *  nointer  - interatomic distances not to be printed')
 1140 format(' *  isotope  - force matrix written to disk (chan. 9 )')
 1150 format(' *  denout   - density matrix output on channel 10')
 1160 format(' *  shift    - a damping factor of',f8.2,' defined')
 1170 format(' *  oldens   - initial density matrix read of disk')
 1180 format(' *  scfcrt   - default scf criterion replaced by',g12.3)
 1190 format(' *  enpart   - energy to be partitioned into components')
 1200 format(' *  noxyz    - cartesian coordinates not to be printed')
 1210 format(' *  sigma    - geometry to be optimized using sigma.')
 1220 format(' *  nllsq    - gradients to be minimized using nllsq.')
 1230 format(' *  root     - in a c.i. calculation, root',i2,
     1                       ' to be optimized.')
 1240 format(' *  trans    - the reaction vibration to be deleted from',
     1' the thermo calculation')
 1250 format(' *  trans=   - ',i4,' vibrations are to be deleted from',
     1' the thermo calculation')
 1260 format(' *  saddle   - transition state to be optimized')
 1270 format(' *   let     - override some safety checks')
 1275 format(' *  nodump   - suppress writing of restart files')
 1280 format(' *  compfg   - print heat of formation calc''d in compfg')
 1290 format(' *  gnorm=   - exit when gradient norm drops below ',g8.3)
 1300 format(' *  pulay    - pulay''s method to be used in scf')
 1310 format(' *  step1    - first  step-size in grid =',f7.2)
 1320 format(' *  step2    - second step-size in grid =',f7.2)
 1330 format(' *  point1   - number of rows in grid =',i3)
 1340 format(' *  point2   - number of columns in grid =',i3)
 1350 format(' *  max      - grid size 23*23 ')
 1360 format(' *  bar=     - reduce bar length by a max. of',f7.2)
 1370 format(' *  camp,king- the camp-king converger to be used')
 1380 format(' *  eigs     - print all eigenvalues in iter')
 1390 format(' *  eiginv   - use hessian eigenvalue reversion in ef')
 1400 format(' *  nonr     - do not use newton-raphson step in ef')
 1410 format(' *  oride    - unconditionally, use calculated lamdas in'
     1//' ef')
 1420 format(' *  hyperfine- hyperfine coupling constants to be'
     1,' printed')
 1430 format(' *   pl      - monitor convergance in density matrix')
 1440 format(' *  fill=    - in rhf closed shell, force m.o.',i3,' to be
     1 filled')
 1450 format(' *  thermo   - thermodynamic quantities to be calculated')
 1460 format(' *  rot      - symmetry number of',i3,' specified')
 1470 format(' *  itry=    - do a maximum of',i6,' iterations for scf')
 1480 format( //10x,' impossible option requested,')
 1490 format(' *  0scf     - after reading and printing data, stop')
 1500 format(' *  step     - step-size in path=',f7.3)
 1510 format(' *  point    - number of points in path=',i3)
 1520 format(' *  fix      - optimize input cartesian geometry')
      end
      subroutine wrttxt(iprt)
      common /keywrd/ keywrd
      common /titles/ koment,title
      character keywrd*241, koment*81, title*81
      do 10 i=81,2,-1
   10 if(keywrd(i:i).ne.' ')goto 20
   20 write(iprt,'(a)')keywrd(:i)
      if(index(keywrd(1:81),' +')+index(keywrd(1:81),'&')+
     1index(keywrd,'setup').ne.0) then
         do 30 i=161,82,-1
   30    if(keywrd(i:i).ne.' ')goto 40
   40    if(keywrd(81:81).ne.' ')then
            write(iprt,'(1x,a)')keywrd(81:i)
         else
            write(iprt,'(a)')keywrd(81:i)
         endif
      endif
      if(index(keywrd(81:241),' +')+index(keywrd(81:241),'&') +
     1index(keywrd,'setup').ne.0) then
         do 50 i=241,161,-1
   50    if(keywrd(i:i).ne.' ')goto 60
   60    if(keywrd(161:161).ne.' ')then
            write(iprt,'(1x,a)')keywrd(161:i)
         else
            write(iprt,'(a)')keywrd(161:i)
         endif
      endif
      do 70 i=81,2,-1
   70 if(koment(i:i).ne.' ')goto 80
   80 if(index(koment,' null ').eq.0)write(iprt,'(a)')koment(:i)
      do 90 i=81,2,-1
   90 if(title(i:i).ne.' ')goto 100
  100 if(index(title,' null ').eq.0)write(iprt,'(a)')title(:i)
      end
      subroutine xxx(type,i,j,k,l,r)
      character type*1, r*(*)
************************************************************************
*
*    xxx will form a unique string label 'r' for gaussian-type input
*    the label will be letter (either r, p, or f, normally), followed
*    by the connectivity, in the order i, j, k, l.
*    'r' is 13 characters long in order to accommodate 3 digits per
*    label, when necessary
*
************************************************************************
      dimension ijk(4)
      r=type
      ijk(1)=i
      ijk(2)=j
      ijk(3)=k
      ijk(4)=l
      m=1
      do 10 loop=1,4
         ii=ijk(loop)
         if(ii.eq.0) goto 10
c
c   if labels greater than 99 are used, uncomment the following code
c
c#         i2=ii/100
c#         if(i2.ne.0) then
c#            m=m+1
c#            r(m:m)=char(ichar('0')+i2)
c#            ii=ii-i2*100
c#         endif
         i2=ii/10
         if(i2.ne.0) then
            m=m+1
            r(m:m)=char(ichar('0')+i2)
            ii=ii-i2*10
         endif
         m=m+1
         r(m:m)=char(ichar('0')+ii)
   10 continue
      return
      end
      subroutine xyzgeo(xyz,numat,na,nb,nc,degree,geo)
      implicit REAL (a-h,o-z)
      dimension xyz(3,*), na(*), nb(*), nc(*), geo(3,*)
***********************************************************************
*
*   xyzgeo converts coordinates from cartesian to internal.
*
*     on input xyz  = array of cartesian coordinates
*              numat= number of atoms
*              na   = numbers of atom to which atoms are related
*                     by distance
*              nb   = numbers of atom to which atoms are related
*                     by angle
*              nc   = numbers of atom to which atoms are related
*                     by dihedral
*
*    on output geo  = internal coordinates in angstroms, radians,
*                     and radians
*
***********************************************************************
      do 30 i=2,numat
         j=na(i)
         k=nb(i)
         l=nc(i)
         if(i.lt.3) goto 30
         ii=i
         call bangle(xyz,ii,j,k,geo(2,i))
         geo(2,i)=geo(2,i)*degree
         if(i.lt.4) goto 30
c
c   make sure dihedral is meaninglful
c
         call bangle(xyz,j,k,l,angl)
         tol=0.2617994d0
         if(angl.gt.3.1415926d0-tol.or.angl.lt.tol)then
c
c  angle is unsatisfactory, let's search for another atom for
c  defining the dihedral.
   10       sum=100.d0
            do 20 i1=1,ii-1
               r=(xyz(1,i1)-xyz(1,k))**2+
     1          (xyz(2,i1)-xyz(2,k))**2+
     2          (xyz(3,i1)-xyz(3,k))**2
               if(r.lt.sum.and.i1.ne.j.and.i1.ne.k) then
                  call bangle(xyz,j,k,i1,angl)
                  if(angl.lt.3.1415926d0-tol.and.angl.gt.tol)then
                     sum=r
                     l=i1
                     nc(ii)=l
                  endif
               endif
   20       continue
            if(sum.gt.99.d0.and.tol.gt.0.1d0)then
c
c anything within 5 degrees?
c
               tol=0.087266d0
               goto 10
            endif
         endif
         call dihed(xyz,ii,j,k,l,geo(3,i))
         geo(3,i)=geo(3,i)*degree
   30 geo(1,i)= dsqrt((xyz(1,i)-xyz(1,j))**2+
     1                   (xyz(2,i)-xyz(2,j))**2+
     2                   (xyz(3,i)-xyz(3,j))**2)
      geo(1,1)=0.d0
      geo(2,1)=0.d0
      geo(3,1)=0.d0
      geo(2,2)=0.d0
      geo(3,2)=0.d0
      geo(3,3)=0.d0
      return
      end
_IF(ipsc,tools)
_IF(tools)
      function cpulft(i)
      implicit REAL  (a-h,p-w),integer    (i-n),logical    (o)
      implicit character *8 (z),character *1 (x)
      implicit character *4 (y)
      common/timez/timemx,timlim(11),isec
c
c ------ return the clock time in seconds if i=1
c ------        the cpu time remaining if i=0
c
_IF(rs6000)
      ak = dfloat(mclock() ) / 100.0d0
_ELSE
      real*4 etime,t4(2)
      dum = etime(t4)
      ak=t4(1)
_ENDIF
      if(i.eq.1) then
        cpulft=ak
      else if(i.eq.0) then
        cpulft=timemx-ak
c
c  if file STOP exists kill GAMESS orderly
c
         inquire(file='STOP',exist=oex)
         if (oex) cpulft = 0.5d0
      else
       write(6,*) ' called cpulft with invalid i ',i,' returning 0'
       cpulft = 0.0d0
      endif
      return
      end
      subroutine ininod
c
c...  set few parameters needed in node proces
c
      REAL  tgoptm,tfndtm,tgettm,tputtm
      common/nodinf/mpid,minode,mihost,ldim,nnode,noddim
      common/nodtim/ tgoptm,topen(10),tfndtm(10),tgettm(10),tputtm(10)
      parameter (nreal=8,nint=4,iroot=0)
c
      mpid = 0
      minode = nodeid()
      mihost = 0
      nnode = nnodes()
      noddim = 1
c
      tgoptm = 0.0d0
      do 100 loop=1,10
      topen (loop) = 0.0d0
      tfndtm(loop) = 0.0d0
      tgettm(loop) = 0.0d0
100   tputtm(loop) = 0.0d0
c
      return
      end
      subroutine initia
      implicit REAL  (a-h,p-w),integer   (i-n),logical    (o)
      implicit character *8 (z),character *1 (x)
      implicit character *4 (y)
      character*20 fname
      common/iofile/iread,iwr
INCLUDE(../m4/common/utilc)
      common/timez/timlim(12),isec
      common/prints/oprntd(60)
c
c
c***   ***MPP***
      common/nodinf/mpid,minode,mihost,ldim,nnodes,nodscr
c***   ***MPP***
      opnode = .false.
      odumpm = .false.
      call ininod
      iwr = 6
      iread = 5
      opkill=.true.
      oprntd(28)=.true.
c
c...  set iwr to 94 to seperate output of nodes
c
      if (.not.oroot()) then
         iwr = 94
c...      different numbers are not needed / different names are
c...      if no node output is requested send it to sink
         nn = 100+minode
         write(fname,'(a,i3)') 'out_mopac_',nn
c        if (opkill) oprnts(60) = .false.
         if (opnode) then
          open(iwr,form='formatted',file=fname,err=9998)
         else
          open(iwr,form='formatted',file='/dev/null',err=9998)
         endif
c
      end if
      call synch(88888)
      call pproc
      return
9998  write(6,9997)
9997  format(/' *** failed to open output file *** '/)
      call pend
      return
      end
      function oipsci()
      implicit REAL  (a-h,o-z)
      logical oipsci
c
c...   decide  if we should process this integral batch
c...   called from jkin70 (integs) etc.
c
      common/nodinf/mpid,minode,mihost,ldim,nnodes,nodscr
      common/nodin2/icount
c
       icount = icount + 1
       oipsci = mod(icount,nnodes).ne.minode
c
       return
       end
       function  iipsci()
c
c...   initialise
c
       common/nodin2/icount
c
       icount = 0
       iipsci = 0
c
       return
       end
      logical function oroot()
c...   tells me if i am the root
      common/nodinf/mpid,minode,mihost,ldim,nnodes,nodscr
      oroot = minode.eq.0
c
      return
      end
      subroutine mxm(a,nar,b,nac,c,nbc)
      implicit REAL  (a-h,p-w),integer (i-n),logical  (o)
      implicit character *8 (z),character *1 (x)
      implicit character *4 (y)
      dimension a(nar,nac),b(nac,nbc),c(nar,nbc)
_IFN1(tpbds)      call dgemm ( 'n' , 'n' , nar , nbc , nac , 1.0d0 , a , nar ,
_IF1(tpds)      call dgemmx( 'n' , 'n' , nar , nbc , nac , 1.0d0 , a , nar ,
_IF1(b)      call blas_$dgemm( 
_IF1(b)     + 'n' , 'n' , nar , nbc , nac , 1.0d0 , a , nar ,
     *                         b , nac , 0.0d0 , c , nar )
      return
      end
      subroutine caserr(log)
      implicit REAL  (a-h,p-w),integer   (i-n),logical    (o)
      implicit character *8 (z),character *1 (x)
      implicit character *4 (y)
      character*(*) log
INCLUDE(../m4/common/utilc)
      character*80 ia
      common/iofile/iread,iwr
c
      ia = log
      write(iwr,30)ia
30    format(//65('*#')//50x,'error detected'/50x,'**************'/
     1/20x,a80//65('*#')//)
      call parerr(12345)
      return
      end
      subroutine pproc
      implicit logical (o)
      character*30 host, user, mach
      dimension  ibuff(91)
      call hostcc(host,30)
      call namcc(user,30)
      mach=
_IF1(x)     *'CONVEX  version 3.0'
_IF1(a)     *'ALLIANT version 2.0'
_IF1(s)     *'  SUN   version 2.0'
_IF1(p)     *'APOLLO  version 2.1'
_IF1(g)     *'  SGI   version 2.0'
_IF1(b)     *'HP-700  version 1.0'
_IF1(d)     *'  DEC   version 1.0'
_IF1(r)     *'RS-6000 version 1.0'
_IF1(t)     *' TITAN  version 2.0'
_IF1(c)     *'UNICOS  version 2.0'
      call pidcc(ipid)
      if(oroot())then
         write(6,1000)
         write(6,1001)ipid,host(1:12),user(1:12),mach
         do 10 i=1,nnodes()-1
            call rcv(100,ibuff,91*4,il,i,if,0)
            call itoch(ibuff(1),host)
            call itoch(ibuff(31),user)
            call itoch(ibuff(61),mach)
            ipid=ibuff(91)
         write(6,1002)i,ipid,host(1:12),user(1:12),mach
   10    continue
      else
         call chtoi(ibuff(1),host)
         call chtoi(ibuff(31),user)
         call chtoi(ibuff(61),mach)
         ibuff(91)=ipid
         call snd(100,ibuff,91*4,0,0)
      endif
1000  format(//,40x,'node information',/,40x,16('-'),
     & //,40x,'node     pid   hostname     user           version',/)
 1001 format(40x,'root',i8,3x,a12,1x,a12,1x,a30)
 1002 format(40x,   i4 ,i8,3x,a12,1x,a12,1x,a30)
      end
      function dclock()
      implicit REAL  (a-h,p-w),integer    (i-n),logical    (o)
      implicit character *8 (z),character *1 (x)
      implicit character *4 (y)
      call timef(dum)
      dclock = dum * 0.001d0
      return
      end
      subroutine timef(elapse)
      implicit REAL  (a-h,p-w),integer   (i-n),logical    (o)
      implicit character *8 (z),character *1 (x)
      implicit character *4 (y)
c
c return wall time in milli-seconds
c
      save ienter,tst
      data ienter/0/
      if (ienter.eq.0) then
        ienter = 1
        call cputm(ii)
        tst = dfloat(ii) * 10.0d0
        elapse = 0.0d0
      else
        call cputm(ii)
        elapse = dfloat(ii)*10.0d0 - tst
      endif
      return
      end
      subroutine chtoi(i,s)
      integer i(*)
      character s*(*)
      ilen=len(s)
      do 10 ii = 1,ilen
        i(ii)=ichar(s(ii:ii))
10    continue
      return
      end
      subroutine itoch(i,s)
      integer i(*)
      character s*(*)
      ilen=len(s)
      do 10 ii = 1,ilen
        s(ii:ii)=char(i(ii))
10    continue
      return
      end
_IFN(blas)
      function ddot(n,sx,incx,sy,incy)
c
c     returns the dot product of real sx and sy.
c
      implicit REAL  (a-h,p-w),integer    (i-n),logical    (o)
      implicit character *8 (z),character *1 (x)
      implicit character *4 (y)
      dimension sx(*),sy(*)
      ddot = 0.0d0
      if(n.le.0)return
      if(incx.eq.incy) if(incx-1) 1, 2, 6
    1 continue
c
c         code for unequal or nonpositive increments.
c
      ix = 1
      iy = 1
      if(incx.lt.0)ix = (-n+1)*incx + 1
      if(incy.lt.0)iy = (-n+1)*incy + 1
      ddot = vec_$ddot_i(sx(ix),incx,sy(iy),incy,n)
      return
c        code for both increments equal to 1.
c
    2 continue
      ddot = vec_$ddot(sx,sy,n)
      return
c
c         code for positive equal increments .ne.1.
c
    6 continue
      ddot = vec_$ddot_i(sx,incx,sy,incx,n)
      return
      end
_ENDIF
_ELSE
      function cpulft(i)
c..
c..    ipsc timer (both cputime,wallclock and reset)
c..
      implicit REAL (a-h,p-w),integer (i-n),logical  (o)
      implicit character *8 (z),character *1 (x)
      implicit character *4 (y)
      common/timez/timlim,timed(9),begin,elapl,isecs
      ak = dclock() - begin
      if (i.le.0) then
         cpulft=(timlim-ak)
      else
          cpulft=ak
      end if
c
      return
      end
      integer function dimcube(p)
      implicit REAL (a-h,o-z)
      integer p
c
c     dimension of a hypercube containing at least p nodes
c        = ceil(log2(p))
c
      dimcube = idint(1.44d0*dlog(dfloat(p)) + 0.99d0)
      return
      end
      subroutine ggop (type, x, n, op, work)
      integer type, n, root, dim
      character*1 op
      double precision x(n), work(n)
      common/nodinf/mpid,minode,mihost,dim,nnodes
c
c  global vector commutative operation using spanning tree.
c
c  all participating processes must have the same process id (pid).
c
c***  modified version : all nodes receive final result
c     use gdprod, gdsum, gdhigh and gdlow routines
c  input..
c
c    type      message type.  must be the same for all participating
c              processes.  there must be no other messages of this type
c              in the system.
c    x         the input vector to be used in the operation.
c    n         the length of the vector.
c    op        '+'  sum
c              '*'  product
c              'm'  maximum
c              'm'  minimum
c    root      node id of root process (which will get the final message
c              (if + or myhost(), then the smallest node number in the a
c              subcube acts as root and then forwards the message to the
c    dim       the size of the subcube participating.
c
c  output..
c
c    x         for the root process, x contains the desired result.
c              for all other processes, x contains the partial result
c              for their subtrees.
c
c  workspace
c
c    work      used to receive other contributions.
c
c  errors conditions
c
c        if called by a nonparticipating node, an error message is
c        syslogged and then the subroutine exits.
c
c        if a message longer than n elements is received, only the first
c        elements are saved, an error message is syslogged,
c        and then the computation continues with the truncated results.
c
c        if a message shorter than n elements is received, then an error
c        message is syslogged and the computation continues.
c
c  calls:  mynode, mypid, recvw, sendw, xor
c
      integer bit, bytes, diff, i, ignore, me, mynode,
     *   mypid, p, parent, pid, troot, xor
      REAL   tgoptm,tfndtm,tgettm,tputtm,dclock,dumtim
      common/nodtim/ tgoptm,topen(10),tfndtm(10),tgettm(10),tputtm(10)
c
      dumtim = dclock()
c
         if (op .eq. '+') then
            call gdsum(x,n,work)
         else if (op .eq. '*') then
            call gdprod(x,n,work)
         else if (op .eq. 'm') then
            call gdhigh(x,n,work)
         else if (op .eq. 'm') then
            call gdlow(x,n,work)
         else
            call caserr(' unrecognised operation in ggop')
         end if
c
      tgoptm = tgoptm + (dclock()-dumtim)
c
      return
      end
      subroutine ininod
c
c...  set few parameters needed in node proces
c
      common/nodinf/mpid,minode,mihost,ldim,nnodes,noddim
      REAL  tgoptm,tfndtm,tgettm,tputtm
      common/nodtim/ tgoptm,topen(10),tfndtm(10),tgettm(10),tputtm(10)
      parameter (nreal=8,nint=4,iroot=0)
      integer dimcube
      logical oroot
      common/iofile/ir,iw
c
      mpid = mypid()
      minode = mynode()
      mihost = 0
      nnodes = numnodes()
      noddim = nodedim()
      ldim = dimcube(nnodes)
      if (nnodes.ne.2**ldim.and.oroot()) then
         print *,ldim-nnodes,' nodes not in cube '
      end if
c
      tgoptm = 0.0d0
      do 100 loop=1,10
      topen (loop) = 0.0d0
      tfndtm(loop) = 0.0d0
      tgettm(loop) = 0.0d0
100   tputtm(loop) = 0.0d0
c
      return
      end
      subroutine initia
      implicit REAL (a-h,p-w),integer   (i-n),logical    (o)
      implicit character *8 (z),character *1 (x)
      implicit character *4 (y)
      character*20 fname
INCLUDE(../m4/common/utilc)
      common/iofile/iread,iwr
      common/timez/timlim(12),isec
      common/prints/oprntd(60)
c
c
c***   ***NODE-IPSC***
      common/nodinf/mpid,minode,mihost,ldim,nnodes,nodscr
c***   ***NODE-IPSC***
      opnode = .false.
      odumpm = .true.
      call ininod
      call setcpu
      iwr = 6
      iread = 5
      opkill=.true.
      oprntd(28)=.true.
c
c...  set iwr to 94 to seperate output of nodes
c
      if (.not.oroot()) then
         iwr = 94
c...      different numbers are not needed / different names are
c...      if no node output is requested send it to sink
         nn = 100+minode
         write(fname,'(a,i3)') 'out_mopac_',nn
c        if (opkill) oprnts(60) = .false.
         if (opnode) then
          open(iwr,form='formatted',file=fname,err=9998)
         else
          open(iwr,form='formatted',file='/dev/null',err=9998)
         endif
c
      end if
      return
9998  write(6,9997)
9997  format(/' *** failed to open output file *** '/)
      call pend
      return
      end
      subroutine pend
      implicit REAL (a-h,p-w),integer   (i-n),logical    (o)
      call exit
      stop
      end
      function oipsci()
      implicit REAL (a-h,o-z)
      logical oipsci
c
c...   decide  if we should process this integral batch
c...   called from jkin70 (integs) etc.
c
      common/nodinf/mpid,minode,mihost,ldim,nnodes
      common/nodin2/icount
c
       icount = icount + 1
       oipsci = mod(icount,nnodes).ne.minode
c
       return
       end
       function  iipsci()
c
c...   initialise
c
       common/nodin2/icount
c
       icount = 0
       iipsci = 0
c
       return
       end
      logical function oroot()
c...   tells me if i am the root
      common/nodinf/mpid,minode,mihost,ldim,nnodes
      oroot = minode.eq.0
c
      return
      end
      subroutine setcpu
c
c...   set start of clock to 0.0 **must** be called
c
      implicit REAL (a-h,p-w),integer (i-n),logical  (o)
      implicit character *8 (z),character *1 (x)
      implicit character *4 (y)
      integer ftimen
      common/timez/timlim,timed(9),begin,elapl,isecs
      begin = dclock()
      elapl = ftimen()
      return
      end
      subroutine mxm(a,nar,b,nac,c,nbc)
      implicit REAL (a-h,p-w),integer (i-n),logical  (o)
      implicit character *8 (z),character *1 (x)
      implicit character *4 (y)
      dimension a(nar,nac),b(nac,nbc),c(nar,nbc)
      call dgemm ( 'n' , 'n' , nar , nbc , nac , 1.0d0 , a , nar ,
     *                         b , nac , 0.0d0 , c , nar )
      return
      end
      subroutine caserr(log)
      implicit REAL (a-h,p-w),integer   (i-n),logical    (o)
      implicit character *8 (z),character *1 (x)
      implicit character *4 (y)
      character*(*) log
      character*80 ia
      common/iofile/iread,iwrite
c
      ia = log
      write(iwrite,30)ia
30    format(//65('*#')//50x,'error detected'/50x,'**************'/
     1/20x,a80//65('*#')//)
      call exit
      return
      end
_ENDIF
