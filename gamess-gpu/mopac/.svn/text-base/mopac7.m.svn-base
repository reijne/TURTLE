c
c  $Author: mrdj $
c  $Date: 2007-08-19 22:20:56 $
c  $Locker:  $
c  $Revision: 1.7 $
c  $Source: /c/qcg/cvs/psh/GAMESS-UK/mopac/mopac7.m,v $
c  $State: Exp $
c
      block data mopc0
      implicit REAL (a-h,o-z)
      common /cmporb/ natorb(107)
***********************************************************************
*
*     common blocks for am1
*
***********************************************************************
      common /elemts/ elemnt(107)
      common /corec/ core(107)
      common /multip/ dd(107),qq(107),am(107),ad(107),aq(107)
      common /expont/ zs(107),zp(107),zd(107)
      common /cmpone/ uss(107),upp(107),udd(107)
      common /betas/ betas(107),betap(107),betad(107)
      common /twoele/ gss(107),gsp(107),gpp(107),gp2(107),hsp(107),
     +                gsd(107),gpd(107),gdd(107)
      common /atomic/ eisol(107),eheat(107)
      common /vsips/ vs(107),vp(107),vd(107)
      common /istope/ ams(107)
      common /ideaa/ guesa1(107,10),guesa2(107,10),guesa3(107,10)
      common /ideap/ guesp1(107,10),guesp2(107,10),guesp3(107,10)
      common /cmpga/ fn1(107),fn2(107)
***********************************************************************
*
*     common blocks for mndo
*
***********************************************************************
      common /mndo/  ussm(107), uppm(107), uddm(107), zsm(107),
     1zpm(107), zdm(107), betasm(107), betapm(107), betadm(107),
     2alpm(107), eisolm(107), ddm(107), qqm(107), amm(107), adm(107),
     3aqm(107) ,gssm(107), gspm(107), gppm(107), gp2m(107), hspm(107),
     4polvom(107)
***********************************************************************
*
*     common blocks for pm3
*
***********************************************************************
      common /pm3/ usspm3(107), upppm3(107), uddpm3(107), zspm3(107),
     1zppm3(107), zdpm3(107), betasp(107), betapp(107), betadp(107),
     2alppm3(107), eisolp(107), ddpm3(107), qqpm3(107), ampm3(107),
     3adpm3(107), aqpm3(107) ,gsspm3(107), gsppm3(107), gpppm3(107),
     4gp2pm3(107), hsppm3(107),polvop(107)
***********************************************************************
*
*     common blocks for am1
*
***********************************************************************
      common /am1blo/ussam1(107), uppam1(107), uddam1(107), zsam1(107),
     1zpam1(107), zdam1(107), betasa(107), betapa(107), betada(107),
     2alpam1(107), eisola(107), ddam1(107), qqam1(107), amam1(107),
     3adam1(107), aqam1(107) ,gssam1(107), gspam1(107), gppam1(107),
     4gp2am1(107), hspam1(107),polvoa(107)
      common /refs/ refmn(107), refm3(107), refam(107), refpm3(107)
***********************************************************************
*
*  common blocks for mindo/3
*
***********************************************************************
      common /onele3/ uss3(18),upp3(18)
      common /twoel3/ f03(107)
      common /atomi3/ eisol3(18),eheat3(18)
      common /beta3/ beta3(153)
      common /alpha3/ alp3(153)
      common /expon3/ zs3(18),zp3(18)
*
*  end of mindo/3 common blocks
*
c
c electric field options for polarizability
c
      common /cmpfd/ efield(3)
      character elemnt*2, refmn*80, refm3*80, refam*80, refpm3*80
      data efield/0.0d00,0.0d00,0.0d00/
      data elemnt/' h','he',
     1 'li','be',' b',' c',' n',' o',' f','ne',
     2 'na','mg','al','si',' p',' s','cl','ar',
     3 ' k','ca','sc','ti',' v','cr','mn','fe','co','ni','cu',
     4 'zn','ga','ge','as','se','br','kr',
     5 'rb','sr',' y','zr','nb','mo','tc','ru','rh','pd','ag',
     6 'cd','in','sn','sb','te',' i','xe',
     7 'cs','ba','la','ce','pr','nd','pm','sm','eu','gd','tb','dy',
     8 'ho','er','tm','yb','lu','hf','ta',' w','re','os','ir','pt',
     9 'au','hg','tl','pb','bi','po','at','rn',
     1 'fr','ra','ac','th','pa',' u','np','pu','am','cm','bk','cf','xx',
     2 'fm','md','cb','++',' +','--',' -','tv'/
c
c   natorb is the number of atomic orbitals per atom.
c
      data natorb/2*1, 4, 7*4, 0, 7*4, 0, 4, 9*9, 7*4,
     12*4, 9*9, 7*4, 2*2, 14*8, 9*9, 7*4, 15*0,1,5*0/
***********************************************************************
*                      valence shells are defined as                  *
*  pqn   valence shells                                               *
*                 p-group              f-group    transition metals   *
*   1       1s                                                        *
*   2       2s 2p                                                     *
*   3       3s 3p  or  3s 3p 3d                                       *
*   4       4s 4p                                    4s 4p 3d         *
*   5       5s 5p                                    5s 5p 4d         *
*   6       6s 6p                       6s 4f        6s 6p 5d         *
*   7  not assigned yet  ****do  not  use****                         *
***********************************************************************
      data      polvom(1) /0.2287d0/
      data      polvom(6) /0.2647d0/
      data      polvom(7) /0.3584d0/
      data      polvom(8) /0.2324d0/
      data      polvom(9) /0.1982d0/
      data      polvom(17)/1.3236d0/
      data      polvom(35)/2.2583d0/
      data      polvom(53)/4.0930d0/
c
c                standard atomic masses
c
      data  ams /  1.00790d0,  4.00260d0,  6.94000d0,  9.01218d0,
     110.81000d0, 12.01100d0, 14.00670d0, 15.99940d0, 18.99840d0,
     220.17900d0, 22.98977d0, 24.30500d0, 26.98154d0, 28.08550d0,
     330.97376d0, 32.06000d0, 35.45300d0, 39.94800d0, 39.09830d0,
     440.08000d0, 44.95590d0, 47.90000d0, 50.94150d0, 51.99600d0,
     554.93800d0, 55.84700d0, 58.93320d0, 58.71000d0, 63.54600d0,
     665.38000d0, 69.73500d0, 72.59000d0, 74.92160d0, 78.96000d0,
     779.90400d0, 83.80000d0, 85.46780d0, 87.62000d0, 88.90590d0,
     891.22000d0, 92.90640d0, 95.94000d0, 98.90620d0, 101.0700d0,
     9102.9055d0, 106.4000d0, 107.8680d0, 112.4100d0, 114.8200d0,
     1118.6900d0, 121.7500d0, 127.6000d0, 126.9045d0, 131.3000d0,
     2132.9054d0, 137.3300d0, 15*0.000d0, 178.4900d0, 180.9479d0,
     3183.8500d0, 186.2070d0, 190.2000d0, 192.2200d0, 195.0900d0,
     4196.9665d0, 200.5900d0, 204.3700d0, 207.2000d0, 208.9804d0,
     518*0.000d0,   1.0079d0,  5*0.000d0/
c
c   core is the charge on the atom as seen by the electrons
c
      data core/1.d0,0.d0,
     1 1.d0,2.d0,3.d0,4.d0,5.d0,6.d0,7.d0,0.d0,
     2 1.d0,2.d0,3.d0,4.d0,5.d0,6.d0,7.d0,0.d0,
     3 1.d0,2.d0,3.d0,4.d0,5.d0,6.d0,7.d0,8.d0,9.d0,10.d0,11.d0,2.d0,
     4 3.d0,4.d0,5.d0,6.d0,7.d0,0.d0,
     5 1.d0,2.d0,3.d0,4.d0,5.d0,6.d0,7.d0,8.d0,9.d0,10.d0,11.d0,2.d0,
     6 3.d0,4.d0,5.d0,6.d0,7.d0,0.d0,
     7 1.d0,2.d0,3.d0,4.d0,5.d0,6.d0,7.d0,8.d0,9.d0,10.d0,
     8 11.d0,12.d0,13.d0,14.d0,15.d0,16.d0,
     9 3.d0,4.d0,5.d0,6.d0,7.d0,8.d0,9.d0,10.d0,11.d0,2.d0,
     1 3.d0,4.d0,5.d0,6.d0,7.d0,0.d0,
     2  15*0.d0,1.d0,2.d0,1.d0,-2.d0,-1.d0,0.d0/
c
c     enthalpies of formation of gaseous atoms are taken from \annual
c     reports,1974,71b,p 117\  there are some significant differences
c     between the values reported there and the values previously in
c     the block data of this program.  only the third  row elements
c     have been updated.
c
* all the other elements are taken from crc handbook 1981-1982
      data eheat(1)  / 52.102d0/
      data eheat(2)  /  0.000d0/
c
      data eheat(3)  / 38.410d0/
      data eheat(4)  / 76.960d0/
      data eheat(5)  /135.700d0/
      data eheat(6)  /170.890d0/
      data eheat(7)  /113.000d0/
      data eheat(8)  / 59.559d0/
      data eheat(9)  / 18.890d0/
      data eheat(10) /  0.000d0/
c
      data eheat(11) / 25.850d0/
      data eheat(12) / 35.000d0/
      data eheat(13) / 79.490d0/
      data eheat(14) /108.390d0/
      data eheat(15) / 75.570d0/
      data eheat(16) / 66.400d0/
      data eheat(17) / 28.990d0/
      data eheat(18) /  0.000d0/
c
      data eheat(19) / 21.420d0/
      data eheat(20) / 42.600d0/
      data eheat(21) / 90.300d0/
      data eheat(22) /112.300d0/
      data eheat(23) /122.900d0/
      data eheat(24) / 95.000d0/
      data eheat(25) / 67.700d0/
      data eheat(26) / 99.300d0/
      data eheat(27) /102.400d0/
      data eheat(28) /102.800d0/
      data eheat(29) / 80.700d0/
      data eheat(30) / 31.170d0/
      data eheat(31) / 65.400d0/
      data eheat(32) / 89.500d0/
      data eheat(33) / 72.300d0/
      data eheat(34) / 54.300d0/
      data eheat(35) / 26.740d0/
      data eheat(36) /  0.000d0/
c
      data eheat(37) / 19.600d0/
      data eheat(38) / 39.100d0/
      data eheat(39) /101.500d0/
      data eheat(40) /145.500d0/
      data eheat(41) /172.400d0/
      data eheat(42) /157.300d0/
      data eheat(44) /155.500d0/
      data eheat(45) /133.000d0/
      data eheat(46) / 90.000d0/
      data eheat(47) / 68.100d0/
      data eheat(48) / 26.720d0/
      data eheat(49) / 58.000d0/
      data eheat(50) / 72.200d0/
      data eheat(51) / 63.200d0/
      data eheat(52) / 47.000d0/
      data eheat(53) / 25.517d0/
      data eheat(54) /  0.000d0/
c
      data eheat(55) / 18.700d0/
      data eheat(56) / 42.500d0/
      data eheat(58) /101.300d0/
      data eheat(62) / 49.400d0/
      data eheat(68) / 75.800d0/
      data eheat(70) / 36.350d0/
      data eheat(72) /148.000d0/
      data eheat(73) /186.900d0/
      data eheat(74) /203.100d0/
      data eheat(75) /185.000d0/
      data eheat(76) /188.000d0/
      data eheat(77) /160.000d0/
      data eheat(78) /135.200d0/
      data eheat(79) / 88.000d0/
      data eheat(80) / 14.690d0/
      data eheat(81) / 43.550d0/
      data eheat(82) / 46.620d0/
      data eheat(83) / 50.100d0/
      data eheat(86) /  0.000d0/
      data eheat(102)  / 207.0d0/
c
      data vs(1) /  -13.605  /
      data vs(5)/-15.16d00/
      data vs(6)/-21.34d00/
      data vs(7)/-27.51d00/
      data vs(8)/-35.30d00/
      data vs(9)/-43.70d00/
      data vs(14)/-17.82d00/
      data vs(15)/-21.10d00/
      data vs(16)/-23.84d00/
      data vs(17)/-25.26d00/
      data vp(1)  /  0.0d00  /
      data vp(5)/-8.52d00/
      data vp(6)/-11.54d00/
      data vp(7)/-14.34d00/
      data vp(8)/-17.91d00/
      data vp(9)/-20.89d00/
      data vp(14)/-8.51d00/
      data vp(15)/-10.29d00/
      data vp(16)/-12.41d00/
      data vp(17)/-15.09d00/
c      data npq/1,1, 2,2,2,2,2,2,2,2, 3,3,3,3,3,3,3,3, 4,4,4,4,4,4,4,4,
c     +4,4,4,4,4,4,4,4,4,4, 5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5/
c
c *** one center repulsion integrals
c     gss ::= (ss,ss)
c     gpp ::= (pp,pp)
c     gsp ::= (ss,pp)
c     gp2 ::= (pp,p*p*)
c     hsp ::= (sp,sp)
************************************************************************
      data gssm(1) / 12.848d00 /
      data gssm(4)/9.00d00/
      data gssm(5)/10.59d00/
      data gssm(6) / 12.23d00 /
      data gssm(7)/13.59d00/
      data gssm(8)/15.42d00/
      data gssm(9)/16.92d00/
      data gssm(13)/8.09d00/
      data gssm(14)/9.82d00/
      data gssm(15)/11.56d00/
      data gssm(16)/12.88d00/
      data gssm(17)/15.03d00/
      data gssm(35)/15.03643948d0/
      data gssm(53)/15.04044855d0/
      data gppm(4)/6.97d00/
      data gppm(5)/8.86d00/
      data gppm(6) / 11.08d00 /
      data gppm(7)/12.98d00/
      data gppm(8)/14.52d00/
      data gppm(9)/16.71d00/
      data gppm(13)/5.98d00/
      data gppm(14)/7.31d00/
      data gppm(15)/8.64d00/
      data gppm(16)/9.90d00/
      data gppm(17)/11.30d00/
      data gppm(35)/11.27632539d0/
      data gppm(53)/11.14778369d0/
      data gspm(4)/7.43d00/
      data gspm(5)/9.56d00/
      data gspm(6) / 11.47d00 /
      data gspm(7)/12.66d00/
      data gspm(8)/14.48d00/
      data gspm(9)/17.25d00/
      data gspm(13)/6.63d00/
      data gspm(14)/8.36d00/
      data gspm(15)/10.08d00/
      data gspm(16)/11.26d00/
      data gspm(17)/13.16d00/
      data gspm(35)/13.03468242d0/
      data gspm(53)/13.05655798d0/
      data gp2m(4)/6.22d00/
      data gp2m(5)/7.86d00/
      data gp2m(6) / 9.84d00 /
      data gp2m(7)/11.59d00/
      data gp2m(8)/12.98d00/
      data gp2m(9)/14.91d00/
      data gp2m(13)/5.40d00/
      data gp2m(14)/6.54d00/
      data gp2m(15)/7.68d00/
      data gp2m(16)/8.83d00/
      data gp2m(17)/9.97d00/
      data gp2m(35)/9.85442552d0/
      data gp2m(53)/9.91409071d0/
      data hspm(4)/1.28d00/
      data hspm(5)/1.81d00/
      data hspm(6) / 2.43d00 /
      data hspm(7)/3.14d00/
      data hspm(8)/3.94d00/
      data hspm(9)/4.83d00/
      data hspm(13)/0.70d00/
      data hspm(14)/1.32d00/
      data hspm(15)/1.92d00/
      data hspm(16)/2.26d00/
      data hspm(17)/2.42d00/
      data hspm(35)/2.45586832d0/
      data hspm(53)/2.45638202d0/
c
c     the monocentric integrals hsp and gsp for aluminium are only
c     estimates. a value of g1 for al is needed to resolve olearis
c     integrals.
c
c     optimized mndo parameters for h, be, b, c, n, o, f
c                                                     cl
c     estimated mndo parameters for       al,si, p, s
c
c     elements h, c, n, o were parameterized by walter thiel
c     elements b,si,p,s   were      ..          michael mckee
c     elements be,f,al,cl were      ..          henry rzepa
c
***********************************************************************
*
*    start of mindo/3 parameters
*
***********************************************************************
c *** f03 is the one center averaged repulsion integral for use in the
c        two center electronic repulsion integral evaluation.
      data refm3  ( 1)/'  h: (mindo/3): r.c.bingham et.al., j.am.chem.so
     1c. 97,1285,1294,1302,1307 (1975)'/
      data refm3  ( 5)/'  b: (mindo/3): r.c.bingham et.al., j.am.chem.so
     1c. 97,1285,1294,1302,1307 (1975)'/
      data refm3  ( 6)/'  c: (mindo/3): r.c.bingham et.al., j.am.chem.so
     1c. 97,1285,1294,1302,1307 (1975)'/
      data refm3  ( 7)/'  n: (mindo/3): r.c.bingham et.al., j.am.chem.so
     1c. 97,1285,1294,1302,1307 (1975)'/
      data refm3  ( 8)/'  o: (mindo/3): r.c.bingham et.al., j.am.chem.so
     1c. 97,1285,1294,1302,1307 (1975)'/
      data refm3  ( 9)/'  f: (mindo/3): r.c.bingham et.al., j.am.chem.so
     1c. 97,1285,1294,1302,1307 (1975)'/
      data refm3  (14)/' si: (mindo/3): r.c.bingham et.al., j.am.chem.so
     1c. 97,1285,1294,1302,1307 (1975)'/
      data refm3  (15)/'  p: (mindo/3): r.c.bingham et.al., j.am.chem.so
     1c. 97,1285,1294,1302,1307 (1975)'/
      data refm3  (16)/'  s: (mindo/3): r.c.bingham et.al., j.am.chem.so
     1c. 97,1285,1294,1302,1307 (1975)'/
      data refm3  (17)/' cl: (mindo/3): r.c.bingham et.al., j.am.chem.so
     1c. 97,1285,1294,1302,1307 (1975)'/
      data f03              /  12.848d0, 10.0d0, 10.0d0, 0.0d0,
     1  8.958d0, 10.833d0, 12.377d0, 13.985d0, 16.250d0,
     2         10.000d0, 10.000d0, 0.000d0, 0.000d0,7.57d0 ,  9.00d0 ,
     3         10.20d0 , 11.73,10.0d0,35*0.d0,10.d0,53*10.d0/
c *** uss and upp are the one-center core electron attraction and kineti
c     energy integrals for s and p electrons respectively in e.v.
      data uss3             / -12.505d0, 0.000d0, 0.000d0, 0.000d0,
     1                       -33.61d0, -51.79d0, -66.06d0, -91.73d0 ,
     2                       -129.86d0,
     3                        0.0000d0 , 0.000 d0 ,0.000d0 , 0.000d0 ,
     4          -39.82d0 , -56.23d0 , -73.39d0 , -98.99d0 ,.0d0/
      data upp3             /   0.0d0, 0.0d0, 0.0d0, 0.0d0,
     1     -25.11d0 , -39.18d0 , -56.40d0 , -78.80d0 , -105.93d0 ,
     2                        0.000d0 , 0.000d0 , 0.000d0 , 0.000d0 ,
     3         -29.15d0 , -42.31d0 , -57.25d0 , -76.43d0 ,.0d0/
c *** eisol3 and eheat3 are the gs electronic energy of the neutral atom
c     (in e.v.) and the heat of formation if the free atom (in kcal/mol)
      data eisol3             /-12.505d0 , 0.0d0 , 0.0d0 ,0.0d0 ,
     1        -61.70d0 ,-119.47d0 , -187.51d0 , -307.07d0 , -475.00d0 ,
     2                         0.0d0 , 0.0d0 , 0.0d0 , 0.0d0 ,
     3          -90.98d0 , -150.81d0 , -229.15d0 , -345.93d0 , 0.0d0/
      data eheat3             / 52.102d0 , 0.0d0 , 0.0d0 , 0.0d0 ,
     1     135.7 d0 , 170.89d0 ,  113.0 d0 ,  59.559d0 ,  18.86d0 ,
     2                         0.0d0 , 0.0d0 , 0.0d0 , 0.0d0 ,
     3     106.0d0 ,   79.8d0 ,  65.65d0 ,  28.95d0 , 0.0d0 /
c *** beta3 and alp3 are the bond parameters used in the
c     resonance integral and the core core repulsion integral respective
c     that is according to the following convention
c
c     here is the
c     bond type designation
c
c
c         h   b   c   n   o   f  si   p   s  cl
c       -----------------------------------------
c      h  1  11  16  22  29  37  92 106 121 137
c      b     15  20  26  33  41
c      c         21  27  34  42  97 111 126 142
c      n             28  35  43         127 143
c      o                 36  44     113 128
c      f                     45     114
c     si                        105
c      p                            120     151
c      s                                136 152
c     cl                                    153
      data beta3(1),alp3(1)   /  0.244770d0 ,  1.489450d0 /
      data beta3(11),alp3(11)   /  0.185347d0 ,  2.090352d0 /
      data beta3(15),alp3(15)   /  0.151324d0 ,  2.280544d0 /
      data beta3(16),alp3(16)   /  0.315011d0 ,  1.475836d0 /
      data beta3(20),alp3(20)   /  0.250031d0 ,  2.138291d0 /
      data beta3(21),alp3(21)   /  0.419907d0 ,  1.371208d0 /
      data beta3(22),alp3(22)   /  0.360776d0 ,  0.589380d0 /
      data beta3(26),alp3(26)   /  0.310959d0 ,  1.909763d0 /
      data beta3(27),alp3(27)   /  0.410886d0 ,  1.635259d0 /
      data beta3(28),alp3(28) /  0.377342d0 ,  2.029618d0 /
      data beta3(29),alp3(29) /  0.417759d0 ,  0.478901d0 /
      data beta3(33),alp3(33) /  0.349745d0 ,  2.484827d0 /
      data beta3(34),alp3(34) /  0.464514d0 ,  1.820975d0 /
      data beta3(35),alp3(35) /  0.458110d0 ,  1.873859d0 /
      data beta3(36),alp3(36) /  0.659407d0 ,  1.537190d0 /
      data beta3(37),alp3(37) /  0.195242d0 ,  3.771362d0 /
      data beta3(41),alp3(41) /  0.219591d0 ,  2.862183d0 /
      data beta3(42),alp3(42) /  0.247494d0 ,  2.725913d0 /
      data beta3(43),alp3(43) /  0.205347d0 ,  2.861667d0 /
      data beta3(44),alp3(44) /  0.334044d0 ,  2.266949d0 /
      data beta3(45),alp3(45) /  0.197464d0 ,  3.864997d0 /
      data beta3(92),alp3(92) /  0.289647d0 ,  0.940789d0 /
      data beta3(97),alp3(97) /  0.411377d0 ,  1.101382d0 /
      data beta3(105),alp3(105) /  0.291703d0 ,  0.918432d0 /
      data beta3(106),alp3(106) /  0.320118d0 ,  0.923170d0 /
      data beta3(111),alp3(111) /  0.457816d0 ,  1.029693d0 /
      data beta3(113),alp3(113) /  0.470000d0 ,  1.662500d0 /
      data beta3(114),alp3(114) /  0.300000d0 ,  1.750000d0 /
      data beta3(120),alp3(120) /  0.311790d0 ,  1.186652d0 /
      data beta3(121),alp3(121) /  0.220654d0 ,  1.700698d0 /
      data beta3(126),alp3(126) /  0.284620d0 ,  1.761370d0 /
      data beta3(127),alp3(127) /  0.313170d0 ,  1.878176d0/
      data beta3(128),alp3(128) /  0.422890d0 ,  2.077240d0 /
      data beta3(136),alp3(136) /  0.202489d0 ,  1.751617d0 /
      data beta3(137),alp3(137) /  0.231653d0 ,  2.089404d0 /
      data beta3(142),alp3(142) /  0.315480d0 ,  1.676222d0 /
      data beta3(143),alp3(143) /  0.302298d0 ,  1.817064d0 /
      data beta3(151),alp3(151) /  0.277322d0 ,  1.543720d0 /
      data beta3(152),alp3(152) /  0.221764d0 ,  1.950318d0 /
      data beta3(153),alp3(153) /  0.258969d0 ,  1.792125d0 /
c *** here comes the optimized slater_s exponents for the evaluation
c     of the overlap integrals and molecular dipole moments.
      data zs3(1),zp3(1)      /  1.3d0       ,  0.0d0      /
      data zs3(5),zp3(5)      /  1.211156d0 ,  0.972826d0 /
      data zs3(6),zp3(6)      /  1.739391d0 ,  1.709645d0 /
      data zs3(7),zp3(7)      /  2.704546d0 ,  1.870839d0 /
      data zs3(8),zp3(8)      /  3.640575d0 ,  2.168448d0 /
      data zs3(9),zp3(9)      /  3.111270d0 ,  1.41986d0 /
      data zs3(14),zp3(14)    /  1.629173d0 ,  1.381721d0 /
      data zs3(15),zp3(15)    /  1.926108d0 ,  1.590665d0 /
      data zs3(16),zp3(16)    /  1.719480d0 ,  1.403205d0 /
      data zs3(17),zp3(17)    /  3.430887d0 ,  1.627017d0 /
*************************************************************
*                                                           *
*               data for the sparkles                       *
*                                                           *
*************************************************************
*                               data for the " ++ " sparkle
      data eheat(103)    / 0.0d0/
      data vs(103)       /10.0d0/
c
c  start of mndo
c
      data alpm(103)     / 1.5d0/
      data eisolm(103)   / 0.0d0/
      data amm(103)      / 0.5d0/
c
c  start of am1
c
      data alpam1(103)   / 1.5d0/
      data eisola(103)   / 0.0d0/
      data amam1(103)    / 0.5d0/
c
c  start of pm3
c
      data alppm3(103)   / 1.5d0/
      data eisolp(103)   / 0.0d0/
      data ampm3(103)    / 0.5d0/
*                               data for the " + " sparkle
      data eheat(104)    / 0.0d0/
      data vs(104)       /10.0d0/
      data alpam1(104)   / 1.5d0/
      data eisola(104)   / 0.0d0/
      data amam1(104)    / 0.5d0/
      data alpm(104)     / 1.5d0/
      data eisolm(104)   / 0.0d0/
      data amm(104)      / 0.5d0/
      data alppm3(104)   / 1.5d0/
      data eisolp(104)   / 0.0d0/
      data ampm3(104)    / 0.5d0/
*                               data for the " -- " sparkle
      data eheat(105)    / 0.0d0/
      data vs(105)       /10.0d0/
      data alpam1(105)   / 1.5d0/
      data eisola(105)   / 0.0d0/
      data amam1(105)    / 0.5d0/
      data alpm(105)     / 1.5d0/
      data eisolm(105)   / 0.0d0/
      data amm(105)      / 0.5d0/
      data alppm3(105)   / 1.5d0/
      data eisolp(105)   / 0.0d0/
      data ampm3(105)    / 0.5d0/
*                               data for the " - " sparkle
      data eheat(106)    / 0.0d0/
      data vs(106)       /10.0d0/
      data alpam1(106)   / 1.5d0/
      data eisola(106)   / 0.0d0/
      data amam1(106)    / 0.5d0/
      data alpm(106)     / 1.5d0/
      data eisolm(106)   / 0.0d0/
      data amm(106)      / 0.5d0/
      data alppm3(106)   / 1.5d0/
      data eisolp(106)   / 0.0d0/
      data ampm3(106)    / 0.5d0/
***********************************************************************
*
*    start of mndo parameters
*
***********************************************************************
c                    data for element  1        hydrogen
      data refmn  ( 1)/'  h: (mndo):  m.j.s. dewar, w. thiel, j. am. che
     1m. soc., 99, 4899, (1977)       '/
      data ussm   ( 1)/     -11.9062760d0/
      data betasm ( 1)/      -6.9890640d0/
      data zsm    ( 1)/       1.3319670d0/
      data alpm   ( 1)/       2.5441341d0/
      data eisolm ( 1)/     -11.9062760d0/
      data amm    ( 1)/       0.4721793d0/
      data adm    ( 1)/       0.4721793d0/
      data aqm    ( 1)/       0.4721793d0/
c                    data for element  3        lithium
      data refmn  ( 3)/' li: (mndo):  taken from mndoc by w.thiel,
     1qcpe no.438, v. 2, p.63, (1982).'/
      data ussm   (  3)/      -5.1280000d0/
      data uppm   (  3)/      -2.7212000d0/
      data betasm (  3)/      -1.3500400d0/
      data betapm (  3)/      -1.3500400d0/
      data zsm    (  3)/       0.7023800d0/
      data zpm    (  3)/       0.7023800d0/
      data alpm   (  3)/       1.2501400d0/
      data eisolm (  3)/      -5.1280000d0/
      data gssm   (  3)/       7.3000000d0/
      data gspm   (  3)/       5.4200000d0/
      data gppm   (  3)/       5.0000000d0/
      data gp2m   (  3)/       4.5200000d0/
      data hspm   (  3)/       0.8300000d0/
      data ddm    (  3)/       2.0549783d0/
      data qqm    (  3)/       1.7437069d0/
      data amm    (  3)/       0.2682837d0/
      data adm    (  3)/       0.2269793d0/
      data aqm    (  3)/       0.2614581d0/
c                    data for element  4        beryllium
      data refmn  ( 4)/' be: (mndo):  m.j.s. dewar, h.s. rzepa, j. am. c
     1hem. soc., 100, 777, (1978)     '/
      data ussm   ( 4)/     -16.6023780d0/
      data uppm   ( 4)/     -10.7037710d0/
      data betasm ( 4)/      -4.0170960d0/
      data betapm ( 4)/      -4.0170960d0/
      data zsm    ( 4)/       1.0042100d0/
      data zpm    ( 4)/       1.0042100d0/
      data alpm   ( 4)/       1.6694340d0/
      data eisolm ( 4)/     -24.2047560d0/
      data ddm    ( 4)/       1.4373245d0/
      data qqm    ( 4)/       1.2196103d0/
      data amm    ( 4)/       0.3307607d0/
      data adm    ( 4)/       0.3356142d0/
      data aqm    ( 4)/       0.3846373d0/
c                    data for element  5        boron
      data refmn  ( 5)/'  b: (mndo):  m.j.s. dewar, m.l. mckee, j. am. c
     1hem. soc., 99, 5231, (1977)     '/
      data ussm   ( 5)/     -34.5471300d0/
      data uppm   ( 5)/     -23.1216900d0/
      data betasm ( 5)/      -8.2520540d0/
      data betapm ( 5)/      -8.2520540d0/
      data zsm    ( 5)/       1.5068010d0/
      data zpm    ( 5)/       1.5068010d0/
      data alpm   ( 5)/       2.1349930d0/
      data eisolm ( 5)/     -64.3159500d0/
      data ddm    ( 5)/       0.9579073d0/
      data qqm    ( 5)/       0.8128113d0/
      data amm    ( 5)/       0.3891951d0/
      data adm    ( 5)/       0.4904730d0/
      data aqm    ( 5)/       0.5556979d0/
c                    data for element  6        carbon
      data refmn  ( 6)/'  c: (mndo):  m.j.s. dewar, w. thiel, j. am. che
     1m. soc., 99, 4899, (1977)       '/
      data ussm   ( 6)/     -52.2797450d0/
      data uppm   ( 6)/     -39.2055580d0/
      data betasm ( 6)/     -18.9850440d0/
      data betapm ( 6)/      -7.9341220d0/
      data zsm    ( 6)/       1.7875370d0/
      data zpm    ( 6)/       1.7875370d0/
      data alpm   ( 6)/       2.5463800d0/
      data eisolm ( 6)/    -120.5006060d0/
      data ddm    ( 6)/       0.8074662d0/
      data qqm    ( 6)/       0.6851578d0/
      data amm    ( 6)/       0.4494671d0/
      data adm    ( 6)/       0.6149474d0/
      data aqm    ( 6)/       0.6685897d0/
c                    data for element  7        nitrogen
      data refmn  ( 7)/'  n: (mndo):  m.j.s. dewar, w. thiel, j. am. che
     1m. soc., 99, 4899, (1977)       '/
      data ussm   ( 7)/     -71.9321220d0/
      data uppm   ( 7)/     -57.1723190d0/
      data betasm ( 7)/     -20.4957580d0/
      data betapm ( 7)/     -20.4957580d0/
      data zsm    ( 7)/       2.2556140d0/
      data zpm    ( 7)/       2.2556140d0/
      data alpm   ( 7)/       2.8613420d0/
      data eisolm ( 7)/    -202.5662010d0/
      data ddm    ( 7)/       0.6399037d0/
      data qqm    ( 7)/       0.5429763d0/
      data amm    ( 7)/       0.4994487d0/
      data adm    ( 7)/       0.7843643d0/
      data aqm    ( 7)/       0.81264450d0/
c                    data for element  8        oxygen
      data refmn  ( 8)/'  o: (mndo):  m.j.s. dewar, w. thiel, j. am. che
     1m. soc., 99, 4899, (1977)       '/
      data ussm   ( 8)/     -99.6443090d0/
      data uppm   ( 8)/     -77.7974720d0/
      data betasm ( 8)/     -32.6880820d0/
      data betapm ( 8)/     -32.6880820d0/
      data zsm    ( 8)/       2.6999050d0/
      data zpm    ( 8)/       2.6999050d0/
      data alpm   ( 8)/       3.1606040d0/
      data eisolm ( 8)/    -317.8685060d0/
      data ddm    ( 8)/       0.5346024d0/
      data qqm    ( 8)/       0.4536252d0/
      data amm    ( 8)/       0.5667034d0/
      data adm    ( 8)/       0.9592562d0/
      data aqm    ( 8)/       0.9495934d0/
c                    data for element  9        fluorine
      data refmn  ( 9)/'  f: (mndo):  m.j.s. dewar, h.s. rzepa, j. am. c
     1hem. soc., 100, 777, (1978)     '/
      data ussm   ( 9)/    -131.0715480d0/
      data uppm   ( 9)/    -105.7821370d0/
      data betasm ( 9)/     -48.2904660d0/
      data betapm ( 9)/     -36.5085400d0/
      data zsm    ( 9)/       2.8484870d0/
      data zpm    ( 9)/       2.8484870d0/
      data alpm   ( 9)/       3.4196606d0/
      data eisolm ( 9)/    -476.6837810d0/
      data ddm    ( 9)/       0.5067166d0/
      data qqm    ( 9)/       0.4299633d0/
      data amm    ( 9)/       0.6218302d0/
      data adm    ( 9)/       1.0850301d0/
      data aqm    ( 9)/       1.0343643d0/
*                               data for the sodium-like sparkle
      data refmn  (11)/' na: (mndo):  sodium-like sparkle.   use with ca
     1re.                             '/
      data refam  (11)/' na: (am1):   sodium-like sparkle.   use with ca
     1re.                             '/
      data refpm3 (11)/' na: (pm3):   sodium-like sparkle.   use with ca
     1re.                             '/
      data vs(11)       /10.0d0/
      data alpam1(11)      / 1.668d0/
      data alpm(11)        / 1.660d0/
      data alppm3(11)      / 1.681d0/
c
      data eisola(11)      / 0.0d0/
      data eisolm(11)      / 0.0d0/
      data eisolp(11)      / 0.0d0/
c
      data amam1(11)       / 0.5d0/
      data amm(11)         / 0.5d0/
      data ampm3(11)       / 0.5d0/
c                    data for element 13        aluminum
      data refmn  (13)/' al: (mndo):  l.p. davis, et.al.  j. comp. chem.
     1, 2, 433, (1981) see manual.    '/
      data ussm   (13)/     -23.8070970d0/
      data uppm   (13)/     -17.5198780d0/
      data betasm (13)/      -2.6702840d0/
      data betapm (13)/      -2.6702840d0/
      data zsm    (13)/       1.4441610d0/
      data zpm    (13)/       1.4441610d0/
      data zdm    (13)/       1.0000000d0/
      data alpm   (13)/       1.8688394d0/
      data eisolm (13)/     -44.4840720d0/
      data ddm    (13)/       1.3992387d0/
      data qqm    (13)/       1.1586797d0/
      data amm    (13)/       0.2973172d0/
      data adm    (13)/       0.2635574d0/
      data aqm    (13)/       0.3673560d0/
c                    data for element 14          silicon
      data refmn  (14)/' si: (mndo): m.j.s.dewar, et. al. organometallic
     1s  5, 375 (1986)                '/
      data ussm   (14)/     -37.0375330d0/
      data uppm   (14)/     -27.7696780d0/
      data betasm (14)/      -9.0868040d0/
      data betapm (14)/      -1.0758270d0/
      data zsm    (14)/       1.3159860d0/
      data zpm    (14)/       1.7099430d0/
      data zdm    (14)/       1.0000000d0/
      data alpm   (14)/       2.2053160d0/
      data eisolm (14)/     -82.8394220d0/
      data ddm    (14)/       1.2580349d0/
      data qqm    (14)/       0.9785824d0/
      data amm    (14)/       0.3608967d0/
      data adm    (14)/       0.3664244d0/
      data aqm    (14)/       0.4506740d0/
c                    data for element 15        phosphorus
      data refmn  (15)/'  p: (mndo): m.j.s.dewar, m.l.mckee, h.s.rzepa,
     1j. am. chem. soc., 100 3607 1978'/
      data ussm   (15)/     -56.1433600d0/
      data uppm   (15)/     -42.8510800d0/
      data betasm (15)/      -6.7916000d0/
      data betapm (15)/      -6.7916000d0/
      data zsm    (15)/       2.1087200d0/
      data zpm    (15)/       1.7858100d0/
      data zdm    (15)/       1.0000000d0/
      data alpm   (15)/       2.4152800d0/
      data eisolm (15)/    -152.9599600d0/
      data ddm    (15)/       1.0129699d0/
      data qqm    (15)/       0.9370090d0/
      data amm    (15)/       0.4248438d0/
      data adm    (15)/       0.4882420d0/
      data aqm    (15)/       0.4979406d0/
c                    data for element 16        sulfur
c
      data refmn  (16)/'  s: (mndo): m.j.s.dewar, c.h. reynolds, j. com
     1p. chem. 7, 140-143 (1986)      '/
      data ussm   (16)/     -72.2422810d0/
      data uppm   (16)/     -56.9732070d0/
      data betasm (16)/     -10.7616700d0/
      data betapm (16)/     -10.1084330d0/
      data zsm    (16)/       2.3129620d0/
      data zpm    (16)/       2.0091460d0/
      data zdm    (16)/       1.0000000d0/
      data alpm   (16)/       2.4780260d0/
      data eisolm (16)/    -226.0123900d0/
      data ddm    (16)/       0.9189935d0/
      data qqm    (16)/       0.8328514d0/
      data amm    (16)/       0.4733554d0/
      data adm    (16)/       0.5544502d0/
      data aqm    (16)/       0.5585244d0/
c                    data for element 17        chlorine
      data refmn  (17)/' cl: (mndo): m.j.s.dewar, h.s.rzepa, j. comp. ch
     1em., 4, 158, (1983)             '/
      data ussm   (17)/    -100.2271660d0/
      data uppm   (17)/     -77.3786670d0/
      data betasm (17)/     -14.2623200d0/
      data betapm (17)/     -14.2623200d0/
      data zsm    (17)/       3.7846450d0/
      data zpm    (17)/       2.0362630d0/
      data zdm    (17)/       1.0000000d0/
      data alpm   (17)/       2.5422010d0/
      data eisolm (17)/    -353.1176670d0/
      data ddm    (17)/       0.4986870d0/
      data qqm    (17)/       0.8217603d0/
      data amm    (17)/       0.5523705d0/
      data adm    (17)/       0.8061220d0/
      data aqm    (17)/       0.6053435d0/
*                               data for the potassium-like sparkle
      data refam   (19)/' k:  (am1):  potassium-like sparkle.   use with
     1 care.                          '/
      data refmn   (19)/' k:  (mndo): potassium-like sparkle.   use with
     1 care.                          '/
      data refpm3  (19)/' k:  (pm3):  potassium-like sparkle.   use with
     1 care.                          '/
      data vs(19)       /10.0d0/
      data alpam1(19)      / 1.405d0/
      data alpm(19)        / 1.396d0/
      data alppm3(19)      / 1.400d0/
c
      data eisola(19)      / 0.0d0/
      data eisolm(19)      / 0.0d0/
      data eisolp(19)      / 0.0d0/
c
      data amam1(19)       / 0.5d0/
      data amm(19)         / 0.5d0/
      data ampm3(19)       / 0.5d0/
c                    data for element 24  chromium
      data refmn  (24)/' cr: (mndo):  m.j.s. dewar, e.f. healy, j.j.p.
     1stewart (in preparation)        '/
      data ussm   (24)/     -17.5170270d0/
      data uppm  (24)/     -12.5337290d0/
      data uddm  (24)/     -44.1249280d0/
      data betasm (24)/      -0.1000000d0/
      data betapm (24)/      -0.1000000d0/
      data betadm (24)/      -8.7766360d0/
      data zsm    (24)/       1.5000000d0/
      data zpm    (24)/       1.5000000d0/
      data zdm    (24)/       2.8845490d0/
      data alpm   (24)/       3.0683070d0/
      data eisolm (24)/    -134.8187920d0/
      data gssm   (24)/       6.0000000d0/
      data gspm   (24)/       4.1500000d0/
      data gppm   (24)/       5.0000000d0/
      data gp2m   (24)/       3.5000000d0/
      data hspm   (24)/       1.0000000d0/
      data gsd    (24)/       2.8746410d0/
      data gpd    (24)/       3.0000000d0/
      data gdd    (24)/       8.8949670d0/
      data ddm    (24)/       1.7320508d0/
      data qqm    (24)/       1.4142136d0/
      data amm    (24)/       0.2205072d0/
      data adm    (24)/       0.2711332d0/
      data aqm    (24)/       0.4464656d0/
c                    data for element 30        zinc
      data refmn  (30)/' zn: (mndo):  m.j.s. dewar, k.m. merz, organomet
     1allics, 5, 1494-1496 (1986)     '/
c                    data for element 30
      data ussm  ( 30)/     -20.8397160d0/
      data uppm  ( 30)/     -19.6252240d0/
      data betasm( 30)/      -1.0000000d0/
      data betapm( 30)/      -2.0000000d0/
      data zsm   ( 30)/       2.0473590d0/
      data zpm   ( 30)/       1.4609460d0/
      data zdm   ( 30)/       1.0000000d0/
      data alpm  ( 30)/       1.5064570d0/
      data eisolm( 30)/     -29.8794320d0/
      data gssm  ( 30)/      11.8000000d0/
      data gspm  ( 30)/      11.1820180d0/
      data gppm  ( 30)/      13.3000000d0/
      data gp2m  ( 30)/      12.9305200d0/
      data hspm  ( 30)/       0.4846060d0/
      data ddm   ( 30)/       1.3037826d0/
      data qqm   ( 30)/       1.4520183d0/
      data amm   ( 30)/       0.4336641d0/
      data adm   ( 30)/       0.2375912d0/
      data aqm   ( 30)/       0.2738858d0/
c                    data for element 32        germanium
      data refmn  (32)/' ge: (mndo): m.j.s.dewar, g.l.grady, e.f.healy,o
     1rganometallics 6 186-189, (1987)'/
      data ussm  ( 32)/     -33.9493670d0/
      data uppm  ( 32)/     -27.4251050d0/
      data betasm( 32)/      -4.5164790d0/
      data betapm( 32)/      -1.7555170d0/
      data zsm   ( 32)/       1.2931800d0/
      data zpm   ( 32)/       2.0205640d0/
      data alpm  ( 32)/       1.9784980d0/
      data eisolm( 32)/     -76.2489440d0/
      data gssm  ( 32)/       9.8000000d0/
      data gspm  ( 32)/       8.3000000d0/
      data gppm  ( 32)/       7.3000000d0/
      data gp2m  ( 32)/       6.5000000d0/
      data hspm  ( 32)/       1.3000000d0/
      data ddm   ( 32)/       1.2556091d0/
      data qqm   ( 32)/       1.0498655d0/
      data amm   ( 32)/       0.3601617d0/
      data adm   ( 32)/       0.3643722d0/
      data aqm   ( 32)/       0.4347337d0/
c                    data for element 35        bromine
      data refmn  (35)/' br: (mndo): m.j.s.dewar, e.f. healy, j. comp. c
     1hem., 4, 542, (1983)            '/
      data ussm   (35)/     -99.9864405d0/
      data uppm   (35)/     -75.6713075d0/
      data betasm (35)/      -8.9171070d0/
      data betapm (35)/      -9.9437400d0/
      data zsm    (35)/       3.8543019d0/
      data zpm    (35)/       2.1992091d0/
      data zdm    (35)/       1.0000000d0/
      data alpm   (35)/       2.4457051d0/
      data eisolm (35)/    -346.6812500d0/
      data ddm    (35)/       0.6051074d0/
      data qqm    (35)/       0.9645873d0/
      data amm    (35)/       0.5526068d0/
      data adm    (35)/       0.7258330d0/
      data aqm    (35)/       0.5574589d0/
c                    data for element 50        tin
      data refmn  (50)/' sn: (mndo): m.j.s.dewar,g.l.grady,j.j.p.stewart
     1, j.am.chem.soc.,106 6771 (1984)'/
      data ussm  (50)/     -40.8518020d0/
      data uppm   (50)/     -28.5602490d0/
      data betasm (50)/      -3.2351470d0/
      data betapm (50)/      -4.2904160d0/
      data zsm    (50)/       2.0803800d0/
      data zpm   (50)/       1.9371060d0/
      data alpm   (50)/       1.8008140d0/
      data eisolm (50)/     -92.3241020d0/
      data gssm   (50)/       9.8000000d0/
      data gspm   (50)/       8.3000000d0/
      data gppm   (50)/       7.3000000d0/
      data gp2m   (50)/       6.5000000d0/
      data hspm   (50)/       1.3000000d0/
      data ddm    (50)/       1.5697766d0/
      data qqm    (50)/       1.3262292d0/
      data amm    (50)/       0.3601617d0/
      data adm    (50)/       0.3219998d0/
      data aqm    (50)/       0.3713827d0/
c                    data for element 53        iodine
      data refmn  (53)/'  i: (mndo): m.j.s.dewar, e.f. healy, j.j.p. ste
     1wart, j.comp.chem., 5,358,(1984)'/
      data ussm   (53)/    -100.0030538d0/
      data uppm   (53)/     -74.6114692d0/
      data betasm (53)/      -7.4144510d0/
      data betapm (53)/      -6.1967810d0/
      data zsm    (53)/       2.2729610d0/
      data zpm    (53)/       2.1694980d0/
      data zdm    (53)/       1.0000000d0/
      data alpm   (53)/       2.2073200d0/
      data eisolm (53)/    -340.5983600d0/
      data ddm    (53)/       1.4253233d0/
      data qqm    (53)/       1.1841707d0/
      data amm    (53)/       0.5527541d0/
      data adm    (53)/       0.4593451d0/
      data aqm    (53)/       0.4585376d0/
c                    data for element 80        mercury
      data refmn  (80)/' hg: (mndo): m.j.s.dewar,  et. al. organometalli
     1cs 4, 1964, (1985) see manual   '/
      data ussm   ( 80)/     -19.8095740d0/
      data uppm   ( 80)/     -13.1025300d0/
      data betasm ( 80)/      -0.4045250d0/
      data betapm ( 80)/      -6.2066830d0/
      data zsm    ( 80)/       2.2181840d0/
      data zpm    ( 80)/       2.0650380d0/
      data alpm   ( 80)/       1.3356410d0/
      data eisolm ( 80)/     -28.8191480d0/
      data gssm   ( 80)/      10.8000000d0/
      data gspm   ( 80)/       9.3000000d0/
      data gppm   ( 80)/      14.3000000d0/
      data gp2m   ( 80)/      13.5000000d0/
      data hspm   ( 80)/       1.3000000d0/
      data ddm    ( 80)/       1.7378048d0/
      data qqm    ( 80)/       1.4608064d0/
      data amm    ( 80)/       0.3969129d0/
      data adm    ( 80)/       0.3047694d0/
      data aqm    ( 80)/       0.3483102d0/
c                    data for element 82        lead
      data refmn  (82)/' pb: (mndo): m.j.s.dewar, et.al organometallics
     14 1973-1980 (1985)              '/
      data ussm   ( 82)/     -47.3196920d0/
      data uppm   ( 82)/     -28.8475600d0/
      data betasm ( 82)/      -8.0423870d0/
      data betapm ( 82)/      -3.0000000d0/
      data zsm    ( 82)/       2.4982860d0/
      data zpm    ( 82)/       2.0820710d0/
      data alpm   ( 82)/       1.7283330d0/
      data eisolm ( 82)/    -105.8345040d0/
      data gssm   ( 82)/       9.8000000d0/
      data gspm   ( 82)/       8.3000000d0/
      data gppm   ( 82)/       7.3000000d0/
      data gp2m   ( 82)/       6.5000000d0/
      data hspm   ( 82)/       1.3000000d0/
      data ddm    ( 82)/       1.5526624d0/
      data qqm    ( 82)/       1.4488558d0/
      data amm    ( 82)/       0.3601617d0/
      data adm    ( 82)/       0.3239309d0/
      data aqm    ( 82)/       0.3502057d0/
c
c     start of "old" elements: these are old parameters which
c     can be used, if desired, by specifying "<chemical symbol>year"
c     as in si1978 or  s1983.
c
c                    data for element 90        silicon
      data refmn  (90)/' si: (mndo): m.j.s.dewar, m.l.mckee, h.s.rzepa,
     1j. am. chem. soc., 100 3607 1978'/
      data ussm   (90)/     -40.5682920d0/
      data uppm   (90)/     -28.0891870d0/
      data betasm (90)/      -4.2562180d0/
      data betapm (90)/      -4.2562180d0/
      data zsm    (90)/       1.4353060d0/
      data zpm    (90)/       1.4353060d0/
      data zdm    (90)/       1.0000000d0/
      data alpm   (90)/       2.1961078d0/
      data eisolm (90)/     -90.5399580d0/
      data ddm    (90)/       1.4078712d0/
      data qqm    (90)/       1.1658281d0/
      data amm    (90)/       0.3608967d0/
      data adm    (90)/       0.3441817d0/
      data aqm    (90)/       0.3999442d0/
      data hspm(90)/1.32d00/
      data gp2m(90)/6.54d00/
      data gppm(90)/7.31d00/
      data gspm(90)/8.36d00/
      data gssm(90)/9.82d00/
      data refmn  (91)/'  s: (mndo): m.j.s.dewar, h.s. rzepa, m.l.mckee,
     1 j.am.chem.soc.100, 3607 (1978).'/
      data ussm   (91)/     -75.2391520d0/
      data uppm   (91)/     -57.8320130d0/
      data betasm (91)/     -11.1422310d0/
      data betapm (91)/     -11.1422310d0/
      data zsm    (91)/       2.6135910d0/
      data zpm    (91)/       2.0343930d0/
      data zdm    (91)/       1.0000000d0/
      data alpm   (91)/       2.4916445d0/
      data eisolm (91)/    -235.4413560d0/
      data ddm    (91)/       0.8231596d0/
      data qqm    (91)/       0.8225156d0/
      data amm    (91)/       0.4733554d0/
      data adm    (91)/       0.5889395d0/
      data aqm    (91)/       0.5632724d0/
      data refmn (102)/' cb: (mndo):  capped bond  (hydrogen-like, takes
     1 on a  zero charge.)            '/
      data ussm  (102)/     -11.9062760d0/
      data betasm(102)/-9999999.0000000d0/
      data zsm   (102)/       4.0000000d0/
      data zpm   (102)/       0.3000000d0/
      data zdm   (102)/       0.3000000d0/
      data alpm  (102)/       2.5441341d0/
      data eisolm(102)/       4.0000000d0/
      data gssm  (102)/      12.8480000d0/
      data hspm  (102)/       0.1000000d0/
      data ddm   (102)/       0.0684105d0/
      data qqm   (102)/       1.0540926d0/
      data amm   (102)/       0.4721793d0/
      data adm   (102)/       0.9262742d0/
      data aqm   (102)/       0.2909059d0/
***********************************************************************
*
*    start of am1 parameters
*
***********************************************************************
c                    data for element  1       am1:   hydrogen
      data refam  ( 1)/'  h: (am1): m.j.s. dewar et al, j. am. chem. soc
     1. 107 3902-3909 (1985)          '/
      data ussam1( 1)/     -11.3964270d0/
      data betasa( 1)/      -6.1737870d0/
      data zsam1(  1)/       1.1880780d0/
      data alpam1( 1)/       2.8823240d0/
      data eisola( 1)/     -11.3964270d0/
      data gssam1( 1)/      12.8480000d0/
      data amam1(  1)/       0.4721793d0/
      data adam1(  1)/       0.4721793d0/
      data aqam1(  1)/       0.4721793d0/
      data guesa1( 1,1)/       0.1227960d0/
      data guesa2( 1,1)/       5.0000000d0/
      data guesa3( 1,1)/       1.2000000d0/
      data guesa1( 1,2)/       0.0050900d0/
      data guesa2( 1,2)/       5.0000000d0/
      data guesa3( 1,2)/       1.8000000d0/
      data guesa1( 1,3)/      -0.0183360d0/
      data guesa2( 1,3)/       2.0000000d0/
      data guesa3( 1,3)/       2.1000000d0/
c                    data for element  3       am1:   lithium    *
      data refam  ( 3)/' li: (mndo):  taken from mndoc by w.thiel,
     1qcpe no.438, v. 2, p.63, (1982).'/
      data ussam1(  3)/      -5.1280000d0/
      data uppam1(  3)/      -2.7212000d0/
      data betasa(  3)/      -1.3500400d0/
      data betapa(  3)/      -1.3500400d0/
      data zsam1(   3)/       0.7023800d0/
      data zpam1(   3)/       0.7023800d0/
      data alpam1(  3)/       1.2501400d0/
      data eisola(  3)/      -5.1280000d0/
      data gssam1(  3)/       7.3000000d0/
      data gspam1(  3)/       5.4200000d0/
      data gppam1(  3)/       5.0000000d0/
      data gp2am1(  3)/       4.5200000d0/
      data hspam1(  3)/       0.8300000d0/
      data ddam1(   3)/       2.0549783d0/
      data qqam1(   3)/       1.7437069d0/
      data amam1(   3)/       0.2682837d0/
      data adam1(   3)/       0.2269793d0/
      data aqam1(   3)/       0.2614581d0/
c                    data for element  4       am1:   beryllium  *
      data refam  ( 4)/' be: (mndo):  m.j.s. dewar, h.s. rzepa, j. am. c
     1hem. soc., 100, 777, (1978)     '/
      data ussam1( 4)/     -16.6023780d0/
      data uppam1( 4)/     -10.7037710d0/
      data betasa( 4)/      -4.0170960d0/
      data betapa( 4)/      -4.0170960d0/
      data zsam1(  4)/       1.0042100d0/
      data zpam1(  4)/       1.0042100d0/
      data alpam1( 4)/       1.6694340d0/
      data eisola( 4)/     -24.2047560d0/
      data gssam1( 4)/       9.0000000d0/
      data gspam1( 4)/       7.4300000d0/
      data gppam1( 4)/       6.9700000d0/
      data gp2am1( 4)/       6.2200000d0/
      data hspam1( 4)/       1.2800000d0/
      data ddam1(  4)/       1.4373245d0/
      data qqam1(  4)/       1.2196103d0/
      data amam1(  4)/       0.3307607d0/
      data adam1(  4)/       0.3356142d0/
      data aqam1(  4)/       0.3846373d0/
c                    data for element  5       am1:   boron  *
      data refam  ( 5)/'  b: (am1):  m.j.s. dewar, c. jie, e. g. zoebisc
     1h organometallics 7, 513 (1988) '/
c                    data for element  5
      data ussam1(  5)/     -34.4928700d0/
      data uppam1(  5)/     -22.6315250d0/
      data betasa(  5)/      -9.5991140d0/
      data betapa(  5)/      -6.2737570d0/
      data zsam1(   5)/       1.6117090d0/
      data zpam1(   5)/       1.5553850d0/
      data alpam1(  5)/       2.4469090d0/
      data eisola(  5)/     -63.7172650d0/
      data gssam1(  5)/      10.5900000d0/
      data gspam1(  5)/       9.5600000d0/
      data gppam1(  5)/       8.8600000d0/
      data gp2am1(  5)/       7.8600000d0/
      data hspam1(  5)/       1.8100000d0/
      data ddam1(   5)/       0.9107622d0/
      data qqam1(   5)/       0.7874223d0/
      data amam1(   5)/       0.3891951d0/
      data adam1(   5)/       0.5045152d0/
      data aqam1(   5)/       0.5678856d0/
c                    data for element  6       am1:   carbon
      data refam  ( 6)/'  c: (am1): m.j.s. dewar et al, j. am. chem. soc
     1. 107 3902-3909 (1985)          '/
      data ussam1( 6)/     -52.0286580d0/
      data uppam1( 6)/     -39.6142390d0/
      data betasa( 6)/     -15.7157830d0/
      data betapa( 6)/      -7.7192830d0/
      data zsam1(  6)/       1.8086650d0/
      data zpam1(  6)/       1.6851160d0/
      data alpam1( 6)/       2.6482740d0/
      data eisola( 6)/    -120.8157940d0/
      data gssam1( 6)/      12.2300000d0/
      data gspam1( 6)/      11.4700000d0/
      data gppam1( 6)/      11.0800000d0/
      data gp2am1( 6)/       9.8400000d0/
      data hspam1( 6)/       2.4300000d0/
      data ddam1(  6)/       0.8236736d0/
      data qqam1(  6)/       0.7268015d0/
      data amam1(  6)/       0.4494671d0/
      data adam1(  6)/       0.6082946d0/
      data aqam1(  6)/       0.6423492d0/
      data guesa1( 6,1)/       0.0113550d0/
      data guesa2( 6,1)/       5.0000000d0/
      data guesa3( 6,1)/       1.6000000d0/
      data guesa1( 6,2)/       0.0459240d0/
      data guesa2( 6,2)/       5.0000000d0/
      data guesa3( 6,2)/       1.8500000d0/
      data guesa1( 6,3)/      -0.0200610d0/
      data guesa2( 6,3)/       5.0000000d0/
      data guesa3( 6,3)/       2.0500000d0/
      data guesa1( 6,4)/      -0.0012600d0/
      data guesa2( 6,4)/       5.0000000d0/
      data guesa3( 6,4)/       2.6500000d0/
c                    data for element  7       am1:   nitrogen
      data refam  ( 7)/'  n: (am1): m.j.s. dewar et al, j. am. chem. soc
     1. 107 3902-3909 (1985)          '/
      data ussam1( 7)/     -71.8600000d0/
      data uppam1( 7)/     -57.1675810d0/
      data betasa( 7)/     -20.2991100d0/
      data betapa( 7)/     -18.2386660d0/
      data zsam1(  7)/       2.3154100d0/
      data zpam1(  7)/       2.1579400d0/
      data alpam1( 7)/       2.9472860d0/
      data eisola( 7)/    -202.4077430d0/
      data gssam1( 7)/      13.5900000d0/
      data gspam1( 7)/      12.6600000d0/
      data gppam1( 7)/      12.9800000d0/
      data gp2am1( 7)/      11.5900000d0/
      data hspam1( 7)/       3.1400000d0/
      data ddam1(  7)/       0.6433247d0/
      data qqam1(  7)/       0.5675528d0/
      data amam1(  7)/       0.4994487d0/
      data adam1(  7)/       0.7820840d0/
      data aqam1(  7)/       0.7883498d0/
      data guesa1( 7,1)/       0.0252510d0/
      data guesa2( 7,1)/       5.0000000d0/
      data guesa3( 7,1)/       1.5000000d0/
      data guesa1( 7,2)/       0.0289530d0/
      data guesa2( 7,2)/       5.0000000d0/
      data guesa3( 7,2)/       2.1000000d0/
      data guesa1( 7,3)/      -0.0058060d0/
      data guesa2( 7,3)/       2.0000000d0/
      data guesa3( 7,3)/       2.4000000d0/
c                    data for element  8       am1:   oxygen
      data refam  ( 8)/'  o: (am1): m.j.s. dewar et al, j. am. chem. soc
     1. 107 3902-3909 (1985)          '/
      data ussam1( 8)/     -97.8300000d0/
      data uppam1( 8)/     -78.2623800d0/
      data betasa( 8)/     -29.2727730d0/
      data betapa( 8)/     -29.2727730d0/
      data zsam1(  8)/       3.1080320d0/
      data zpam1(  8)/       2.5240390d0/
      data alpam1( 8)/       4.4553710d0/
      data eisola( 8)/    -316.0995200d0/
      data gssam1( 8)/      15.4200000d0/
      data gspam1( 8)/      14.4800000d0/
      data gppam1( 8)/      14.5200000d0/
      data gp2am1( 8)/      12.9800000d0/
      data hspam1( 8)/       3.9400000d0/
      data ddam1(  8)/       0.4988896d0/
      data qqam1(  8)/       0.4852322d0/
      data amam1(  8)/       0.5667034d0/
      data adam1(  8)/       0.9961066d0/
      data aqam1(  8)/       0.9065223d0/
      data guesa1( 8,1)/       0.2809620d0/
      data guesa2( 8,1)/       5.0000000d0/
      data guesa3( 8,1)/       0.8479180d0/
      data guesa1( 8,2)/       0.0814300d0/
      data guesa2( 8,2)/       7.0000000d0/
      data guesa3( 8,2)/       1.4450710d0/
c                    data for element  9       am1:   fluorine  *
      data refam  ( 9)/'  f: (am1): m.j.s. dewar and e. g. zoebisch, the
     1ochem, 180, 1 (1988).           '/
      data ussam1( 9)/    -136.1055790d0/
      data uppam1( 9)/    -104.8898850d0/
      data betasa( 9)/     -69.5902770d0/
      data betapa( 9)/     -27.9223600d0/
      data zsam1(  9)/       3.7700820d0/
      data zpam1(  9)/       2.4946700d0/
      data alpam1( 9)/       5.5178000d0/
      data eisola( 9)/    -482.2905830d0/
      data gssam1( 9)/      16.9200000d0/
      data gspam1( 9)/      17.2500000d0/
      data gppam1( 9)/      16.7100000d0/
      data gp2am1( 9)/      14.9100000d0/
      data hspam1( 9)/       4.8300000d0/
      data ddam1(  9)/       0.4145203d0/
      data qqam1(  9)/       0.4909446d0/
      data amam1(  9)/       0.6218302d0/
      data adam1(  9)/       1.2088792d0/
      data aqam1(  9)/       0.9449355d0/
      data guesa1( 9,1)/       0.2420790d0/
      data guesa2( 9,1)/       4.8000000d0/
      data guesa3( 9,1)/       0.9300000d0/
      data guesa1( 9,2)/       0.0036070d0/
      data guesa2( 9,2)/       4.6000000d0/
      data guesa3( 9,2)/       1.6600000d0/
c                    data for element 13       am1:   aluminum  *
      data refam  (13)/' al: (am1):  m. j. s. dewar, a. j. holder, organ
     1ometallics, 9, 508-511 (1990).  '/
      data ussam1( 13)/     -24.3535850d0/
      data uppam1( 13)/     -18.3636450d0/
      data betasa( 13)/      -3.8668220d0/
      data betapa( 13)/      -2.3171460d0/
      data zsam1 ( 13)/       1.5165930d0/
      data zpam1 ( 13)/       1.3063470d0/
      data zdam1 ( 13)/       1.0000000d0/
      data alpam1( 13)/       1.9765860d0/
      data eisola( 13)/     -46.4208150d0/
      data gssam1( 13)/       8.0900000d0/
      data gspam1( 13)/       6.6300000d0/
      data gppam1( 13)/       5.9800000d0/
      data gp2am1( 13)/       5.4000000d0/
      data hspam1( 13)/       0.7000000d0/
      data ddam1 ( 13)/       1.4040443d0/
      data qqam1 ( 13)/       1.2809154d0/
      data amam1 ( 13)/       0.2973172d0/
      data adam1 ( 13)/       0.2630229d0/
      data aqam1 ( 13)/       0.3427832d0/
      data guesa1( 13,1)/       0.0900000d0/
      data guesa2( 13,1)/      12.3924430d0/
      data guesa3( 13,1)/       2.0503940d0/
c                    data for element 14       am1:   silicon  *
      data refam  (14)/' si: (am1): m.j.s.dewar, c. jie, organometallics
     1, 6, 1486-1490 (1987).          '/
      data ussam1(14)/     -33.9536220d0/
      data uppam1(14)/     -28.9347490d0/
      data betasa(14)/      -3.784852d0/
      data betapa(14)/      -1.968123d0/
      data zsam1( 14)/       1.830697d0/
      data zpam1( 14)/       1.2849530d0/
      data zdam1( 14)/       1.0000000d0/
      data alpam1(14)/       2.257816d0/
      data eisola(14)/     -79.0017420d0/
      data gssam1(14)/       9.8200000d0/
      data gspam1(14)/       8.3600000d0/
      data gppam1(14)/       7.3100000d0/
      data gp2am1(14)/       6.5400000d0/
      data hspam1(14)/       1.3200000d0/
      data ddam1( 14)/       1.1631107d0/
      data qqam1( 14)/       1.3022422d0/
      data amam1( 14)/       0.3608967d0/
      data adam1( 14)/       0.3829813d0/
      data aqam1( 14)/       0.3712106d0/
      data guesa1(14,1)/       0.25d0/
      data guesa2(14,1)/       9.000d0/
      data guesa3(14,1)/       0.911453d0/
      data guesa1(14,2)/       0.061513d0/
      data guesa2(14,2)/       5.00d0/
      data guesa3(14,2)/       1.995569d0/
      data guesa1(14,3)/       0.0207890d0/
      data guesa2(14,3)/       5.00d0/
      data guesa3(14,3)/       2.990610d0/
c                    data for element 15        phosphorus
      data refam  (15)/'  p: (am1): m.j.s.dewar, jie, c, theochem, 187,
     11 (1989)                        '/
      data ussam1( 15)/     -42.0298630d0/
      data uppam1( 15)/     -34.0307090d0/
      data betasa( 15)/      -6.3537640d0/
      data betapa( 15)/      -6.5907090d0/
      data zsam1(  15)/       1.9812800d0/
      data zpam1(  15)/       1.8751500d0/
      data zdam1(  15)/       1.0000000d0/
      data alpam1( 15)/       2.4553220d0/
      data eisola( 15)/    -124.4368355d0/
      data gssam1( 15)/      11.5600050d0/
      data gspam1( 15)/       5.2374490d0/
      data gppam1( 15)/       7.8775890d0/
      data gp2am1( 15)/       7.3076480d0/
      data hspam1( 15)/       0.7792380d0/
      data ddam1(  15)/       1.0452022d0/
      data qqam1(  15)/       0.8923660d0/
      data amam1(  15)/       0.4248440d0/
      data adam1(  15)/       0.3275319d0/
      data aqam1(  15)/       0.4386854d0/
      data guesa1( 15,1)/      -0.0318270d0/
      data guesa2( 15,1)/       6.0000000d0/
      data guesa3( 15,1)/       1.4743230d0/
      data guesa1( 15,2)/       0.0184700d0/
      data guesa2( 15,2)/       7.0000000d0/
      data guesa3( 15,2)/       1.7793540d0/
      data guesa1( 15,3)/       0.0332900d0/
      data guesa2( 15,3)/       9.0000000d0/
      data guesa3( 15,3)/       3.0065760d0/
c
c   alternative set of phosphorus parameters.  to use these, use
c   keyword `p1994'.
c
      data refmn  (89)/'  p: (am1): j. j. p. stewart
     1                                '/
      data ussam1( 89)/     -38.7231455d0/
      data uppam1( 89)/     -30.1613047d0/
      data betasa( 89)/      -9.2236117d0/
      data betapa( 89)/      -4.3528337d0/
      data zsam1 ( 89)/       2.2301010d0/
      data zpam1 ( 89)/       1.5994849d0/
      data zdam1 ( 89)/       1.0000000d0/
      data alpam1( 89)/       2.6586560d0/
      data eisola( 89)/    -112.4368928d0/
      data gssam1( 89)/       7.9592273d0/
      data gspam1( 89)/       6.9074760d0/
      data gppam1( 89)/       6.0021281d0/
      data gp2am1( 89)/       5.9615933d0/
      data hspam1( 89)/       3.9115829d0/
      data ddam1 ( 89)/       0.9585157d0/
      data qqam1 ( 89)/       1.0461618d0/
      data amam1 ( 89)/       0.2925111d0/
      data adam1 ( 89)/       0.7073332d0/
      data aqam1 ( 89)/       0.2925300d0/
      data guesa1( 89,1)/       0.0689254d0/
      data guesa2( 89,1)/       6.0132141d0/
      data guesa3( 89,1)/       1.4483359d0/
      data guesa1( 89,2)/       0.0355545d0/
      data guesa2( 89,2)/       6.0153980d0/
      data guesa3( 89,2)/       1.9669719d0/
      data guesa1( 89,3)/       0.0080668d0/
      data guesa2( 89,3)/       6.0136825d0/
      data guesa3( 89,3)/       2.4975390d0/
c                    data for element 16       am1:   sulfur  *
c
      data refam  (16)/'  s: (am1): m.j.s.dewar, y-c yuan, theochem, in
     1 press                          '/
      data ussam1(16)/     -56.6940560d0/
      data uppam1(16)/     -48.7170490d0/
      data betasa(16)/      -3.9205660d0/
      data betapa(16)/      -7.9052780d0/
      data zsam1( 16)/       2.3665150d0/
      data zpam1( 16)/       1.6672630d0/
      data zdam1( 16)/       1.0000000d0/
      data alpam1(16)/       2.4616480d0/
      data eisola(16)/    -191.7321930d0/
      data gssam1(16)/      11.7863290d0/
      data gspam1(16)/       8.6631270d0/
      data gppam1(16)/      10.0393080d0/
      data gp2am1(16)/       7.7816880d0/
      data hspam1(16)/       2.5321370d0/
      data ddam1( 16)/       0.9004265d0/
      data qqam1( 16)/       1.0036329d0/
      data amam1( 16)/       0.4331617d0/
      data adam1( 16)/       0.5907115d0/
      data aqam1( 16)/       0.6454943d0/
      data guesa1(16,1)/      -0.5091950d0/
      data guesa2(16,1)/       4.5936910d0/
      data guesa3(16,1)/       0.7706650d0/
      data guesa1(16,2)/      -0.0118630d0/
      data guesa2(16,2)/       5.8657310d0/
      data guesa3(16,2)/       1.5033130d0/
      data guesa1(16,3)/       0.0123340d0/
      data guesa2(16,3)/      13.5573360d0/
      data guesa3(16,3)/       2.0091730d0/
c                    data for element 17       am1:   chlorine  *
      data refam  (17)/' cl: (am1): m.j.s. dewar and e. g. zoebisch, the
     1ochem, 180, 1 (1988).           '/
      data ussam1(17)/    -111.6139480d0/
      data uppam1(17)/     -76.6401070d0/
      data betasa(17)/     -24.5946700d0/
      data betapa(17)/     -14.6372160d0/
      data zsam1( 17)/       3.6313760d0/
      data zpam1( 17)/       2.0767990d0/
      data zdam1( 17)/       1.0000000d0/
      data alpam1(17)/       2.9193680d0/
      data eisola(17)/    -372.1984310d0/
      data gssam1(17)/      15.0300000d0/
      data gspam1(17)/      13.1600000d0/
      data gppam1(17)/      11.3000000d0/
      data gp2am1(17)/       9.9700000d0/
      data hspam1(17)/       2.4200000d0/
      data ddam1( 17)/       0.5406286d0/
      data qqam1( 17)/       0.8057208d0/
      data amam1( 17)/       0.5523705d0/
      data adam1( 17)/       0.7693200d0/
      data aqam1( 17)/       0.6133369d0/
      data guesa1(17,1)/       0.0942430d0/
      data guesa2(17,1)/       4.0000000d0/
      data guesa3(17,1)/       1.3000000d0/
      data guesa1(17,2)/       0.0271680d0/
      data guesa2(17,2)/       4.0000000d0/
      data guesa3(17,2)/       2.1000000d0/
c                    data for element 30        zinc
      data refam  (30)/' zn: (am1):  m.j.s. dewar, k.m. merz, organomet
     1allics, 7, 522-524 (1988)       '/
      data ussam1( 30)/     -21.0400080d0/
      data uppam1( 30)/     -17.6555740d0/
      data betasa( 30)/      -1.9974290d0/
      data betapa( 30)/      -4.7581190d0/
      data zsam1(  30)/       1.9542990d0/
      data zpam1(  30)/       1.3723650d0/
      data zdam1(  30)/       1.0000000d0/
      data alpam1( 30)/       1.4845630d0/
      data eisola( 30)/     -30.2800160d0/
      data gssam1( 30)/      11.8000000d0/
      data gspam1( 30)/      11.1820180d0/
      data gppam1( 30)/      13.3000000d0/
      data gp2am1( 30)/      12.9305200d0/
      data hspam1( 30)/       0.4846060d0/
      data ddam1(  30)/       1.3581113d0/
      data qqam1(  30)/       1.5457406d0/
      data amam1(  30)/       0.4336641d0/
      data adam1(  30)/       0.2317423d0/
      data aqam1(  30)/       0.2621165d0/
c                    data for element 32        germanium
      data refam  (32)/' ge: (am1): m.j.s.dewar and c.jie, organometalli
     1cs, 8, 1544, (1989)             '/
      data ussam1( 32)/     -34.1838890d0/
      data uppam1( 32)/     -28.6408110d0/
      data betasa( 32)/      -4.3566070d0/
      data betapa( 32)/      -0.9910910d0/
      data zsam1(  32)/       1.2196310d0/
      data zpam1(  32)/       1.9827940d0/
      data alpam1( 32)/       2.1364050d0/
      data eisola( 32)/     -78.7084810d0/
      data gssam1( 32)/      10.1686050d0/
      data gspam1( 32)/       8.1444730d0/
      data gppam1( 32)/       6.6719020d0/
      data gp2am1( 32)/       6.2697060d0/
      data hspam1( 32)/       0.9370930d0/
      data ddam1(  32)/       1.2472095d0/
      data qqam1(  32)/       1.0698642d0/
      data amam1(  32)/       0.3737084d0/
      data adam1(  32)/       0.3180309d0/
      data aqam1(  32)/       0.3485612d0/
c                    data for element 33      arsenic
      data refam (33)/ ' as: (am1): j. j. p. stewart
     1                                '/
      data ussam1( 33)/     -41.6817510d0/
      data uppam1( 33)/     -33.4506152d0/
      data betasa( 33)/      -5.6481504d0/
      data betapa( 33)/      -4.9979109d0/
      data zsam1 ( 33)/       2.2576897d0/
      data zpam1 ( 33)/       1.7249710d0/
      data alpam1( 33)/       2.2405380d0/
      data eisola( 33)/    -122.5721346d0/
      data gssam1( 33)/      11.0962258d0/
      data gspam1( 33)/       4.9259328d0/
      data gppam1( 33)/       7.8781648d0/
      data gp2am1( 33)/       7.5961088d0/
      data hspam1( 33)/       0.6246173d0/
      data ddam1 ( 33)/       1.2028902d0/
      data qqam1 ( 33)/       1.2297716d0/
      data amam1 ( 33)/       0.4077996d0/
      data adam1 ( 33)/       0.2756200d0/
      data aqam1 ( 33)/       0.2853049d0/
      data guesa1( 33,1)/      -0.0073614d0/
      data guesa2( 33,1)/       4.9433993d0/
      data guesa3( 33,1)/       1.4544264d0/
      data guesa1( 33,2)/       0.0437629d0/
      data guesa2( 33,2)/       3.1944613d0/
      data guesa3( 33,2)/       2.0144939d0/
c                    data for element 34        selenium
      data refam (34)/ ' se: (am1): j. j. p. stewart
     1                                '/
      data ussam1( 34)/     -41.9984056d0/
      data uppam1( 34)/     -32.8575485d0/
      data betasa( 34)/      -3.1470826d0/
      data betapa( 34)/      -6.1468406d0/
      data zsam1 ( 34)/       2.6841570d0/
      data zpam1 ( 34)/       2.0506164d0/
      data alpam1( 34)/       2.6375694d0/
      data eisola( 34)/    -143.5256480d0/
      data gssam1( 34)/       6.7908891d0/
      data gspam1( 34)/       6.4812786d0/
      data gppam1( 34)/       6.4769273d0/
      data gp2am1( 34)/       5.2796993d0/
      data hspam1( 34)/       4.4548356d0/
      data ddam1 ( 34)/       1.0117551d0/
      data qqam1 ( 34)/       1.0344794d0/
      data amam1 ( 34)/       0.2495733d0/
      data adam1 ( 34)/       0.7380836d0/
      data aqam1 ( 34)/       0.5017066d0/
      data guesa1( 34,1)/       0.1116681d0/
      data guesa2( 34,1)/       6.5086644d0/
      data guesa3( 34,1)/       1.4981077d0/
      data guesa1( 34,2)/       0.0396143d0/
      data guesa2( 34,2)/       6.5241228d0/
      data guesa3( 34,2)/       2.0751916d0/
c                    data for element 35       am1:   bromine  *
      data refam  (35)/' br: (am1): m.j.s. dewar and e. g. zoebisch, the
     1ochem, 180, 1 (1988).           '/
      data ussam1(35)/    -104.6560630d0/
      data uppam1(35)/     -74.9300520d0/
      data betasa(35)/     -19.3998800d0/
      data betapa(35)/      -8.9571950d0/
      data zsam1( 35)/       3.0641330d0/
      data zpam1( 35)/       2.0383330d0/
      data zdam1( 35)/       1.0000000d0/
      data alpam1(35)/       2.5765460d0/
      data eisola(35)/    -352.3142087d0/
      data gssam1(35)/      15.0364395d0/
      data gspam1(35)/      13.0346824d0/
      data gppam1(35)/      11.2763254d0/
      data gp2am1(35)/       9.8544255d0/
      data hspam1(35)/       2.4558683d0/
      data ddam1( 35)/       0.8458104d0/
      data qqam1( 35)/       1.0407133d0/
      data amam1( 35)/       0.5526071d0/
      data adam1( 35)/       0.6024598d0/
      data aqam1( 35)/       0.5307555d0/
      data guesa1(35,1)/       0.0666850d0/
      data guesa2(35,1)/       4.0000000d0/
      data guesa3(35,1)/       1.5000000d0/
      data guesa1(35,2)/       0.0255680d0/
      data guesa2(35,2)/       4.0000000d0/
      data guesa3(35,2)/       2.3000000d0/
c                    data for element 51        antimony
      data refam (51)/ ' sb: (am1): j. j. p. stewart
     1                                '/
      data ussam1( 51)/     -44.4381620d0/
      data uppam1( 51)/     -32.3895140d0/
      data betasa( 51)/      -7.3823300d0/
      data betapa( 51)/      -3.6331190d0/
      data zsam1 ( 51)/       2.2548230d0/
      data zpam1 ( 51)/       2.2185920d0/
      data alpam1( 51)/       2.2763310d0/
      data eisola( 51)/    -120.4669295d0/
      data gssam1( 51)/      11.4302510d0/
      data gspam1( 51)/       5.7879220d0/
      data gppam1( 51)/       6.4240940d0/
      data gp2am1( 51)/       6.8491810d0/
      data hspam1( 51)/       0.5883400d0/
      data ddam1 ( 51)/       1.4191757d0/
      data qqam1 ( 51)/       1.1579626d0/
      data amam1 ( 51)/       0.4200754d0/
      data adam1 ( 51)/       0.2436302d0/
      data aqam1 ( 51)/       0.2714705d0/
      data guesa1( 51,1)/      -0.5964470d0/
      data guesa2( 51,1)/       6.0279500d0/
      data guesa3( 51,1)/       1.7103670d0/
      data guesa1( 51,2)/       0.8955130d0/
      data guesa2( 51,2)/       3.0281090d0/
      data guesa3( 51,2)/       1.5383180d0/
c                    data for element 52        tellurium
      data refam (52)/ ' te: (am1): j. j. p. stewart
     1                                '/
c                    data for element 52
      data ussam1( 52)/     -39.2454230d0/
      data uppam1( 52)/     -30.8515845d0/
      data betasa( 52)/      -8.3897294d0/
      data betapa( 52)/      -5.1065429d0/
      data zsam1 ( 52)/       2.1321165d0/
      data zpam1 ( 52)/       1.9712680d0/
      data alpam1( 52)/       6.0171167d0/
      data eisola( 52)/    -140.2236064d0/
      data gssam1( 52)/       4.9925231d0/
      data gspam1( 52)/       4.9721484d0/
      data gppam1( 52)/       7.2097852d0/
      data gp2am1( 52)/       5.6211521d0/
      data hspam1( 52)/       4.0071821d0/
      data ddam1 ( 52)/       1.5346762d0/
      data qqam1 ( 52)/       1.3032457d0/
      data amam1 ( 52)/       0.1834812d0/
      data adam1 ( 52)/       0.5784039d0/
      data aqam1 ( 52)/       0.4799578d0/
      data guesa1( 52,1)/       0.4873378d0/
      data guesa2( 52,1)/       6.0519413d0/
      data guesa3( 52,1)/       1.3079857d0/
      data guesa1( 52,2)/       0.1520464d0/
      data guesa2( 52,2)/       3.8304067d0/
      data guesa3( 52,2)/       2.0899707d0/
c                    data for element 53       am1:   iodine  *
      data refam  (53)/'  i: (am1): m.j.s. dewar and e. g. zoebisch, the
     1ochem, 180, 1 (1988).           '/
      data ussam1(53)/    -103.5896630d0/
      data uppam1(53)/     -74.4299970d0/
      data betasa(53)/      -8.4433270d0/
      data betapa(53)/      -6.3234050d0/
      data zsam1( 53)/       2.1028580d0/
      data zpam1( 53)/       2.1611530d0/
      data zdam1( 53)/       1.0000000d0/
      data alpam1(53)/       2.2994240d0/
      data eisola(53)/    -346.8642857d0/
      data gssam1(53)/      15.0404486d0/
      data gspam1(53)/      13.0565580d0/
      data gppam1(53)/      11.1477837d0/
      data gp2am1(53)/       9.9140907d0/
      data hspam1(53)/       2.4563820d0/
      data ddam1( 53)/       1.4878778d0/
      data qqam1( 53)/       1.1887388d0/
      data amam1( 53)/       0.5527544d0/
      data adam1( 53)/       0.4497523d0/
      data aqam1( 53)/       0.4631775d0/
      data guesa1(53,1)/       0.0043610d0/
      data guesa2(53,1)/       2.3000000d0/
      data guesa3(53,1)/       1.8000000d0/
      data guesa1(53,2)/       0.0157060d0/
      data guesa2(53,2)/       3.0000000d0/
      data guesa3(53,2)/       2.2400000d0/
c                    data for element 80        mercury
      data refam  (80)/' hg: (am1): m.j.s.dewar and c.jie, organometalli
     1cs 8, 1547, (1989)              '/
      data ussam1( 80)/     -19.9415780d0/
      data uppam1( 80)/     -11.1108700d0/
      data betasa( 80)/      -0.9086570d0/
      data betapa( 80)/      -4.9093840d0/
      data zsam1(  80)/       2.0364130d0/
      data zpam1(  80)/       1.9557660d0/
      data alpam1( 80)/       1.4847340d0/
      data eisola( 80)/     -29.0831560d0/
      data gssam1( 80)/      10.8000000d0/
      data gspam1( 80)/       9.3000000d0/
      data gppam1( 80)/      14.3000000d0/
      data gp2am1( 80)/      13.5000000d0/
      data hspam1( 80)/       1.3000000d0/
      data ddam1(  80)/       1.8750829d0/
      data qqam1(  80)/       1.5424241d0/
      data amam1(  80)/       0.3969129d0/
      data adam1(  80)/       0.2926605d0/
      data aqam1(  80)/       0.3360599d0/
c
c     start of "old" elements: these are old parameters which
c     can be used, if desired, by specifying "<chemical symbol>year"
c     as in si1978 or  s1983.
c
c                    data for element 90        silicon
      data refam  (90)/' si: (mndo): m.j.s.dewar, m.l.mckee, h.s.rzepa,
     1j. am. chem. soc., 100 3607 1978'/
      data ussam1 (90)/     -40.5682920d0/
      data uppam1 (90)/     -28.0891870d0/
      data betasa (90)/      -4.2562180d0/
      data betapa (90)/      -4.2562180d0/
      data zsam1  (90)/       1.4353060d0/
      data zpam1  (90)/       1.4353060d0/
      data zdam1  (90)/       1.0000000d0/
      data alpam1  (90)/       2.1961078d0/
      data eisola (90)/     -90.5399580d0/
      data ddam1  (90)/       1.4078712d0/
      data qqam1  (90)/       1.1658281d0/
      data amam1  (90)/       0.3608967d0/
      data adam1  (90)/       0.3441817d0/
      data aqam1  (90)/       0.3999442d0/
      data hspam1 (90)/1.32d00/
      data gp2am1 (90)/6.54d00/
      data gppam1 (90)/7.31d00/
      data gspam1 (90)/8.36d00/
      data gssam1 (90)/9.82d00/
      data refam  (91)/'  s: (mndo): m.j.s.dewar, h.s. rzepa, m.l.mckee,
     1 j.am.chem.soc.100, 3607 (1978).'/
      data ussam1 (91)/     -75.2391520d0/
      data uppam1 (91)/     -57.8320130d0/
      data betasa (91)/     -11.1422310d0/
      data betapa (91)/     -11.1422310d0/
      data zsam1  (91)/       2.6135910d0/
      data zpam1  (91)/       2.0343930d0/
      data zdam1  (91)/       1.0000000d0/
      data alpam1 (91)/       2.4916445d0/
      data eisola (91)/    -235.4413560d0/
      data gssam1 (91)/      12.8800000d0/
      data gspam1 (91)/      11.2600000d0/
      data gppam1 (91)/       9.9000000d0/
      data gp2am1 (91)/       8.8300000d0/
      data hspam1 (91)/       2.2600000d0/
      data ddam1  (91)/       0.8231596d0/
      data qqam1  (91)/       0.8225156d0/
      data amam1  (91)/       0.4733554d0/
      data adam1  (91)/       0.5889395d0/
      data aqam1  (91)/       0.5632724d0/
      data refam (102)/' cb: (am1):  capped bond  (hydrogen-like, takes
     1 on zero charge.)               '/
c                    data for element102
      data ussam1 (102)/     -11.9062760d0/
      data betasa (102)/-9999999.0000000d0/
      data zsam1  (102)/       4.0000000d0/
      data zpam1  (102)/       0.3000000d0/
      data zdam1  (102)/       0.3000000d0/
      data alpam1 (102)/       2.5441341d0/
      data eisola (102)/       4.0000000d0/
      data gssam1 (102)/      12.8480000d0/
      data hspam1 (102)/       0.1000000d0/
      data ddam1  (102)/       0.0684105d0/
      data qqam1  (102)/       1.0540926d0/
      data amam1  (102)/       0.4721793d0/
      data adam1  (102)/       0.9262742d0/
      data aqam1  (102)/       0.2909059d0/
c
c     start of mndo-pm3 parameter set
c
c                    data for element  1        hydrogen
      data refpm3 ( 1)/'  h: (pm3): j. j. p. stewart, j. comp. chem.
     1 10, 209 (1989).                '/
      data usspm3(  1)/     -13.0733210d0/
      data betasp(  1)/      -5.6265120d0/
      data zspm3 (  1)/       0.9678070d0/
      data alppm3(  1)/       3.3563860d0/
      data eisolp(  1)/     -13.0733210d0/
      data gsspm3(  1)/      14.7942080d0/
      data ampm3 (  1)/       0.5437048d0/
      data adpm3 (  1)/       0.5437048d0/
      data aqpm3 (  1)/       0.5437048d0/
      data guesp1(  1,1)/       1.1287500d0/
      data guesp2(  1,1)/       5.0962820d0/
      data guesp3(  1,1)/       1.5374650d0/
      data guesp1(  1,2)/      -1.0603290d0/
      data guesp2(  1,2)/       6.0037880d0/
      data guesp3(  1,2)/       1.5701890d0/
c                    data for element  3        lithium
      data refpm3( 3)/ ' li: (pm3): e. anders, r. koch, p. freunscht,
     1 j. comp. chem 14 1301-1312 1993'/
      data usspm3(  3)/      -5.3000000d0/
      data upppm3(  3)/      -3.4000000d0/
      data betasp(  3)/      -0.5500000d0/
      data betapp(  3)/      -1.5000000d0/
      data zspm3 (  3)/       0.6500000d0/
      data zppm3 (  3)/       0.7500000d0/
      data alppm3(  3)/       1.2550000d0/
      data eisolp(  3)/      -5.3000000d0/
      data gsspm3(  3)/       4.5000000d0/
      data gsppm3(  3)/       3.0000000d0/
      data gpppm3(  3)/       5.2500000d0/
      data gp2pm3(  3)/       4.5000000d0/
      data hsppm3(  3)/       0.1500000d0/
      data ddpm3 (  3)/       2.0357652d0/
      data qqpm3 (  3)/       1.6329932d0/
      data ampm3 (  3)/       0.1653804d0/
      data adpm3 (  3)/       0.1156738d0/
      data aqpm3 (  3)/       0.3166080d0/
      data guesp1(  3,1)/      -0.4500000d0/
      data guesp2(  3,1)/       5.0000000d0/
      data guesp3(  3,1)/       1.0000000d0/
      data guesp1(  3,2)/       0.8000000d0/
      data guesp2(  3,2)/       6.5000000d0/
      data guesp3(  3,2)/       1.0000000d0/
c                    data for element  4        beryllium
      data refpm3( 4)/ ' be: (pm3): j. j. p. stewart, j. comp. chem.
     1(accepted)                      '/
      data usspm3(  4)/     -17.2647520d0/
      data upppm3(  4)/     -11.3042430d0/
      data betasp(  4)/      -3.9620530d0/
      data betapp(  4)/      -2.7806840d0/
      data zspm3 (  4)/       0.8774390d0/
      data zppm3 (  4)/       1.5087550d0/
      data alppm3(  4)/       1.5935360d0/
      data eisolp(  4)/     -25.5166530d0/
      data gsspm3(  4)/       9.0128510d0/
      data gsppm3(  4)/       6.5761990d0/
      data gpppm3(  4)/       6.0571820d0/
      data gp2pm3(  4)/       9.0052190d0/
      data hsppm3(  4)/       0.5446790d0/
      data ddpm3 (  4)/       1.0090531d0/
      data qqpm3 (  4)/       0.8117586d0/
      data ampm3 (  4)/       0.3312330d0/
      data adpm3 (  4)/       0.2908996d0/
      data aqpm3 (  4)/       0.3530008d0/
      data guesp1(  4,1)/       1.6315720d0/
      data guesp2(  4,1)/       2.6729620d0/
      data guesp3(  4,1)/       1.7916860d0/
      data guesp1(  4,2)/      -2.1109590d0/
      data guesp2(  4,2)/       1.9685940d0/
      data guesp3(  4,2)/       1.7558710d0/
c                    data for element  6        carbon
      data refpm3 ( 6)/'  c: (pm3): j. j. p. stewart, j. comp. chem.
     1 10, 209 (1989).                '/
      data usspm3(  6)/     -47.2703200d0/
      data upppm3(  6)/     -36.2669180d0/
      data betasp(  6)/     -11.9100150d0/
      data betapp(  6)/      -9.8027550d0/
      data zspm3 (  6)/       1.5650850d0/
      data zppm3 (  6)/       1.8423450d0/
      data alppm3(  6)/       2.7078070d0/
      data eisolp(  6)/    -111.2299170d0/
      data gsspm3(  6)/      11.2007080d0/
      data gsppm3(  6)/      10.2650270d0/
      data gpppm3(  6)/      10.7962920d0/
      data gp2pm3(  6)/       9.0425660d0/
      data hsppm3(  6)/       2.2909800d0/
      data ddpm3 (  6)/       0.8332396d0/
      data qqpm3 (  6)/       0.6647750d0/
      data ampm3 (  6)/       0.4116394d0/
      data adpm3 (  6)/       0.5885862d0/
      data aqpm3 (  6)/       0.7647667d0/
      data guesp1(  6,1)/       0.0501070d0/
      data guesp2(  6,1)/       6.0031650d0/
      data guesp3(  6,1)/       1.6422140d0/
      data guesp1(  6,2)/       0.0507330d0/
      data guesp2(  6,2)/       6.0029790d0/
      data guesp3(  6,2)/       0.8924880d0/
c                    data for element  7        nitrogen
      data refpm3 ( 7)/'  n: (pm3): j. j. p. stewart, j. comp. chem.
     1 10, 209 (1989).                '/
      data usspm3(  7)/     -49.3356720d0/
      data upppm3(  7)/     -47.5097360d0/
      data betasp(  7)/     -14.0625210d0/
      data betapp(  7)/     -20.0438480d0/
      data zspm3 (  7)/       2.0280940d0/
      data zppm3 (  7)/       2.3137280d0/
      data alppm3(  7)/       2.8305450d0/
      data eisolp(  7)/    -157.6137755d0/
      data gsspm3(  7)/      11.9047870d0/
      data gsppm3(  7)/       7.3485650d0/
      data gpppm3(  7)/      11.7546720d0/
      data gp2pm3(  7)/      10.8072770d0/
      data hsppm3(  7)/       1.1367130d0/
      data ddpm3 (  7)/       0.6577006d0/
      data qqpm3 (  7)/       0.5293383d0/
      data ampm3 (  7)/       0.4375151d0/
      data adpm3 (  7)/       0.5030995d0/
      data aqpm3 (  7)/       0.7364933d0/
      data guesp1(  7,1)/       1.5016740d0/
      data guesp2(  7,1)/       5.9011480d0/
      data guesp3(  7,1)/       1.7107400d0/
      data guesp1(  7,2)/      -1.5057720d0/
      data guesp2(  7,2)/       6.0046580d0/
      data guesp3(  7,2)/       1.7161490d0/
c                    data for element  8        oxygen
      data refpm3 ( 8)/'  o: (pm3): j. j. p. stewart, j. comp. chem.
     1 10, 209 (1989).                '/
      data usspm3(  8)/     -86.9930020d0/
      data upppm3(  8)/     -71.8795800d0/
      data betasp(  8)/     -45.2026510d0/
      data betapp(  8)/     -24.7525150d0/
      data zspm3 (  8)/       3.7965440d0/
      data zppm3 (  8)/       2.3894020d0/
      data alppm3(  8)/       3.2171020d0/
      data eisolp(  8)/    -289.3422065d0/
      data gsspm3(  8)/      15.7557600d0/
      data gsppm3(  8)/      10.6211600d0/
      data gpppm3(  8)/      13.6540160d0/
      data gp2pm3(  8)/      12.4060950d0/
      data hsppm3(  8)/       0.5938830d0/
      data ddpm3 (  8)/       0.4086173d0/
      data qqpm3 (  8)/       0.5125738d0/
      data ampm3 (  8)/       0.5790430d0/
      data adpm3 (  8)/       0.5299630d0/
      data aqpm3 (  8)/       0.8179630d0/
      data guesp1(  8,1)/      -1.1311280d0/
      data guesp2(  8,1)/       6.0024770d0/
      data guesp3(  8,1)/       1.6073110d0/
      data guesp1(  8,2)/       1.1378910d0/
      data guesp2(  8,2)/       5.9505120d0/
      data guesp3(  8,2)/       1.5983950d0/
c                    data for element  9        fluorine
      data refpm3 ( 9)/'  f: (pm3): j. j. p. stewart, j. comp. chem.
     1 10, 209 (1989).                '/
      data usspm3(  9)/    -110.4353030d0/
      data upppm3(  9)/    -105.6850470d0/
      data betasp(  9)/     -48.4059390d0/
      data betapp(  9)/     -27.7446600d0/
      data zspm3 (  9)/       4.7085550d0/
      data zppm3 (  9)/       2.4911780d0/
      data alppm3(  9)/       3.3589210d0/
      data eisolp(  9)/    -437.5171690d0/
      data gsspm3(  9)/      10.4966670d0/
      data gsppm3(  9)/      16.0736890d0/
      data gpppm3(  9)/      14.8172560d0/
      data gp2pm3(  9)/      14.4183930d0/
      data hsppm3(  9)/       0.7277630d0/
      data ddpm3 (  9)/       0.3125302d0/
      data qqpm3 (  9)/       0.4916328d0/
      data ampm3 (  9)/       0.3857650d0/
      data adpm3 (  9)/       0.6768503d0/
      data aqpm3 (  9)/       0.6120047d0/
      data guesp1(  9,1)/      -0.0121660d0/
      data guesp2(  9,1)/       6.0235740d0/
      data guesp3(  9,1)/       1.8568590d0/
      data guesp1(  9,2)/      -0.0028520d0/
      data guesp2(  9,2)/       6.0037170d0/
      data guesp3(  9,2)/       2.6361580d0/
c                    data for element 12        magnesium
      data refpm3(12)/ ' mg: (pm3): j. j. p. stewart, j. comp. chem.
     1(accepted)                      '/
      data usspm3( 12)/     -14.6236880d0/
      data upppm3( 12)/     -14.1734600d0/
      data betasp( 12)/      -2.0716910d0/
      data betapp( 12)/      -0.5695810d0/
      data zspm3 ( 12)/       0.6985520d0/
      data zppm3 ( 12)/       1.4834530d0/
      data alppm3( 12)/       1.3291470d0/
      data eisolp( 12)/     -22.5530760d0/
      data gsspm3( 12)/       6.6943000d0/
      data gsppm3( 12)/       6.7939950d0/
      data gpppm3( 12)/       6.9104460d0/
      data gp2pm3( 12)/       7.0908230d0/
      data hsppm3( 12)/       0.5433000d0/
      data ddpm3 ( 12)/       1.1403950d0/
      data qqpm3 ( 12)/       1.1279899d0/
      data ampm3 ( 12)/       0.2460235d0/
      data adpm3 ( 12)/       0.2695751d0/
      data aqpm3 ( 12)/       0.2767522d0/
      data guesp1( 12,1)/       2.1170500d0/
      data guesp2( 12,1)/       6.0094770d0/
      data guesp3( 12,1)/       2.0844060d0/
      data guesp1( 12,2)/      -2.5477670d0/
      data guesp2( 12,2)/       4.3953700d0/
      data guesp3( 12,2)/       2.0636740d0/
c                    data for element 13        aluminum
      data refpm3 (13)/' al: (pm3): j. j. p. stewart, j. comp. chem.
     1 10, 209 (1989).                '/
      data usspm3( 13)/     -24.8454040d0/
      data upppm3( 13)/     -22.2641590d0/
      data betasp( 13)/      -0.5943010d0/
      data betapp( 13)/      -0.9565500d0/
      data zspm3 ( 13)/       1.7028880d0/
      data zppm3 ( 13)/       1.0736290d0/
      data zdpm3 ( 13)/       1.0000000d0/
      data alppm3( 13)/       1.5217030d0/
      data eisolp( 13)/     -46.8647630d0/
      data gsspm3( 13)/       5.7767370d0/
      data gsppm3( 13)/      11.6598560d0/
      data gpppm3( 13)/       6.3477900d0/
      data gp2pm3( 13)/       6.1210770d0/
      data hsppm3( 13)/       4.0062450d0/
      data ddpm3 ( 13)/       1.2102799d0/
      data qqpm3 ( 13)/       1.5585645d0/
      data ampm3 ( 13)/       0.2123020d0/
      data adpm3 ( 13)/       0.6418584d0/
      data aqpm3 ( 13)/       0.2262838d0/
      data guesp1( 13,1)/      -0.4730900d0/
      data guesp2( 13,1)/       1.9158250d0/
      data guesp3( 13,1)/       1.4517280d0/
      data guesp1( 13,2)/      -0.1540510d0/
      data guesp2( 13,2)/       6.0050860d0/
      data guesp3( 13,2)/       2.5199970d0/
c                    data for element 14        silicon
      data refpm3 (14)/' si: (pm3): j. j. p. stewart, j. comp. chem.
     1 10, 209 (1989).                '/
      data usspm3( 14)/     -26.7634830d0/
      data upppm3( 14)/     -22.8136350d0/
      data betasp( 14)/      -2.8621450d0/
      data betapp( 14)/      -3.9331480d0/
      data zspm3 ( 14)/       1.6350750d0/
      data zppm3 ( 14)/       1.3130880d0/
      data zdpm3 ( 14)/       1.0000000d0/
      data alppm3( 14)/       2.1358090d0/
      data eisolp( 14)/     -67.7882140d0/
      data gsspm3( 14)/       5.0471960d0/
      data gsppm3( 14)/       5.9490570d0/
      data gpppm3( 14)/       6.7593670d0/
      data gp2pm3( 14)/       5.1612970d0/
      data hsppm3( 14)/       0.9198320d0/
      data ddpm3 ( 14)/       1.3144550d0/
      data qqpm3 ( 14)/       1.2743396d0/
      data ampm3 ( 14)/       0.1854905d0/
      data adpm3 ( 14)/       0.3060715d0/
      data aqpm3 ( 14)/       0.4877432d0/
      data guesp1( 14,1)/      -0.3906000d0/
      data guesp2( 14,1)/       6.0000540d0/
      data guesp3( 14,1)/       0.6322620d0/
      data guesp1( 14,2)/       0.0572590d0/
      data guesp2( 14,2)/       6.0071830d0/
      data guesp3( 14,2)/       2.0199870d0/
c                    data for element 15        phosphorus
      data refpm3 (15)/'  p: (pm3): j. j. p. stewart, j. comp. chem.
     1 10, 209 (1989).                '/
      data usspm3( 15)/     -40.4130960d0/
      data upppm3( 15)/     -29.5930520d0/
      data betasp( 15)/     -12.6158790d0/
      data betapp( 15)/      -4.1600400d0/
      data zspm3 ( 15)/       2.0175630d0/
      data zppm3 ( 15)/       1.5047320d0/
      data zdpm3 ( 15)/       1.0000000d0/
      data alppm3( 15)/       1.9405340d0/
      data eisolp( 15)/    -117.9591740d0/
      data gsspm3( 15)/       7.8016150d0/
      data gsppm3( 15)/       5.1869490d0/
      data gpppm3( 15)/       6.6184780d0/
      data gp2pm3( 15)/       6.0620020d0/
      data hsppm3( 15)/       1.5428090d0/
      data ddpm3 ( 15)/       1.0644947d0/
      data qqpm3 ( 15)/       1.1120386d0/
      data ampm3 ( 15)/       0.2867187d0/
      data adpm3 ( 15)/       0.4309446d0/
      data aqpm3 ( 15)/       0.3732517d0/
      data guesp1( 15,1)/      -0.6114210d0/
      data guesp2( 15,1)/       1.9972720d0/
      data guesp3( 15,1)/       0.7946240d0/
      data guesp1( 15,2)/      -0.0939350d0/
      data guesp2( 15,2)/       1.9983600d0/
      data guesp3( 15,2)/       1.9106770d0/
c                    data for element 16        sulfur
      data refpm3 (16)/'  s: (pm3): j. j. p. stewart, j. comp. chem.
     1 10, 209 (1989).                '/
      data usspm3( 16)/     -49.8953710d0/
      data upppm3( 16)/     -44.3925830d0/
      data betasp( 16)/      -8.8274650d0/
      data betapp( 16)/      -8.0914150d0/
      data zspm3 ( 16)/       1.8911850d0/
      data zppm3 ( 16)/       1.6589720d0/
      data zdpm3 ( 16)/       1.0000000d0/
      data alppm3( 16)/       2.2697060d0/
      data eisolp( 16)/    -183.4537395d0/
      data gsspm3( 16)/       8.9646670d0/
      data gsppm3( 16)/       6.7859360d0/
      data gpppm3( 16)/       9.9681640d0/
      data gp2pm3( 16)/       7.9702470d0/
      data hsppm3( 16)/       4.0418360d0/
      data ddpm3 ( 16)/       1.1214313d0/
      data qqpm3 ( 16)/       1.0086488d0/
      data ampm3 ( 16)/       0.3294622d0/
      data adpm3 ( 16)/       0.6679118d0/
      data aqpm3 ( 16)/       0.6137472d0/
      data guesp1( 16,1)/      -0.3991910d0/
      data guesp2( 16,1)/       6.0006690d0/
      data guesp3( 16,1)/       0.9621230d0/
      data guesp1( 16,2)/      -0.0548990d0/
      data guesp2( 16,2)/       6.0018450d0/
      data guesp3( 16,2)/       1.5799440d0/
c                    data for element 17        chlorine
      data refpm3 (17)/' cl: (pm3): j. j. p. stewart, j. comp. chem.
     1 10, 209 (1989).                '/
      data usspm3( 17)/    -100.6267470d0/
      data upppm3( 17)/     -53.6143960d0/
      data betasp( 17)/     -27.5285600d0/
      data betapp( 17)/     -11.5939220d0/
      data zspm3 ( 17)/       2.2462100d0/
      data zppm3 ( 17)/       2.1510100d0/
      data zdpm3 ( 17)/       1.0000000d0/
      data alppm3( 17)/       2.5172960d0/
      data eisolp( 17)/    -315.1949480d0/
      data gsspm3( 17)/      16.0136010d0/
      data gsppm3( 17)/       8.0481150d0/
      data gpppm3( 17)/       7.5222150d0/
      data gp2pm3( 17)/       7.5041540d0/
      data hsppm3( 17)/       3.4811530d0/
      data ddpm3 ( 17)/       0.9175856d0/
      data qqpm3 ( 17)/       0.7779230d0/
      data ampm3 ( 17)/       0.5885190d0/
      data adpm3 ( 17)/       0.6814522d0/
      data aqpm3 ( 17)/       0.3643694d0/
      data guesp1( 17,1)/      -0.1715910d0/
      data guesp2( 17,1)/       6.0008020d0/
      data guesp3( 17,1)/       1.0875020d0/
      data guesp1( 17,2)/      -0.0134580d0/
      data guesp2( 17,2)/       1.9666180d0/
      data guesp3( 17,2)/       2.2928910d0/
c                    data for element 30        zinc
      data refpm3(30)/ ' zn: (pm3): j. j. p. stewart, j. comp. chem.
     1(accepted)                      '/
      data usspm3( 30)/     -18.5321980d0/
      data upppm3( 30)/     -11.0474090d0/
      data betasp( 30)/      -0.7155780d0/
      data betapp( 30)/      -6.3518640d0/
      data zspm3 ( 30)/       1.8199890d0/
      data zppm3 ( 30)/       1.5069220d0/
      data zdpm3 ( 30)/       1.0000000d0/
      data alppm3( 30)/       1.3501260d0/
      data eisolp( 30)/     -27.3872000d0/
      data gsspm3( 30)/       9.6771960d0/
      data gsppm3( 30)/       7.7362040d0/
      data gpppm3( 30)/       4.9801740d0/
      data gp2pm3( 30)/       4.6696560d0/
      data hsppm3( 30)/       0.6004130d0/
      data ddpm3 ( 30)/       1.5005758d0/
      data qqpm3 ( 30)/       1.4077174d0/
      data ampm3 ( 30)/       0.3556485d0/
      data adpm3 ( 30)/       0.2375689d0/
      data aqpm3 ( 30)/       0.2661069d0/
      data guesp1( 30,1)/      -0.1112340d0/
      data guesp2( 30,1)/       6.0014780d0/
      data guesp3( 30,1)/       1.5160320d0/
      data guesp1( 30,2)/      -0.1323700d0/
      data guesp2( 30,2)/       1.9958390d0/
      data guesp3( 30,2)/       2.5196420d0/
c                    data for element 31        gallium
      data refpm3(31)/ ' ga: (pm3): j. j. p. stewart, j. comp. chem.
     1(accepted)                      '/
      data usspm3( 31)/     -29.8555930d0/
      data upppm3( 31)/     -21.8753710d0/
      data betasp( 31)/      -4.9456180d0/
      data betapp( 31)/      -0.4070530d0/
      data zspm3 ( 31)/       1.8470400d0/
      data zppm3 ( 31)/       0.8394110d0/
      data alppm3( 31)/       1.6051150d0/
      data eisolp( 31)/     -57.3280250d0/
      data gsspm3( 31)/       8.4585540d0/
      data gsppm3( 31)/       8.9256190d0/
      data gpppm3( 31)/       5.0868550d0/
      data gp2pm3( 31)/       4.9830450d0/
      data hsppm3( 31)/       2.0512600d0/
      data ddpm3 ( 31)/       0.9776692d0/
      data qqpm3 ( 31)/       2.5271534d0/
      data ampm3 ( 31)/       0.3108620d0/
      data adpm3 ( 31)/       0.5129360d0/
      data aqpm3 ( 31)/       0.1546208d0/
      data guesp1( 31,1)/      -0.5601790d0/
      data guesp2( 31,1)/       5.6232730d0/
      data guesp3( 31,1)/       1.5317800d0/
      data guesp1( 31,2)/      -0.2727310d0/
      data guesp2( 31,2)/       1.9918430d0/
      data guesp3( 31,2)/       2.1838640d0/
c                    data for element 32        germanium
      data refpm3(32)/ ' ge: (pm3): j. j. p. stewart, j. comp. chem.
     1(accepted)                      '/
      data usspm3( 32)/     -35.4671955d0/
      data upppm3( 32)/     -31.5863583d0/
      data betasp( 32)/      -5.3250024d0/
      data betapp( 32)/      -2.2501567d0/
      data zspm3 ( 32)/       2.2373526d0/
      data zppm3 ( 32)/       1.5924319d0/
      data alppm3( 32)/       1.9723370d0/
      data eisolp( 32)/     -84.0156006d0/
      data gsspm3( 32)/       5.3769635d0/
      data gsppm3( 32)/      10.2095293d0/
      data gpppm3( 32)/       7.6718647d0/
      data gp2pm3( 32)/       6.9242663d0/
      data hsppm3( 32)/       1.3370204d0/
      data ddpm3 ( 32)/       1.1920304d0/
      data qqpm3 ( 32)/       1.3321263d0/
      data ampm3 ( 32)/       0.1976098d0/
      data adpm3 ( 32)/       0.3798182d0/
      data aqpm3 ( 32)/       0.3620669d0/
      data guesp1( 32,1)/       0.9631726d0/
      data guesp2( 32,1)/       6.0120134d0/
      data guesp3( 32,1)/       2.1633655d0/
      data guesp1( 32,2)/      -0.9593891d0/
      data guesp2( 32,2)/       5.7491802d0/
      data guesp3( 32,2)/       2.1693724d0/
c                    data for element 33        arsenic
      data refpm3(33)/ ' as: (pm3): j. j. p. stewart, j. comp. chem.
     1(accepted)                      '/
      data usspm3( 33)/     -38.5074240d0/
      data upppm3( 33)/     -35.1524150d0/
      data betasp( 33)/      -8.2321650d0/
      data betapp( 33)/      -5.0173860d0/
      data zspm3 ( 33)/       2.6361770d0/
      data zppm3 ( 33)/       1.7038890d0/
      data alppm3( 33)/       1.7944770d0/
      data eisolp( 33)/    -122.6326140d0/
      data gsspm3( 33)/       8.7890010d0/
      data gsppm3( 33)/       5.3979830d0/
      data gpppm3( 33)/       8.2872500d0/
      data gp2pm3( 33)/       8.2103460d0/
      data hsppm3( 33)/       1.9510340d0/
      data ddpm3 ( 33)/       0.9679655d0/
      data qqpm3 ( 33)/       1.2449874d0/
      data ampm3 ( 33)/       0.3230063d0/
      data adpm3 ( 33)/       0.5042239d0/
      data aqpm3 ( 33)/       0.2574219d0/
      data guesp1( 33,1)/      -0.4600950d0/
      data guesp2( 33,1)/       1.9831150d0/
      data guesp3( 33,1)/       1.0867930d0/
      data guesp1( 33,2)/      -0.0889960d0/
      data guesp2( 33,2)/       1.9929440d0/
      data guesp3( 33,2)/       2.1400580d0/
c                    data for element 34        selenium
      data refpm3(34)/ ' se: (pm3): j. j. p. stewart, j. comp. chem.
     1(accepted)                      '/
      data usspm3( 34)/     -55.3781350d0/
      data upppm3( 34)/     -49.8230760d0/
      data betasp( 34)/      -6.1578220d0/
      data betapp( 34)/      -5.4930390d0/
      data zspm3 ( 34)/       2.8280510d0/
      data zppm3 ( 34)/       1.7325360d0/
      data alppm3( 34)/       3.0439570d0/
      data eisolp( 34)/    -192.7748115d0/
      data gsspm3( 34)/       7.4325910d0/
      data gsppm3( 34)/      10.0604610d0/
      data gpppm3( 34)/       9.5683260d0/
      data gp2pm3( 34)/       7.7242890d0/
      data hsppm3( 34)/       4.0165580d0/
      data ddpm3 ( 34)/       0.8719813d0/
      data qqpm3 ( 34)/       1.2244019d0/
      data ampm3 ( 34)/       0.2731566d0/
      data adpm3 ( 34)/       0.7509697d0/
      data aqpm3 ( 34)/       0.5283737d0/
      data guesp1( 34,1)/       0.0478730d0/
      data guesp2( 34,1)/       6.0074000d0/
      data guesp3( 34,1)/       2.0817170d0/
      data guesp1( 34,2)/       0.1147200d0/
      data guesp2( 34,2)/       6.0086720d0/
      data guesp3( 34,2)/       1.5164230d0/
c                    data for element 35        bromine
      data refpm3 (35)/' br: (pm3): j. j. p. stewart, j. comp. chem.
     1 10, 209 (1989).                '/
      data usspm3( 35)/    -116.6193110d0/
      data upppm3( 35)/     -74.2271290d0/
      data betasp( 35)/     -31.1713420d0/
      data betapp( 35)/      -6.8140130d0/
      data zspm3 ( 35)/       5.3484570d0/
      data zppm3 ( 35)/       2.1275900d0/
      data zdpm3 ( 35)/       1.0000000d0/
      data alppm3( 35)/       2.5118420d0/
      data eisolp( 35)/    -352.5398970d0/
      data gsspm3( 35)/      15.9434250d0/
      data gsppm3( 35)/      16.0616800d0/
      data gpppm3( 35)/       8.2827630d0/
      data gp2pm3( 35)/       7.8168490d0/
      data hsppm3( 35)/       0.5788690d0/
      data ddpm3 ( 35)/       0.2759025d0/
      data qqpm3 ( 35)/       0.9970532d0/
      data ampm3 ( 35)/       0.5859399d0/
      data adpm3 ( 35)/       0.6755383d0/
      data aqpm3 ( 35)/       0.3823719d0/
      data guesp1( 35,1)/       0.9604580d0/
      data guesp2( 35,1)/       5.9765080d0/
      data guesp3( 35,1)/       2.3216540d0/
      data guesp1( 35,2)/      -0.9549160d0/
      data guesp2( 35,2)/       5.9447030d0/
      data guesp3( 35,2)/       2.3281420d0/
c                    data for element 48        cadmium
      data refpm3(48)/ ' cd: (pm3): j. j. p. stewart, j. comp. chem.
     1(accepted)                      '/
      data usspm3( 48)/     -15.8285840d0/
      data upppm3( 48)/       8.7497950d0/
      data betasp( 48)/      -8.5819440d0/
      data betapp( 48)/      -0.6010340d0/
      data zspm3 ( 48)/       1.6793510d0/
      data zppm3 ( 48)/       2.0664120d0/
      data alppm3( 48)/       1.5253820d0/
      data eisolp( 48)/     -22.4502080d0/
      data gsspm3( 48)/       9.2069600d0/
      data gsppm3( 48)/       8.2315390d0/
      data gpppm3( 48)/       4.9481040d0/
      data gp2pm3( 48)/       4.6696560d0/
      data hsppm3( 48)/       1.6562340d0/
      data ddpm3 ( 48)/       1.5982681d0/
      data qqpm3 ( 48)/       1.2432402d0/
      data ampm3 ( 48)/       0.3383668d0/
      data adpm3 ( 48)/       0.3570290d0/
      data aqpm3 ( 48)/       0.2820582d0/
c                    data for element 49        indium
      data refpm3(49)/ ' in: (pm3): j. j. p. stewart, j. comp. chem.
     1(accepted)                      '/
      data usspm3( 49)/     -26.1762050d0/
      data upppm3( 49)/     -20.0058220d0/
      data betasp( 49)/      -2.9933190d0/
      data betapp( 49)/      -1.8289080d0/
      data zspm3 ( 49)/       2.0161160d0/
      data zppm3 ( 49)/       1.4453500d0/
      data alppm3( 49)/       1.4183850d0/
      data eisolp( 49)/     -51.9750470d0/
      data gsspm3( 49)/       6.5549000d0/
      data gsppm3( 49)/       8.2298730d0/
      data gpppm3( 49)/       6.2992690d0/
      data gp2pm3( 49)/       4.9842110d0/
      data hsppm3( 49)/       2.6314610d0/
      data ddpm3 ( 49)/       1.5766241d0/
      data qqpm3 ( 49)/       1.7774563d0/
      data ampm3 ( 49)/       0.2409004d0/
      data adpm3 ( 49)/       0.4532655d0/
      data aqpm3 ( 49)/       0.3689812d0/
      data guesp1( 49,1)/      -0.3431380d0/
      data guesp2( 49,1)/       1.9940340d0/
      data guesp3( 49,1)/       1.6255160d0/
      data guesp1( 49,2)/      -0.1095320d0/
      data guesp2( 49,2)/       5.6832170d0/
      data guesp3( 49,2)/       2.8670090d0/
c                    data for element 50        tin
      data refpm3(50)/ ' sn: (pm3): j. j. p. stewart, j. comp. chem.
     1(accepted)                      '/
      data usspm3( 50)/     -34.5501920d0/
      data upppm3( 50)/     -25.8944190d0/
      data betasp( 50)/      -2.7858020d0/
      data betapp( 50)/      -2.0059990d0/
      data zspm3 ( 50)/       2.3733280d0/
      data zppm3 ( 50)/       1.6382330d0/
      data alppm3( 50)/       1.6996500d0/
      data eisolp( 50)/     -78.8877790d0/
      data gsspm3( 50)/      10.1900330d0/
      data gsppm3( 50)/       7.2353270d0/
      data gpppm3( 50)/       5.6738100d0/
      data gp2pm3( 50)/       5.1822140d0/
      data hsppm3( 50)/       1.0331570d0/
      data ddpm3 ( 50)/       1.3120038d0/
      data qqpm3 ( 50)/       1.5681814d0/
      data ampm3 ( 50)/       0.3744959d0/
      data adpm3 ( 50)/       0.3218163d0/
      data aqpm3 ( 50)/       0.2832529d0/
      data guesp1( 50,1)/      -0.1503530d0/
      data guesp2( 50,1)/       6.0056940d0/
      data guesp3( 50,1)/       1.7046420d0/
      data guesp1( 50,2)/      -0.0444170d0/
      data guesp2( 50,2)/       2.2573810d0/
      data guesp3( 50,2)/       2.4698690d0/
c                    data for element 51        antimony
      data refpm3(51)/ ' sb: (pm3): j. j. p. stewart, j. comp. chem.
     1(accepted)                      '/
      data usspm3( 51)/     -56.4321960d0/
      data upppm3( 51)/     -29.4349540d0/
      data betasp( 51)/     -14.7942170d0/
      data betapp( 51)/      -2.8179480d0/
      data zspm3 ( 51)/       2.3430390d0/
      data zppm3 ( 51)/       1.8999920d0/
      data alppm3( 51)/       2.0343010d0/
      data eisolp( 51)/    -148.9382890d0/
      data gsspm3( 51)/       9.2382770d0/
      data gsppm3( 51)/       5.2776800d0/
      data gpppm3( 51)/       6.3500000d0/
      data gp2pm3( 51)/       6.2500000d0/
      data hsppm3( 51)/       2.4244640d0/
      data ddpm3 ( 51)/       1.4091903d0/
      data qqpm3 ( 51)/       1.3521354d0/
      data ampm3 ( 51)/       0.3395177d0/
      data adpm3 ( 51)/       0.4589010d0/
      data aqpm3 ( 51)/       0.2423472d0/
      data guesp1( 51,1)/       3.0020280d0/
      data guesp2( 51,1)/       6.0053420d0/
      data guesp3( 51,1)/       0.8530600d0/
      data guesp1( 51,2)/      -0.0188920d0/
      data guesp2( 51,2)/       6.0114780d0/
      data guesp3( 51,2)/       2.7933110d0/
c                    data for element 52        tellurium
      data refpm3(52)/ ' te: (pm3): j. j. p. stewart, j. comp. chem.
     1(accepted)                      '/
      data usspm3( 52)/     -44.9380360d0/
      data upppm3( 52)/     -46.3140990d0/
      data betasp( 52)/      -2.6651460d0/
      data betapp( 52)/      -3.8954300d0/
      data zspm3 ( 52)/       4.1654920d0/
      data zppm3 ( 52)/       1.6475550d0/
      data alppm3( 52)/       2.4850190d0/
      data eisolp( 52)/    -168.0945925d0/
      data gsspm3( 52)/      10.2550730d0/
      data gsppm3( 52)/       8.1691450d0/
      data gpppm3( 52)/       7.7775920d0/
      data gp2pm3( 52)/       7.7551210d0/
      data hsppm3( 52)/       3.7724620d0/
      data ddpm3 ( 52)/       0.3484177d0/
      data qqpm3 ( 52)/       1.5593085d0/
      data ampm3 ( 52)/       0.3768862d0/
      data adpm3 ( 52)/       1.1960743d0/
      data aqpm3 ( 52)/       0.2184786d0/
      data guesp1( 52,1)/       0.0333910d0/
      data guesp2( 52,1)/       5.9563790d0/
      data guesp3( 52,1)/       2.2775750d0/
      data guesp1( 52,2)/      -1.9218670d0/
      data guesp2( 52,2)/       4.9732190d0/
      data guesp3( 52,2)/       0.5242430d0/
c                    data for element 53        iodine
      data refpm3 (53)/'  i: (pm3): j. j. p. stewart, j. comp. chem.
     1 10, 209 (1989).                '/
      data usspm3( 53)/     -96.4540370d0/
      data upppm3( 53)/     -61.0915820d0/
      data betasp( 53)/     -14.4942340d0/
      data betapp( 53)/      -5.8947030d0/
      data zspm3 ( 53)/       7.0010130d0/
      data zppm3 ( 53)/       2.4543540d0/
      data zdpm3 ( 53)/       1.0000000d0/
      data alppm3( 53)/       1.9901850d0/
      data eisolp( 53)/    -288.3160860d0/
      data gsspm3( 53)/      13.6319430d0/
      data gsppm3( 53)/      14.9904060d0/
      data gpppm3( 53)/       7.2883300d0/
      data gp2pm3( 53)/       5.9664070d0/
      data hsppm3( 53)/       2.6300350d0/
      data ddpm3 ( 53)/       0.1581469d0/
      data qqpm3 ( 53)/       1.0467302d0/
      data ampm3 ( 53)/       0.5009902d0/
      data adpm3 ( 53)/       1.6699104d0/
      data aqpm3 ( 53)/       0.5153082d0/
      data guesp1( 53,1)/      -0.1314810d0/
      data guesp2( 53,1)/       5.2064170d0/
      data guesp3( 53,1)/       1.7488240d0/
      data guesp1( 53,2)/      -0.0368970d0/
      data guesp2( 53,2)/       6.0101170d0/
      data guesp3( 53,2)/       2.7103730d0/
c                    data for element 80        mercury
      data refpm3(80)/ ' hg: (pm3): j. j. p. stewart, j. comp. chem.
     1(accepted)                      '/
      data usspm3( 80)/     -17.7622290d0/
      data upppm3( 80)/     -18.3307510d0/
      data betasp( 80)/      -3.1013650d0/
      data betapp( 80)/      -3.4640310d0/
      data zspm3 ( 80)/       1.4768850d0/
      data zppm3 ( 80)/       2.4799510d0/
      data alppm3( 80)/       1.5293770d0/
      data eisolp( 80)/     -28.8997380d0/
      data gsspm3( 80)/       6.6247200d0/
      data gsppm3( 80)/      10.6392970d0/
      data gpppm3( 80)/      14.7092830d0/
      data gp2pm3( 80)/      16.0007400d0/
      data hsppm3( 80)/       2.0363110d0/
      data ddpm3 ( 80)/       1.2317811d0/
      data qqpm3 ( 80)/       1.2164033d0/
      data ampm3 ( 80)/       0.2434664d0/
      data adpm3 ( 80)/       0.4515472d0/
      data aqpm3 ( 80)/       0.2618394d0/
      data guesp1( 80,1)/       1.0827200d0/
      data guesp2( 80,1)/       6.4965980d0/
      data guesp3( 80,1)/       1.1951460d0/
      data guesp1( 80,2)/      -0.0965530d0/
      data guesp2( 80,2)/       3.9262810d0/
      data guesp3( 80,2)/       2.6271600d0/
c                    data for element 81        thallium
      data refpm3(81)/ ' tl: (pm3): j. j. p. stewart, j. comp. chem.
     1(accepted)                      '/
      data usspm3( 81)/     -30.0531700d0/
      data upppm3( 81)/     -26.9206370d0/
      data betasp( 81)/      -1.0844950d0/
      data betapp( 81)/      -7.9467990d0/
      data zspm3 ( 81)/       6.8679210d0/
      data zppm3 ( 81)/       1.9694450d0/
      data alppm3( 81)/       1.3409510d0/
      data eisolp( 81)/     -56.6492050d0/
      data gsspm3( 81)/      10.4604120d0/
      data gsppm3( 81)/      11.2238830d0/
      data gpppm3( 81)/       4.9927850d0/
      data gp2pm3( 81)/       8.9627270d0/
      data hsppm3( 81)/       2.5304060d0/
      data ddpm3 ( 81)/       0.0781362d0/
      data qqpm3 ( 81)/       1.5317110d0/
      data ampm3 ( 81)/       0.3844326d0/
      data adpm3 ( 81)/       2.5741815d0/
      data aqpm3 ( 81)/       0.2213264d0/
      data guesp1( 81,1)/      -1.3613990d0/
      data guesp2( 81,1)/       3.5572260d0/
      data guesp3( 81,1)/       1.0928020d0/
      data guesp1( 81,2)/      -0.0454010d0/
      data guesp2( 81,2)/       2.3069950d0/
      data guesp3( 81,2)/       2.9650290d0/
c                    data for element 82        lead
      data refpm3(82)/ ' pb: (pm3): j. j. p. stewart, j. comp. chem.
     1(accepted)                      '/
      data usspm3( 82)/     -30.3227560d0/
      data upppm3( 82)/     -24.4258340d0/
      data betasp( 82)/      -6.1260240d0/
      data betapp( 82)/      -1.3954300d0/
      data zspm3 ( 82)/       3.1412890d0/
      data zppm3 ( 82)/       1.8924180d0/
      data alppm3( 82)/       1.6200450d0/
      data eisolp( 82)/     -73.4660775d0/
      data gsspm3( 82)/       7.0119920d0/
      data gsppm3( 82)/       6.7937820d0/
      data gpppm3( 82)/       5.1837800d0/
      data gp2pm3( 82)/       5.0456510d0/
      data hsppm3( 82)/       1.5663020d0/
      data ddpm3 ( 82)/       0.9866290d0/
      data qqpm3 ( 82)/       1.5940562d0/
      data ampm3 ( 82)/       0.2576991d0/
      data adpm3 ( 82)/       0.4527678d0/
      data aqpm3 ( 82)/       0.2150175d0/
      data guesp1( 82,1)/      -0.1225760d0/
      data guesp2( 82,1)/       6.0030620d0/
      data guesp3( 82,1)/       1.9015970d0/
      data guesp1( 82,2)/      -0.0566480d0/
      data guesp2( 82,2)/       4.7437050d0/
      data guesp3( 82,2)/       2.8618790d0/
c                    data for element 83        bismuth
      data refpm3(83)/ ' bi: (pm3): j. j. p. stewart, j. comp. chem.
     1(accepted)                      '/
      data usspm3( 83)/     -33.4959380d0/
      data upppm3( 83)/     -35.5210260d0/
      data betasp( 83)/      -5.6072830d0/
      data betapp( 83)/      -5.8001520d0/
      data zspm3 ( 83)/       4.9164510d0/
      data zppm3 ( 83)/       1.9349350d0/
      data alppm3( 83)/       1.8574310d0/
      data eisolp( 83)/    -109.2774910d0/
      data gsspm3( 83)/       4.9894800d0/
      data gsppm3( 83)/       6.1033080d0/
      data gpppm3( 83)/       8.6960070d0/
      data gp2pm3( 83)/       8.3354470d0/
      data hsppm3( 83)/       0.5991220d0/
      data ddpm3 ( 83)/       0.2798609d0/
      data qqpm3 ( 83)/       1.5590294d0/
      data ampm3 ( 83)/       0.1833693d0/
      data adpm3 ( 83)/       0.6776013d0/
      data aqpm3 ( 83)/       0.2586520d0/
      data guesp1( 83,1)/       2.5816930d0/
      data guesp2( 83,1)/       5.0940220d0/
      data guesp3( 83,1)/       0.4997870d0/
      data guesp1( 83,2)/       0.0603200d0/
      data guesp2( 83,2)/       6.0015380d0/
      data guesp3( 83,2)/       2.4279700d0/
c                    data for element  103      capped bond
      data refpm3(102)/' cb: (pm3):  capped bond  (hydrogen-like, takes
     1on a  zero charge.)             '/
      data usspm3(102)/     -11.9062760d0/
      data betasp(102)/-9999999.0000000d0/
      data zspm3 (102)/       4.0000000d0/
      data zppm3 (102)/       0.3000000d0/
      data zdpm3 (102)/       0.3000000d0/
      data alppm3(102)/       2.5441341d0/
      data eisolp(102)/       4.0000000d0/
      data gsspm3(102)/      12.8480000d0/
      data hsppm3(102)/       0.1000000d0/
      data ddpm3 (102)/       0.0684105d0/
      data qqpm3 (102)/       1.0540926d0/
      data ampm3 (102)/       0.4721793d0/
      data adpm3 (102)/       0.9262742d0/
      data aqpm3 (102)/       0.2909059d0/
      end
      function aababc(iocca1, ioccb1, iocca2, nmos)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      dimension iocca1(nmos), ioccb1(nmos), iocca2(nmos)
***********************************************************************
*
* aababc evaluates the c.i. matrix element for two microstates differing
*       by beta electron. that is, one microstate has a beta electron
*       in psi(i) which, in the other microstate is in psi(j)
*
***********************************************************************
      common /xyijkl/ xy(nmeci,nmeci,nmeci,nmeci)
      common /baseoc/ occa(nmeci)
      do 10 i=1,nmos
   10 if(iocca1(i).ne.iocca2(i)) goto 20
   20 ij=ioccb1(i)
      do 30 j=i+1,nmos
         if(iocca1(j).ne.iocca2(j)) goto 40
   30 ij=ij+iocca1(j)+ioccb1(j)
   40 sum=0.0d0
      do 50 k=1,nmos
   50 sum=sum+ (xy(i,j,k,k)-xy(i,k,j,k))*(iocca1(k)-occa(k)) +
     1          xy(i,j,k,k)             *(ioccb1(k)-occa(k))
      if(mod(ij,2).eq.1)sum=-sum
      aababc=sum
      return
      end
      function aabacd(iocca1, ioccb1, iocca2, ioccb2, nmos)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      dimension iocca1(nmos), ioccb1(nmos), iocca2(nmos), ioccb2(nmos)
***********************************************************************
*
* aabacd evaluates the c.i. matrix element for two microstates differing
*       by two alpha mos. one microstate has alpha electrons in
*       m.o.s psi(i) and psi(j) for which the other microstate has
*       electrons in psi(k) and psi(l)
*
***********************************************************************
      common /xyijkl/ xy(nmeci,nmeci,nmeci,nmeci)
      ij=0
      do 10 i=1,nmos
   10 if(iocca1(i) .lt. iocca2(i)) goto 20
   20 do 30 j=i+1,nmos
         if(iocca1(j) .lt. iocca2(j)) goto 40
   30 ij=ij+iocca2(j)+ioccb2(j)
   40 do 50 k=1,nmos
   50 if(iocca1(k) .gt. iocca2(k)) goto 60
   60 do 70 l=k+1,nmos
         if(iocca1(l) .gt. iocca2(l)) goto 80
   70 ij=ij+iocca1(l)+ioccb1(l)
   80 ij=ij+ioccb2(i)+ioccb1(k)
      sum=(xy(i,k,j,l)-xy(i,l,k,j))
      if(mod(ij,2).eq.1)sum=-sum
      aabacd=sum
      return
      end
      function aabbcd(iocca1, ioccb1, iocca2, ioccb2, nmos)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      dimension iocca1(nmos), ioccb1(nmos), iocca2(nmos), ioccb2(nmos)
***********************************************************************
*
* aabbcd evaluates the c.i. matrix element for two microstates differing
*       by two sets of m.o.s. one microstate has an alpha electron
*       in psi(i) and a beta electron in psi(k) for which the other
*       microstate has an alpha electron in psi(j) and a beta electron
*       in psi(l)
*
***********************************************************************
      common /xyijkl/ xy(nmeci,nmeci,nmeci,nmeci)
      common /spqr/ ispqr(nmeci*nmeci,nmeci),is,iloop, jloop
      do 10 i=1,nmos
   10 if(iocca1(i) .ne. iocca2(i)) goto 20
   20 do 30 j=i+1,nmos
   30 if(iocca1(j) .ne. iocca2(j)) goto 40
   40 do 50 k=1,nmos
   50 if(ioccb1(k) .ne. ioccb2(k)) goto 60
   60 do 70 l=k+1,nmos
   70 if(ioccb1(l) .ne. ioccb2(l)) goto 80
   80 if( i.eq.k .and. j.eq.l .and. iocca1(i).ne.ioccb1(i)) then
         ispqr(iloop,is)=jloop
         is=is+1
      endif
      if(iocca1(i) .lt. iocca2(i)) then
         m=i
         i=j
         j=m
      endif
      if(ioccb1(k) .lt. ioccb2(k)) then
         m=k
         k=l
         l=m
      endif
      xr=xy(i,j,k,l)
c#      write(6,'(4i5,f12.6)')i,j,k,l,xr
c
c   now untangle the microstates
c
      ij=1
      if( i.gt.k .and. j.gt.l .or. i.le.k .and. j.le.l)ij=0
      if( i.gt.k ) ij=ij+iocca1(k)+ioccb1(i)
      if( j.gt.l ) ij=ij+iocca2(l)+ioccb2(j)
      if(i.gt.k)then
         m=i
         i=k
         k=m
      endif
      do 90 m=i,k
   90 ij=ij+ioccb1(m)+iocca1(m)
      if(j.gt.l)then
         m=j
         j=l
         l=m
      endif
      do 100 m=j,l
  100 ij=ij+ioccb2(m)+iocca2(m)
c
c   ij in the permutation number, .equiv. -1 if ij is odd.
c
      if(mod(ij,2).eq.1)xr=-xr
      aabbcd=xr
      return
      end
      subroutine aintgs (x,k)
      implicit REAL (a-h,o-z)
      common /cmops/ a(7),b(7),sdum(3),idum(2)
c***********************************************************************
c
c    aintgs forms the "a" integrals for the overlap calculation.
c
c***********************************************************************
      c=dexp(-x)
      a(1)=c/x
      do 10 i=1,k
         a(i+1)=(a(i)*i+c)/x
   10 continue
      return
      end
      subroutine analyt(psum,palpha,pbeta,coord,nat,jja,jjd,
     1iia,iid,eng)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      dimension coord(3,*),eng(3), psum(*), palpha(*), pbeta(*),nat(*)
************************************************************************
*                                                                      *
*         calculation of analytical derivatives                        *
*                                                                      *
************************************************************************
c
c common blocks 'owned' by rest of program.
c
      common /corec/ core(107)
      common /betas/ betas(107),betap(107),betad(107)
      common /expont/ zs(107),zp(107),zd(107)
      common /alpha/ alpa(107)
      common /twoel3/ f03(107)
      common /cmporb/ natorb(107)
      common /alpha3/ alp3(153)
      common /ideas/ fn1(107,10),fn2(107,10),fn3(107,10)
      common /wmatrc/ w(n2elec*2)
      common /natype/ nztype(107),mtype(30),ltype
      common /beta3/ beta3(153)
      common /vsips/ vs(107),vp(107),vd(107)
      common /keywrd/ keywrd
c
c common blocks 'owned' by ant
c
      common /derivs/ ds(16),dg(22),dr(100),tdx(3),tdy(3),tdz(3)
      common /cmpex/ g(22), txyz(9)
c
c on return, eng holds analytical derivatives
c
      common /force3/ idmy(5),i3n,ix
      common /numcal/ numcal
      dimension eaa(3),eab(3),enuc(3), bi(4), bj(4)
      character*241 keywrd
      save am1, mindo3
      logical am1, mindo3
      save icalcn
      data icalcn/0/
      if (icalcn.ne.numcal) then
         icalcn=numcal
         am1=(index(keywrd,'am1')+index(keywrd,'pm3').ne.0)
         mindo3=(index(keywrd,'mindo').ne.0)
      endif
      a0=0.529167d0
      jd=jjd-jja+1
      ja=1
      id=iid-iia+1+jd
      ia=jd+1
      do 10 j=1,3
         eaa(j)=0.0d0
         eab(j)=0.0d0
         enuc(j)=0.0d0
         eng(j)=0.0d0
   10 continue
      i=2
      ni=nat(i)
      istart=nztype(ni)*4-3
      j=1
      nj=nat(j)
      jstart=nztype(nj)*4-3
      r2=(coord(1,i)-coord(1,j))**2+(coord(2,i)-coord(2,j))**2
     1   + (coord(3,i)-coord(3,j))**2
      rij=dsqrt(r2)
      r0=rij/a0
      rr=r2/(a0*a0)
      do 150 ix=1,3
         del1=coord(ix,i)-coord(ix,j)
         termaa=0.0d0
         termab=0.0d0
         isp=0
         iol=0
c   the first derivatives of overlap integrals
         do 30 k=ia,id
            ka=k-ia
            kg=istart+ka
            do 30 l=ja,jd
               la=l-ja
               lg=jstart+la
               iol=iol+1
               ds(iol)=0.0d0
               if(ka.eq.0.and.la.eq.0) then
c   (s/s) term
                  if(dabs(del1).le.1.0d-6) go to 30
                  is=1
               elseif(ka.eq.0.and.la.gt.0) then
c   (s/p) term
                  is=3
                  if(ix.eq.la) go to 20
                  if(dabs(del1).le.1.0d-6) go to 30
                  is=2
                  del2=coord(la,i)-coord(la,j)
               elseif(ka.gt.0.and.la.eq.0) then
c   (p/s) term
                  is=5
                  if(ix.eq.ka) go to 20
                  if(dabs(del1).le.1.0d-6) go to 30
                  is=4
                  del2=coord(ka,i)-coord(ka,j)
               else
c   (p/p) term
                  if(ka.eq.la) then
c    p/p
                     is=9
                     if(ix.eq.ka) go to 20
                     if(dabs(del1).le.1.0d-6) go to 30
c    p'/p'
                     is=8
                     del2=coord(ka,i)-coord(ka,j)
                  elseif(ix.ne.ka.and.ix.ne.la) then
c    p'/p"
                     if(dabs(del1).le.1.0d-6) go to 30
                     is=7
                     del2=coord(ka,i)-coord(ka,j)
                     del3=coord(la,i)-coord(la,j)
                  else
c    p/p' or p'/p
                     del2=coord(ka+la-ix,i)-coord(ka+la-ix,j)
                     is=6
                  endif
               endif
c
c        calculate overlap derivatives, store results in ds
c
   20          call ders(kg,lg,rr,del1,del2,del3,is,iol)
   30    continue
         if(.not.mindo3.and.ix.eq.1) read (2) (g(i22),i22=1,22)
         if(.not.mindo3) call delri(dg,ni,nj,r0,del1)
         call delmol(coord,i,j,ni,nj,ia,id,ja,jd,ix,rij,del1,isp)
c
c   the first derivative of nuclear repulsion term
         if(mindo3)then
            ii=max(ni,nj)
            nbond=(ii*(ii-1))/2+ni+nj-ii
            alpha=0
            if(nbond.lt.154)then
               alpha=alp3(nbond)
            else
               alph1=100
               alph2=100
               if(natorb(ni).eq.0)alph1=alpa(ni)
               if(natorb(nj).eq.0)alph2=alpa(nj)
            endif
            c2=(7.1995d0/f03(ni)+7.1995d0/f03(nj))**2
            c1=del1/rij*core(ni)*core(nj)*14.399d0
            c3=del1/rij*dabs(core(ni)*core(nj))*14.399d0
            if(nbond.eq.22.or.nbond.eq.29)then
               termnc=-c1*alpha*(1.d0/rij**2 - rij*(rij**2+c2)**(-1.5d0)
     1 +  1.d0/rij - 1.d0/dsqrt(rij**2+c2)) * dexp(-rij) -
     2c1*rij*(rij**2+c2)**(-1.5d0)
            elseif (rij.lt.1.d0.and.natorb(ni)*natorb(nj).eq.0) then
               termnc=0.0d0
            elseif(nbond.ge.154) then
c
c  special case involving sparkles
c
               exp1=dexp(-dmin1(alph1*rij,20.d0))
               exp2=dexp(-dmin1(alph2*rij,20.d0))
               part1=-c3*(1.d0/rij**2 - rij*(rij**2+c2)**(-1.5d0))
     1*(exp1+exp2)
               part2=-c3*(1.d0/rij -1.d0/dsqrt(rij**2+c2))
     1*(alph1*exp1 + alph2*exp2)
               part3=-c1*rij*(rij**2+c2)**(-1.5d0)
               termnc=part1+part2+part3
c#            write(6,'(4f13.6)')part1,part2,part3,termnc
            else
               termnc=-c1*(1.d0/rij**2 - rij*(rij**2+c2)**(-1.5d0) +
     1alpha/rij - alpha/dsqrt(rij**2+c2)) * dexp(-alpha*rij) -
     2c1*rij*(rij**2+c2)**(-1.5d0)
            endif
            dr1=del1/rij*14.399d0*rij*(rij**2+c2)**(-1.5d0)
         else
c
c      core-core terms, mndo and am1
c
c
c  special treatment for n-h and o-h terms
c
            if(rij.lt.1.d0.and.natorb(ni)*natorb(nj).eq.0)then
               termnc=0.0d0
               goto 50
            endif
            c1=core(ni)*core(nj)
            if(ni.eq.1.and.(nj.eq.7.or.nj.eq.8)) then
               f3=1.0d0+dexp(-alpa(1)*rij)+rij*dexp(-alpa(nj)*rij)
               dd=(dg(1)*f3-g(1)*(del1/rij)*(alpa(1)*dexp(-alpa(1)*rij)
     1 +(alpa(nj)*rij-1.0d0)*dexp(-alpa(nj)*rij)))*c1
            elseif((ni.eq.7.or.ni.eq.8).and.nj.eq.1) then
               f3=1.0d0+dexp(-alpa(1)*rij)+rij*dexp(-alpa(ni)*rij)
               dd=(dg(1)*f3-g(1)*(del1/rij)*(alpa(1)*dexp(-alpa(1)*rij)
     1 +(alpa(ni)*rij-1.0d0)*dexp(-alpa(ni)*rij)))*c1
            else
c#            elseif(natorb(ni)+natorb(nj).eq.0) then
c
c  special case of two sparkles
c
               part1=dg(1)*c1
               part2=-(g(1)*(del1/rij)*(alpa(ni)*dexp(-alpa(ni)*ri
     1j) +alpa(nj)*dexp(-alpa(nj)*rij)))*dabs(c1)
               part3=dg(1)*(dexp(-alpa(ni)*rij)+dexp(-alpa(nj)*rij))*
     +         dabs(c1)
               dd=part1+part2+part3
c#            write(6,'(4f13.6)')part1,part2,part3,dd
c#            else
c
c   the general case
c
c#               f3=1.0d0+dexp(-alpa(ni)*rij)+dexp(-alpa(nj)*rij)
c#               dd=(dg(1)*f3-g(1)*(del1/rij)*(alpa(ni)*dexp(-alpa(ni)*ri
c#     1j) +alpa(nj)*dexp(-alpa(nj)*rij)))*c1
            endif
            termnc=dd
         endif
c
c   ****   start of the am1 specific derivative code   ***
c
c      analyt=-a*(1/(r*r)+2.d0*b*(r-c)/r)*dexp(-b*(r-c)**2)
c
c    analytical derivatives
c
         if( am1 )then
            anam1=0.0d0
            do 40 ig=1,10
               if(dabs(fn1(ni,ig)).gt.0.d0)
     1anam1=anam1+fn1(ni,ig)*
     2(1.d0/(rij*rij)+2.d0*fn2(ni,ig)*(rij-fn3(ni,ig))/rij)*
     3dexp(dmax1(-30.d0,-fn2(ni,ig)*(rij-fn3(ni,ig))**2))
               if(dabs(fn1(nj,ig)).gt.0.d0)
     1anam1=anam1+fn1(nj,ig)*
     2(1.d0/(rij*rij)+2.d0*fn2(nj,ig)*(rij-fn3(nj,ig))/rij)*
     3dexp(dmax1(-30.d0,-fn2(nj,ig)*(rij-fn3(nj,ig))**2))
   40       continue
            anam1=anam1*core(ni)*core(nj)
            termnc=termnc-anam1*del1/rij
         endif
c
c   ****   end of the am1 specific derivative code   ***
c
   50    continue
c
c   combine together the overlap derivative parts
c
         if(mindo3)then
            ii=max(ni,nj)
            nbond=(ii*(ii-1))/2+ni+nj-ii
            if(nbond.gt.153)goto 60
            bi(1)=beta3(nbond)*vs(ni)*2.d0
            bi(2)=beta3(nbond)*vp(ni)*2.d0
            bi(3)=bi(2)
            bi(4)=bi(2)
            bj(1)=beta3(nbond)*vs(nj)*2.d0
            bj(2)=beta3(nbond)*vp(nj)*2.d0
            bj(3)=bj(2)
            bj(4)=bj(2)
   60       continue
         else
            bi(1)=betas(ni)
            bi(2)=betap(ni)
            bi(3)=bi(2)
            bi(4)=bi(2)
            bj(1)=betas(nj)
            bj(2)=betap(nj)
            bj(3)=bj(2)
            bj(4)=bj(2)
         endif
c
c       code common to mindo/3, mndo, and am1
c
         iol=0
         do 70 k=ia,id
            do 70 l=ja,jd
               lk=l+k*(k-1)/2
               termk=bi(k-ia+1)
               terml=bj(l-ja+1)
               iol=iol+1
               termab=termab+(termk+terml)
     1*psum(lk)*ds(iol)
   70    continue
         if(mindo3)then
c
c        first, core-electron attraction derivatives (mindo/3)
c
c          atom core i affecting a.o.s on j
            do 80 m=ja,jd
               mn=(m*(m+1))/2
   80       termab=termab+core(ni)*psum(mn)*dr1
c          atom core j affecting a.o.s on i
            do 90 m=ia,id
               mn=(m*(m+1))/2
   90       termab=termab+core(nj)*psum(mn)*dr1
c
c   now for coulomb and exchange terms (mindo/3)
c
            do 100 i1=ia,id
               ii=(i1*(i1+1))/2
               do 100 j1=ja,jd
                  jj=(j1*(j1+1))/2
                  ij=j1+(i1*(i1-1))/2
c
c           coulomb term
c
                  termaa=termaa-psum(ii)*dr1*psum(jj)
c
c           exchange term
c
                  termaa=termaa+(palpha(ij)*palpha(ij)+pbeta(ij)*pbeta(i
     1j))*dr1
  100       continue
         else
c
c        first, core-electron attraction derivatives (mndo and am1)
c
c          atom core i affecting a.o.s on j
            isp=0
            do 110 m=ja,jd
               bb=1.d0
               do 110 n=m,jd
                  mn=m+n*(n-1)/2
                  isp=isp+1
                  termab=termab-bb*core(ni)*psum(mn)*dr(isp)
  110       bb=2.d0
c          atom core j affecting a.o.s on i
            k=max(jd-ja+1,1)
            k=(k*(k+1))/2
            isp=-k+1
            do 120 m=ia,id
               bb=1.d0
               do 120 n=m,id
                  mn=m+n*(n-1)/2
                  isp=isp+k
                  termab=termab-bb*core(nj)*psum(mn)*dr(isp)
  120       bb=2.d0
            isp=0
c
c   now for coulomb and exchange terms (mndo and am1)
c
            do 140 k=ia,id
               aa=1.d0
               kk=(k*(k-1))/2
               do 140 l=k,id
                  ll=(l*(l-1))/2
                  do 130 m=ja,jd
                     bb=1.d0
                     do 130 n=m,jd
                        isp=isp+1
                        kl=k+ll
                        mn=m+n*(n-1)/2
c
c    coulomb term
c
                        termaa=termaa+aa*bb*psum(kl)*psum(mn)*dr(isp)
                        mk=m+kk
                        nk=n+kk
                        ml=m+ll
                        nl=n+ll
c
c    exchange term
c
                        termaa= termaa-0.5d0*aa*bb*(palpha(m
     1k)*palpha(nl)+palpha(nk)*palpha(ml)+pbeta(mk)*pbeta(nl)+pbeta(nk)*
     2pbeta(ml))*dr(isp)
  130             bb=2.d0
  140       aa=2.d0
c           end of mndo and am1 specific code
         endif
         eaa(ix)=eaa(ix)+termaa
         eab(ix)=eab(ix)+termab
         enuc(ix)=enuc(ix)+termnc
  150 continue
c#            write(6,*)eaa,eab,enuc,nat(1),nat(2)
      do 180 j=1,3
         eng(j)=eaa(j)+eab(j)+enuc(j)
         eng(j) = -eng(j)*23.061d0
  180 continue
      return
      end
      subroutine anavib(coord,eigs,dipt,n3,vibs,rij,hess,travel,redmas)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      dimension coord(3,numatm),eigs(n3),vibs(n3,n3), dipt(n3),
     1rij(maxhes), travel(n3), hess(*), redmas(*)
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),
     1                nlast(numatm), norbs, nelecs,nalpha,nbeta,
     2                nclose,nopen,ndumy,fract
      common /elemts/ elemnt(107)
      common /iofile/ mfgr,mfgw
      logical vib1, vib2, vib3, vib4
      common /fokmat/ f(mpack*2)
      character*2 elemnt
      dimension vanrad(107), ijf(10), fij(10)
      save vanrad
      data vanrad/0.32d0,0.93d0,
     + 1.23d0,0.90d0,0.82d0,0.77d0,0.75d0,0.73d0,0.72d0,0.71d0,
     + 1.54d0,1.36d0,1.18d0,1.11d0,1.06d0,1.02d0,0.99d0,0.98d0,
     + 2.03d0,1.74d0,1.44d0,1.32d0,1.22d0,1.18d0,1.17d0,1.17d0,
     + 1.16d0,1.15d0,1.17d0,1.25d0,1.26d0,1.22d0,1.20d0,1.16d0,
     + 1.14d0,1.12d0,2.16d0,1.91d0,1.62d0,1.45d0,1.34d0,1.30d0,
     + 1.27d0,1.25d0,1.25d0,1.28d0,1.34d0,1.48d0,1.44d0,1.41d0,
     + 1.40d0,1.36d0,1.33d0,1.31d0,2.35d0,1.98d0,1.69d0,1.65d0,
     + 1.65d0,1.64d0,1.63d0,1.62d0,1.85d0,1.61d0,1.59d0,1.59d0,
     + 1.58d0,1.57d0,1.56d0,1.56d0,1.56d0,1.44d0,1.34d0,1.30d0,
     + 1.28d0,1.26d0,1.27d0,1.30d0,1.34d0,1.49d0,1.48d0,1.47d0,
     + 1.46d0,1.46d0,1.45d0,1.45d0,21*1.45d0/
      n3=numat*3
c
c    compute interatomic distances.
c
      l=0
      do 10 i=1,numat
         do 10 j=1,i-1
            l=l+1
   10 rij(l)=dsqrt((coord(1,j)-coord(1,i))**2+
     1            (coord(2,j)-coord(2,i))**2+
     2            (coord(3,j)-coord(3,i))**2)+1.d-10
c
c     analyse vibrations
c
      write(mfgw,'(''1'',//10x,''description of vibrations'',/)')
      iline=0
      do 120 k=1,n3
         if(dabs(eigs(k)).lt.50.0d0) goto 120
         vib1=.true.
         vib2=.true.
         vib3=.true.
         vib4=.true.
         j3=0
         l=0
         tot=0.0d0
         linear=0
         j1=-2
         do 70 j=1,numat
            j1=j1+3
            i1=-2
            do 70 i=1,j-1
               i1=i1+3
               vdw=(vanrad(nat(i))+vanrad(nat(j)))*1.5d0
               l=l+1
               f(l)=0.0d0
               if(   rij(l)  .lt.  vdw) then
c
c calculate energy term between the two atoms
c
                  eab=0.0d0
                  do 20 jj=j1,j1+2
                     do 20 ii=i1,i1+2
   20             eab=eab+vibs(jj,k)*hess((jj*(jj-1))/2+ii)*vibs(ii,k)
                  eb=0.0d0
                  do 40 jj=j1,j1+2
                     do 30 ii=j1,jj
   30                eb=eb+vibs(jj,k)*hess((jj*(jj-1))/2+ii)*vibs(ii,k)*
     12.d0
   40             eb=eb-vibs(jj,k)*hess((jj*(jj+1))/2)*vibs(jj,k)
                  ea=0.0d0
                  do 60 jj=i1,i1+2
                     do 50 ii=i1,jj
   50                ea=ea+vibs(jj,k)*hess((jj*(jj-1))/2+ii)*vibs(ii,k)*
     12.d0
   60             ea=ea-vibs(jj,k)*hess((jj*(jj+1))/2)*vibs(jj,k)
                  linear=linear+1
                  f(l)=ea+eab*2.d0+eb
                  tot=tot+f(l)
               endif
   70    continue
c
c  now to sort f into decending order
c
         do 90 i=1,10
            sum=-100.d0
            do 80 j=1,l
               if(dabs(f(j)).gt.sum)then
                  jj=j
                  sum=dabs(f(j))
               endif
   80       continue
            if(sum.lt.0.d0)goto 100
            fij(i)=sum
            f(jj)=-1.d-5
            ijf(i)=jj
c#      write(mfgw,*)fij(i),ijf(i)
   90    continue
         i=10
  100    linear=i
         sum=1.d0/(tot+1.d-8)
         do 110 ij=1,linear
            j=0.5d0*(0.99d0+dsqrt(1.d0+8.d0*ijf(ij)))
            i=ijf(ij)-(j*(j-1))/2
            j=j+1
            xj=coord(1,j)
            yj=coord(2,j)
            zj=coord(3,j)
            j1=3*j-2
            j2=j1+1
            j3=j2+1
            i3=0
            xi=coord(1,i)
            yi=coord(2,i)
            zi=coord(3,i)
            i1=3*i-2
            i2=i1+1
            i3=i2+1
            x= vibs(j1,k)-vibs(i1,k)
            y= vibs(j2,k)-vibs(i2,k)
            z= vibs(j3,k)-vibs(i3,k)
            e=fij(ij)*sum*100.d0
c#            if(dabs(e).gt.110)goto 120
            shift=x*x+y*y+z*z+1.d-30
            if(dabs(e).gt.10.0d0.or.ij.lt.5.and.
     +         dabs(e).gt.0.1d0) then
               shift=dsqrt(shift)
               radial=((x*(xi-xj)+y*(yi-yj)+z*(zi-zj))
     1                  /(shift*rij(ijf(ij))))**2*100.d0
               if (vib1) then
               write(mfgw,'(/,'' vibration'',i4,''            atom pair
     1 '',''    energy contribution              radial'')')k
                  ans=100.d0*dsqrt(fij(ij)*1.d5*6.023d23)/
     +                (2.998d10*3.14159d0*2.d0)/eigs(k)
                    ans=dmin1(999.9d0,dmax1(-99.9d0,ans))
               write(mfgw,'('' freq.   '',f9.2,6x,1a2,i2,
     1'' -- '',a2,i2, ''         '',f6.1,''% ('',f5.1,''%)'',f18.1
     2,''%'')')
     3eigs(k),elemnt(nat(i)),i,elemnt(nat(j)),j,e,ans,radial
c#      write(6,*)ans
                  vib1=.false.
               elseif (vib2) then
                  vib2=.false.
                  write(mfgw,'('' t-dipole'',f9.4,6x,1a2,i2,
     1'' -- '',a2,i2, ''         '',f6.1,''%'',f27.1,''%'')')
     2dipt(k),elemnt(nat(i)),i,elemnt(nat(j)),j,e,radial
               elseif (vib3) then
                  vib3=.false.
                  write(mfgw,'('' travel  '',f9.4,6x,1a2,i2,
     1'' -- '',a2,i2, ''         '',f6.1,''%'',f27.1,''%'')')
     2travel(k),elemnt(nat(i)),i,elemnt(nat(j)),j,e,radial
               elseif (vib4) then
                  vib4=.false.
                  write(mfgw,'('' red. mass'',f8.4,6x,1a2,i2,
     1'' -- '',a2,i2, ''         '',f6.1,''%'',f27.1,''%'')')
     2redmas(k),elemnt(nat(i)),i,elemnt(nat(j)),j,e,radial
               else
                  iline=iline+1
               write(mfgw,'(''                        '',1a2,i2,
     1'' -- '',a2,i2, ''         '',f6.1,''%'',f27.1,''%'')')
     2elemnt(nat(i)),i,elemnt(nat(j)),j,e,radial
               endif
            endif
  110    continue
         iline=iline+6
         if(vib1)write(mfgw,'(/,'' vibration'',i4)')k
         if(vib1)write(mfgw,'(  '' freq.    '',f8.2)')eigs(k)
         if(vib2)write(mfgw,'(  '' t-dipole '',f8.4)')dipt(k)
         if(vib3)write(mfgw,'(  '' travel   '',f8.4)')travel(k)
         if(vib4)write(mfgw,'(  '' red. mass'',f8.4)')redmas(k)
         if(iline.gt.52)then
            iline=0
            write(mfgw,'(''1'')')
         endif
  120 continue
      return
      end
      subroutine axis(coord,numat,a,b,c,sumw, mass,evec)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      dimension coord(3,numat)
      common /keywrd/ keywrd
************************************************************************
*
*  axis calculates the three moments of inertia and the molecular
*       weight.  the moments of inertia are returned in a, b, and c.
*       the molecular weight in sumw.
*       the units of inertia are 10**(-40)gram-cm**2,
*       and mol.weight in atomic-mass-units. (amu's)
************************************************************************
      common /numcal/ numcal
      common /atmass/ atmass(numatm)
      common/iofile/mfgr,mfgw
      dimension t(6), x(numatm), y(numatm),
     1          z(numatm), rot(3), xyzmom(3), eig(3), evec(3,3)
      logical first
      character*241 keywrd
      save icalcn, t, first, eig, rot, xyzmom
      data t /6*0.d0/
      data icalcn /0/
      if (icalcn.ne.numcal) then
         icalcn=numcal
         first=.true.
      endif
************************************************************************
*     const1 =  10**40/(n*a*a)
*               n = avergadro's number
*               a = cm in an angstrom
*               10**40 is to allow units to be 10**(-40)gram-cm**2
*
************************************************************************
      const1 = 1.66053d0
************************************************************************
*
*     const2 = conversion factor from angstrom-amu to cm**(-1)
*
*            = (planck's constant*n*10**16)/(8*pi*pi*c)
*            = 6.62618*10**(-27)[erg-sec]*6.02205*10**23*10**16/
*              (8*(3.1415926535)**2*2.997925*10**10[cm/sec])
*
************************************************************************
      const2=16.8576522d0
c    first we centre the molecule about the centre of gravity,
c    this depends on the isotopic masses, and the cartesian geometry.
c
      sumw=1.d-20
      sumwx=0.0d0
      sumwy=0.0d0
      sumwz=0.0d0
c
      if(mass.gt.0) then
         do 10 i=1,numat
            sumw=sumw+atmass(i)
            sumwx=sumwx+atmass(i)*coord(1,i)
            sumwy=sumwy+atmass(i)*coord(2,i)
            sumwz=sumwz+atmass(i)*coord(3,i)
   10    continue
      else
         sumw=sumw+dfloat(numat)
         do 20 i=1,numat
            sumwx=sumwx+coord(1,i)
            sumwy=sumwy+coord(2,i)
            sumwz=sumwz+coord(3,i)
   20    continue
      endif
c
      if(mass.gt.0.and.first)
     1 write(mfgw,'(/10x,''molecular weight ='',f8.2,/)')
     2dmin1(99999.99d0,sumw)
      sumwx=sumwx/sumw
      sumwy=sumwy/sumw
      sumwz=sumwz/sumw
      do 30 i=1,numat
         x(i)=coord(1,i)-sumwx
         y(i)=coord(2,i)-sumwy
   30 z(i)=coord(3,i)-sumwz
************************************************************************
*
*    matrix for moments of inertia is of form
*
*           |   y**2+z**2                         |
*           |    -y*x       z**2+x**2             | -i =0
*           |    -z*x        -z*y       x**2+y**2 |
*
************************************************************************
c
c$doit asis
      do 40 i=1,6
   40 t(i)=dfloat(i)*1.0d-10
c
      if(mass.gt.0) then
         do 50 i=1,numat
            t(1)=t(1)+atmass(i)*(y(i)**2+z(i)**2)
            t(2)=t(2)-atmass(i)*x(i)*y(i)
            t(3)=t(3)+atmass(i)*(z(i)**2+x(i)**2)
            t(4)=t(4)-atmass(i)*z(i)*x(i)
            t(5)=t(5)-atmass(i)*y(i)*z(i)
            t(6)=t(6)+atmass(i)*(x(i)**2+y(i)**2)
   50    continue
      else
         do 60 i=1,numat
            t(1)=t(1)+(y(i)**2+z(i)**2)
            t(2)=t(2)-x(i)*y(i)
            t(3)=t(3)+(z(i)**2+x(i)**2)
            t(4)=t(4)-z(i)*x(i)
            t(5)=t(5)-y(i)*z(i)
            t(6)=t(6)+(x(i)**2+y(i)**2)
   60    continue
      endif
c
      call rsp(t,3,3,eig,evec)
      if(mass.gt.0.and. first.and.index(keywrd,'rc=').eq.0) then
      write(mfgw,'(//10x,'' principal moments of inertia in cm(-1)'',/)'
     1)
c$doit asis
         do 70 i=1,3
            if(eig(i).lt.3.d-4) then
               eig(i)=0.0d0
               rot(i)=0.0d0
            else
               rot(i)=const2/eig(i)
            endif
   70    xyzmom(i)=eig(i)*const1
         write(mfgw,'(10x,''a ='',f12.6,''   b ='',f12.6,
     1''   c ='',f12.6,/)')(rot(i),i=1,3)
         if(index(keywrd,'rc=').eq.0)
     1write(mfgw,'(//10x,'' principal moments of inertia in '',
     2''units of 10**(-40)*gram-cm**2'',/)')
         write(mfgw,'(10x,''a ='',f12.6,''   b ='',f12.6,
     1''   c ='',f12.6,/)')(xyzmom(i),i=1,3)
         c=rot(1)
         b=rot(2)
         a=rot(3)
      endif
c
c   now to orient the molecule so the chirality is preserved
c
      sum=evec(1,1)*(evec(2,2)*evec(3,3)-evec(3,2)*evec(2,3)) +
     1    evec(1,2)*(evec(2,3)*evec(3,1)-evec(2,1)*evec(3,3)) +
     2    evec(1,3)*(evec(2,1)*evec(3,2)-evec(2,2)*evec(3,1))
      if( sum .lt. 0) then
c$doit asis
         do 80 j=1,3
   80    evec(j,1)=-evec(j,1)
      endif
      do 90 i=1,numat
         coord(1,i)=x(i)
         coord(2,i)=y(i)
         coord(3,i)=z(i)
   90 continue
      if(mass.gt.0)first=.false.
      end
      function babbbc(iocca1, ioccb1, ioccb2, nmos)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      dimension iocca1(nmos), ioccb1(nmos), ioccb2(nmos)
***********************************************************************
*
* babbbc evaluates the c.i. matrix element for two microstates differing
*       by one beta electron. that is, one microstate has a beta
*       electron in psi(i) and the other microstate has an electron in
*       psi(j).
***********************************************************************
      common /xyijkl/ xy(nmeci,nmeci,nmeci,nmeci)
      common /baseoc/ occa(nmeci)
      do 10 i=1,nmos
   10 if(ioccb1(i).ne.ioccb2(i)) goto 20
   20 ij=0
      do 30 j=i+1,nmos
         if(ioccb1(j).ne.ioccb2(j)) goto 40
   30 ij=ij+iocca1(j)+ioccb1(j)
   40 ij=ij+iocca1(j)
c
c   the unpaired m.o.s are i and j
      sum=0.0d0
      do 50 k=1,nmos
   50 sum=sum+ (xy(i,j,k,k)-xy(i,k,j,k))*(ioccb1(k)-occa(k)) +
     1          xy(i,j,k,k)             *(iocca1(k)-occa(k))
      if(mod(ij,2).eq.1)sum=-sum
      babbbc=sum
      return
      end
      function babbcd(iocca1, ioccb1, iocca2, ioccb2, nmos)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      dimension iocca1(nmos), ioccb1(nmos), iocca2(nmos), ioccb2(nmos)
***********************************************************************
*
* babbcd evaluates the c.i. matrix element for two microstates differing
*       by two beta mos. one microstate has beta electrons in
*       m.o.s psi(i) and psi(j) for which the other microstate has
*       electrons in psi(k) and psi(l)
*
***********************************************************************
      common /xyijkl/ xy(nmeci,nmeci,nmeci,nmeci)
      ij=0
      do 10 i=1,nmos
   10 if(ioccb1(i) .lt. ioccb2(i)) goto 20
   20 do 30 j=i+1,nmos
         if(ioccb1(j) .lt. ioccb2(j)) goto 40
   30 ij=ij+iocca2(j)+ioccb2(j)
   40 ij=ij+iocca2(j)
      do 50 k=1,nmos
   50 if(ioccb1(k) .gt. ioccb2(k)) goto 60
   60 do 70 l=k+1,nmos
         if(ioccb1(l) .gt. ioccb2(l)) goto 80
   70 ij=ij+iocca1(l)+ioccb1(l)
   80 ij=ij+iocca1(l)
      if((ij/2)*2.eq.ij) then
         one=1.d0
      else
         one=-1.d0
      endif
      babbcd=(xy(i,k,j,l)-xy(i,l,j,k))*one
      return
      end
      subroutine bangle(xyz,i,j,k,angle)
      implicit REAL (a-h,o-z)
      dimension xyz(3,*)
*********************************************************************
*
* bangle calculates the angle between atoms i,j, and k. the
*        cartesian coordinates are in xyz.
*
*********************************************************************
      d2ij = (xyz(1,i)-xyz(1,j))**2+
     1       (xyz(2,i)-xyz(2,j))**2+
     2       (xyz(3,i)-xyz(3,j))**2
      d2jk = (xyz(1,j)-xyz(1,k))**2+
     1       (xyz(2,j)-xyz(2,k))**2+
     2       (xyz(3,j)-xyz(3,k))**2
      d2ik = (xyz(1,i)-xyz(1,k))**2+
     1       (xyz(2,i)-xyz(2,k))**2+
     2       (xyz(3,i)-xyz(3,k))**2
      xy = dsqrt(d2ij*d2jk)
      temp = 0.5d0 * (d2ij+d2jk-d2ik) / xy
      if (temp .gt. 1.0d0) temp=1.0d0
      if (temp .lt. -1.0d0) temp=-1.0d0
      angle = dacos( temp )
      return
      end
      subroutine bfn(x,bf)
      implicit REAL (a-h,o-z)
      dimension bf(13)
c**********************************************************************
c
c     bintgs forms the "b" integrals for the overlap calculation.
c
c**********************************************************************
      dimension fact(17)
      save fact
      data fact/1.d0,2.d0,6.d0,24.d0,120.d0,720.d0,5040.d0,40320.d0,
     1362880.d0,3628800.d0,39916800.d0,479001600.d0,6227020800.d0,
     28.71782912d10,1.307674368d12,2.092278989d13,3.556874281d14/
      k=12
      io=0
      absx = dabs(x)
      if (absx.gt.3.d00) go to 40
      if (absx.le.2.d00) go to 10
      last=15
      go to 60
   10 if (absx.le.1.d00) go to 20
      last=12
      go to 60
   20 if (absx.le.0.5d00) go to 30
      last=7
      go to 60
   30 if (absx.le.1.d-6) goto 90
      last=6
      go to 60
   40 expx=dexp(x)
      expmx=1.d00/expx
      bf(1)=(expx-expmx)/x
      do 50 i=1,k
   50 bf(i+1)=(i*bf(i)+(-1.d00)**i*expx-expmx)/x
      go to 110
   60 do 80 i=io,k
         y=0.0d00
         do 70 m=io,last
            xf=1.0d00
            if(m.ne.0) xf=fact(m)
   70    y=y+(-x)**m*(2*mod(m+i+1,2))/(xf*(m+i+1))
   80 bf(i+1)=y
      go to 110
   90 do 100 i=io,k
  100 bf(i+1)=(2*mod(i+1,2))/(i+1.d0)
  110 continue
      return
c
      end
      subroutine bintgs (x,k)
      implicit REAL (a-h,o-z)
      common /cmops/ a(7),b(7),sdum(3),idum(2)
      dimension fact(17)
c**********************************************************************
c
c     bintgs forms the "b" integrals for the overlap calculation.
c
c**********************************************************************
      save fact
      data fact/1.d0,2.d0,6.d0,24.d0,120.d0,720.d0,5040.d0,40320.d0,
     1362880.d0,3628800.d0,39916800.d0,479001600.d0,6227020800.d0,
     28.71782912d10,1.307674368d12,2.092278989d13,3.556874281d14/
      io=0
      absx = dabs(x)
      if (absx.gt.3.d00) go to 40
      if (absx.le.2.d00) go to 10
      if (k.le.10) go to 40
      last=15
      go to 60
   10 if (absx.le.1.d00) go to 20
      if (k.le.7) go to 40
      last=12
      go to 60
   20 if (absx.le.0.5d00) go to 30
      if (k.le.5) go to 40
      last=7
      go to 60
   30 if (absx.le.1.d-6) goto 90
      last=6
      go to 60
   40 expx=dexp(x)
      expmx=1.d00/expx
      b(1)=(expx-expmx)/x
      do 50 i=1,k
   50 b(i+1)=(i*b(i)+(-1.d00)**i*expx-expmx)/x
      go to 110
   60 do 80 i=io,k
         y=0.0d00
         do 70 m=io,last
            xf=1.0d00
            if(m.ne.0) xf=fact(m)
   70    y=y+(-x)**m*(2*mod(m+i+1,2))/(xf*(m+i+1))
   80 b(i+1)=y
      go to 110
   90 do 100 i=io,k
  100 b(i+1)=(2*mod(i+1,2))/(i+1.d0)
  110 continue
      return
c
      end
      subroutine bkrsav(tt0,hess,funct,grad,xparam,pmat,il,jl,bmat,ipow)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
INCLUDE(../m4/common/utilc)
      character elemnt*2, keywrd*241, koment*81, title*81
_IF(ipsc,tools)
      logical oroot
_ENDIF
      dimension hess(maxpar,*),grad(*),bmat(maxpar,*),ipow(9),
     1 xparam(*), pmat(*)
**********************************************************************
*
* bkrsav stores and retrieve data used in the ef geometry
*        optimisation. very similar to powsav.
*
*  on input hess   = hessian matrix, partial or whole.
*           grad   = gradients.
*           xparam = current state of parameters.
*           il     = index of hessian,
*           jl     = cycle number reached so-far.
*           bmat   = "b" matrix!
*           ipow   = indices and flags.
*           ipow(9)= 0 for restore, 1 for dump, 2 for silent dump
*
**********************************************************************
      common /geovar/ nvar,loc(2,maxpar), idumy, dumy(maxpar)
      common /elemts/ elemnt(107)
      common /geosym/ ndep,locpar(maxpar),idepfn(maxpar),
     1                     locdep(maxpar)
      common/fmatrx/oldf(maxpar),d(maxpar),vmode(maxpar),
     $u(maxpar,maxpar),dd,rmin,rmax,omin,xlamd,xlamd0,skal,
     $mode,nstep,negreq,iprnt
      common /titles/ koment,title
      common /geokst/ natoms,labels(numatm),
     1                na(numatm),nb(numatm),nc(numatm)
      common /cmpg/ geo(3,numatm)
      common /locvar/ locvar(2,maxpar)
      common /numscf/ nscf
      common /keywrd/ keywrd
      common /valvar/ valvar(maxpar),numvar
      common /densty/ p(mpack), pa(mpack), pb(mpack)
      common /alparm/ alparm(3,maxpar),x0, x1, x2, jloop
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),
     1                nlast(numatm), norbs, nelecs,nalpha,nbeta,
     2                nclose,nopen,ndumy,fract
      common /path/ latom,lparam,react(200)
      common/iofile/mfgr,mfgw
      character*80 getmop
c
_IF(ipsc,tools)
      if(oroot().and.odumpm) then
_ELSE
      if(odumpm) then
_ENDIF
      open(unit=9,file=getmop(3)
     +                         ,status='unknown',form='unformatted')
      rewind 9
      open(unit=10,file=getmop(4)
     +                         ,status='unknown',form='unformatted')
      rewind 10
      endif
      ir=9
      if(ipow(9) .eq. 1 .or. ipow(9) .eq. 2) then
         funct1=dsqrt(ddot(nvar,grad,1,grad,1))
         if(ipow(9).eq.1)then
         write(mfgw,'(//10x,''current value of gradient norm =''
     1  ,f12.6)')funct1
         write(mfgw,'(/10x,''current value of geometry'',/)')
         call geout(6)
         endif
      endif
c
c  ipow(1) and ipow(9) are used already, the rest are free for use
c  
         ipow(8)=nscf
_IF(ipsc,tools)
       if(oroot().and.odumpm) then
_ELSE
       if(odumpm) then
_ENDIF
         write(ir)ipow,il,jl,funct,tt0
         write(ir)(xparam(i),i=1,nvar)
         write(ir)(  grad(i),i=1,nvar)
         write(ir)((hess(j,i),j=1,nvar),i=1,nvar)
         write(ir)((bmat(j,i),j=1,nvar),i=1,nvar)
         write(ir)(oldf(i),i=1,nvar),(d(i),i=1,nvar),(vmode(i),i=1,nvar)
         write(ir)dd,mode,nstep,negreq
         linear=(nvar*(nvar+1))/2
         write(ir)(pmat(i),i=1,linear)
         linear=(norbs*(norbs+1))/2
         write(10)(pa(i),i=1,linear)
         if(nalpha.ne.0)write(10)(pb(i),i=1,linear)
         if(latom .ne. 0) then
            write(ir)((alparm(j,i),j=1,3),i=1,nvar)
            write(ir)jloop,x0, x1, x2
         endif
         close(9)
         close(10)
         return
      else
c#         write(6,'(//10x,'' reading data from disk''/)')
_IF(ipsc,tools)
       if(oroot()) then
_ENDIF
         read(ir,end=10,err=10)ipow,il,jl,funct,tt0
         nscf=ipow(8)
         i=tt0/1000000
         tt0=tt0-i*1000000
         write(mfgw,'(//10x,''total time used so far:'',
     1    f13.2,'' seconds'')')tt0
         write(mfgw,'(  10x,''              function:'',f17.6)')
     +     funct
         read(ir)(xparam(i),i=1,nvar)
         read(ir)(  grad(i),i=1,nvar)
         read(ir)((hess(j,i),j=1,nvar),i=1,nvar)
         read(ir)((bmat(j,i),j=1,nvar),i=1,nvar)
         read(ir)(oldf(i),i=1,nvar),(d(i),i=1,nvar),(vmode(i),i=1,nvar)
         read(ir)dd,mode,nstep,negreq
         linear=(nvar*(nvar+1))/2
         read(ir)(pmat(i),i=1,linear)
         linear=(norbs*(norbs+1))/2
c        read density matrix
         read(10)(pa(i),i=1,linear)
         if(nalpha.ne.0)read(10)(pb(i),i=1,linear)
         if(latom.ne.0) then
            read(ir)((alparm(j,i),j=1,3),i=1,nvar)
            read(ir)jloop,x0, x1, x2
            il=il+1
         endif
_IF(ipsc,tools)
        else
         write(mfgw,*)' restart not yet implemented in bkrsav'
         go to 11
        endif
_ENDIF
         close(9)
         close(10)
         return
   10    write(mfgw,'(//10x,''no restart file exists!'')')
_IF(ipsc,tools)
   11    call pend
_ELSE
         stop
_ENDIF
      endif
      end
      subroutine bonds(p)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      parameter (natms2=maxpar*maxpar-maxorb*maxorb)
      dimension p(*)
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),
     1              nlast(numatm),norbs,nelecs,nalpha,nbeta,
     2              nclose,nopen,ndumy,fract
      common /scrach/ b(maxorb,maxorb),bondab(natms2)
      common /iofile/ mfgr,mfgw
      common /corec/ core(107)
      common /vector/ c(morb2),eigs(maxorb),cbeta(morb2),eigb(maxorb)
      common /keywrd/ keywrd
      common /densty/ pdummy(mpack),pa(mpack),pb(mpack)
      common /drohf/ sdm(mpack)
c*********************************************************************
c   calculates and prints the bond indices and valencies of atoms
c   for reference, see "bond indices and valency", j.c.s.dalton,
c   armstrong,d.r., perkins,p.g. and stewart,j.j.p., 838 (1973)
c
c  on input
c           p = density matrix, lower half triangle, packed.
c               p is not altered by bonds
c
c*********************************************************************
      dimension ps(maxorb,maxorb),spinab(natms2),spna(numatm)
      dimension v(numatm),fv(numatm),sq(numatm),aq(numatm),tq(numatm),
     1pm(numatm),sp(numatm),sd(numatm),aux(numatm,numatm),pspin(mpack)
     2,spsa(numatm),spsq(numatm)
      dimension denw(maxorb,maxorb)
      logical ci,nci,kci
      character*241 keywrd
c
      ci=(index(keywrd,'c.i.')+index(keywrd,'meci').ne.0)
      kci=(index(keywrd,'micros').eq.0)
      nci=(index(keywrd,'root')+index(keywrd,'open').eq.0)
      nopn=nopen-nclose
      nelecs=nclose+nclose+nopn
      write(mfgw,'(2x,''nelecs nclose nopen nopn'',4i5)') 
     +      nelecs,nclose,nopen,nopn
c*****   calculate the degree of bonding   ************
c
      k=0
      do 20 i=1,norbs
         do 20 j=1,i
            k=k+1
            b(i,j)=p(k)
   20 b(j,i)=p(k)
c
c *******  calculate kappa factor for uhf or rohf  ******************
c
      if(index(keywrd,'uhf').ne.0) then
c****** uhf case
        zkappa=0.0d0
        do 23 n=1,nalpha
        do 23 m=1,nbeta
           sum=0.0d0
           do 27 mu=1,norbs
           l=mu+norbs*(n-1)
           k=mu+norbs*(m-1)
   27      sum=sum+c(l)*cbeta(k)
   23   zkappa=zkappa+sum**2
        zkappa=1.d0/(zkappa/dfloat(nalpha+nbeta)+0.5d0)
        else
         if(.not.ci.and.nopn.eq.0.and.nci.and.kci) then
         zkappa=1.0d0
        else
c****** rohf case
        zkappa=1.d0/(1.d0-(dfloat(nopn)/dfloat(nelecs))/2.d0)
        write(mfgw,'(10x,''rohf zkappa='',f10.5,2i5)') 
     +                   zkappa,nopen,nclose
        endif
        endif
        ij=0
        do 60 i=1,numat
         a=0.0d00
         l=nfirst(i)
         ll=nlast(i)
         do 40 j=1,i
            ij=ij+1
            k=nfirst(j)
            kk=nlast(j)
            x=0.0d0
            do 30 il=l,ll
               do 30 ih=k,kk
   30       x=x+b(il,ih)*b(il,ih)
   40    bondab(ij)=x
         x=-bondab(ij)
         do 50 j=l,ll
         a=a+b(j,j)
   50 x=x+2.d0*b(j,j)
      v(i)=x
      sd(i)=a
   60 continue
c
c
c *****  calculate active charge (aq), self charge (sq), free valence(fv)
c          total charge (tq), mulliken type promotion (pm) and statistical
c          promotion (sp)  ********************************************
c
      k=0
      do 65 i=1, numat
         do 65 j=1,i
             k=k+1
             bondab(k)=bondab(k)*zkappa
             aux(i,j)=bondab(k)
   65 aux(j,i)=bondab(k)
      do 70 i=1,numat
       da=0.0d0
         do 80 j=1,numat
  80    if(j.ne.i) da=da+aux(i,j)
      aq(i)=da
      sq(i)=(aux(i,i)-da)/2.d00
      fv(i)=v(i)-aq(i)
      tq(i)=aq(i)+sq(i)
      pm(i)=sd(i)-core(nat(i))
   70 sp(i)=tq(i)-core(nat(i))
c
c
c  ********   output    *****************
c
c
      write(mfgw,'(//)')
      write(mfgw,'(1x,10x,51(''* ''),//1x, 10x,''* '',9x,
     +          ''statistical population analysis'',9x,
     +          ''* '',//1x,10x,51(''* ''))')
      write(mfgw,'(1x//20x,''degrees of bonding''/)')
      call vecprt(bondab,numat)
      write(mfgw,'(///)')
      write(mfgw,'(1x,5x,''self-q'',4x,''activ-q'',3x,''total-q'',
     +  3x,''valence'',3x,''free-va'',1x,''stat.prom'',1x,
     +     ''mull.prom''//)')
      write(mfgw,'(1x,i2,7f10.5/)') 
     +(i,sq(i),aq(i),tq(i),v(i),fv(i),sp(i),
     +pm(i),i=1,numat)
c****** perform spin population statistical analysis
      linear=norbs*(norbs+1)/2
      if(index(keywrd,'uhf').ne.0) go to 1000
         if(.not.ci.and.nopn.eq.0.and.nci.and.kci) then
        write(mfgw,'(1x,''closed shell''//)')
        return
        else
        call dopen(c,norbs,norbs,nclose,nopen,fract)
          do 91 j=1,linear
   91      pspin(j)=sdm(j)
c       write(mfgw,'(1x,''sdm'',10e12.3)')(sdm(j),j=1,linear)
         write(mfgw,'(1x,''rohf''//)')
        go to 1002
         end if
 1000    write(mfgw,'(1x,''uhf ''//)')
        do 90  i=1,linear
   90  pspin(i)=pa(i)-pb(i)
      sum=0.0d0
      l=0
      do 100 i=1,norbs
      do 100 j=1,i
      aa=2.d0
      if(i.eq.j) aa=1.d0
      l=l+1
  100 sum=sum+aa*(pspin(l)*p(l))
      write(mfgw,'(//)')
      write(mfgw,'(10x,''nalpha-nbeta= '',f10.5,//)') sum
1002   write(mfgw,'(1x,''open shell& uhf case''//)')
      kk=0
      do 110 i=1,norbs
      do 110 j=1,i
       kk=kk+1
       ps(i,j)=pspin(kk)
  110  ps(j,i)=pspin(kk)
      write(mfgw,'(1x,10x,51(''* '')//1x,10x,''* '',9x,
     +  ''statistical spin population analysis'',9x,''* '',//
     +    1x,10x,51(''* ''))')
c evaluate  the corresponding inactive atomic and bond spin populations
      ij=0
      do 120 i=1,numat
      l=nfirst(i)
      ll=nlast(i)
      do 130 j=1,i
      ij=ij+1
      k=nfirst(j)
      kk=nlast(j)
      x=0.0d0
      do 140 il=l,ll
      do 140 ih=k,kk
  140 x=x+b(il,ih)*ps(il,ih)
  130 spinab(ij)=x
  120 continue
c evaluate the total atomic spin populations
      k=0
      do 150 i=1,numat
      do 150 j=1,i
      k=k+1
      aux(i,j)=spinab(k)
  150 aux(j,i)=spinab(k)
      do 160 i=1,numat
      da=0.0d0
      do 170 j=1,numat
  170 if(j.ne.i) da=da+aux(i,j)
      spsa(i)=da
      spsq(i)=aux(i,i)
  160 spna(i)=da+aux(i,i)
      write(mfgw,'(1x//20x,
     +           ''self unpaired and bond spin populations ''/)')
      call vecprt(spinab,numat)
      write(mfgw,'(//)')
      write(mfgw,'(10x,'' total atomic spin populations''/)')
      write(mfgw,'(1x,''atom    self uncpld spin    shared uncpld spin  
     + total uncpld spin ''///(1x,i3,3f20.5))')(i,spsq(i),spsa(i),
     1spna(i),i=1,numat)
      return
      end
      subroutine brlzon(fmatrx,fmat2d,n3,sec,vec, b, mono3, step,mode)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      dimension fmatrx((n3*(n3+1))/2), fmat2d(n3,n3), b(mono3,*)
      COMPLEX sec(mono3,mono3), vec(mono3,mono3)
***********************************************************************
*
*   if mode is 1 then
*   brlzon computes the phonon spectrum of a linear polymer given
*   the weighted hessian matrix.
*   if mode is 2 then
*   brlzon computes the electronic energy band structure of a linear
*   polymer given the fock matrix.
*
*                 on input
*
*   if mode is 1 then
*         fmatrx is the mass-weighted hessian matrix, packed lower
*                   half triangle
*         n3     is 3*(number of atoms in unit cell) = size of fmatrx
*         mono3  is 3*(number of atoms in primitive unit cell)
*         fmat2d, sec, vec are scratch arrays
*   if mode is 2 then
*         fmatrx is the fock matrix, packed lower half triangle
*         n3     is number of atomic orbitals in system = size of fmatrx
*         mono3  is number of atomic orbitals in fundamental unit cell
*         fmat2d, sec, vec are scratch arrays
*
***********************************************************************
      common /keywrd/ keywrd
      common/iofile/mfgr,mfgw
      character keywrd*241
      REAL eigs(maxpar)
      COMPLEX phase
      fact=6.023d23
      c=2.998d10
      twopi=2.d0*dacos(-1.d0)
c
c  ncells is the number of primitive unit cells in the unit cell
c
      ncells=n3/mono3
c
c  put the energy matrix into square matrix form
c
      k=0
      do 10 i=1,n3
         do 10 j=1,i
            k=k+1
   10 fmat2d(i,j)=fmatrx(k)
c
c   step is the step size in the brillouin zone (boundaries: 0.0 - 0.5),
c   there are m of these.
c   mono3 is the size of one mer (monomeric unit)
c
      m=0.5d0/step+1
      do 70 loop=1,m
         do 20 i=1,mono3
            do 20 j=1,mono3
   20    sec(i,j)=0
         cay=(loop-1)*step
         do 40 i=1,n3,mono3
            ri=(i-1)/mono3
c
c if the primitive unit cell is more than half way across the unit cell,
c consider it as being less than half way across, but in the opposite
c direction.
c
            if(ri.gt.ncells/2) ri=ri-ncells
c
c  phase is the complex phase exp(i.k.r(i)*(2pi))
c
            phase=exp(sqrt(cmplx(-1.d0,0.d0))*cay*ri*twopi)
            do 30 ii=1,mono3
               iii=ii+i-1
               do 30 jj=1,ii
   30       sec(ii,jj)=sec(ii,jj)+fmat2d(iii,jj)*phase
   40    continue
         call cdiag(sec,eigs,vec,mono3, 0)
         if(mode.eq.1)then
c
c  convert into reciprical centimeters
c
          do 50 i=1,mono3
   50     b(i,loop)=dsign(dsqrt(fact*dabs(eigs(i)*1.d5))/(c*twopi),
     1              dfloat(eigs(i)))
         else
          do 60 i=1,mono3
   60     b(i,loop)=eigs(i)
         endif
   70 continue
      bottom=1.d6
      top=-1.d6
      do 80 i=1,mono3
         do 80 j=1,m
            bottom=dmin1(bottom,b(i,j))
   80 top=dmax1(top,b(i,j))
      if(mode.eq.1)then
         write(mfgw,'(//,a,f6.3,/)')
     1' frequencies in cm(-1) for phonon spectrum across brillouin zone'
         do 90 i=1,mono3
            write(mfgw,'(/,a,i4,/)')'  band:',i
   90    write(mfgw,'(6(f6.3,f7.1))')((j-1)*step,b(i,j),j=1,m)
_IF(ipsc,tools)
         call pend
_ELSE
         stop
_ENDIF
      else
         write(mfgw,'(//,a,f6.3,/)')
     1' energies (in ev) of electronic bands in band structure'
         do 100 i=1,mono3
         write(mfgw,'(a,/,a,i4,/,a)')'  .','  curve',i,
     +              'curve data are'
  100    write(mfgw,'(6(f6.3,f7.2))')((j-1)*step,b(i,j),j=1,m)
      endif
      call dofs(b,mono3,m,fmat2d,500,bottom,top)
      return
      end
      subroutine calpar
      implicit REAL (a-h,o-z)
      common /cmpone/ uss(107),upp(107),udd(107)
      common /atomic/ eisol(107),eheat(107)
      common /alpha/ alp(107)
      common /expont/ zs(107),zp(107),zd(107)
      common /cmpga/ fn1(107),fn2(107)
      common /betas/ betas(107),betap(107),betad(107)
      common /twoele/ gss(107),gsp(107),gpp(107),gp2(107),hsp(107),
     7                gsd(107),gpd(107),gdd(107)
      common /ideas/ guess1(107,10), guess2(107,10), guess3(107,10)
      common /mndo/  ussm(107), uppm(107), uddm(107), zsm(107),zpm(107),
     1zdm(107), betasm(107), betapm(107), betadm(107), alpm(107),
     2eisolm(107), ddm(107), qqm(107), amm(107), adm(107), aqm(107)
     3,gssm(107),gspm(107),gppm(107),gp2m(107),hspm(107), polvom(107)
      common /keywrd/ keywrd
      common /multip/ dd(107),qq(107),am(107),ad(107),aq(107)
      common/iofile/mfgr,mfgw
      dimension nspqn(107)
      character keywrd*241
      dimension ussc(107), uppc(107), gssc(107), gspc(107), hspc(107),
     1gp2c(107), gppc(107), uddc(107), gsdc(107), gddc(107)
      save nspqn, ussc, uppc, uddc, gssc, gspc, hspc, gp2c, gsdc, gddc
      data nspqn/2*1,8*2,8*3,18*4,18*5,32*6,21*0/
c
c the continuation lines indicate the principal quantum number.
c
      data ussc/
     11.d0,                                                      0.d0,
     21.d0,                                               6*2.d0,0.d0,
     31.d0,                                               6*2.d0,0.d0,
     41.d0,4*2.d0,1.d0,4*2.d0,1.d0,                       6*2.d0,0.d0,
     51.d0,3*2.d0,2*1.d0,2.d0,2*1.d0,0.d0,1.d0,           6*2.d0,0.d0,
     61.d0,22*2.d0,1.d0,1.d0,                             6*2.d0,0.d0,
     721*0.d0/
      data  uppc/
     1 2*0.d0,
     2 2*0.d0,1.d0,2.d0,3.d0,4.d0,5.d0,6.d0,
     3 2*0.d0,1.d0,2.d0,3.d0,4.d0,5.d0,6.d0,
     412*0.d0,1.d0,2.d0,3.d0,4.d0,5.d0,6.d0,
     512*0.d0,1.d0,2.d0,3.d0,4.d0,5.d0,6.d0,
     626*0.d0,1.d0,2.d0,3.d0,4.d0,5.d0,6.d0,
     721*0.d0/
      data uddc/18*0.d0,
     1 2*0.d0,1.d0,2.d0,3.d0,5.d0,5.d0,6.d0,7.d0,8.d0,1.d1,1.d1,6*0.d0,
     2 2*0.d0,1.d0,2.d0,4.d0,5.d0,5.d0,7.d0,8.d0,1.d1,1.d1,1.d1,6*0.d0,
     3 2*0.d0,1.d0,6*0.d0,1.d0,6*0.d0,1.d0,2.d0,3.d0,4.d0,
     4                           5.d0,6.d0,7.d0,9.d0,1.d1,1.d1,6*0.d0,
     5 21*0.d0/
      data gssc/2*0.d0,
     1 0.d0,6*1.d0,0.d0,
     2 0.d0,6*1.d0,0.d0,
     3 0.d0,4*1.d0,0.d0,4*1.d0,0.d0,6*1.d0,0.d0,
     4 0.d0,3*1.d0,7*0.d0,6*1.d0,0.d0,
     5 0.d0,22*1.d0,2*1.d0,6*1.d0,0.d0,
     6 21*0.d0/
      data gspc/2*0.d0,
     1 2*0.d0,2.d0,4.d0,6.d0,8.d0,10.d0,0.d0,
     2 2*0.d0,2.d0,4.d0,6.d0,8.d0,10.d0,0.d0,
     312*0.d0,2.d0,4.d0,6.d0,8.d0,10.d0,0.d0,
     412*0.d0,2.d0,4.d0,6.d0,8.d0,10.d0,0.d0,
     526*0.d0,2.d0,4.d0,6.d0,8.d0,10.d0,0.d0,
     621*0.d0/
      data hspc/2*0.d0,
     1 2*0.d0,-1.d0,-2.d0,-3.d0,-4.d0,-5.d0,0.d0,
     2 2*0.d0,-1.d0,-2.d0,-3.d0,-4.d0,-5.d0,0.d0,
     312*0.d0,-1.d0,-2.d0,-3.d0,-4.d0,-5.d0,0.d0,
     412*0.d0,-1.d0,-2.d0,-3.d0,-4.d0,-5.d0,0.d0,
     526*0.d0,-1.d0,-2.d0,-3.d0,-4.d0,-5.d0,0.d0,
     621*0.d0/
      data gp2c/2*0.d0,
     1 3*0.d0,1.5d0,4.5d0,6.5d0,10.d0,0.d0,
     2 3*0.d0,1.5d0,4.5d0,6.5d0,10.d0,0.d0,
     313*0.d0,1.5d0,4.5d0,6.5d0,10.d0,0.d0,
     413*0.d0,1.5d0,4.5d0,6.5d0,10.d0,0.d0,
     527*0.d0,1.5d0,4.5d0,6.5d0,10.d0,0.d0,
     621*0.d0/
      data gppc/2*0.d0,
     1 3*0.d0,-0.5d0,-1.5d0,-0.5d0,2*0.d0,
     2 3*0.d0,-0.5d0,-1.5d0,-0.5d0,2*0.d0,
     313*0.d0,-0.5d0,-1.5d0,-0.5d0,2*0.d0,
     413*0.d0,-0.5d0,-1.5d0,-0.5d0,2*0.d0,
     527*0.d0,-0.5d0,-1.5d0,-0.5d0,2*0.d0,
     621*0.d0/
     7gsdc/18*0.d0,
     8 2*0.d0,2.d0,4.d0,6.d0,5.d0,10.d0,12.d0,14.d0,16.d0,10.d0,7*0.d0,
     9 2*0.d0,2.d0,4.d0,4.d0,5.d0,6.d0,7.d0,8.d0,0.d0,1.d1,7*0.d0,
     1 2*0.d0,2.d0,6*0.d0,2.d0,6*0.d0,2.d0,4.d0,6.d0,8.d0,10.d0,12.d0,
     2                                         14.d0,9.d0,10.d0,7*0.d0,
     321*0.d0/
      data gddc/18*0.d0,
     1 3*0.d0,1.d0,3.d0,10.d0,10.d0,15.d0,21.d0,28.d0,8*0.d0,
     2 3*0.d0,1.d0,6.d0,10.d0,15.d0,21.d0,28.d0,45.d0,8*0.d0,
     317*0.d0,1.d0,3.d0, 6.d0,10.d0,15.d0,21.d0,36.d0,8*0.d0,
     421*0.d0/
c  the data block shown above is derived from the ground-state atomic
c  configuration of the elements.  in checking it, pay careful attention
c  to the actual ground-state configuration. note also that there are no
c  configurations which have both p and d electrons in the valence shell
c
c     set scaling parameter.
      p=2.d0
      p2=p*p
      p4=p**4
      third = 1.0d0/3.0d0
      do 30 i=2,98
         if(zp(i).lt.1.d-4.and.zs(i).lt.1.d-4)goto 30
**********************************************************************
*
*   constraints on the possible values of parameters
*
**********************************************************************
         if(zp(i).lt.0.3d0) zp(i)=0.3d0
c  put in any constraints at this point
**********************************************************************
         hpp=0.5d0*(gpp(i)-gp2(i))
         hpp=dmax1(0.1d0,hpp)
         hsp(i)=dmax1(1.d-7,hsp(i))
         eisol(i)=uss(i)*ussc(i)+upp(i)*uppc(i)+udd(i)*uddc(i)+
     1         gss(i)*gssc(i)+gpp(i)*gppc(i)+gsp(i)*gspc(i)+
     2         gp2(i)*gp2c(i)+hsp(i)*hspc(i)+gsd(i)*gsdc(i)+
     3         gdd(i)*gddc(i)
         qn=nspqn(i)
         dd(i)=(2.d0*qn+1)*(4.d0*zs(i)*zp(i))**(qn+0.5d0)/(zs(i)+zp(i))
     1**(2.d0*qn+2)/dsqrt(3.d0)
         ddm(i)=dd(i)
         qq(i)=dsqrt((4.d0*qn*qn+6.d0*qn+2.d0)/20.d0)/zp(i)
         qqm(i)=qq(i)
c     calculate additive terms, in atomic units.
         jmax=5
         gdd1= (p2*hsp(i)/(27.21d0* 4.0d0*dd(i)**2))**(third)
         gqq= (p4*hpp/(27.21d0*48.0d0*qq(i)**4))**0.2d0
         d1=gdd1
         d2=gdd1+0.04d0
         q1=gqq
         q2=gqq+0.04d0
         do 10 j=1,jmax
            df=d2-d1
            hsp1= 2.0d0*d1 - 2.0d0/dsqrt(4.0d0*dd(i)**2+1.0d0/d1**2)
            hsp2= 2.0d0*d2 - 2.0d0/dsqrt(4.0d0*dd(i)**2+1.0d0/d2**2)
            hsp1= hsp1/p2
            hsp2= hsp2/p2
            d3= d1 + df*(hsp(i)/27.21d0-hsp1)/(hsp2-hsp1)
            d1= d2
            d2= d3
   10    continue
         do 20 j=1,jmax
            qf=q2-q1
            hpp1= 4.0d0*q1 - 8.0d0/dsqrt(4.0d0*qq(i)**2+1.0d0/q1**2)
     1          + 4.0d0/dsqrt(8.0d0*qq(i)**2+1.0d0/q1**2)
            hpp2= 4.0d0*q2 - 8.0d0/dsqrt(4.0d0*qq(i)**2+1.0d0/q2**2)
     1          + 4.0d0/dsqrt(8.0d0*qq(i)**2+1.0d0/q2**2)
            hpp1= hpp1/p4
            hpp2= hpp2/p4
            q3= q1 + qf*(hpp/27.21d0-hpp1)/(hpp2-hpp1)
            q1= q2
            q2= q3
   20    continue
         am(i)= gss(i)/27.21d0
         ad(i)= d2
         aq(i)= q2
         amm(i)=am(i)
         adm(i)=ad(i)
         aqm(i)=aq(i)
   30 continue
      eisol(1)=uss(1)
      am(1)=gss(1)/27.21d0
      ad(1)=am(1)
      aq(1)=am(1)
      amm(1)=am(1)
      adm(1)=ad(1)
      aqm(1)=aq(1)
c
c     debug printing.
c     this is formatted for direct insertion into 'param'
c
      if(index(keywrd,'dep').eq.0) return
      write(mfgw,50)
   50    format(1h ,1x,'output includes debug information',//)
      if(index(keywrd,' am1').ne.0) then
      do 60 i=1,107
         if(zs(i).eq.0) goto 60
         write(mfgw,'(''c'',20x,''data for element'',i3)')i
         write(mfgw,'(6x,''data ussam1('',i3,'')/'',f16.7,''d0/'')')
     1                    i,uss(i)
         if(upp(i) .ne. 0.d0)
     1write(mfgw,'(6x,''data uppam1('',i3,'')/'',f16.7,''d0/'')')
     +     i,upp(i)
         if(udd(i) .ne. 0.d0)
     1write(mfgw,'(6x,''data uddam1('',i3,'')/'',f16.7,''d0/'')')
     +     i,udd(i)
         if(betas(i) .ne. 0.d0)
     1write(mfgw,'(6x,''data betasa('',i3,'')/'',f16.7,''d0/'')')
     2i,betas(i)
         if(betap(i) .ne. 0.d0)
     1write(mfgw,'(6x,''data betapa('',i3,'')/'',f16.7,''d0/'')')
     2i,betap(i)
         if(betad(i) .ne. 0.d0)
     1write(mfgw,'(6x,''data betada('',i3,'')/'',f16.7,''d0/'')')
     2i,betad(i)
         write(mfgw,'(6x,''data zsam1 ('',i3,'')/'',f16.7,''d0/'')')
     1i,zs(i)
         if(zp(i) .ne. 0.d0)
     1write(mfgw,'(6x,''data zpam1 ('',i3,'')/'',f16.7,''d0/'')')
     +     i,zp(i)
         if(zd(i) .ne. 0.d0)
     1write(mfgw,'(6x,''data zdam1 ('',i3,'')/'',f16.7,''d0/'')')
     +     i,zd(i)
         write(mfgw,'(6x,''data alpam1('',i3,'')/'',f16.7,''d0/'')')
     1i,alp(i)
         write(mfgw,'(6x,''data eisola('',i3,'')/'',f16.7,''d0/'')')
     1i,eisol(i)
         if(gss(i) .ne. 0.d0)
     1write(mfgw,'(6x,''data gssam1('',i3,'')/'',f16.7,''d0/'')')
     2i,gss(i)
         if(gsp(i) .ne. 0.d0)
     1write(mfgw,'(6x,''data gspam1('',i3,'')/'',f16.7,''d0/'')')
     2i,gsp(i)
         if(gpp(i) .ne. 0.d0)
     1write(mfgw,'(6x,''data gppam1('',i3,'')/'',f16.7,''d0/'')')
     2i,gpp(i)
         if(gp2(i) .ne. 0.d0)
     1write(mfgw,'(6x,''data gp2am1('',i3,'')/'',f16.7,''d0/'')')
     2i,gp2(i)
         if(hsp(i) .ne. 0.d0)
     1write(mfgw,'(6x,''data hspam1('',i3,'')/'',f16.7,''d0/'')')
     2i,hsp(i)
         if(dd(i) .ne. 0.d0)
     1write(mfgw,'(6x,''data ddam1 ('',i3,'')/'',f16.7,''d0/'')')
     +     i,dd(i)
         if(qq(i) .ne. 0.d0)
     1write(mfgw,'(6x,''data qqam1 ('',i3,'')/'',f16.7,''d0/'')')
     +     i,qq(i)
         write(mfgw,'(6x,''data amam1 ('',i3,'')/'',f16.7,''d0/'')')
     1i,am(i)
         if(ad(i) .ne. 0.d0)
     1write(mfgw,'(6x,''data adam1 ('',i3,'')/'',f16.7,''d0/'')')
     +     i,ad(i)
         if(aq(i) .ne. 0.d0)
     1write(mfgw,'(6x,''data aqam1 ('',i3,'')/'',f16.7,''d0/'')')
     +     i,aq(i)
         if(fn1(i) .ne. 0.d0)
     1write(mfgw,'(6x,''data fn1am1('',i3,'')/'',f16.7,''d0/'')')
     +     i,fn1(i)
         if(fn2(i) .ne. 0.d0)
     1write(mfgw,'(6x,''data fn2am1('',i3,'')/'',f16.7,''d0/'')')
     +     i,fn2(i)
         do 40 j=1,10
            if(guess1(i,j) .eq.0.d0) goto 40
            write(mfgw,'(6x,''data guesa1('',i3,'','',i1,'')/'',
     1f16.7,''d0/'')')i,j,guess1(i,j)
            write(mfgw,'(6x,''data guesa2('',i3,'','',i1,'')/'',
     1f16.7,''d0/'')')i,j,guess2(i,j)
            write(mfgw,'(6x,''data guesa3('',i3,'','',i1,'')/'',
     1f16.7,''d0/'')')i,j,guess3(i,j)
   40    continue
   60 continue
      elseif(index(keywrd,' pm3').ne.0)then
      do 62 i=1,107
         if(zs(i).eq.0) goto 62
         write(mfgw,'(''c'',20x,''data for element'',i3)')i
         write(mfgw,
     +   '(6x,''data usspm3('',i3,'')/'',f16.7,''d0/'')')
     1                    i,uss(i)
         if(upp(i) .ne. 0.d0)
     1write(mfgw,'(6x,''data upppm3('',i3,'')/'',f16.7,''d0/'')')
     +     i,upp(i)
         if(udd(i) .ne. 0.d0)
     1write(mfgw,'(6x,''data uddpm3('',i3,'')/'',f16.7,''d0/'')')
     +     i,udd(i)
         if(betas(i) .ne. 0.d0)
     1write(mfgw,'(6x,''data betasp('',i3,'')/'',f16.7,''d0/'')')
     2i,betas(i)
         if(betap(i) .ne. 0.d0)
     1write(mfgw,'(6x,''data betapp('',i3,'')/'',f16.7,''d0/'')')
     2i,betap(i)
         if(betad(i) .ne. 0.d0)
     1write(mfgw,'(6x,''data betadp('',i3,'')/'',f16.7,''d0/'')')
     2i,betad(i)
         write(mfgw,'(6x,''data zspm3 ('',i3,'')/'',f16.7,''d0/'')')
     1i,zs(i)
         if(zp(i) .ne. 0.d0)
     1write(mfgw,'(6x,''data zppm3 ('',i3,'')/'',f16.7,''d0/'')')
     +     i,zp(i)
         if(zd(i) .ne. 0.d0)
     1write(mfgw,'(6x,''data zdpm3 ('',i3,'')/'',f16.7,''d0/'')')
     +     i,zd(i)
         write(mfgw,'(6x,''data alppm3('',i3,'')/'',f16.7,''d0/'')')
     1i,alp(i)
         write(mfgw,'(6x,''data eisolp('',i3,'')/'',f16.7,''d0/'')')
     1i,eisol(i)
         if(gss(i) .ne. 0.d0)
     1write(mfgw,'(6x,''data gsspm3('',i3,'')/'',f16.7,''d0/'')')
     2i,gss(i)
         if(gsp(i) .ne. 0.d0)
     1write(mfgw,'(6x,''data gsppm3('',i3,'')/'',f16.7,''d0/'')')
     2i,gsp(i)
         if(gpp(i) .ne. 0.d0)
     1write(mfgw,'(6x,''data gpppm3('',i3,'')/'',f16.7,''d0/'')')
     2i,gpp(i)
         if(gp2(i) .ne. 0.d0)
     1write(mfgw,'(6x,''data gp2pm3('',i3,'')/'',f16.7,''d0/'')')
     2i,gp2(i)
         if(hsp(i) .ne. 0.d0)
     1write(mfgw,'(6x,''data hsppm3('',i3,'')/'',f16.7,''d0/'')')
     2i,hsp(i)
         if(dd(i) .ne. 0.d0)
     1write(mfgw,'(6x,''data ddpm3 ('',i3,'')/'',f16.7,''d0/'')')
     +     i,dd(i)
         if(qq(i) .ne. 0.d0)
     1write(mfgw,'(6x,''data qqpm3 ('',i3,'')/'',f16.7,''d0/'')')
     +     i,qq(i)
         write(mfgw,'(6x,''data ampm3 ('',i3,'')/'',f16.7,''d0/'')')
     1i,am(i)
         if(ad(i) .ne. 0.d0)
     1write(mfgw,'(6x,''data adpm3 ('',i3,'')/'',f16.7,''d0/'')')
     +     i,ad(i)
         if(aq(i) .ne. 0.d0)
     1write(mfgw,'(6x,''data aqpm3 ('',i3,'')/'',f16.7,''d0/'')')
     +     i,aq(i)
         if(fn1(i) .ne. 0.d0)
     1write(mfgw,'(6x,''data fn1pm3('',i3,'')/'',f16.7,''d0/'')')
     +     i,fn1(i)
         if(fn2(i) .ne. 0.d0)
     1write(mfgw,'(6x,''data fn2pm3('',i3,'')/'',f16.7,''d0/'')')
     +     i,fn2(i)
         do 42 j=1,10
            if(guess1(i,j) .eq.0.d0) goto 42
            write(mfgw,'(6x,''data guesp1('',i3,'','',i1,'')/'',
     1f16.7,''d0/'')')i,j,guess1(i,j)
            write(mfgw,'(6x,''data guesp2('',i3,'','',i1,'')/'',
     1f16.7,''d0/'')')i,j,guess2(i,j)
            write(mfgw,'(6x,''data guesp3('',i3,'','',i1,'')/'',
     1f16.7,''d0/'')')i,j,guess3(i,j)
   42    continue
   62 continue
      else
      do 64 i=1,107
         if(zs(i).eq.0) goto 64
         write(mfgw,'(''c'',20x,''data for element'',i3)')i
         write(mfgw,
     +       '(6x,''data ussm  ('',i3,'')/'',f16.7,''d0/'')')
     1                    i,uss(i)
         if(upp(i) .ne. 0.d0)
     1write(mfgw,'(6x,''data uppm  ('',i3,'')/'',f16.7,''d0/'')')
     +     i,upp(i)
         if(udd(i) .ne. 0.d0)
     1write(mfgw,'(6x,''data uddm  ('',i3,'')/'',f16.7,''d0/'')')
     +     i,udd(i)
         if(betas(i) .ne. 0.d0)
     1write(mfgw,'(6x,''data betasm('',i3,'')/'',f16.7,''d0/'')')
     2i,betas(i)
         if(betap(i) .ne. 0.d0)
     1write(mfgw,'(6x,''data betapm('',i3,'')/'',f16.7,''d0/'')')
     2i,betap(i)
         if(betad(i) .ne. 0.d0)
     1write(mfgw,'(6x,''data betadm('',i3,'')/'',f16.7,''d0/'')')
     2i,betad(i)
         write(mfgw,'(6x,''data zsm   ('',i3,'')/'',f16.7,''d0/'')')
     1i,zs(i)
         if(zp(i) .ne. 0.d0)
     1write(mfgw,'(6x,''data zpm   ('',i3,'')/'',f16.7,''d0/'')')
     +     i,zp(i)
         if(zd(i) .ne. 0.d0)
     1write(mfgw,'(6x,''data zdm   ('',i3,'')/'',f16.7,''d0/'')')
     +     i,zd(i)
         write(mfgw,'(6x,''data alpm  ('',i3,'')/'',f16.7,''d0/'')')
     1i,alp(i)
         write(mfgw,'(6x,''data eisolm('',i3,'')/'',f16.7,''d0/'')')
     1i,eisol(i)
         if(gss(i) .ne. 0.d0)
     1write(mfgw,'(6x,''data gssm  ('',i3,'')/'',f16.7,''d0/'')')
     2i,gss(i)
         if(gsp(i) .ne. 0.d0)
     1write(mfgw,'(6x,''data gspm  ('',i3,'')/'',f16.7,''d0/'')')
     2i,gsp(i)
         if(gpp(i) .ne. 0.d0)
     1write(mfgw,'(6x,''data gppm  ('',i3,'')/'',f16.7,''d0/'')')
     2i,gpp(i)
         if(gp2(i) .ne. 0.d0)
     1write(mfgw,'(6x,''data gp2m  ('',i3,'')/'',f16.7,''d0/'')')
     2i,gp2(i)
         if(hsp(i) .ne. 0.d0)
     1write(mfgw,'(6x,''data hspm  ('',i3,'')/'',f16.7,''d0/'')')
     2i,hsp(i)
         if(dd(i) .ne. 0.d0)
     1write(mfgw,'(6x,''data ddm   ('',i3,'')/'',f16.7,''d0/'')')
     +     i,dd(i)
         if(qq(i) .ne. 0.d0)
     1write(mfgw,'(6x,''data qqm   ('',i3,'')/'',f16.7,''d0/'')')
     +     i,qq(i)
         write(mfgw,'(6x,''data amm   ('',i3,'')/'',f16.7,''d0/'')')
     1i,am(i)
         if(ad(i) .ne. 0.d0)
     1write(mfgw,'(6x,''data adm   ('',i3,'')/'',f16.7,''d0/'')')
     +     i,ad(i)
         if(aq(i) .ne. 0.d0)
     1write(mfgw,'(6x,''data aqm   ('',i3,'')/'',f16.7,''d0/'')')
     +     i,aq(i)
         if(fn1(i) .ne. 0.d0)
     1write(mfgw,'(6x,''data fn1m  ('',i3,'')/'',f16.7,''d0/'')')
     +     i,fn1(i)
         if(fn2(i) .ne. 0.d0)
     1write(mfgw,'(6x,''data fn2m  ('',i3,'')/'',f16.7,''d0/'')')
     +     i,fn2(i)
         do 44 j=1,10
            if(guess1(i,j) .eq.0.d0) goto 44
            write(mfgw,'(6x,''data guesp1('',i3,'','',i1,'')/'',
     1f16.7,''d0/'')')i,j,guess1(i,j)
            write(mfgw,'(6x,''data guesp2('',i3,'','',i1,'')/'',
     1f16.7,''d0/'')')i,j,guess2(i,j)
            write(mfgw,'(6x,''data guesp3('',i3,'','',i1,'')/'',
     1f16.7,''d0/'')')i,j,guess3(i,j)
   44    continue
   64 continue
      endif
      return
      end
      function capcor(nat,nfirst,nlast,numat,p,h)
      implicit REAL (a-h,o-z)
      dimension p(*), h(*), nfirst(numat), nlast(numat), nat(numat)
******************************************************************
*
*    correction to electronic energy due to capped bonds
*
******************************************************************
      sum=0.0d0
      do 40 i=1,numat
         ni=nat(i)
         il=nfirst(i)
         iu=nlast(i)
         if(ni.eq.102) then
c
c   do entire row - no need to check further.
c
            j=(nlast(i)*(nlast(i)+1))/2
            ii=iu-1
            do 10 k=1,ii
               j=j-1
   10       sum=sum+p(j)*h(j)
         else
            do 30 j=1,i
               jl=nfirst(j)
               if(nat(j).eq.102)then
                  do  20 k=il,iu
                     kk=(k*(k-1))/2+jl
   20             sum=sum+p(kk)*h(kk)
               endif
   30       continue
         endif
   40 continue
c
c   double sum since we only calculated lower half, and capcor
c   will appear in 1/2*p(h+f).  only h part of f will be used.
      capcor=-sum*2.d0
      return
      end
      subroutine cdiag(a,value,vec,n, need)
c
c to find the eigenvalues and eigenvectors of a hermitian matrix.
      REAL value(*),h
      COMPLEX w(6000)
      COMPLEX a(n,*),vec(n,*)
      COMPLEX fm06as
      ia=n
      iv=n
c
c reduce matrix to a tri-diagonal hermitian matrix.
      call me08a(a,w,w(n+1),n,ia,w(2*n+1))
c
c find the eigenvalues and eigenvectors of the tri-diagonal matrix
      call ec08c(w,w(n+1),value,vec,n,iv,w(2*n+1))
      if(need.eq.0) goto 50
      if(n.lt.2)return
c
c the eigenvectors of the original matrix are now found by
c back transformation using information store in the upper
c triangle of matrix a (by me08)
      do 40 ii=3,n
         i=n-ii+1
         h=w(n+i+1)*conjg(a(i,i+1))
         if(h)10,40,10
   10    do 30 l=1,n
            i1=i+1
            s=fm06as(n-i,a(i,i+1),ia,vec(i+1,l),1)
            s=s/h
            do 20 k=i1,n
   20       vec(k,l)=vec(k,l)+conjg(a(i,k))*s
   30    continue
   40 continue
   50 call mops(value,vec,n)
      return
      end
      subroutine chrge(p,q)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      dimension p(*),q(*)
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),
     1                nlast(numatm), norbs, nelecs,nalpha,nbeta,
     2                nclose,nopen,ndumy,fract
c***********************************************************************
c
c      chrge stores in q the total electron densities on the atoms
c
c      on input p      = density matrix
c
c      on output q     = atom electron densities
c
c***********************************************************************
      k=0
      do 10 i=1,numat
         ia=nfirst(i)
         ib=nlast(i)
         q(i)=0.0d0
         do 10 j=ia,ib
            k=k+j
   10 q(i)=q(i)+p(k)
      return
      end
      subroutine cnvg(pnew, p, p1,norbs, niter, pl)
      implicit REAL (a-h,o-z)
      dimension p1(*), p(*), pnew(*)
      logical extrap
c***********************************************************************
c
c  cnvg is a two-point interpolation routine for speeding convergence
c       of the density matrix.
c
c on output p      = new density matrix
c           p1     = diagonal of old density matrix
c           pl     = largest difference between old and new density
c                    matrix diagonal elements
c***********************************************************************
      common/keywrd/ keywrd
      common /numcal/ numcal
      save rhfuhf
      save icalcn
      character*241 keywrd
      data icalcn/0/
      if (icalcn.ne.numcal) then
         icalcn=numcal
         if(index(keywrd,'uhf').ne.0)then
            rhfuhf=1.d0
         else
            rhfuhf=2.d0
         endif
      endif
      pl=0.0d00
      faca=0.0d00
      damp=1.d10
      if(niter.gt.3)damp=0.05d0
      facb=0.0d00
      fac=0.0d00
      ii=mod(niter,3)
      extrap=ii.ne.0
      sum1=0.0d0
      k=0
      do 20 i=1,norbs
         k=k+i
         a=pnew(k)
         sum1=sum1+a
         sa=dabs(a-p(k))
         if (sa.gt.pl) pl=sa
         if (extrap) go to 10
         faca=faca+sa**2
         facb=facb+(a-2.d00*p(k)+p1(i))**2
   10    p1(i)=p(k)
   20 p(k)=a
      if (facb.le.0.0d00) go to 30
      if (faca.lt.(100.d00*facb)) fac=dsqrt(faca/facb)
   30 ie=0
      sum2=0.0d0
      do 50 i=1,norbs
         ii=i-1
         do 40 j=1,ii
            ie=ie+1
            a=pnew(ie)
            p(ie)=a+fac*(a-p(ie))
            pnew(ie)=p(ie)
   40    continue
         ie=ie+1
         if(dabs(p(ie)-p1(i)) .gt. damp) then
            p(ie)=p1(i)+dsign(damp,p(ie)-p1(i))
         else
            p(ie)=p(ie)+fac*(p(ie)-p1(i))
         endif
         p(ie)=dmin1(rhfuhf,dmax1(p(ie),0.d0))
         sum2=sum2+p(ie)
   50 pnew(ie)=p(ie)
c
c   re-normalize if any density matrix elements have been truncated
c
      sum0=sum1
   60 if(sum2.gt.1.d-3)then
         sum=sum1/sum2
      else
         sum=0.0d0
      endif
      sum1=sum0
      if(sum2.gt.1.d-3.and.dabs(sum-1.d0).gt.1.d-5)then
c#      write(6,'(6f12.6)')(p((i*(i+1))/2),i=1,norbs)
         sum2=0.0d0
         do 70 i=1,norbs
            j=(i*(i+1))/2
c
c   add on a small number in case an occupancy is exactly zero
c
            p(j)=p(j)*sum+1.d-20
            p(j)=dmax1(p(j),0.d0)
c
c  set up renormalization over partly occupied m.o.'s only.  full m.o.'s
c  can't be filled any more
c
            if(p(j).gt.rhfuhf)then
               p(j)=rhfuhf
               sum1=sum1-rhfuhf
            else
               sum2=sum2+p(j)
            endif
   70    pnew(j)=p(j)
         goto 60
      endif
      return
      end
      subroutine coe(x1,y1,z1,x2,y2,z2,pq1,pq2,c,r)
      implicit REAL (a-h,o-z)
      integer pq1,pq2,pq
      dimension c(75)
      xy=(x2-x1)**2+(y2-y1)**2
      r=dsqrt(xy+(z2-z1)**2)
      xy=dsqrt(xy)
      if (xy.lt.1.d-10) go to 10
      ca=(x2-x1)/xy
      cb=(z2-z1)/r
      sa=(y2-y1)/xy
      sb=xy/r
      go to 50
   10 if (z2-z1) 20,30,40
   20 ca=-1.d0
      cb=-1.d0
      sa=0.0d0
      sb=0.0d0
      go to 50
   30 ca=0.0d0
      cb=0.0d0
      sa=0.0d0
      sb=0.0d0
      go to 50
   40 ca=1.d0
      cb=1.d0
      sa=0.0d0
      sb=0.0d0
   50 continue
      do 60 i=1,75
   60 c(i)=0.0d0
      if (pq1.gt.pq2) go to 70
      pq=pq2
      go to 80
   70 pq=pq1
   80 continue
      c(37)=1.d0
      if (pq.lt.2) go to 90
      c(56)=ca*cb
      c(41)=ca*sb
      c(26)=-sa
      c(53)=-sb
      c(38)=cb
      c(23)=0.0d0
      c(50)=sa*cb
      c(35)=sa*sb
      c(20)=ca
      if (pq.lt.3) go to 90
      c2a=2*ca*ca-1.d0
      c2b=2*cb*cb-1.d0
      s2a=2*sa*ca
      s2b=2*sb*cb
      c(75)=c2a*cb*cb+0.5d0*c2a*sb*sb
      c(60)=0.5d0*c2a*s2b
      c(45)=0.8660254037841d0*c2a*sb*sb
      c(30)=-s2a*sb
      c(15)=-s2a*cb
      c(72)=-0.5d0*ca*s2b
      c(57)=ca*c2b
      c(42)=0.8660254037841d0*ca*s2b
      c(27)=-sa*cb
      c(12)=sa*sb
      c(69)=0.5773502691894d0*sb*sb*1.5d0
      c(54)=-0.8660254037841d0*s2b
      c(39)=cb*cb-0.5d0*sb*sb
      c(66)=-0.5d0*sa*s2b
      c(51)=sa*c2b
      c(36)=0.8660254037841d0*sa*s2b
      c(21)=ca*cb
      c(6)=-ca*sb
      c(63)=s2a*cb*cb+0.5d0*s2a*sb*sb
      c(48)=0.5d0*s2a*s2b
      c(33)=0.8660254037841d0*s2a*sb*sb
      c(18)=c2a*sb
      c(3)=c2a*cb
   90 continue
      return
      end
c****************************************************************
      function collidm(cw,rw,cnbr,rnbr,mnbr,nnbr,ishape,
     +                         jnbr,knbr)
c****************************************************************
c
c     collision check of probe with neighboring atoms
c     used by surfac only.
c
c****************************************************************
      implicit REAL (a-h,o-z)
      logical collidm
      dimension cw(3)
      dimension cnbr(3,200)
      dimension rnbr(200)
      logical mnbr(200)
      if (nnbr .le. 0) go to 20
c
c     check whether probe is too close to any neighbor
c
      do 10 i = 1, nnbr
         if (ishape .gt. 1 .and. i .eq. jnbr) go to 10
         if (ishape .eq. 3 .and. (i .eq. knbr .or. .not. mnbr(i)))
     1   go to 10
         sumrad = rw + rnbr(i)
         vect1 = dabs(cw(1) - cnbr(1,i))
         if (vect1 .ge. sumrad) go to 10
         vect2 = dabs(cw(2) - cnbr(2,i))
         if (vect2 .ge. sumrad) go to 10
         vect3 = dabs(cw(3) - cnbr(3,i))
         if (vect3 .ge. sumrad) go to 10
         sr2 = sumrad ** 2
         dd2 = vect1 ** 2 + vect2 ** 2 + vect3 ** 2
         if (dd2 .lt. sr2) go to 30
   10 continue
   20 continue
      collidm = .false.
      go to 40
   30 continue
      collidm = .true.
   40 continue
      return
      end
      subroutine compfg(xparam,int,escf,fulscf,grad,lgrad)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      dimension xparam(maxpar),grad(maxpar)
      logical lgrad, fulscf
      common /geovar/ nvar,loc(2,maxpar),idumy,dumy(maxpar)
      common /geosym/ ndep,locpar(maxpar),idepfn(maxpar),locdep(maxpar)
      common /cmpg/ geo(3,numatm)
      common /atheat/ atheat
      common /wmatrc/ wj(n2elec), wk(n2elec)
      common /enuclr/ enuclr
      common /natype/ nztype(107),mtype(30),ltype
      common /elect/ elect
      parameter (mdumy=maxpar**2-mpack)
      common /scrach/ rxyz(mpack), xdumy(mdumy)
      common /hmatrx/ h(mpack)
      common /geokst/ natoms,labels(numatm),
     1                na(numatm), nb(numatm), nc(numatm)
      common /errfn/ errfn(maxpar), aicorr(maxpar)
      common /vector/ c(morb2),eigs(maxorb),cbeta(morb2),eigb(maxorb)
      common /last/ last
      common /numcal/ numcal
      common /scftyp/ emin, limscf
      common /molmec/ htype(4),nhco(4,20),nnhco,itype
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),
     2                nlast(numatm), norbs, nelecs,nalpha,nbeta,
     3                nclose,nopen,ndumy,fract
c cosmo change a. klamt
      logical iseps, useps , upda
      common /iseps/  iseps, useps, upda
c end of cosmo change
      common/iofile/mfgr,mfgw
c***********************************************************************
c
c   compfg calculates (a) the heat of formation of the system, and
c                     (b) the gradients, if lgrad is .true.
c
c   on input  xparam = array of parameters to be used in internal coords
c             lgrad  = .true. if gradients are needed, .false. otherwise
c             int    = .true. if heat of formation is to be calculated
c             fulscf = .true. if full scf to be done, .false. otherwise.
c
c   on output escf  = heat of formation.
c             grad   = array of gradients, if lgrad = .true.
c
c***********************************************************************
      common /keywrd/keywrd
      character*241 keywrd
      logical debug, int, print, analyt, large, usedci,
     1force, times, aider
      dimension coord(3,numatm), w(n2elec), degree(3), xparef(maxpar)
     1,deltap(nmeci**2) ,delta(nmeci*maxorb)
      save icalcn,times,aider
      save degree, print, debug, analyt, usedci, force, large
      save xparef,coord
      equivalence (w,wj)
      data icalcn /0/
c                 mndo     am1      pm3      mindo/
      if (icalcn.ne.numcal) then
         icalcn=numcal
         htype(1)=6.1737d0
         htype(2)=3.3191d0
         htype(3)=7.1853d0
         htype(4)=1.7712d0
         ltype=0
         do 30 i=1,numat
            if(nat(i).lt.99)then
               do 10 j=1,ltype
   10          if(nat(i).eq.mtype(j)) goto 20
               ltype=ltype+1
               mtype(ltype)=nat(i)
               nztype(nat(i))=ltype
c
c       ltype = number of types of real atom present
c       mtype = types of real atoms present
               j=ltype
   20          continue
            endif
   30    continue
         aider=(index(keywrd,'aider').ne.0)
         times=(index(keywrd,'times').ne.0)
         analyt=(index(keywrd,'analyt').ne.0)
         if(int.and.analyt)call setupg
         degree(1)=1.d0
         if(index(keywrd,' xyz').ne.0)then
            degree(2)=1.d0
         else
            degree(2)=180.d0/3.141592652589d0
         endif
         degree(3)=degree(2)
         usedci=(nclose.ne.nopen.and.fract.ne.2.d0.and.fract.ne.0.d0
     1         .or.(index(keywrd,'c.i.').ne.0))
         force=(index(keywrd,'force').ne.0)
         large=(index(keywrd,'large') .ne. 0)
         print=(index(keywrd,'compfg') .ne. 0)
         debug=(index(keywrd,'debug') .ne. 0 .and. print)
         emin=0.0d0
         do 40 i=1,nvar
   40    xparef(i)=xparam(i)
      endif
c
c set up coordinates for current calculation
c
c       place the new values of the variables in the array geo.
c       make changes in the geometry.
      do 50 i=1,nvar
         k=loc(1,i)
         l=loc(2,i)
   50 geo(l,k)=xparam(i)
c      impose the symmetry conditions + compute the dependent-parameters
      if(ndep.ne.0) call mopsym()
c      now compute the atomic coordinates.
      if( debug ) then
         if( large ) then
            k=natoms
         else
            k=min(5,natoms)
         endif
         write(mfgw,fmt='('' internal coords'',/100(/,3f12.6))')
     1            ((geo(j,i)*degree(j),j=1,3),i=1,k)
      end if
      call gmetry(geo,coord)
      if( debug ) then
         if( large ) then
            k=numat
         else
            k=min(5,numat)
         endif
         write(mfgw,fmt='('' cartesian coords'',/100(/,3f16.9))')
     1            ((coord(j,i),j=1,3),i=1,k)
      endif
      if(int.and.analyt)rewind 2
c cosmo change a. klamt
      if (.not. useps) then
c end of cosmo change
      if(times)call timop('before mophc')
      if(int)call mophc(coord,h,w,wj,wk,enuclr)
      if(times)call timop('after mophc')
c
c compute the heat of formation.
c
      if(norbs.gt.0.and.nelecs.gt.0) then
         if(times)call timop('before iterm')
         if(int) call iterm(h, w, wj, wk, elect, fulscf,.true.)
         if(times)call timop('after iterm')
      else
         elect=0.0d0
      endif
      escf=(elect+enuclr)*23.061d0+atheat
      if(escf.lt.emin.or.emin.eq.0.d0)emin=escf
      do 60 i=1,nnhco
         call dihed(coord,nhco(1,i),nhco(2,i),nhco(3,i),nhco(4,i),angle)
         escf=escf+htype(itype)*dsin(angle)**2
   60 continue
c cosmo change a. klamt 18.7.91
      endif
      if (iseps) then
c the following routine constructs the dielectric screening surface
           call consts (coord,.true.)
c the following routine constructs dielectric response matrix ccmat
        call btoc (coord)
c a. klamt 18.7.91
        useps = .true.
        if(times) call timop('before mophc')
        if(int) call mophc(coord,h,w,wj,wk,enuclr)
        if(times) call timop('after mophc')
c
c compute the heat of formation.
c
        if(norbs.gt.0.and.nelecs.gt.0) then
          if(times) call timop('before iterm')
          if(int) call iterm(h, w, wj, wk, elect, fulscf,.true.)
          if(times) call timop('after iterm')
        else
          elect=0.0d0
        endif
        escf=(elect+enuclr)*23.060542301389d0+atheat
        if(escf.lt.emin.or.emin.eq.0.d0) emin=escf
        do 61 i=1,nnhco
         call dihed(coord,nhco(1,i),nhco(2,i),nhco(3,i),nhco(4,i),angle)
         escf=escf+htype(itype)*dsin(angle)**2
   61   continue
      endif
c end of cosmo change
c
c find derivatives if desired
c
      if(lgrad) then
         if(times)call timop('before deriv')
         call mopdv(geo,grad)
         if(times)call timop('after deriv')
      endif
      if(aider)then
c
c  add in ab initio correction
c
         do 70 i=1,nvar
   70    escf=escf+(xparam(i)-xparef(i))*aicorr(i)
      endif
      if(int.and.print)
     1write(mfgw,'(/10x,'' heat of formation'',g30.17)')escf
      if(print.and.lgrad)
     1   write(mfgw,fmt='('' gradient       '',8f8.2,(/10f8.2))')
     2                (grad(i),i=1,nvar)
c
c reform density matrix, if a c.i. done and either the last scf or a
c force calculation
c
      if(usedci.and. (last.eq.1 .or. force))
     1call mecip(c,norbs,deltap,delta)
      return
      end
      subroutine dang(a1,a2,b1,b2,rcos)
      implicit REAL (a-h,o-z)
**********************************************************************
*
*    dang  determines the angle between the points (a1,a2), (0,0),
*          and (b1,b2).  the result is put in rcos.
*
**********************************************************************
      zero=1.0d-6
      if(dabs(a1).lt.zero.and.dabs(a2).lt.zero) go to 10
      if(dabs(b1).lt.zero.and.dabs(b2).lt.zero) go to 10
      anorm=1.0d0/ dsqrt(a1**2+a2**2)
      bnorm=1.0d0/ dsqrt(b1**2+b2**2)
      a1=a1*anorm
      a2=a2*anorm
      b1=b1*bnorm
      b2=b2*bnorm
      sinth=(a1*b2)-(a2*b1)
      costh=a1*b1+a2*b2
      if(costh.gt.1.0d0) costh=1.0d0
      if(costh.lt.-1.0d0) costh=-1.0d0
      rcos= dacos(costh)
      if(dabs(rcos).lt.4.0d-4) go to 10
      if(sinth.gt.0.d0) rcos=4.0d0* dasin(1.0d00)-rcos
      rcos=-rcos
      return
   10 rcos=0.0d0
      return
      end
      subroutine datin
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      character numbrs(0:9)*1, partyp(25)*5, files*64, dummy*50,
     1          keywrd*241, text*50, txtnew*50, elemnt(107)*2,
     2          getmop*80
      common /atheat/ atheat
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),
     2                nlast(numatm), norbs, nelecs,nalpha,nbeta,
     3                nclose,nopen,ndumy,fract
      common /atomic/ eisol(107),eheat(107)
      common /keywrd/ keywrd
      common/iofile/mfgr,mfgw
      dimension  ijpars(5,1000), parsij(1000)
      save numbrs, partyp, elemnt
      data numbrs/' ','1','2','3','4','5','6','7','8','9'/
      data partyp/'uss  ','upp  ','udd  ','zs   ','zp   ','zd   ',
     1    'betas','betap','betad','gss  ','gsp  ','gpp  ','gp2  ',
     2    'hsp  ','am1  ','expc ','gauss','alp  ','gsd  ','gpd  ',
     3    'gdd  ','fn1  ','fn2  ','fn3  ','orb  '/
      data (elemnt(i),i=1,107)/'h ','he',
     1 'li','be','b ','c ','n ','o ','f ','ne',
     2 'na','mg','al','si','p ','s ','cl','ar',
     3 'k ','ca','sc','ti','v ','cr','mn','fe','co','ni','cu',
     4 'zn','ga','ge','as','se','br','kr',
     5 'rb','sr','y ','zr','nb','mo','tc','ru','rh','pd','ag',
     6 'cd','in','sn','sb','te','i ','xe',
     7 'cs','ba','la','ce','pr','nd','pm','sm','eu','gd','tb','dy',
     8 'ho','er','tm','yb','lu','hf','ta','w ','re','os','ir','pt',
     9 'au','hg','tl','pb','bi','po','at','rn',
     1 'fr','ra','ac','th','pa','u ','np','pu','am','cm','bk','cf','xx',
     2 'fm','md','cb','++','+','--','-','tv'/
      i=index(keywrd,'external=')+9
      j=index(keywrd(i:),' ')+i-1
      read(keywrd(i:j),*)iunit
      files=getmop(iunit)
      write(mfgw,
     +      '(//5x,'' parameter type      element    parameter'')')
      open(14,status='unknown',file=files)
      i=0
      nparas=0
   10 read(14,'(a40)',err=90,end=90)text
      nparas=nparas+1
      if(text.eq.' ')goto 90
      if(index(text,'end').ne.0)goto 90
      ilowa = ichar('a')
      ilowz = ichar('z')
      icapa = ichar('a')
************************************************************************
      do 20 i=1,50
         iline=ichar(text(i:i))
         if(iline.ge.ilowa.and.iline.le.ilowz) then
            text(i:i)=char(iline+icapa-ilowa)
         endif
   20 continue
************************************************************************
      if(index(text,'end') .ne. 0) goto 90
      do 30 j=1,25
         if(j.gt.21) then
            it=index(text,'fn')
            txtnew = text(1:it+2)
            if(index(txtnew,partyp(j)) .ne. 0) goto 40
         endif
         if(index(text,partyp(j)) .ne. 0) goto 40
   30 continue
      write(mfgw,'(''  faulty line:'',a)')txtnew
      write(mfgw,'(''  faulty line:'',a)')text
      write(mfgw,'(''   name not found'')')
_IF(ipsc,tools)
      call pend
_ELSE
      stop
_ENDIF
   40 iparam=j
      if(iparam.gt.21) then
         i=index(text,'fn')
         kfn=reada(text,i+3)
      else
         kfn=0
         i=index(text,partyp(j))
      endif
      k=index(text(i:),' ')+1
      dummy=text(k:)
      text=dummy
      do 50 j=1,107
   50 if(index(text,' '//elemnt(j)) .ne. 0) goto 60
      write(mfgw,'('' element not found '')')
      write(mfgw,*)' faulty line: "'//text//'"'
_IF(ipsc,tools)
      call pend
_ELSE
      stop
_ENDIF
   60 ielmnt=j
      param=reada(text,index(text,elemnt(j)))
      do 70 i=1,lpars
         if(ijpars(1,i).eq.kfn.and.ijpars(2,i).eq.ielmnt.and.
     1ijpars(3,i).eq.iparam) goto 80
   70 continue
      lpars=lpars+1
      i=lpars
   80 ijpars(1,i)=kfn
      ijpars(2,i)=ielmnt
      ijpars(3,i)=iparam
      parsij(i)=param
      goto 10
   90 continue
      if(nparas.eq.0)then
         write(mfgw,'(//10x,a)')
     +              ' external parameters file missing or empty'
_IF(ipsc,tools)
         call pend
_ELSE
         stop
_ENDIF
      endif
      close(14)
      do 120 j=1,107
         do 110 k=1,25
            do 100 i=1,lpars
               iparam=ijpars(3,i)
               kfn=ijpars(1,i)
               ielmnt=ijpars(2,i)
               if(iparam.ne.k) goto 100
               if(ielmnt.ne.j) goto 100
               param=parsij(i)
               if(kfn.ne.0)then
                  write(mfgw,'(10x,a6,11x,a2,f17.6)')
     1partyp(iparam)(:3)//numbrs(kfn)//'  ',
     2elemnt(ielmnt),param
               else
                  write(mfgw,'(10x,a6,11x,a2,f17.6)')
     1partyp(iparam)//numbrs(kfn),
     2elemnt(ielmnt),param
               endif
               call mopupd(iparam,ielmnt,param,kfn)
  100       continue
  110    continue
  120 continue
      call moldat(1)
      call calpar
      atheat=0.0d0
      eth=0.0d0
      do 130 i=1,numat
         ni=nat(i)
         atheat=atheat+eheat(ni)
  130 eth=eth+eisol(ni)
      atheat=atheat-eth*23.061d0
      return
      end
      subroutine dcart (coord,dxyz)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      dimension coord(3,*), dxyz(3,*)
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),
     1                nlast(numatm), norbs, nelecs,nalpha,nbeta,
     2                nclose,nopen,ndumy,fract
      common /densty/ p(mpack), pa(mpack), pb(mpack)
c***********************************************************************
c
c    dcart calculates the derivatives of the energy with respect to the
c          cartesian coordinates. this is done by finite differences.
c
c    the main arrays in dcart are:
c        dxyz   on exit contains the cartesian derivatives.
c
c***********************************************************************
      common /keywrd/ keywrd
      common /euler/ tvec(3,3), id
      common /molmec/ htype(4),nhco(4,20),nnhco,itype
      common /ucell/ l1l,l2l,l3l,l1u,l2u,l3u
      common /dcartc/ k1l,k2l,k3l,k1u,k2u,k3u
      common /numcal/ numcal
      common /iofile/ mfgr,mfgw
c cosmo change
      logical iseps, useps , upda
      common /iseps/  iseps, useps, upda
c end of cosmo change
      character*241 keywrd
      dimension pdi(171),padi(171),pbdi(171),
     1cdi(3,2),ndi(2),lstor1(6), lstor2(6), eng(3)
      logical debug, force, makep, anader, large
      equivalence (lstor1(1),l1l), (lstor2(1), k1l)
      save chnge, chnge2, anader, debug, force, large
      save icalcn
      data icalcn/0/
      data chnge /1.d-4/
      chnge2=chnge*0.5d0
*
* chnge is a machine-precision dependent constant
* chnge2=chnge/2
*
      if (icalcn.ne.numcal) then
         icalcn=numcal
         large = (index(keywrd,'large') .ne. 0)
         anader= (index(keywrd,'analyt') .ne. 0)
         debug = (index(keywrd,'dcart') .ne. 0)
         force = (index(keywrd,'prec')+index(keywrd,'force') .ne. 0)
      endif
      ncells=(l1u-l1l+1)*(l2u-l2l+1)*(l3u-l3l+1)
      do 10 i=1,6
         lstor2(i)=lstor1(i)
   10 lstor1(i)=0
      iofset=(ncells+1)/2
      numtot=numat*ncells
      do 20 i=1,numtot
         do 20 j=1,3
   20 dxyz(j,i)=0.0d0
      if(anader) rewind 2
      do 130 ii=1,numat
         iii=ncells*(ii-1)+iofset
         im1=ii
         if=nfirst(ii)
         im=nmidle(ii)
         il=nlast(ii)
         ndi(2)=nat(ii)
         do 30 i=1,3
   30    cdi(i,2)=coord(i,ii)
         do 130 jj=1,im1
            jjj=ncells*(jj-1)
c  form diatomic matrices
            jf=nfirst(jj)
            jm=nmidle(jj)
            jl=nlast(jj)
c   get first atom
            ndi(1)=nat(jj)
            makep=.true.
            do 120 ik=k1l,k1u
               do 120 jk=k2l,k2u
                  do 120 kl=k3l,k3u
                     jjj=jjj+1
                     kkk=kkk-1
                     do 40 l=1,3
   40                cdi(l,1)=coord(l,jj)+tvec(l,1)*ik+tvec(l,2)*jk+tvec
     1(l,3)*kl
                     if(.not. makep) goto 90
                     makep=.false.
                     ij=0
                     do 50 i=jf,jl
                        k=i*(i-1)/2+jf-1
                        do 50 j=jf,i
                           ij=ij+1
                           k=k+1
                           padi(ij)=pa(k)
                           pbdi(ij)=pb(k)
   50                pdi(ij)=p(k)
c get second atom first atom intersection
                     do 80 i=if,il
                        l=i*(i-1)/2
                        k=l+jf-1
                        do 60 j=jf,jl
                           ij=ij+1
                           k=k+1
                           padi(ij)=pa(k)
                           pbdi(ij)=pb(k)
   60                   pdi(ij)=p(k)
                        k=l+if-1
                        do 70 l=if,i
                           k=k+1
                           ij=ij+1
                           padi(ij)=pa(k)
                           pbdi(ij)=pb(k)
   70                   pdi(ij)=p(k)
   80                continue
   90                continue
                     if(ii.eq.jj) goto  120
                     if(anader)then
                        call analyt(pdi,padi,pbdi,cdi,ndi,jf,jl,if,il
     1,                 eng)
                        do 100 k=1,3
                           dxyz(k,iii)=dxyz(k,iii)-eng(k)
  100                   dxyz(k,jjj)=dxyz(k,jjj)+eng(k)
                     else
                        if( .not. force) then
                           cdi(1,1)=cdi(1,1)+chnge2
                           cdi(2,1)=cdi(2,1)+chnge2
                           cdi(3,1)=cdi(3,1)+chnge2
                           call dhc(pdi,padi,pbdi,cdi,ndi,jf,jm,jl,if,im
     1,il,                 aa,1)
                        endif
                        do 110 k=1,3
                           if( force )then
                              cdi(k,2)=cdi(k,2)-chnge2
                              call dhc(pdi,padi,pbdi,cdi,ndi,jf,jm,jl,if
     1,im,il,                 aa,1)
                           endif
                           cdi(k,2)=cdi(k,2)+chnge
                           call dhc(pdi,padi,pbdi,cdi,ndi,jf,jm,jl,if,im
     1,il,                 ee,2)
                           cdi(k,2)=cdi(k,2)-chnge2
                           if( .not. force) cdi(k,2)=cdi(k,2)-chnge2
                           deriv=(aa-ee)*23.061d0/chnge
                           dxyz(k,iii)=dxyz(k,iii)-deriv
                           dxyz(k,jjj)=dxyz(k,jjj)+deriv
  110                   continue
                     endif
  120       continue
  130 continue
      if(nnhco.ne.0)then
c
c   now add in molecular-mechanics correction to the h-n-c=o torsion
c
         del=1.d-8
         do 160 i=1,nnhco
            do 150 j=1,4
               do 140 k=1,3
                  coord(k,nhco(j,i))=coord(k,nhco(j,i))-del
                  call dihed(coord,nhco(1,i),nhco(2,i),nhco(3,i),nhco(4,
     1i),angle)
                  refh=htype(itype)*dsin(angle)**2
                  coord(k,nhco(j,i))=coord(k,nhco(j,i))+del*2.d0
                  call dihed(coord,nhco(1,i),nhco(2,i),nhco(3,i),nhco(4,
     1i),angle)
                  coord(k,nhco(j,i))=coord(k,nhco(j,i))-del
                  heat=htype(itype)*dsin(angle)**2
                  sum=(refh-heat)/(2.d0*del)
                  dxyz(k,nhco(j,i))=dxyz(k,nhco(j,i))-sum
  140          continue
  150       continue
  160    continue
      endif
c cosmo change a. klamt
c analytic calculation of the gradient of the dielectric energy a.klamt
      if (useps) call diegrd(coord,dxyz)
c     do 170 i=1,6
c 170 lstor1(i)=lstor2(i)
      if (  .not. debug) return
      write(mfgw,'(//10x,''cartesian coordinate derivatives'',//3x,
     1''number  atom '',5x,''x'',12x,''y'',12x,''z'',/)')
      if(ncells.eq.1)then
         write(mfgw,'(2i6,f13.6,2f13.6)')
     1 (i,nat(i),(dxyz(j,i),j=1,3),i=1,numtot)
      elseif(large)then
         write(mfgw,'(2i6,f13.6,2f13.6)')
     1 (i,nat((i-1)/ncells+1),(dxyz(j,i),j=1,3),i=1,numtot)
      else
         write(mfgw,'(2i6,f13.6,2f13.6)')
     1 (i,nat((i-1)/ncells+1),(dxyz(j,i)+dxyz(j,i+1)+dxyz(j,i+2)
     2,j=1,3),i=1,numtot,3)
      endif
****  irot not defined
****  if (anader) rewind irot
      if (anader) rewind 2
c end of cosmo (a. klamt) changes
      if (  .not. debug) return
      write(mfgw,'(//10x,''cartesian coordinate derivatives'',//3x,
     1''number  atom '',5x,''x'',12x,''y'',12x,''z'',/)')
      if(ncells.eq.1)then
         write(mfgw,'(2i6,f13.6,2f13.6)')
     1 (i,nat(i),(dxyz(j,i),j=1,3),i=1,numtot)
      elseif(large)then
         write(mfgw,'(2i6,f13.6,2f13.6)')
     1 (i,nat((i-1)/ncells+1),(dxyz(j,i),j=1,3),i=1,numtot)
      else
         write(mfgw,'(2i6,f13.6,2f13.6)')
     1 (i,nat((i-1)/ncells+1),(dxyz(j,i)+dxyz(j,i+1)+dxyz(j,i+2)
     2,j=1,3),i=1,numtot,3)
      endif
      if (anader) rewind 2
      return
      end
      subroutine delmol(coord,i,j,ni,nj,ia,id,ja,jd,ix,rij,tomb,isp)
      implicit REAL (a-h,o-z)
      dimension coord(3,25)
      common /derivs/ ds(16),dg(22),dr(100),tdx(3),tdy(3),tdz(3)
      common /cmpex/  g(22),tx(3),ty(3),tz(3)
      if(ni.gt.1.or.nj.gt.1) call mopro(coord,i,j,ix,rij,tomb,2)
      ib=max(ia,id)
      jb=max(ja,jd)
      do 10 k=ia,ib
         kk=k-ia
         do 10 l=k,ib
            ll=l-ia
            do 10 m=ja,jb
               mm=m-ja
               do 10 n=m,jb
                  nn=n-ja
                  isp=isp+1
                  if(nn.eq.0)then
                     if(ll.eq.0) then
c   (ss/ss)
                        dr(isp)=dg(1)
                     elseif(kk.eq.0) then
c   (sp/ss)
                        dr(isp)=dg(2)*tx(ll)+g(2)*tdx(ll)
                     else
c   (pp/ss)
                        dr(isp)=dg(3)*tx(kk)*tx(ll)
     1       +g(3)*(tdx(kk)*tx(ll)+tx(kk)*tdx(ll))
     2       +dg(4)*(ty(kk)*ty(ll)+tz(kk)*tz(ll))
     3       +g(4)*(tdy(kk)*ty(ll)+ty(kk)*tdy(ll)
     4             +tdz(kk)*tz(ll)+tz(kk)*tdz(ll))
                     endif
                  elseif(mm.eq.0) then
                     if(ll.eq.0) then
c   (ss/sp)
                        dr(isp)=dg(5)*tx(nn)+g(5)*tdx(nn)
                     elseif(kk.eq.0) then
c   (sp/sp)
                        dr(isp)=dg(6)*tx(ll)*tx(nn)
     1       +g(6)*(tdx(ll)*tx(nn)+tx(ll)*tdx(nn))
     2       +dg(7)*(ty(ll)*ty(nn)+tz(ll)*tz(nn))
     3       +g(7)*(tdy(ll)*ty(nn)+ty(ll)*tdy(nn)
     4             +tdz(ll)*tz(nn)+tz(ll)*tdz(nn))
                     else
c   (pp/sp)
                        dr(isp)=dg(8)*tx(kk)*tx(ll)*tx(nn)
     1       +g(8)*(tdx(kk)*tx(ll)*tx(nn)+tx(kk)*tdx(ll)*tx(nn)
     2             +tx(kk)*tx(ll)*tdx(nn))
     3       +dg(9)*(ty(kk)*ty(ll)+tz(kk)*tz(ll))*tx(nn)
     4       +g(9)*((tdy(kk)*ty(ll)+ty(kk)*tdy(ll)
     5              +tdz(kk)*tz(ll)+tz(kk)*tdz(ll))*tx(nn)
     6             +(ty(kk)*ty(ll)+tz(kk)*tz(ll))*tdx(nn))
     7       +dg(10)*(tx(kk)*(ty(ll)*ty(nn)+tz(ll)*tz(nn))
     8               +tx(ll)*(ty(kk)*ty(nn)+tz(kk)*tz(nn)))
     9       +g(10)*(tdx(kk)*(ty(ll)*ty(nn)+tz(ll)*tz(nn))
     1              +tdx(ll)*(ty(kk)*ty(nn)+tz(kk)*tz(nn))
     2              +tx(kk)*(tdy(ll)*ty(nn)+ty(ll)*tdy(nn)
     3                      +tdz(ll)*tz(nn)+tz(ll)*tdz(nn))
     4              +tx(ll)*(tdy(kk)*ty(nn)+ty(kk)*tdy(nn)
     5                      +tdz(kk)*tz(nn)+tz(kk)*tdz(nn)))
                     endif
                  elseif(ll.eq.0) then
c   (ss/pp)
                     dr(isp)=dg(11)*tx(mm)*tx(nn)
     1       +g(11)*(tdx(mm)*tx(nn)+tx(mm)*tdx(nn))
     2       +dg(12)*(ty(mm)*ty(nn)+tz(mm)*tz(nn))
     3       +g(12)*(tdy(mm)*ty(nn)+ty(mm)*tdy(nn)
     4              +tdz(mm)*tz(nn)+tz(mm)*tdz(nn))
                  elseif(kk.eq.0) then
c   (sp/pp)
                     dr(isp)=dg(13)*tx(ll)*tx(mm)*tx(nn)
     1       +g(13)*(tdx(ll)*tx(mm)*tx(nn)+tx(ll)*tdx(mm)*tx(nn)
     2              +tx(ll)*tx(mm)*tdx(nn))
     3       +dg(14)*tx(ll)*(ty(mm)*ty(nn)+tz(mm)*tz(nn))
     4       +g(14)*(tdx(ll)*(ty(mm)*ty(nn)+tz(mm)*tz(nn))
     5              +tx(ll)*(tdy(mm)*ty(nn)+ty(mm)*tdy(nn)
     6                      +tdz(mm)*tz(nn)+tz(mm)*tdz(nn)))
     7       +dg(15)*(ty(ll)*(ty(mm)*tx(nn)+ty(nn)*tx(mm))
     8               +tz(ll)*(tz(mm)*tx(nn)+tz(nn)*tx(mm)))
     9       +g(15)*(tdy(ll)*(ty(mm)*tx(nn)+ty(nn)*tx(mm))
     1              +tdz(ll)*(tz(mm)*tx(nn)+tz(nn)*tx(mm))
     2              +ty(ll)*(tdy(mm)*tx(nn)+ty(mm)*tdx(nn)
     3                      +tdy(nn)*tx(mm)+ty(nn)*tdx(mm))
     4              +tz(ll)*(tdz(mm)*tx(nn)+tz(mm)*tdx(nn)
     5                      +tdz(nn)*tx(mm)+tz(nn)*tdx(mm)))
                  else
c   (pp/pp)
                     dr(isp)=dg(16)*tx(kk)*tx(ll)*tx(mm)*tx(nn)
     1       +g(16)*(tdx(kk)*tx(ll)*tx(mm)*tx(nn)
     2              +tx(kk)*tdx(ll)*tx(mm)*tx(nn)
     3              +tx(kk)*tx(ll)*tdx(mm)*tx(nn)
     4              +tx(kk)*tx(ll)*tx(mm)*tdx(nn))
     5       +dg(17)*(ty(kk)*ty(ll)+tz(kk)*tz(ll))*tx(mm)*tx(nn)
     6       +g(17)*((tdy(kk)*ty(ll)+ty(kk)*tdy(ll)
     7               +tdz(kk)*tz(ll)+tz(kk)*tdz(ll))*tx(mm)*tx(nn)
     8              +(ty(kk)*ty(ll)+tz(kk)*tz(ll))
     9              *(tdx(mm)*tx(nn)+tx(mm)*tdx(nn)))
     1       +dg(18)*tx(kk)*tx(ll)*(ty(mm)*ty(nn)+tz(mm)*tz(nn))
     2       +g(18)*((tdx(kk)*tx(ll)+tx(kk)*tdx(ll))
     3                 *(ty(mm)*ty(nn)+tz(mm)*tz(nn))
     4              +tx(kk)*tx(ll)*(tdy(mm)*ty(nn)+ty(mm)*tdy(nn)
     5                             +tdz(mm)*tz(nn)+tz(mm)*tdz(nn)))
                     dr(isp)=dr(isp)
     1       +dg(19)*(ty(kk)*ty(ll)*ty(mm)*ty(nn)
     2                  +tz(kk)*tz(ll)*tz(mm)*tz(nn))
     3       +g(19)*(tdy(kk)*ty(ll)*ty(mm)*ty(nn)
     4                 +ty(kk)*tdy(ll)*ty(mm)*ty(nn)
     5                 +ty(kk)*ty(ll)*tdy(mm)*ty(nn)
     6                 +ty(kk)*ty(ll)*ty(mm)*tdy(nn)
     7                 +tdz(kk)*tz(ll)*tz(mm)*tz(nn)
     8                 +tz(kk)*tdz(ll)*tz(mm)*tz(nn)
     9                 +tz(kk)*tz(ll)*tdz(mm)*tz(nn)
     1                 +tz(kk)*tz(ll)*tz(mm)*tdz(nn))
     2       +dg(20)*(tx(kk)*(tx(mm)*(ty(ll)*ty(nn)+tz(ll)*tz(nn))
     3                          +tx(nn)*(ty(ll)*ty(mm)+tz(ll)*tz(mm)))
     4                  +tx(ll)*(tx(mm)*(ty(kk)*ty(nn)+tz(kk)*tz(nn))
     5                          +tx(nn)*(ty(kk)*ty(mm)+tz(kk)*tz(mm))))
c      to avoid compiler difficulties this is divided
                     temp1=tdx(kk)*(tx(mm)*(ty(ll)*ty(nn)+tz(ll)*
     +                         tz(nn))+tx(nn)*(ty(ll)*ty(mm)+
     +                         tz(ll)*tz(mm)))+tdx(ll)*(tx(mm)*
     +                        (ty(kk)*ty(nn)+tz(kk)*tz(nn))+tx(nn)*
     +                        (ty(kk)*ty(mm)+tz(kk)*tz(mm)))
     +                    +tx(kk)*(tdx(mm)*(ty(ll)*ty(nn)+tz(ll)*tz(nn))
     5                    +tdx(nn)*(ty(ll)*ty(mm)+tz(ll)*tz(mm)))
     6                    +tx(ll)*(tdx(mm)*(ty(kk)*ty(nn)+tz(kk)*tz(nn))
     7                    +tdx(nn)*(ty(kk)*ty(mm)+tz(kk)*tz(mm)))
                     temp2=            tx(kk)*(tx(mm)*(tdy(ll)*ty(nn)+ty
     1(ll)*tdy(nn)                                 +tdz(ll)*tz(nn)+tz(ll
     2)*tdz(nn))                         +tx(nn)*(tdy(ll)*ty(mm)+ty(ll)*
     3tdy(mm)                                 +tdz(ll)*tz(mm)+tz(ll)*tdz
     4(mm)))                 +tx(ll)*(tx(mm)*(tdy(kk)*ty(nn)+ty(kk)*tdy(
     5nn)                                 +tdz(kk)*tz(nn)+tz(kk)*tdz(nn)
     6)                         +tx(nn)*(tdy(kk)*ty(mm)+ty(kk)*tdy(mm)
     7                                 +tdz(kk)*tz(mm)+tz(kk)*tdz(mm)))
                     dr(isp)=dr(isp)+g(20)*(temp1+temp2)
                     dr(isp)=dr(isp)
     1       +dg(21)*(ty(kk)*ty(ll)*tz(mm)*tz(nn)
     2                 +tz(kk)*tz(ll)*ty(mm)*ty(nn))
     3       +g(21)*(tdy(kk)*ty(ll)*tz(mm)*tz(nn)
     4                 +ty(kk)*tdy(ll)*tz(mm)*tz(nn)
     5                 +ty(kk)*ty(ll)*tdz(mm)*tz(nn)
     6                 +ty(kk)*ty(ll)*tz(mm)*tdz(nn)
     7                 +tdz(kk)*tz(ll)*ty(mm)*ty(nn)
     8                 +tz(kk)*tdz(ll)*ty(mm)*ty(nn)
     9                 +tz(kk)*tz(ll)*tdy(mm)*ty(nn)
     1                 +tz(kk)*tz(ll)*ty(mm)*tdy(nn))
                     dr(isp)=dr(isp)
     1       +dg(22)*(ty(kk)*tz(ll)+tz(kk)*ty(ll))
     2                 *(ty(mm)*tz(nn)+tz(mm)*ty(nn))
     3       +g(22)*((tdy(kk)*tz(ll)+ty(kk)*tdz(ll)
     4                  +tdz(kk)*ty(ll)+tz(kk)*tdy(ll))
     5                 *(ty(mm)*tz(nn)+tz(mm)*ty(nn))
     6                 +(ty(kk)*tz(ll)+tz(kk)*ty(ll))
     7                 *(tdy(mm)*tz(nn)+ty(mm)*tdz(nn)
     8                  +tdz(mm)*ty(nn)+tz(mm)*tdy(nn)))
                  endif
   10 continue
      return
      end
      subroutine delri(dg,ni,nj,rr,del1)
      implicit REAL (a-h,o-z)
      dimension dg(22)
************************************************************************
*                                                                      *
*    on input ni = atomic number of first atom                         *
*             nj = atomic number of second atom                        *
*             rr = interatomic distance in bohrs                       *
*                                                                      *
************************************************************************
      common  /multip/  dd(107),qq(107),bdd(107,3)
      common /twoel3/ f03(107)
      common /cmporb/ natorb(107)
      common /alpha3/ alp3(153)
      common /keywrd/ keywrd
      common /numcal/ numcal
      character*241 keywrd
      save icalcn
      data icalcn/0/
      if (icalcn.ne.numcal) then
         icalcn=numcal
      endif
      a0=0.529167d0
      term=(27.21d0*del1)/(rr*a0*a0)
      da=dd(ni)
      db=dd(nj)
      qa=qq(ni)
      qb=qq(nj)
c   hydrogen-hydrogen
      aee=0.25d0*(1.0d0/bdd(ni,1)+1.0d0/bdd(nj,1))**2
      ee    =-rr/(dsqrt(rr**2+aee))**3
      dg(1)=term*ee
      if(natorb(ni).le.2.and.natorb(nj).le.2) return
      if(natorb(ni).le.2) go to 10
c   heavy atom-hydrogen
      ade=0.25d0*(1.0d0/bdd(ni,2)+1.0d0/bdd(nj,1))**2
      aqe=0.25d0*(1.0d0/bdd(ni,3)+1.0d0/bdd(nj,1))**2
      dze   = (rr+da)/(dsqrt((rr+da)**2+ade))**3
     1       -(rr-da)/(dsqrt((rr-da)**2+ade))**3
      qzze  =-(rr+2.0d0*qa)/(dsqrt((rr+2.0d0*qa)**2+aqe))**3
     1       -(rr-2.0d0*qa)/(dsqrt((rr-2.0d0*qa)**2+aqe))**3
     2       +(2.0d0*rr)/(dsqrt(rr**2+aqe))**3
      qxxe  =-(2.0d0*rr)/(dsqrt(rr**2+4.0d0*qa**2+aqe))**3
     1       +(2.0d0*rr)/(dsqrt(rr**2+aqe))**3
      dg(2)=-(term*dze)/2.0d0
      dg(3)=term*(ee+qzze/4.0d0)
      dg(4)=term*(ee+qxxe/4.0d0)
      if(natorb(nj).le.2) return
c   hydrogen-heavy atom
   10 aed=0.25d0*(1.0d0/bdd(ni,1)+1.0d0/bdd(nj,2))**2
      aeq=0.25d0*(1.0d0/bdd(ni,1)+1.0d0/bdd(nj,3))**2
      edz   = (rr-db)/(dsqrt((rr-db)**2+aed))**3
     1       -(rr+db)/(dsqrt((rr+db)**2+aed))**3
      eqzz  =-(rr-2.0d0*qb)/(dsqrt((rr-2.0d0*qb)**2+aeq))**3
     1       -(rr+2.0d0*qb)/(dsqrt((rr+2.0d0*qb)**2+aeq))**3
     2       +(2.0d0*rr)/(dsqrt(rr**2+aeq))**3
      eqxx  =-(2.0d0*rr)/(dsqrt(rr**2+4.0d0*qb**2+aeq))**3
     1       +(2.0d0*rr)/(dsqrt(rr**2+aeq))**3
      dg(5)=-(term*edz)/2.0d0
      dg(11)=term*(ee+eqzz/4.0d0)
      dg(12)=term*(ee+eqxx/4.0d0)
      if(natorb(ni).le.2) return
c   heavy atom-heavy atom
      add=0.25d0*(1.d0/bdd(ni,2)+1.d0/bdd(nj,2))**2
      adq=0.25d0*(1.d0/bdd(ni,2)+1.d0/bdd(nj,3))**2
      aqd=0.25d0*(1.d0/bdd(ni,3)+1.d0/bdd(nj,2))**2
      aqq=0.25d0*(1.d0/bdd(ni,3)+1.d0/bdd(nj,3))**2
      dxdx  =-(2.d0*rr)/(dsqrt(rr**2+(da-db)**2+add))**3
     1       +(2.d0*rr)/(dsqrt(rr**2+(da+db)**2+add))**3
      dzdz  =-(rr+da-db)/(dsqrt((rr+da-db)**2+add))**3
     1       -(rr-da+db)/(dsqrt((rr-da+db)**2+add))**3
     2       +(rr-da-db)/(dsqrt((rr-da-db)**2+add))**3
     3       +(rr+da+db)/(dsqrt((rr+da+db)**2+add))**3
      dzqxx = 2.d0*(rr+da)/(dsqrt((rr+da)**2+4.d0*qb**2+adq))**3
     1       -2.d0*(rr-da)/(dsqrt((rr-da)**2+4.d0*qb**2+adq))**3
     2       -2.d0*(rr+da)/(dsqrt((rr+da)**2+adq))**3
     3       +2.d0*(rr-da)/(dsqrt((rr-da)**2+adq))**3
      qxxdz = 2.d0*(rr-db)/(dsqrt((rr-db)**2+4.d0*qa**2+aqd))**3
     1       -2.d0*(rr+db)/(dsqrt((rr+db)**2+4.d0*qa**2+aqd))**3
     2       -2.d0*(rr-db)/(dsqrt((rr-db)**2+aqd))**3
     3       +2.d0*(rr+db)/(dsqrt((rr+db)**2+aqd))**3
      dzqzz = (rr+da-2.d0*qb)/(dsqrt((rr+da-2.d0*qb)**2+adq))**3
     1       -(rr-da-2.d0*qb)/(dsqrt((rr-da-2.d0*qb)**2+adq))**3
     2       +(rr+da+2.d0*qb)/(dsqrt((rr+da+2.d0*qb)**2+adq))**3
     3       -(rr-da+2.d0*qb)/(dsqrt((rr-da+2.d0*qb)**2+adq))**3
     4       +2.d0*(rr-da)/(dsqrt((rr-da)**2+adq))**3
     5       -2.d0*(rr+da)/(dsqrt((rr+da)**2+adq))**3
      qzzdz = (rr+2.d0*qa-db)/(dsqrt((rr+2.d0*qa-db)**2+aqd))**3
     1       -(rr+2.d0*qa+db)/(dsqrt((rr+2.d0*qa+db)**2+aqd))**3
     2       +(rr-2.d0*qa-db)/(dsqrt((rr-2.d0*qa-db)**2+aqd))**3
     3       -(rr-2.d0*qa+db)/(dsqrt((rr-2.d0*qa+db)**2+aqd))**3
     4       -2.d0*(rr-db)/(dsqrt((rr-db)**2+aqd))**3
     5       +2.d0*(rr+db)/(dsqrt((rr+db)**2+aqd))**3
      qxxqxx=-(2.d0*rr)/(dsqrt(rr**2+4.d0*(qa-qb)**2+aqq))**3
     1       -(2.d0*rr)/(dsqrt(rr**2+4.d0*(qa+qb)**2+aqq))**3
     2       +(4.d0*rr)/(dsqrt(rr**2+4.d0*qa**2+aqq))**3
     3       +(4.d0*rr)/(dsqrt(rr**2+4.d0*qb**2+aqq))**3
     4       -(4.d0*rr)/(dsqrt(rr**2+aqq))**3
      qxxqyy=-(4.d0*rr)/(dsqrt(rr**2+4.d0*qa**2+4.d0*qb**2+aqq))**3
     1       +(4.d0*rr)/(dsqrt(rr**2+4.d0*qa**2+aqq))**3
     2       +(4.d0*rr)/(dsqrt(rr**2+4.d0*qb**2+aqq))**3
     3       -(4.d0*rr)/(dsqrt(rr**2+aqq))**3
      qxxqzz=
     1     -2.d0*(rr-2.d0*qb)/(dsqrt((rr-2.d0*qb)**2+4.d0*qa**2+aqq))**3
     2     -2.d0*(rr+2.d0*qb)/(dsqrt((rr+2.d0*qb)**2+4.d0*qa**2+aqq))**3
     3       +2.d0*(rr-2.d0*qb)/(dsqrt((rr-2.d0*qb)**2+aqq))**3
     4       +2.d0*(rr+2.d0*qb)/(dsqrt((rr+2.d0*qb)**2+aqq))**3
     5       +(4.d0*rr)/(dsqrt(rr**2+4.d0*qa**2+aqq))**3
     6       -(4.d0*rr)/(dsqrt(rr**2+aqq))**3
      qzzqxx=
     1     -2.d0*(rr+2.d0*qa)/(dsqrt((rr+2.d0*qa)**2+4.d0*qb**2+aqq))**3
     2     -2.d0*(rr-2.d0*qa)/(dsqrt((rr-2.d0*qa)**2+4.d0*qb**2+aqq))**3
     3       +2.d0*(rr+2.d0*qa)/(dsqrt((rr+2.d0*qa)**2+aqq))**3
     4       +2.d0*(rr-2.d0*qa)/(dsqrt((rr-2.d0*qa)**2+aqq))**3
     5       +(4.d0*rr)/(dsqrt(rr**2+4.d0*qb**2+aqq))**3
     6       -(4.d0*rr)/(dsqrt(rr**2+aqq))**3
      qzzqzz=
     1     -(rr+2.d0*qa-2.d0*qb)/(dsqrt((rr+2.d0*qa-2.d0*qb)**2+aqq))**3
     2     -(rr+2.d0*qa+2.d0*qb)/(dsqrt((rr+2.d0*qa+2.d0*qb)**2+aqq))**3
     3     -(rr-2.d0*qa-2.d0*qb)/(dsqrt((rr-2.d0*qa-2.d0*qb)**2+aqq))**3
     4     -(rr-2.d0*qa+2.d0*qb)/(dsqrt((rr-2.d0*qa+2.d0*qb)**2+aqq))**3
     5       +2.d0*(rr-2.d0*qa)/(dsqrt((rr-2.d0*qa)**2+aqq))**3
     6       +2.d0*(rr+2.d0*qa)/(dsqrt((rr+2.d0*qa)**2+aqq))**3
     7       +2.d0*(rr-2.d0*qb)/(dsqrt((rr-2.d0*qb)**2+aqq))**3
     8       +2.d0*(rr+2.d0*qb)/(dsqrt((rr+2.d0*qb)**2+aqq))**3
     9       -(4.d0*rr)/(dsqrt(rr**2+aqq))**3
      dxqxz = 2.d0*(rr-qb)/(dsqrt((rr-qb)**2+(da-qb)**2+adq))**3
     1       -2.d0*(rr+qb)/(dsqrt((rr+qb)**2+(da-qb)**2+adq))**3
     2       -2.d0*(rr-qb)/(dsqrt((rr-qb)**2+(da+qb)**2+adq))**3
     3       +2.d0*(rr+qb)/(dsqrt((rr+qb)**2+(da+qb)**2+adq))**3
      qxzdx = 2.d0*(rr+qa)/(dsqrt((rr+qa)**2+(qa-db)**2+aqd))**3
     1       -2.d0*(rr-qa)/(dsqrt((rr-qa)**2+(qa-db)**2+aqd))**3
     2       -2.d0*(rr+qa)/(dsqrt((rr+qa)**2+(qa+db)**2+aqd))**3
     3       +2.d0*(rr-qa)/(dsqrt((rr-qa)**2+(qa+db)**2+aqd))**3
      qxzqxz=-2.d0*(rr+qa-qb)/(dsqrt((rr+qa-qb)**2+(qa-qb)**2+aqq))**3
     1       +2.d0*(rr+qa+qb)/(dsqrt((rr+qa+qb)**2+(qa-qb)**2+aqq))**3
     2       +2.d0*(rr-qa-qb)/(dsqrt((rr-qa-qb)**2+(qa-qb)**2+aqq))**3
     3       -2.d0*(rr-qa+qb)/(dsqrt((rr-qa+qb)**2+(qa-qb)**2+aqq))**3
     4       +2.d0*(rr+qa-qb)/(dsqrt((rr+qa-qb)**2+(qa+qb)**2+aqq))**3
     5       -2.d0*(rr+qa+qb)/(dsqrt((rr+qa+qb)**2+(qa+qb)**2+aqq))**3
     6       -2.d0*(rr-qa-qb)/(dsqrt((rr-qa-qb)**2+(qa+qb)**2+aqq))**3
     7       +2.d0*(rr-qa+qb)/(dsqrt((rr-qa+qb)**2+(qa+qb)**2+aqq))**3
      dg(6)=(term*dzdz)/4.0d0
      dg(7)=(term*dxdx)/4.0d0
      dg(8)=-term*(edz/2.0d0+qzzdz/8.0d0)
      dg(9)=-term*(edz/2.0d0+qxxdz/8.0d0)
      dg(10)=-(term*qxzdx)/8.0d0
      dg(13)=-term*(dze/2.0d0+dzqzz/8.0d0)
      dg(14)=-term*(dze/2.0d0+dzqxx/8.0d0)
      dg(15)=-(term*dxqxz)/8.0d0
      dg(16)=term*(ee+eqzz/4.0d0+qzze/4.0d0+qzzqzz/16.0d0)
      dg(17)=term*(ee+eqzz/4.0d0+qxxe/4.0d0+qxxqzz/16.0d0)
      dg(18)=term*(ee+eqxx/4.0d0+qzze/4.0d0+qzzqxx/16.0d0)
      dg(19)=term*(ee+eqxx/4.0d0+qxxe/4.0d0+qxxqxx/16.0d0)
      dg(20)=(term*qxzqxz)/16.0d0
      dg(21)=term*(ee+eqxx/4.0d0+qxxe/4.0d0+qxxqyy/16.0d0)
      dg(22)=term*(qxxqxx-qxxqyy)/32.0d0
      return
      end
      subroutine denrot
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      common /densty/ p(mpack),pa(mpack),pb(mpack)
      common /cmpg/ geo(3,numatm)
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),
     1                nlast(numatm), norbs, nelecs,nalpha,nbeta,
     2                nclose,nopen,ndumy,fract
      common /elemts/ elemnt(107)
      common /scrach/ b(maxorb*maxorb), bondab(maxpar**2-maxorb*maxorb)
      common/iofile/mfgr,mfgw
************************************************************************
*
* denrot prints the density matrix as (s-sigma, p-sigma, p-pi) rather
*        than (s, px, py, pz).
*
************************************************************************
      dimension arot(9,9), c(3,5,5), pab(9,9), vect(9,9)
      dimension natom(maxorb)
      dimension xyz(3,numatm), irot(5,35), isp(9)
      character * 6 line(21)
      character elemnt*2,atorbs(9)*7,itext(maxorb)*7,jtext(maxorb)*2
      save atorbs, irot, isp
      data atorbs/'s-sigma','p-sigma','  p-pi ','  p-pi ','d-sigma',
     1            '  d-pi ','  d-pi ',' d-dell',' d-dell'/
***********************************************************************
* irot is a mapping list. for each element of arot 5 numbers are
* needed. these are, in order, first and second subscripts of arot,
* and first,second, and third subscripts of c, thus the first
* line of irot defines arot(1,1)=c(1,3,3)
*
***********************************************************************
      data irot/1,1,1,3,3, 2,2,2,4,3, 3,2,2,2,3, 4,2,2,3,3, 2,3,2,4,2,
     1          3,3,2,2,2, 4,3,2,3,2, 2,4,2,4,4, 3,4,2,2,4, 4,4,2,3,4,
     2          5,5,3,1,5, 6,5,3,4,3, 7,5,3,3,3, 8,5,3,2,3, 9,5,3,5,3,
     3          5,6,3,1,2, 6,6,3,4,2, 7,7,3,3,2, 8,6,3,2,2, 9,6,3,5,2,
     4          5,7,3,1,4, 6,7,3,4,4, 7,7,3,3,4, 8,7,3,2,4, 9,7,3,5,4,
     5          5,8,3,1,1, 6,8,3,4,1, 7,8,3,3,1, 8,8,3,2,1, 9,8,3,5,1,
     6          5,9,3,1,5, 6,9,3,4,5, 7,9,3,3,5, 8,9,3,2,5, 9,9,3,5,5/
      data isp /1,2,3,3,4,5,5,6,6/
      call gmetry(geo,xyz)
      iprt=0
      do 120 i=1,numat
         if=nfirst(i)
         il=nlast(i)
         ipq=il-if-1
         ii=ipq+2
         if(ii.eq.0)goto 120
         do 10 i1=1,ii
            j1=iprt+isp(i1)
            itext(j1)=atorbs(i1)
            jtext(j1)=elemnt(nat(i))
            natom(j1)=i
   10    continue
         iprt=j1
         if(ipq.ne.2)ipq=min(max(ipq,1),3)
         do 110 j=1,i
            jf=nfirst(j)
            jl=nlast(j)
            jpq=jl-jf-1
            jj=jpq+2
            if(jj.eq.0)goto 110
            if(jpq.ne.2)jpq=min(max(jpq,1),3)
            do 20 i1=1,9
               do 20 j1=1,9
   20       pab(i1,j1)=0.0d0
            kk=0
            do 30 k=if,il
               kk=kk+1
               ll=0
               do 30 l=jf,jl
                  ll=ll+1
   30       pab(kk,ll)=p(l+(k*(k-1))/2)
            call coe(xyz(1,i),xyz(2,i),xyz(3,i),
     1                 xyz(1,j),xyz(2,j),xyz(3,j),ipq,jpq,c,r)
            do 40 i1=1,9
               do 40 j1=1,9
   40       arot(i1,j1)=0.0d0
            do 50 i1=1,35
   50       arot(irot(1,i1),irot(2,i1))=
     1            c(irot(3,i1),irot(4,i1),irot(5,i1))
            l1=isp(ii)
            l2=isp(jj)
            do 60 i1=1,9
               do 60 j1=1,9
   60       vect(i1,j1)=-1.d0
            do 70 i1=1,l1
               do 70 j1=1,l2
   70       vect(i1,j1)=0.0d0
            if(i.ne.j) then
               ij=max(ii,jj)
               do 90 i1=1,ii
                  do 90 j1=1,jj
                     sum=0.0d0
                     do 80 l1=1,ij
                        do 80 l2=1,ij
   80                sum=sum+arot(l1,i1)*pab(l1,l2)*arot(l2,j1)
   90          vect(isp(i1),isp(j1))=
     1                        vect(isp(i1),isp(j1))+sum**2
            endif
            k=0
            do  100 i1=if,il
               k=k+1
               l=0
               do 100 j1=jf,jl
                  l=l+1
  100       if(j1.le.i1) b(j1+(i1*(i1-1))/2)=vect(k,l)
  110    continue
  120 continue
c
c now to remove all the dead space in p, characterized by -1.0
c
      linear=(norbs*(norbs+1))/2
      l=0
      do 130 i=1,linear
         if(b(i).gt.-0.1) then
            l=l+1
            b(l)=b(i)
         endif
  130 continue
c
c   put atomic orbital valencies onto the diagonal
c
      do 160 i=1,iprt
         sum=0.0d0
         ii=(i*(i-1))/2
         do 140 j=1,i
  140    sum=sum+b(j+ii)
         do 150 j=i+1,iprt
  150    sum=sum+b((j*(j-1))/2+i)
  160 b((i*(i+1))/2)=sum
      do 170 i=1,21
  170 line(i)='------'
      limit=(iprt*(iprt+1))/2
      kk=8
      na=1
  180 ll=0
      m=min((iprt+1-na),6)
      ma=2*m+1
      m=na+m-1
      write(mfgw,'(/16x,10(1x,a7,3x))')(itext(i),i=na,m)
      write(mfgw,'(15x,10(2x,a2,i3,4x))')(jtext(i),natom(i),i=na,m)
      write(mfgw,'(20a6)') (line(k),k=1,ma)
      do 200 i=na,iprt
         ll=ll+1
         k=(i*(i-1))/2
         l=min((k+m),(k+i))
         k=k+na
         if ((kk+ll).le.50) go to 190
         write(mfgw,'(''1'')')
         write(mfgw,'(/17x,10(1x,a7,3x))')(itext(n),n=na,m)
         write(mfgw,'( 17x,10(2x,a2,i3,4x))')(jtext(n),natom(n),n=na,m)
         write(mfgw,'(20a6)') (line(n),n=1,ma)
         kk=4
         ll=0
  190    write(mfgw,'(1x,a7,1x,a2,i3,10f11.6)')
     1   itext(i),jtext(i),natom(i),(b(n),n=k,l)
  200 continue
      if (l.ge.limit) go to 210
      kk=kk+ll+4
      na=m+1
      if ((kk+iprt+1-na).le.50) go to 180
      kk=4
      write (mfgw,'(''1'')')
      go to 180
  210 return
      end
      subroutine densit( c,mdim, norbs,ndubl, nsingl, fract, p,mode)
      implicit REAL (a-h,o-z)
      dimension p(*), c(mdim,*)
c***********************************************************************
c
c   densit computes the density matrix given the eigenvector matrix, and
c          information about the m.o. occupancy.
c
c  input:  c     = square eigenvector matrix, c is of size mdim by mdim
c                  and the eigenvectors are stored in the top left-hand
c                  corner.
c          norbs = number of orbitals
c          ndubl = number of doubly-occupied m.o.s ( =0 if uhf)
c          nsingl= number of singly or fractionally occupied m.o.s.
c          mode  = 2 if positron equivalent is not to be used
c
c   on exit: p   = density matrix
c
c***********************************************************************
c
c set up limits for sums
c  nl1 = begining of one electron sum
c  nu1 = end of same
c  nl2 = begining of two electron sum
c  nu2 = end of same
c
      norbs2=norbs/2
      nsingl=max(ndubl,nsingl)
      if(ndubl.ne.0.and.nsingl .gt. norbs2 .and. mode.ne.2) then
c
c    take positron equivalent
c
         sign=-1.d0
         frac=2.d0-fract
         const=2.d0
         nl2=nsingl+1
         nu2=norbs
         nl1=ndubl+1
         nu1=nsingl
      else
c
c    take electron equivalent
c
         sign=1.d0
         frac=fract
         const=0.0d0
         nl2=1
         nu2=ndubl
         nl1=ndubl+1
         nu1=nsingl
      endif
      l=0
      do 40 i=1,norbs
         do 30 j=1,i
            l=l+1
_IFN(blas)
            sum2=0.d0
            do 10 k=nl2,nu2
   10       sum2=sum2+c(i,k)*c(j,k)
_ELSE
      sum2=ddot(nu2-nl2+1,c(i,nl2),mdim,c(j,nl2),mdim)
_ENDIF
            sum2=sum2*2.d0
_IFN(blas)
            sum1=0.d0
            do 20 k=nl1,nu1
   20       sum1=sum1+c(i,k)*c(j,k)
_ELSE
      sum1=ddot(nu1-nl1+1,c(i,nl1),mdim,c(j,nl1),mdim)
_ENDIF
   30    p(l)=(sum2+sum1*frac)*sign
   40 p(l)=const+p(l)
      return
      end
      subroutine depvar (a,i,w,l)
      implicit REAL (a-h,o-z)
      dimension a(3,*)
c***********************************************************************
c
c  in subroutine haddon when m, the symmetry operation, is 18 depvar is
c  called. depvar should then contain a user-written symmetry operation.
c  see haddon to get the idea on how to write depvar.
c
c on input:
c           a = array of internal coordinates
c           i = address of reference atom
c on output:
c           l = 1 (if a bond-length is the dependent function)
c             = 2 (if an angle is the dependent function)
c             = 3 (if a dihedral angle is the dependent function)
c           w = value of the function
c
c  note:  it is the writer's responsibility to make certain that the
c         routine does not contain any errors!
c***********************************************************************
      common /keywrd/ keywrd
      common /numcal/ numcal
      common/iofile/mfgr,mfgw
      save fact
      character*241 keywrd
      save icalcn
      data icalcn/0/
      if (icalcn.ne.numcal) then
         icalcn=numcal
         fact=reada(keywrd,index(keywrd,'depvar'))
         write(mfgw,'(''  unit cell length ='',f14.7,
     1'' times bond length'')')fact
      endif
      w=a(1,i)*fact
      l=1
      return
      end
      subroutine deri0 (e,n, scalar,diag,fract,nbo)
      implicit REAL (a-h,o-z)
      dimension  e(n), scalar(*), diag(*), nbo(3)
c
c     compute the diagonal dominant part of the super-matrix and
c     define the scalar coefficients applied on each row of the
c     super linear system in order to reduce the eigenvalue spectrum of
c     the electronic hessian,
c     thus speeding convergence of relaxation process in 'deri2'.
c  input
c     e(n)             : eigenvalues of fock matrix.
c     n                : number of m.o.
c     nbo(3)           : occupancy boundaries.
c     fract            : partial occupancy of 'open' shells.
c     scalar(minear)   : scale applied on each column and row of the
c                        symmetric super system.
c
      shift=2.36d0
c
c     dominant diagonal part of the super-matrix.
c     -------------------------------------------
      nopen=nbo(1)+nbo(2)
      const=1.d-3
      l=1
      if(nbo(2).gt.0 .and. nbo(1).gt.0) then
c        open-closed
         do 10 j=1,nbo(1)
            do 10 i=nbo(1)+1,nopen
               diag(l)=(e(i)-e(j))/(2.d0-fract+const)
   10    l=l+1
      endif
      if(nbo(3).gt.0 .and. nbo(1).gt.0) then
c         virtual-closed
         do 20 j=1,nbo(1)
            do 20 i=nopen+1,n
               diag(l)=(e(i)-e(j))/2.d0
   20    l=l+1
      endif
      if(nbo(3).ne.0 .and. nbo(2).ne.0) then
c        virtual-open
         do 30 j=nbo(1)+1,nopen
            do 30 i=nopen+1,n
               diag(l)=(e(i)-e(j))/(fract+const)
   30    l=l+1
      endif
c
c     take scale factors as (shift-diag)**(-0.5) .
c     ------------------------------------------
      do 40 i=1,l-1
   40 scalar(i)=dsqrt(1.d0/dmax1(0.3d0*diag(i),diag(i)-shift))
      return
      end
      subroutine deri1(c,norbs,coord,number,work,grad
     1                 ,f,minear,fd,wmat,hmat,fmat)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      dimension wmat(mpack),hmat(mpack*2),fmat(mpack*2)
*********************************************************************
*
*     deri1 compute the non-relaxed derivative of the non-variationally
*     optimized wavefunction energy with respect to one cartesian
*     coordinate at a time
*                             and
*     compute the non-relaxed fock matrix derivative in m.o basis as
*     required in the relaxation section (routine 'deri2').
*
*   input
*     c(norbs,norbs) : m.o. coefficients.
*     coord  : cartesian coordinates array.
*     number : location of the required variable in coord.
*     work   : work array of size n*n.
*     wmat     : work arrays for d<pq|rs> (2-centers  a.o)
*   output
*     c,coord,number : not modified.
*     grad   : derivative of the heat of formation with respect to
*              coord(number), without relaxation correction.
*     f(minear) : non-relaxed fock matrix derivative with respect to
*              coord(number), expressed in m.o basis, scaled and
*              packed, off-diagonal blocks only.
*     fd     : idem but unscaled, diagonal blocks, c.i-active only.
*
************************************************************************
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm)
     1               ,nlast(numatm), ndumy1, nelecs,nalpha,nbeta
     2               ,nclose,nopen,ndumy,fract
      common /vector/ cdum(morb2),eigs(maxorb),wdum(morb2),eigb(maxorb)
      common /densty/ p(mpack), pa(mpack), pb(mpack)
      common /cibits/ nmos,lab,nelec,nbo(3)
      common /hmatrx/ h(mpack)
      common /xyijkl/ xy(nmeci,nmeci,nmeci,nmeci)
      common /civect/ conf(nmeci**4+nmeci**2+1)
      common /fokmat/ fdumy(mpack), scalar(mpack)
      common /nvomat/ diag(mpack/2)
      common /keywrd/ keywrd
      common /numcal/ numcal
      common/iofile/mfgr,mfgw
      dimension coord(*),c(norbs,norbs),work(norbs,norbs),f(*),fd(*)
      character keywrd*241
      logical debug
      save icalcn,debug,iprt,linear
      data icalcn /0/
c
      if(icalcn.ne.numcal) then
         debug=index(keywrd,'deri1').ne.0
         iprt=6
         linear=norbs*(norbs+1)/2
         icalcn=numcal
      endif
      if(debug) call timop('before deri1')
      step=1.d-3
c
c     2 points finite difference to get the integral derivatives
c     ----------------------------------------------------------
c     stored in hmat and wmat, without dividing by the step size.
c
      nati=(number-1)/3+1
      natx=number-3*(nati-1)
      call dhcore (coord,hmat,wmat,enucl2,nati,natx,step)
c
c hmat holds the one-electron derivatives of atom nati for direction
c      natx w.r.t. all other atoms
c wmat holds the two-electron derivatives of atom nati for direction
c      natx w.r.t. all other atoms
      step=0.5d0/step
c
c     non-relaxed fock matrix derivative in a.o basis.
c     ------------------------------------------------
c     stored in fmat, divided by step.
c
      call dcopy(linear,hmat,1,fmat,1)
      call dfock2(fmat,p,pa,wmat,numat,nfirst,nmidle,nlast,nati)
c
c  fmat holds the one plus two - electron derivatives of atom nati for
c       direction natx w.r.t. all other atoms
c
c       derivative of the scf-only energy (i.e before c.i correction)
c
      grad=(helect(norbs,p,hmat,fmat)+enucl2)*step
c     take step into account in fmat
      do 10 i=1,linear
   10 fmat(i)=fmat(i)*step
c
c     right-hand side super-vector f = c' fmat c used in relaxation
c     -----------------------------------------------------------
c     stored in non-standard packed form in f(minear) and fd.
c     the supervector is the non-relaxed fock matrix derivative in
c     m.o basis: f(ij)= ( (c' * fock * c)(i,j) )   with i.gt.j .
c     f is scaled and packed in supervector form with
c                the consecutive following off-diagonal blocks:
c             1) open-closed  i.e. f(ij)=f(i,j) with i open & j closed
c                                  and i running faster than j,
c             2) virtual-closed same rule of ordering,
c             3) virtual-open   same rule of ordering.
c     fd is packed over the c.i-active m.o with
c                the consecutive diagonal blocks:
c             1) closed-closed   in canonical order, without the
c                                diagonal elements,
c             2) open-open       same rule of ordering,
c             3) virtual-virtual same rule of ordering.
c
c     part 1 : work(n,n) = fmat(n,n) * c(n,n)
      do 20 i=1,norbs
   20 call supdot (work(1,i),fmat,c(1,i),norbs,1)
c
c     part 2 : f(ij) =  (c' * work)(i,j) ... off-diagonal blocks.
      l=1
      if(nbo(2).ne.0 .and. nbo(1).ne.0) then
c        open-closed
         call mtxm (c(1,nbo(1)+1),nbo(2),work,norbs,f(l),nbo(1))
         l=l+nbo(2)*nbo(1)
      endif
      if(nbo(3).ne.0 .and. nbo(1).ne.0) then
c        virtual-closed
         call mtxm (c(1,nopen+1),nbo(3),work,norbs,f(l),nbo(1))
         l=l+nbo(3)*nbo(1)
      endif
      if(nbo(3).ne.0 .and. nbo(2).ne.0) then
c        virtual-open
         call mtxm (c(1,nopen+1),nbo(3),work(1,nbo(1)+1),norbs,f(l),nbo(
     12))
      endif
c     scale f according to the diagonal metric tensor 'scalar '.
      do 30 i=1,minear
   30 f(i)=f(i)*scalar(i)
      if(debug)then
         write(mfgw,*)' f in deri1'
         j=min(20,minear)
         write(mfgw,'(5f12.6)')(f(i),i=1,j)
      endif
c
c     part 3 : super-vector fd, c.i-active diagonal blocks, unscaled.
      l=1
      nend=0
      do 50 loop=1,3
         ninit=nend+1
         nend =nend+nbo(loop)
         n1=max(ninit,nelec+1   )
         n2=min(nend ,nelec+nmos)
         if(n2.lt.n1) go to 50
         do 40 i=n1,n2
            if(i.gt.ninit) then
               call mxm (c(1,i),1,work(1,ninit),norbs,fd(l),i-ninit)
               l=l+i-ninit
            endif
   40    continue
   50 continue
c
c     non-relaxed c.i correction to the energy derivative.
c     ----------------------------------------------------
c
c     c.i-active fock eigenvalues derivatives, stored in fd(continued).
      lcut=l
      do 60 i=nelec+1,nelec+nmos
         fd(l)=ddot(norbs,c(1,i),1,work(1,i),1)
   60 l=l+1
c
c     c.i-active 2-electrons integrals derivatives. stored in xy.
c   fmat is used here as scratch space
c
      call dijkl1 (c(1,nelec+1),norbs,nati,wmat,fmat,hmat,fmat)
      do 70 i=1,nmos
         do 70 j=1,nmos
            do 70 k=1,nmos
               do 70 l=1,nmos
   70 xy(i,j,k,l)=xy(i,j,k,l)*step
c
c     build the c.i matrix derivative, stored in wmat.
      call mecid (fd(lcut-nelec),gse,eigb,work)
      if(debug)then
         write(mfgw,*)' gse:',gse
c#      write(mfgw,*)' eigb:',(eigb(i),i=1,10)
c#      write(mfgw,*)' work:',(work(i,1),i=1,10)
      endif
      call mecih (work,wmat,nmos,lab)
c
c     non-relaxed c.i contribution to the energy derivative.
      call supdot (work,wmat,conf,lab,1)
      grad=(grad+ddot(lab,conf,1,work,1))*23.061d0
      if(debug) then
         write(iprt,'('' * * * gradient component number'',i4)')number
         write(iprt,'('' non-relaxed c.i-active fock eigenvalues '',
     1                ''derivatives (e.v.)'')')
         write(iprt,'(8f10.4)')(fd(lcut-1+i),i=1,nmos)
         write(iprt,'('' non-relaxed 2-electrons derivatives (e.v.)''/
     1''    i    j    k    l       d<i(1)j(1)|k(2)l(2)>'')')
         do 80 i=1,nmos
            do 80 j=1,i
               do 80 k=1,i
                  ll=k
                  if(k.eq.i) ll=j
                  do 80 l=1,ll
   80    write(iprt,'(4i5,f20.10)')
     1              nelec+i,nelec+j,nelec+k,nelec+l,xy(i,j,k,l)
         write(iprt,'('' non-relaxed gradient component'',f10.4,
     1'' kcal/mole'')')grad
         call timop('after deri1')
      endif
      return
      end
      subroutine deri2(c,e,norbs, minear, f, fd, fci, ninear,
     1nvar,work,b,nw2,grad,ab,nw3,fb,throld)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      dimension c(norbs,norbs),e(norbs),work(norbs,norbs)
     1         ,f(minear,mpack/minear)
     2         ,fd(ninear,(5*maxpar+mpack)/ninear)
     3         ,fci(ninear,maxorb/ninear)
     4         ,b(minear,(6*mpack-5*maxpar)/minear)
     5         ,ab(minear,6*mpack/minear),fb(nvar,6*mpack/nvar)
     6         ,grad(nvar)
*********************************************************************
*
*     deri2 compute the relaxation part of the derivatives of the
*     non-variationally optimized energy with respect to two
*     coordinates at a time. this is done in three steps.
*
*     the m.o derivatives are solution {x} of a linear system
*                        (d-a) * x = f
*     where d is a diagonal super-matrix of fock eigenvalue differences
*     and a is a super-matrix of 2-electrons integrals in m.o basis.
*     such a system is too large to be inverted directly thus one must
*     uses a relaxation method to get a reasonable estimate of {x}.
*     this requires a basis set {b} to be generated iteratively, after
*     which we solve by direct inversion the linear system projected
*     in this basis {b}. it works quickly but does require a large
*     core memory.
*
*     use a formalism with fock operator thus avoiding the explicit
*     computation (and storage) of the super-matrix a.
*     the semiempirical methods do not involve large c.i calculations.
*     therefore for each gradient component we build the c.i matrix
*     derivative from the m.o. integrals <ij|kl> and fock eigenvalues
*     derivatives, thus providing the relaxation contribution to the
*     gradient without computation and storage of the 2nd order density
*     matrix.
*
*   step 1)
*     use the previous b and the new f vectors to build an initial
*     basis set b.
*   step 2)
*     because the electronic hessian (d-a) is the same for each
*     derivative, we only need to enlarge iteratively the orthonormal
*     basis set {b} used to invert the projected hessian.
*     (derived from the largest residual vector ).
*     this section is carried out in the diagonal metric 'scalar'.
*   step 3) ... loop on the geometric variable :
* 3.1 for each geometric variable, get the m.o derivatives in a.o.
* 3.2 compute the fock eigenvalues and 2-electron integral relaxation.
* 3.3 build the electronic relaxation contribution to the c.i matrix
*     and get the associated eigenstate derivative with respect to
*     the geometric variable.
*
*   input
*     c(norbs,norbs) : m.o. coefficients, in column.
*     e(norbs)       : eigenvalues of the fock matrix.
*     minear         : number of non redundant rotation of the m.o.
*     f(minear,nvar) : non-relaxed fock matrices derivatives
*                    in m.o basis, off-diagonal blocks.
*     fd(ninear,nvar): idem, diagonal blocks, c.i-active only.
*     work           : work array of size n*n.
*     b(minear,nbsize) : initial orthonormalized basis set {b}.
*     grad(nvar)     : gradient vector before relaxation correction.
*     ab(minear,*): storage for the (d-a) * b vectors.
*     fb(nvar,*)  : storage for the matrix product f' * b.
*   output
*     grad   : derivative of the heat of formation with respect to
*              the nvar optimized variables.
*
************************************************************************
      common /fokmat/ fdumy(mpack), scalar(mpack)
      common /nvomat/ diag(mpack/2)
      common /work3 / dijkl(mpack*4)
      common /xyijkl/ xy(nmeci,nmeci,nmeci,nmeci)
      common /civect/ vectci(nmeci**2),babinv(nmeci**3),
     4bcoef(nmeci**4-nmeci**3+1)
      common /keywrd/ keywrd
      common /cibits/ nmos,lab,nelec,nbo(3)
      common /work2 / bab(mmci,mmci),
     +dumy(nmeci**4+2*nmeci**3+nmeci**2-mmci*mmci)
      common /numcal/ numcal
      common/iofile/mfgr,mfgw
      dimension lconv(60)
      logical fail, lconv, debug, lbab
      character keywrd*241
      save icalcn,debug,linear,nopen,maxite,nfirst
      data icalcn/0/
c
c     * * * step 1 * * *
c     build up the initial orthonormalized basis.
c
      if(icalcn.ne.numcal) then
         debug=index(keywrd,' deri2').ne.0
         icalcn=numcal
         maxite=min(60,idint(dsqrt(nmeci**3.d0)),mpack*2/nvar)
         maxite=min(maxite,min(nw2,nw3)/max(minear,ninear))
         nfirst=min(nvar,1+maxite/4)
      endif
      fail=.false.
      nbsize=0
      time1=secmop()
c
c        normal case. use f only.
c
      call deri21 (f,nvar,minear,nfirst,work
     1               ,work(nvar*nvar+1,1),b,nlast)
      lbab=.false.
      nfirst=nbsize+1
      nlast=nbsize+nlast
      do 10 i=1,nvar
   10 lconv(i)=.false.
c
c     * * * step 2 * * *
c     relaxation method with optimum increase of the basis set.
c     ---------------------------------------------------------
c
c     update ab ,fci and bab. (bab is symmetric)
   20 do 30 j=nfirst,nlast
         call deri22(c,b(1,j),work,norbs,work,ab(1,j),minear,
     1            fci(1,j))
         call mxm(ab(1,j),1,b,minear,bab(1,j),nlast)
         do 30 i=1,nfirst-1
   30 bab(j,i)=bab(i,j)
c     invert bab, store in babinv.
   40 l=0
      do 50 j=1,nlast
         do 50 i=1,nlast
            l=l+1
   50 babinv(l)=bab(i,j)
      call osinv (babinv,nlast,deter)
      if (deter.eq.0) then
      if(nlast.ne.1)then
         write(mfgw,'('' the bab matrix of order'',i3,
     1   '' is singular in deri2''/
     2   '' the relaxation is stopped at this point.'')')nlast
         endif
         lbab=.true.
         nlast=nlast-1
         go to 40
      endif
      if (.not.lbab) then
c        update f * b'
         call mtxm (f,nvar,b(1,nfirst),minear,fb(1,nfirst),nlast-nfirst+
     11)
      endif
c     new solutions in basis b , stored in bcoef(nvar,*).
c     bcoef = babinv * fb'
      if(nlast.ne.0)call mopm(babinv,nlast,fb,nlast,bcoef,nvar)
      if(lbab) go to 90
c
c     select the next basis vector as the largest residual vector.
c     and test for convergence on the largest residue.
      nres=0
      test2=0.0d0
      do 70 ivar=1,nvar
         if(lconv(ivar)) go to 70
c     get one not-converged residual vector (# ivar),
c     stored in work.
         call mxm  (ab,minear,bcoef(nlast*(ivar-1)+1),nlast,work,1)
         test=0.0d0
         do 60 i=1,minear
            work(i,1)=f(i,ivar)-work(i,1)
   60    test=dmax1(dabs(work(i,1)),test)
         if(debug)write(mfgw,*)' test:',test
         test2=dmax1(test2,test)
         if (test.le.throld) then
            lconv(ivar)=.true.
            if(nvar.eq.1) goto 90
            go to 70
         elseif (nlast+nres.eq.maxite-1) then
c        running out of storage
            if (test.le.dmax1(0.01d0,throld*2)) then
               lconv(ivar)=.true.
               go to 70
            endif
         else if (nlast+nres.eq.maxite) then
c
c   completely out of storage
c
            fail=nres.eq.0
            go to 80
         else
c        store the following residue in ab(continued).
            nres=nres+1
            call dcopy(minear,work,1,ab(1,nlast+nres),1)
         endif
   70 continue
   80 if (nres.eq.0) go to 90
c     find optimum following subset, add to b and loop.
      nfirst=nlast+1
      call deri21(ab(1,nfirst),nres,minear,nres,work
     1           ,work(nres*nres+1,1),b(1,nfirst),nadd)
      nlast=nlast+nadd
      go to 20
c
c     convergence achieved or halted.
c     -------------------------------
c
   90 nbsze=nbsize
      if(debug.or.lbab) then
         write(mfgw,'('' relaxation ended in deri2 after'',i3,
     1   '' cycles''/'' required convergence threshold on residuals =''
     2   ,f12.9/'' highest residual on'',i3,'' gradient components = ''
     3   ,f12.9)')nlast-nbsze,throld,nvar,test2
      if(nlast-nbsze.eq.0)then
      write(mfgw,'(a)')
     +' analytic c.i. derivatives do not work for this system'
      write(mfgw,'(a)')' add keyword ''noanci'' and resubmit'
_IF(ipsc,tools)
      call pend
_ELSE
      stop
_ENDIF
      endif
       time2=secmop()
       write(mfgw,'('' elapsed time in relaxation'',f15.3,'' second'')
     1              ')time2-time1
      endif
      if(fail) then
       write(mfgw,
     +       '(a)')' analytical derivatives too inaccurate for this'
       write(mfgw,
     +       '(a)')' work.  job stopped here.  see manual for ideas'
_IF(ipsc,tools)
         call pend
_ELSE
         stop
_ENDIF
      else
         nbsize=0
c        unscaled solution supervectors, stored in f.
         if(nlast.ne.0)call mxm (b,minear,bcoef,nlast,f,nvar)
         do 100 j=1,nvar
            do 100 i=1,minear
  100    f(i,j)=f(i,j)*scalar(i)
c        fock matrix diagonal blocks over c.i-active m.o.
c        stored in fb.
         if(nlast.ne.0)call mxm (fci,ninear,bcoef,nlast,fb,nvar)
      endif
c
c     * * * step 3 * * *
c     final loop (390) on the geometric variables.
c     --------------------------------------------
c
      do 130 ivar=1,nvar
c
c     c.i-active m.o derivatives into the m.o basis,
c         returned in ab (n,nelec+1,...,nelec+nmos).
c     c.i-active eigenvalues derivatives,
c         returned in bcoef(nelec+1,...,nelec+nmos).
         call deri23 (f(1,ivar),fd(1,ivar),e
     1            ,fb(ninear*(ivar-1)+1,1),ab,bcoef,norbs)
c
c     derivatives of the 2-electrons integrals over c.i-active m.o.
c     stored in /xyijkl/.
         call dijkl2 (ab(norbs*nelec+1,1),norbs,nmos,dijkl,xy,nmeci)
         if(debug) then
            write(mfgw,'('' * * * gradient component number'',i4)')ivar
            if(index(keywrd,'debu').ne.0) then
               write(mfgw,
     +         '('' c.i-active m.o. derivatives in m.o basis'',
     1           '', in row.'')')
               l=norbs*nelec+1
               do 110 i=nelec+1,nelec+nmos
                  write(mfgw,'(8f10.4)')(ab(k,1),k=l,l+norbs-1)
  110          l=l+norbs
            endif
            write(mfgw,
     +      '('' c.i-active fock eigenvalues relaxation (e.v.)'')')
            write(mfgw,'(8f10.4)')(bcoef(i),i=nelec+1,nelec+nmos)
            write(mfgw,'('' 2-electron integrals relaxation (e.v.)''/
     1''    i    j    k    l       d<i(1)j(1)|k(2)l(2)> relaxation only'
     2')
     3')
            do 120 i=1,nmos
               do 120 j=1,i
                  do 120 k=1,i
                     ll=k
                     if(k.eq.i) ll=j
                     do 120 l=1,ll
  120       write(mfgw,'(4i5,f20.10)')
     1              nelec+i,nelec+j,nelec+k,nelec+l,xy(i,j,k,l)
         endif
c
c     build the c.i matrix derivative, stored in ab.
         call mecid (bcoef,gse,work(lab+1,1),work)
         call mecih (work,ab,nmos,lab)
c     relaxation correction to the c.i energy derivative.
         call supdot (work,ab,vectci,lab,1)
         grad(ivar)=grad(ivar)+ddot(lab,vectci,1,work,1)*23.061d0
         if (debug) then
         write(mfgw,'('' relaxation of the gradient component'',f10.4,
     1'' kcal/mole'')')  ddot(lab,vectci,1,work,1)*23.061d0
         endif
c
c     the end .
  130 continue
      if(debug)
     1write(mfgw,'('' elapsed time in c.i-energy relaxation'',f15.3,
     2             '' second'')')secmop()-time2
      return
      end
      subroutine deri21 (a,nvar,minear,nfirst,vnert,pnert
     1                  ,b,ncut)
      implicit REAL (a-h,o-z)
      dimension a(minear,nvar),vnert(nvar),pnert(nvar),b(minear,*)
************************************************************************
*
*     least-square analysis of a set of nvar points {a} :
*
*     produce a subset of ncut orthonormalized vectors b, optimum in a
*     least-square sense with respect to the initial space {a}.
*     each new hierarchized vector b extracts a maximum percentage from
*     the remaining dispersion of the set {a} out of the previous
*     {b} subspace.
*   input
*     a(minear,nvar): original set {a}.
*     nfirst        : maximum allowed size of the basis b.
*   output
*     vnert(nvar)   : lowest eigenvector of a'* a.
*     pnert(nvar)     : square root of the associated eigenvalues
*                     in decreasing order.
*     b(minear,ncut): optimum orthonormalized subset {b}.
*
************************************************************************
      dimension work(4)
c
c     vnert = a' * a
      cutoff=0.85d0
      sum2=0.0d0
      call mtxmc(a,nvar,a,minear,work)
      do 10 i=1,(nvar*(nvar+1))/2
  10      work(i)=-work(i)
c     diagonalize in decreasing order of eigenvalues
      if(dabs(work(1)).lt.1.d-28 .and. nvar.eq.1)then
      pnert(1)=dsqrt(-work(1))
      work(1)=1.d15
      vnert(1)=1.d0
      ncut=1
      goto 50
      else
      call hqrii(work,nvar,nvar,pnert, vnert)
c     find ncut according to cutoff, build work = vnert * (pnert)**-0.5
      sum=0.0d0
      do 20 i=1,nvar
   20 sum=sum-pnert(i)
      l=1
      do 40 i=1,nfirst
         sum2=sum2-pnert(i)/sum
         pnert(i)=dsqrt(-pnert(i))
         do 30 j=1,nvar
            work(l)=vnert(l)/pnert(i)
   30    l=l+1
         if(sum2.ge.cutoff) then
            ncut=i
            go to 50
         endif
   40 continue
      ncut=nfirst
c     orthonormalized basis
c     b(minear,ncut) = a(minear,nvar)*work(nvar,ncut)
      endif
   50 call mxm (a,minear,work,nvar,b,ncut)
      return
      end
      subroutine deri22 (c,b,work,norbs,foc2,ab,minear,fci)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      dimension c(norbs,norbs), b(*), work(norbs,norbs), foc2(*),
     1ab(*), fci(*)
************************************************************************
*  1) build the 2-electron fock matrix depending on b as follows :
*     dp = c * scale*b * c' ...  dp density matrix 'derivative',
*     foc2 = 0.5 * trace ( dp * (2<j>-<k>) ) done in fock2 & fock1.
*  2) half-transform onto m.o. basis : dpt =  foc2 * c
*     and compute diagonal blocks elements of c' * foc2, extracting
*     in fci elements over c.i-active m.o only.
*  3) compute supervector ab = (diag + a) * b defined by the matrix :
*     ab(i,j)= ( diag(i,j)*b(i,j)+dpt(i,j) )*scalar(i,j)  with i.gt.j,
*     diag(i,j)=(eigs(i)-eigs(j))/(o(j)-o(i)) >0, o occupancy numbers,
*     eigs eigenvalues of fock operator with eigenvectors c in a.o.
*
*   input
* c(norbs,norbs)   : m.o. eigenvectors (columnwise).
* b(*)             : b supervector packed by off-diagonal blocks, scaled
* work(*)          : work area of size n*n.
* norbs            : number of m.o.s
* nelec,nmos       : last frozen core m.o. , c.i-active band length.
*           in common
* diag,scalar as defined in 'deri0'.
*   output
* foc2(*)       : 2-electron fock matrix, packed canonical.
* ab(*)         : antisymmetric matrix packed in supervector form with
*                 the consecutive following blocks:
*              1) open-closed  i.e. b(ij)=b(i,j) with i open & j closed
*                 and i running faster than j,
*              2) virtual-closed same rule of ordering,
*              3) virtual-open   same rule of ordering.
* fci(*)        : fock diagonal blocks elements over c.i-active m.o.
*            foc2 can be equivalenced with work in the calling sequence.
************************************************************************
c
c  note: norbs and nord are the same address.  the name norbd is not
c        used here.
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm)
     1               ,nlast(numatm),norbd,nelecs,nalpha,nbeta
     2               ,nclose,nopen,ndumy,fract
      common /wmatrc/ wj(n2elec),wk(n2elec)
      common /densty/ pdumy(mpack*2), dpa(mpack)
      common /fokmat/ fdumy(mpack), scalar(mpack)
      common /nvomat/ diag(mpack/2)
      common /work1/ fdumy2(15*npulay), dp(6*npulay)
      common /cibits/ nmos,lab,nelec,nbo(3)
      dimension w(n2elec)
      equivalence (w,wj)
c
      linear=(norbs*(norbs+1))/2
c
c     derivative of the density matrix in dp (packed,canonical).
c     ----------------------------------------------------------
c     dp = c * b * c' .
c
c     step 0 : unscale vector b.
      do 10 i=1,minear
   10 b(i)=b(i)*scalar(i)
c
c     step 1 : work = c * b    .  dp temporary array.
      l=1
      if(nbo(2).ne.0 .and. nbo(1).ne.0) then
c        open-closed
         call mxm(c(1,nbo(1)+1),norbs,b(l),nbo(2),work,nbo(1))
c         closed-open
         call mopm(c,norbs,b(l),nbo(1),work(1,nbo(1)+1),nbo(2))
         l=l+nbo(2)*nbo(1)
      endif
      if(nbo(3).ne.0 .and. nbo(1).ne.0) then
c         virtual-closed
         if(l.gt.1) then
            call mxm(c(1,nopen+1),norbs,b(l),nbo(3),dp,nbo(1))
            do 20 i=1,norbs*nbo(1)
   20       work(i,1)=work(i,1)+dp(i)
         else
            call mxm(c(1,nopen+1),norbs,b(l),nbo(3),work,nbo(1))
         endif
c         closed-virtual
         call mopm(c,norbs,b(l),nbo(1),work(1,nopen+1),nbo(3))
         l=l+nbo(3)*nbo(1)
      endif
      if(nbo(3).ne.0 .and. nbo(2).ne.0) then
c         virtual-open
         call mxm(c(1,nopen+1),norbs,b(l),nbo(3),dp,nbo(2))
         j=norbs*nbo(1)
         do 30 i=1,norbs*nbo(2)
   30    work(j+i,1)=work(j+i,1)+dp(i)
c         open-virtual
         call mopm(c(1,nbo(1)+1),norbs,b(l),nbo(2),dp,nbo(3))
         j=norbs*nopen
         do 40 i=1,norbs*nbo(3)
   40    work(j+i,1)=work(j+i,1)+dp(i)
      endif
c
c     step 2 : dp= work * c'   with dp packed,canonical.
      l=0
      do 50 i=1,norbs
         do 50 j=1,i
            l=l+1
   50 dp(l)=ddot(norbs,work(i,1),norbs,c(j,1),norbs)
c
c     2-electron fock matrix build with the density matrix derivative.
c     ----------------------------------------------------------------
c     returned in foc2 (packed canonical).
      do 60 i=1,linear
         foc2(i)=0.0d0
   60 dpa(i)=0.5d0*dp(i)
      call fock2 (foc2,dp,dpa,w,wj,wk,numat,nat,nfirst,nmidle,nlast)
      call fock1 (foc2,dp,dpa,dpa)
c
c     build dp and extract fci.
c     --------------------------
c
c     dp(norbs,nend) = foc2(norbs,norbs) * c(norbs,nend).
      nend=max(nopen,nelec+nmos)
      l=1
      do 70 i=1,nopen
         call supdot (dp(l),foc2,c(1,i),norbs,1)
   70 l=l+norbs
c     extract fci
      l=1
      nend=0
      do 90 loop=1,3
         ninit=nend+1
         nend =nend+nbo(loop)
         n1=max(ninit,nelec+1   )
         n2=min(nend ,nelec+nmos)
         if(n2.lt.n1) go to 90
         do 80 i=n1,n2
            if(i.gt.ninit) then
               call mxm (c(1,i),1,dp(norbs*(ninit-1)+1),norbs,fci(l),i-n
     1init)
               l=l+i-ninit
            endif
   80    continue
   90 continue
      do 100 i=nelec+1,nelec+nmos
         fci(l)=-ddot(norbs,c(1,i),1,dp(norbs*(i-1)+1),1)
  100 l=l+1
c
c     new supervector ab = (diag + c'* foc2 * c) * b , scaled.
c     --------------------------------------------------------
c
c     part 1 : ab(i,j) = (c' * dp)(i,j) done by blocks.
      l=1
      if(nbo(2).ne.0 .and. nbo(1).ne.0) then
         call mtxm (c(1,nbo(1)+1),nbo(2),dp,norbs,ab(l),nbo(1))
         l=l+nbo(2)*nbo(1)
      endif
      if(nbo(3).ne.0 .and. nbo(1).ne.0) then
         call mtxm (c(1,nopen+1),nbo(3),dp,norbs,ab(l),nbo(1))
         l=l+nbo(3)*nbo(1)
      endif
      if(nbo(3).ne.0 .and. nbo(2).ne.0)
     1call mtxm(c(1,nopen+1),nbo(3),dp(norbs*nbo(1)+1),
     2norbs,ab(l),nbo(2))
c
c     part 2 : ab = scale * (d * b + ab) and rescale basis vector b.
      do 110 i=1,minear
         ab(i)=(diag(i)*b(i)+ab(i))*scalar(i)
  110 b(i)=b(i)/scalar(i)
      return
      end
      subroutine deri23 (f,fd,e,fci,cmo,emo,norbs)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      dimension f(*), fd(*), e(*), fci(*), cmo(norbs,*), emo(*)
***********************************************************************
*  1) unpack the c.i-active m.o. derivatives in m.o. basis,
*     diagonal blocks included.
*  2) extract the fock eigenvalues relaxation over c.i-active m.o.
*   input
*     f           : unscaled solutions vector in m.o. basis,
*                   off-diagonal blocks packed as defined in 'deri21'.
*     fd          : diagonal blocks of non-relaxed fock matrix
*                   as defined in 'deri1'.
*     e(norbs)    : fock eigenvalues.
*     fci         : diagonal blocks of relaxation of the fock matrix.
*     norbs       : number of m.o
*     nelec,nmos  : # of last frozen core m.o , c.i-active band length.
*   output
*     cmo(n,nelec+1,...,nelec+nmos): c.i-active m.o derivatives
*                                  in m.o basis.
*     emo(  nelec+1,...,nelec+nmos): c.i-active fock eigenvalue relaxati
*
***********************************************************************
      common /fokmat/ fdumy(mpack), scalar(mpack)
      common /nvomat/ diag(mpack/2)
      common /cibits/ nmos,lab,nelec,nbo(3)
      common /molkst/ ndumy(4*numatm+8),fract
c
      nopen  =nbo(1)+nbo(2)
      const=1.d-3
c
c     part 1.
c     -------
c     compute and unpack diagonal blocks, diagonal terms included,
c     according to cmo(i,j) = (fd(i,j)-fci(i,j))/(e(i)-e(j))
c     and taking   cmo(i,j)=0 if e(i)=e(j) (threshold 1d-4 ev),
c                             i.e when m.o. degeneracy occurs.
      l=1
      nend=0
      do 30 loop=1,3
         ninit=nend+1
         nend =nend+nbo(loop)
         n1=max(ninit,nelec+1   )
         n2=min(nend ,nelec+nmos)
         if(n2.lt.n1) go to 30
         do 20 i=n1,n2
            if(i.gt.ninit) then
               do 10 j=ninit,i-1
                  diffe=e(i)-e(j)
                  if(dabs(diffe).gt.1.d-4) then
                     com=(fd(l)-fci(l))/diffe
                  else
                     com=0.0d0
                  endif
                  cmo(i,j)=-com
                  cmo(j,i)= com
   10          l=l+1
            endif
   20    cmo(i,i)= 0.d0
   30 continue
c
c     c.i-active eigenvalues relaxation.
      call dcopy(nmos,fci(l),1,emo(nelec+1),1)
c
c     part 2.
c     -------
c     unpack the antisymmetric matrix f in cmo, (off-diagonal blocks).
c
      l=1
      if(nbo(2).gt.0 .and. nbo(1).gt.0) then
c        open-closed
         scal=1.d0/(2.d0-fract+const)
         do 40 j=1       ,nbo(1)
            do 40 i=nbo(1)+1,nopen
               com=f(l)*scal
               cmo(i,j)=-com
               cmo(j,i)= com
   40    l=l+1
      endif
      if(nbo(3).gt.0 .and. nbo(1).gt.0) then
c         virtual-closed
         scal=0.5d0
         do 50 j=1     ,nbo(1)
            do 50 i=nopen+1,norbs
               com=f(l)*scal
               cmo(i,j)=-com
               cmo(j,i)= com
   50    l=l+1
      endif
      if(nbo(3).ne.0 .and. nbo(2).ne.0) then
c        virtual-open
         scal=1.d0/(fract+const)
         do 60 j=nbo(1)+1,nopen
            do 60 i=nopen+1  ,norbs
               com=f(l)*scal
               cmo(i,j)=-com
               cmo(j,i)= com
   60    l=l+1
      endif
      return
      end
      subroutine deritr(errfn,geo)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      dimension geo(3,numatm), errfn(maxpar)
************************************************************************
*
*    deritr calculates the derivatives of the energy with respect to the
*          internal coordinates. this is done by finite differences
*          using full scf calculations.
*
*          this is very time-consuming, and should only be used when
*          no other derivative calculation will do.
*
*    the main arrays in deriv are:
*        loc    integer array, loc(1,i) contains the address of the atom
*               internal coordinate loc(2,i) is to be used in the
*               derivative calculation.
*        geo    array \geo\ holds the internal coordinates.
*
************************************************************************
      common /euler/  tvec(3,3), id
      common /geovar/ nvar,loc(2,maxpar), idumy, dummy(maxpar)
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),
     1                nlast(numatm), norbs, nelecs,nalpha,nbeta,
     2                nclose,nopen,ndumy,fract
      common /geokst/ natoms,labels(numatm),
     1na(numatm),nb(numatm),nc(numatm)
      common /geosym/ ndep, idumys(maxpar,3)
      common /ucell/ l1l,l2l,l3l,l1u,l2u,l3u
      common /enuclr/ enuclr
      common /numcal/ numcal
      common /densty/ p(mpack), pa(mpack), pb(mpack)
      common /wmatrc/ wj(n2elec), wk(n2elec)
      common /hmatrx/ h(mpack)
      common /keywrd/ keywrd
      common /iofile/ mfgr,mfgw
      character*241 keywrd
      dimension change(3), coord(3,numatm)
     1,         xderiv(3), xparam(maxpar), xjuc(3), w(n2elec)
      REAL wj, wk
      save idelta, xderiv
      logical debug
      equivalence (w,wj)
      save icalcn,debug,change
      data icalcn /0/
      if(icalcn.ne.numcal) then
         debug = (index(keywrd,'deritr') .ne. 0)
         icalcn=numcal
*
*   idelta is a machine-precision dependant integer
*
         idelta=-3
         change(1)= 10.d0**idelta
         change(2)= 10.d0**idelta
         change(3)= 10.d0**idelta
c
c    change(i) is the step size used in calculating the derivatives.
c    because full scf calculations are being done quite large steps
c    are needed.  on the other hand, the step cannot be very large,
c    as the second derivitive in flepo is calculated from the
c    differences of two first derivatives. change(1) is for change in
c    bond length, (2) for angle, and (3) for dihedral.
c
         xderiv(1)= 0.5d0/change(1)
         xderiv(2)= 0.5d0/change(2)
         xderiv(3)= 0.5d0/change(3)
      endif
      do 10 i=1,nvar
   10 xparam(i)=geo(loc(2,i),loc(1,i))
      if(ndep.ne.0) call mopsym()
      call gmetry(geo,coord)
c
c  establish the energy at the current point
c
      call mophc(coord,h,w,wj,wk,enuclr)
      if(norbs*nelecs.gt.0)then
         call iterm(h, w, wj, wk, aa,.true.,.false.)
      else
         aa=0.0d0
      endif
      linear=(norbs*(norbs+1))/2
c
c  restore the density matrix (why?)
c
      do 20 i=1,linear
   20 p(i)=pa(i)*2.d0
      aa=(aa+enuclr)
      ij=0
      do 60 ii=1,numat
         do 50 il=l1l,l1u
            do 50 jl=l2l,l2u
               do 50 kl=l3l,l3u
                  do 30 ll=1,3
   30             xjuc(ll)=coord(ll,ii)+tvec(ll,1)*il+tvec(ll,2)*jl+tvec
     1(ll,3)*kl
                  ij=ij+1
   50    continue
   60 continue
      do 90 i=1,nvar
         k=loc(1,i)
         l=loc(2,i)
         xstore=xparam(i)
         do 70 j=1,nvar
   70    geo(loc(2,j),loc(1,j))=xparam(j)
         geo(l,k)=xstore-change(l)
         if(ndep.ne.0) call mopsym()
         call gmetry(geo,coord)
c
c   if needed, calculate "exact" derivitives.
c
         call mophc(coord,h,w,wj,wk,enuclr)
         if(norbs*nelecs.gt.0)then
            call iterm(h,w, wj, wk,ee,.true.,.false.)
         else
            ee=0.0d0
         endif
         do 80 ii=1,linear
   80    p(ii)=pa(ii)*2.d0
         ee=(ee+enuclr)
         errfn(i)=(aa-ee)*23.061d0*xderiv(l)*2.d0
   90 continue
      if(debug)then
         write(mfgw,'('' error function'')')
         write(mfgw,'(10f8.3)')(errfn(i),i=1,nvar)
      endif
      return
      end
      subroutine dernvo(coord,dxyz)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      dimension coord(3,*), dxyz(*)
***********************************************************************
*
*    implementation of analytical formulation for open shell or ci,
*                      variables finite difference methods,
*                      statistical estimate of the errors,
*                   by d. liotard
*                      laboratoire de chimie structurale
*                      universite de pau et des pays de l'adour
*                      avenue de l'universite, 64000, pau (france)
*
*
*   modified by jjps to conform to mopac conventions
*   (note by jjps:  prof. liotard's technique works.  if this
*   implementation does not work, the reason is a fault introduced
*   by jjps, and does not reflect on prof. liotard's ability)
*
*
*    as the wave function is not variationally optimized, i.e.
*    half-electron or ci, the derivatives of the 1 and 2-electron
*    integrals in a.o. basis are evaluated in cartesian coordinates
*    by a 1 or 2 points finite difference formula and stored.
*    thus one gets the non-relaxed (i.e. frozen electronic cloud)
*    contribution to the fock eigenvalues and 2-electron integrals in
*    an m.o. basis.  the non-relaxed gradient comes from the
*    non-relaxed c.i. matrix derivative (subroutine deri1).
*    the derivatives of the m.o. coefficients are then worked out
*    iteratively (ok for both closed shells and half-electron cases)
*    and stored. thus one gets the electronic relaxation contribution to
*    the fock eigenvalues and 2-electron integrals in m.o. basis.
*    finally the relaxation contribution to the c.i. matrix derivative
*    gives the relaxation contribution to the gradient (routine deri2).
*
*
*        coord  holds the cartesian coordinates.
*    input
*        dxyz   not defined.
*    exit
*        dxyz   derivatives of energy w.r.t cartesian coordinates,
*               in kcal/mol/angstrom (3 * numat of these)
*
***********************************************************************
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm)
     1               ,nlast(numatm), norbs, nelecs,nalpha,nbeta
     2               ,nclose,nopen,ndumy,fract
      common /gradnt/ grad(maxpar),gnorm
      common /cibits/ nmos,lab,nelec,nbo(3)
      common /numcal/ numcal
      common /keywrd/ keywrd
      common /vector/ c(morb2),eigs(maxorb),cbeta(morb2)
     3,eigb(maxorb)
      common /fokmat/ fdumy(mpack), scalar(mpack)
      common /nvomat/ diag(mpack/2)
      common /work1/ fmooff(npulay*4), fmoon(npulay*4),
     1work2(9*npulay), work3(4*npulay)
      common/iofile/mfgr,mfgw
      dimension fbwo(5*maxpar)
      character keywrd*241, blank*60
      dimension dxyzr(maxpar), eigbb(6*maxpar)
      logical debug, dcar, large, relaxd, force
      save icalcn,nvax
      save throld,debug,large,force,dcar,dxyzr,minear,ninear
      data icalcn /0/
c
c     select the required option and read keywords
c     --------------------------------------------
c
      if(icalcn.ne.numcal) then
         throld=0.08d0
         debug = (index(keywrd,'dernvo') .ne. 0)
         large = (index(keywrd,'large') .ne. 0)
         force = (index(keywrd,'forc') .ne. 0)
         dcar  = (index(keywrd,'forc') + index(keywrd,'prec') .ne. 0)
         if(dcar)throld=0.004d0
         do 11 i=1,nvax
   11    dxyzr(i)=0.0d0
c        actual sizes for c.i. gradient calculation.
         nbo(1)=nclose
         nbo(2)=nopen-nclose
         nbo(3)=norbs-nopen
         minear=nbo(2)*nbo(1)+nbo(3)*nopen
         ninear=(nmos*(nmos+1))/2+1
         icalcn = numcal
      endif
c        scaling row factors to speed cv of relaxation procedure.
c#      call timop('before deri0')
      call deri0 (eigs,norbs,scalar,diag,fract,nbo)
c#      call timop('after deri0')
      nvax=3*numat
c
c   because deri2 is cpu intensive, and the contribution to the
c   derviative due to relaxation of the electron cloud is relatively
c   insensitive to changes in geometry, where possible only calculate
c   the derivative every 2 calls to dernvo
c
      sum=0.0d0
      if(dcar)then
         do 10 i=1,nvax
   10    dxyzr(i)=0.0d0
         relaxd=.false.
      endif
      do 20 i=1,nvax
   20 sum=sum+dabs(dxyzr(i))
      relaxd=(sum.gt.1.d-7)
c
c  if dxyzr contains data, use it and flush after use.
c
      ilast=0
   30 ifirst=ilast+1
      j=2
      if(min(nw2,nw3)/max(minear,ninear).lt.10)j=1
      ilast=min(nvax,ilast+j)
      j=1-minear
      k=1-ninear
      do 40 i=ifirst,ilast
         k=k+ninear
         j=j+minear
c
c        non-relaxed contribution (frozen electronic cloud) in dxyz
c        and non-relaxed fock matrices in fmooff and fmoon.
c   contents of f-mo-off: open-closed, virtual-closed, and virtual-open
c   contents of f-mo-on:  closed-closed, open-open and virtual-virtual
c   over m.o. indices
c
c#      call timop('before deri1')
         call deri1(c,norbs,coord,i,cbeta,dxyz(i),fmooff(j),minear
     1              ,fmoon(k),work2,work2(6*mpack),work3)
c#      call timop('after deri1')
   40 continue
      if(debug)then
         if(ifirst.eq.1.and.large)then
            write(mfgw,*)' contents of fmooff '
            write(mfgw,*)' open-closed'
            write(mfgw,'(7x,i3,5i12)')(j,j=nclose+1,nopen)
            do 50 i=1,nclose
   50       write(mfgw,'(i3,6f12.6)')
     +      i,(fmooff(j),j=(i-1)*nbo(2)+1,i*nbo(2))
c
c
            write(mfgw,*)' virtual-closed'
            k=nclose*nbo(2)
            write(mfgw,'(7x,i3,5i12)')(j,j=nopen+1,min(nopen+6,norbs))
            do 60 i=1,nclose
   60       write(mfgw,'(i3,6f12.6)')i,
     1   (fmooff(j+k),j=(i-1)*nbo(3)+1,min(6+(i-1)*nbo(3),i*nbo(3)))
            k=nclose*nbo(2)+nbo(3)*nclose
c
c
            write(mfgw,*)' virtual-open'
            write(mfgw,'(7x,i3,4i12)')(j,j=nclose+1,nopen)
            do 70 i=1,min(6,nbo(3))
   70       write(mfgw,'(i3,6f12.6)')i+nopen,
     1   (fmooff(j+k),j=(i-1)*nbo(2)+1,min((i-1)*nbo(2)+6,i*nbo(2)))
            write(mfgw,*)
     +      ' contents of fmoon (active-space -- active space)'
            k=(nmos*(nmos-1))/2
            ll=1
            blank=' '
            do 80 i=1,nmos
               l=ll+nmos-i-1
               write(mfgw,'(a,5f12.6)')blank(:12*i),
     +         (fmoon(j),j=ll,l),fmoon(k+i)
   80       ll=l+1
         endif
      endif
c        compute the electronic relaxation contribution.
c
c   dernvo provides the following scratch areas to deri2: eigb, work2,
c          work3, fbwo, cbeta.  these are dimensioned on entry to deri2
c          which is why they are not declared there.  they are not used
c          at all in dernvo.
c
c#      call timop('before deri2')
      if(.not.relaxd)
     1   call deri2 (c,eigs,norbs,minear,fmooff
     2              ,fmoon,eigbb, ninear,ilast-ifirst+1
     3              ,cbeta,work2,nw2,dxyzr(ifirst)
     4              ,work3,nw3,fbwo,throld)
c#      call timop('after deri2')
      if (ilast.lt.nvax) go to 30
      if(debug)then
         sumx=0.0d0
         sumy=0.0d0
         sumz=0.0d0
         do 90 i=1,numat
            sumx=sumx+dxyz(i*3-2)
            sumy=sumy+dxyz(i*3-1)
   90    sumz=sumz+dxyz(i*3)
         write(mfgw,*)' cartesian derivatives due to frozen core'
         write(mfgw,'('' atom    x           y           z'')')
         do 100 i=1,numat
  100    write(mfgw,'(i4,3f12.7)')i,dxyz(i*3-2),dxyz(i*3-1),dxyz(i*3)
         write(mfgw,'(/10x,''residual error'')')
         write(mfgw,'(4x,3f12.7)')sumx,sumy,sumz
         write(mfgw,*)
         sumx=0.0d0
         sumy=0.0d0
         sumz=0.0d0
         do 110 i=1,numat
            sumx=sumx+dxyzr(i*3-2)
            sumy=sumy+dxyzr(i*3-1)
  110    sumz=sumz+dxyzr(i*3)
         write(mfgw,*)' cartesian derivatives due to relaxing core'
         write(mfgw,'('' atom    x           y           z'')')
         do 120 i=1,numat
  120    write(mfgw,'(i4,3f12.7)')i,dxyzr(i*3-2),dxyzr(i*3-1),dxyzr(i*3)
         write(mfgw,'(/10x,''residual error'')')
         write(mfgw,'(4x,3f12.7)')sumx,sumy,sumz
         write(mfgw,*)
      endif
      do 130 i=1,nvax
  130 dxyz(i)=dxyz(i)+dxyzr(i)
      if(relaxd)then
         do 140 i=1,nvax
  140    dxyzr(i)=0.0d0
      endif
      sumx=0.0d0
      sumy=0.0d0
      sumz=0.0d0
      do 150 i=1,numat
         sumx=sumx+dxyz(i*3-2)
         sumy=sumy+dxyz(i*3-1)
  150 sumz=sumz+dxyz(i*3)
      sum=dmax1(1.d-10,dabs(sumx)+dabs(sumy)+dabs(sumz))
c
c  here is a rough but simple method for defining throld for deri2
c  it may need more work
c
      if(.not. force .and. gnorm .gt. 0.001d0)
     1 throld=throld*dsqrt(gnorm/(sum*100.d0))
      throld=dmin1(2.d0,dmax1(0.002d0,throld))
      if(debug)then
         write(mfgw,*)
     +   'cartesian derivatives from analytical c.i. calculation'
         write(mfgw,'('' atom    x           y           z'')')
         do 160 i=1,numat
  160    write(mfgw,'(i4,3f12.7)')i,dxyz(i*3-2),dxyz(i*3-1),dxyz(i*3)
         write(mfgw,'(/10x,''residual error'')')
         write(mfgw,'(4x,3f12.7)')sumx,sumy,sumz
         write(mfgw,*)
      endif
      return
      end
      subroutine ders(m,n,rr,del1,del2,del3,is,iol)
      implicit REAL (a-h,o-z)
************************************************************************
*                                                                      *
*    on input m    = index of first atomic orbital                     *
*             n    = index of second atomic orbital                    *
*             rr   = square if interatomic diatance (in bohr)          *
*             del1 = catersian distance in derivative direction        *
*             del2 = cartesian distance in m a.o.'s direction          *
*             del3 = cartesian distance in n a.o.'s direction          *
*             is   = indicates type of a.o.-a.o. interaction           *
*                  = 1 s/s, 2 s/p', 3 s/p, 4 p'/s, 5 p/s, 6 p/p',      *
*                    7 p'/p", 8 p'p', 9 p/p                            *
*             iol  = index for storing derivatives in ds               *
*                                                                      *
************************************************************************
      common /derivs/ ds(16),dg(22),dr(100),tdx(3),tdy(3),tdz(3)
      common /temp/  cg(60,6),zg(60,6)
      dimension ss(6,6)
      a0=0.529167d0
      do 110 i=1,6
         do 110 j=1,6
            ss(i,j)=0.0d0
            apb=zg(m,i)*zg(n,j)
            amb=zg(m,i)+zg(n,j)
            adb=apb/amb
            adr=dmin1(adb*rr,35.d0)
            go to (10,20,30,40,50,60,70,80,90),is
   10       abn=-2.0d0*adb*del1/(a0**2)
            go to 100
   20       abn=-4.0d0*(adb**2)*del1*del2/(dsqrt(zg(n,j))*(a0**3))
            go to 100
   30       abn=(2.0d0*adb/(dsqrt(zg(n,j))*a0))*
     1 (1.0d0-2.0d0*adb*(del1**2)/(a0**2))
            go to 100
   40       abn=4.0d0*(adb**2)*del1*del2/(dsqrt(zg(m,i))*(a0**3))
            go to 100
   50       abn=-(2.0d0*adb/(dsqrt(zg(m,i))*a0))*
     1 (1.0d0-2.0d0*adb*(del1**2)/(a0**2))
            go to 100
   60       abn=-(4.0d0*(adb**2)*del2/(dsqrt(apb)*(a0**2)))*
     1 (1.0d0-2.0d0*adb*(del1**2)/(a0**2))
            go to 100
   70       abn=8.0d0*(adb**3)*del1*del2*del3/(dsqrt(apb)*(a0**4))
            go to 100
   80       abn=-(8.0d0*(adb**2)*del1/(dsqrt(apb)*(a0**2)))*
     1 (0.5d0-adb*(del2**2)/(a0**2))
            go to 100
   90       abn=-(8.0d0*(adb**2)*del1/(dsqrt(apb)*(a0**2)))*
     1 (1.5d0-adb*(del1**2)/(a0**2))
  100       ss(i,j)=dsqrt((2.0d0*dsqrt(apb)/amb)**3)*dexp(-adr)*abn
  110 continue
      do 120 i=1,6
         do 120 j=1,6
            ds(iol)=ds(iol)+ss(i,j)*cg(m,i)*cg(n,j)
  120 continue
      return
      end
      function det_mop(a,b,c)
      implicit REAL (a-h,o-z)
      dimension a(3)
      dimension b(3)
      dimension c(3)
      dimension ab(3)
      call cross(a,b,ab)
      det_mop = dot1(ab,c)
      return
      end
      function dex2(m)
      implicit REAL (a-h,o-z)
      if(m .lt. 2) then
         dex2=1
      else
         dex2=1
         do 10 i=1,m,2
   10    dex2=dex2*i
      endif
      return
      end
      subroutine dfock2(f, ptot, p, w, numat, nfirst,
     1nmidle, nlast, nati)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      dimension f(*), ptot(*),  nfirst(*), nmidle(*),
     1          nlast(*), p(*), w(*)
c***********************************************************************
c
c     dfock2 adds the 2-electron 2-center repulsion contribution to
c     the fock matrix derivative within the nddo or mindo formalisms.
c  input
c     f    : 1-electron contributions derivatives.
c     ptot : total density matrix.
c     p    : alpha or beta density matrix. = 0.5 * ptot
c     w    : non vanishing two-electron integral derivatives
c            (ordered as defined in dhcore).
c     nati : # of the atom supporting the varying cartesian coordinate.
c  output
c     f    : fock matrix derivative with respect to the cart. coord.
c
c***********************************************************************
      common /numcal/ numcal
      common /work4/ ptot2(numatm,16)
      common /keywrd/ keywrd
      save itype
      common /work6/ ifact(maxorb),i1fact(maxorb), jindex(256), 
     + kindex(256), ijperm(10), llperm(10),
     + pk(16), pja(16), pjb(16), mmperm(10), jjndex(256), ione
      character*241 keywrd
      save icalcn
      data itype /1/
      data icalcn/0/
      if(icalcn.ne.numcal)then
         icalcn=numcal
         itype=0
      endif
   10 continue
      goto (20,270,70) itype
   20 continue
c
c   set up array of lower half triangle indices (pascal's triangle)
c
      do 30 i=1,maxorb
         ifact(i)=(i*(i-1))/2
   30 i1fact(i)=ifact(i)+i
c
c   set up gather-scatter type arrays for use with two-electron
c   integrals.  jindex are the indices of the j-integrals for atom i
c   integrals.  jjndex are the indices of the j-integrals for atom j
c               kindex are the indices of the k-integrals
c
      m=0
      do 40 i=1,4
         do 40 j=1,4
            ij=min(i,j)
            ji=i+j-ij
            do 40 k=1,4
               ik=min(i,k)
               ki=i+k-ik
               do 40 l=1,4
                  m=m+1
                  kl=min(k,l)
                  lk=k+l-kl
                  jl=min(j,l)
                  lj=j+l-jl
                  kindex(m)= ifact(lj) +jl + 10*( ifact(ki) +ik) -10
   40 jindex(m)=(ifact(ji) + ij)*10 + ifact(lk) + kl - 10
      l=0
      do 50 i=1,4
         i1=(i-1)*4
         do 50 j=1,i
            i1=i1+1
            l=l+1
            ijperm(l)=i1
            mmperm(l)=ijperm(l)-16
            llperm(l)=(i1-1)*16
   50 continue
      l=0
      do 60 i=1,10
         m=mmperm(i)
         l=llperm(i)
         do 60 k=1,16
            l=l+1
            m=m+16
   60 jjndex(l)=jindex(m)
      if(index(keywrd,'mindo') .ne. 0) then
         itype=2
      else
         itype=3
      endif
      goto 10
   70 kk=0
      l=0
      do 90 i=1,numat
         ia=nfirst(i)
         ib=nlast(i)
         m=0
         do 80 j=ia,ib
            do 80 k=ia,ib
               m=m+1
               jk=min(j,k)
               kj=k+j-jk
               jk=jk+(kj*(kj-1))/2
               ptot2(i,m)=ptot(jk)
   80    continue
   90 continue
      ii=nati
      ia=nfirst(ii)
      ib=nlast(ii)
      do 260 jj=1,numat
         if(ii.eq.jj) goto 260
         ja=nfirst(jj)
         jb=nlast(jj)
         jc=nmidle(jj)
            if(ib-ia.ge.3.and.jb-ja.ge.3)then
c
c                         heavy-atom  - heavy-atom
c
c   extract coulomb terms
c
               do 100 i=1,16
                  pja(i)=ptot2(ii,i)
  100          pjb(i)=ptot2(jj,i)
c
c  coulomb terms
c
               call jab(ia,ja,llperm,jindex, jjndex, pja,pjb,w(kk+1),
     1f)
c
c  exchange terms
c
c
c  extract intersection of atoms ii and jj in the spin density matrix
c
               if(ia.gt.ja)then
                  l=0
                  do 110 i=ia,ib
                     do 110 j=ja,jb
                        l=l+1
  110             pk(l)=p(ifact(i)+j)
               else
                  l=0
                  do 120 i=ia,ib
                     do 120 j=ja,jb
                        l=l+1
  120             pk(l)=p(ifact(j)+i)
               endif
               i1=ia
               j1=ja
               call kab(ia,ja, pk, w(kk+1), kindex, f)
               ia=i1
               ja=j1
               kk=kk+100
            elseif(ib-ia.ge.3)then
c
c                         light-atom  - heavy-atom
c
c
c   coulomb terms
c
               sumdia=0.0d0
               sumoff=0.0d0
               ll=i1fact(ja)
               k=0
               do 140 i=0,3
                  j1=ifact(ia+i)+ia-1
                  do 130 j=0,i-1
                     k=k+1
                     j1=j1+1
                     f(j1)=f(j1)+ptot(ll)*w(kk+k)
  130             sumoff=sumoff+ptot(j1)*w(kk+k)
                  j1=j1+1
                  k=k+1
                  f(j1)=f(j1)+ptot(ll)*w(kk+k)
  140          sumdia=sumdia+ptot(j1)*w(kk+k)
               f(ll)=f(ll)+sumoff*2.d0+sumdia
c
c  exchange terms
c
c
c  extract intersection of atoms ii and jj in the spin density matrix
c
               if(ia.gt.ja)then
                  k=0
                  do 160 i=ia,ib
                     i1=ifact(i)+ja
                     sum=0.0d0
                     do 150 j=ia,ib
                        k=k+1
                        j1=ifact(j)+ja
  150                sum=sum+p(j1)*w(kk+jindex(k))
  160             f(i1)=f(i1)-sum
               else
                  k=0
                  do 180 i=ia,ib
                     i1=ifact(ja)+i
                     sum=0.0d0
                     do 170 j=ia,ib
                        k=k+1
                        j1=ifact(ja)+j
  170                sum=sum+p(j1)*w(kk+jindex(k))
  180             f(i1)=f(i1)-sum
               endif
               kk=kk+10
            elseif(jb-ja.ge.3)then
c
c                         heavy-atom - light-atom
c
c
c   coulomb terms
c
               sumdia=0.0d0
               sumoff=0.0d0
               ll=i1fact(ia)
               k=0
               do 200 i=0,3
                  j1=ifact(ja+i)+ja-1
                  do 190 j=0,i-1
                     k=k+1
                     j1=j1+1
                     f(j1)=f(j1)+ptot(ll)*w(kk+k)
  190             sumoff=sumoff+ptot(j1)*w(kk+k)
                  j1=j1+1
                  k=k+1
                  f(j1)=f(j1)+ptot(ll)*w(kk+k)
  200          sumdia=sumdia+ptot(j1)*w(kk+k)
               f(ll)=f(ll)+sumoff*2.d0+sumdia
c
c  exchange terms
c
c
c  extract intersection of atoms ii and jj in the spin density matrix
c
               if(ia.gt.ja)then
                  k=ifact(ia)+ja
                  j=0
                  do 220 i=k,k+3
                     sum=0.0d0
                     do 210 l=k,k+3
                        j=j+1
  210                sum=sum+p(l)*w(kk+jindex(j))
  220             f(i)=f(i)-sum
               else
                  j=0
                  do 240 k=ja,ja+3
                     i=ifact(k)+ia
                     sum=0.0d0
                     do 230 ll=ja,ja+3
                        l=ifact(ll)+ia
                        j=j+1
  230                sum=sum+p(l)*w(kk+jindex(j))
  240             f(i)=f(i)-sum
               endif
               kk=kk+10
            else
c
c                         light-atom - light-atom
c
               i1=i1fact(ia)
               j1=i1fact(ja)
               f(i1)=f(i1)+ptot(j1)*w(kk+1)
               f(j1)=f(j1)+ptot(i1)*w(kk+1)
               if(ia.gt.ja)then
                  ij=i1+ja-ia
                  f(ij)=f(ij)-p   (ij)*w(kk+1)
               else
                  ij=j1+ia-ja
                  f(ij)=f(ij)-p   (ij)*w(kk+1)
               endif
               kk=kk+1
            endif
  260 continue
c
      return
  270 kr=0
      ii=nati
      ia=nfirst(ii)
      ib=nlast(ii)
      do 290 jj=1,numat
         if (jj.eq.ii) go to 290
         kr=kr+1
         elrep=w(kr)
         ja=nfirst(jj)
         jb=nlast(jj)
         do 280 i=ia,ib
            ka=ifact(i)
            kk=ka+i
            do 280 k=ja,jb
               ll=i1fact(k)
               if (ja.lt.ia) then
                  ik=ka+k
               else
                  ik=ll+i-k
               endif
               f(kk)=f(kk)+ptot(ll)*elrep
               f(ll)=f(ll)+ptot(kk)*elrep
  280    f(ik)=f(ik)-p(ik)*elrep
  290 continue
      return
      end
      subroutine dfpsav(totime,xparam,gd,xlast,funct1,mdfp,xdfp)
      implicit REAL (a-h,o-z)
_IF(ipsc,tools)
      logical oroot
_ENDIF
INCLUDE(common/sizes)
INCLUDE(../m4/common/utilc)
      dimension xparam(*), gd(*), xlast(*), mdfp(9),xdfp(9)
**********************************************************************
*
* dfpsav stores and restores data used in the d-f-p geometry
*        optimisation.
*
*  on input totime = total cpu time elapsed during the calculation.
*           xparam = current value of parameters.
*           gd     = old gradient.
*           xlast  = old value of parameters.
*           funct1 = current value of heat of formation.
*           mdfp   = integer constants used in d-f-p.
*           xdfp   = real constants used in d-f-p.
*           mdfp(9)= 1 for dump, 0 for restore.
**********************************************************************
      common /keywrd/ keywrd
      common /gradnt/ grad(maxpar),gnorm
      common /geovar/ nvar,loc(2,maxpar), idumy, dumy(maxpar)
      common /densty/ p(mpack), pa(mpack), pb(mpack)
      common /alparm/ alparm(3,maxpar),x0, x1, x2, iloop
      common /pparam/ currt
      common /gparam/ currt1,currt2
      common /profilm/ profil
      common /surf/ surf
      common /kloop/ kloop
      common /ijlp/ ijlp, ilp, jlp, jlp1, ione
      common /reactn/ step, geoa(3,numatm), geovec(3,numatm),calcst
      common /cmpg/ geo(3,numatm)
      common /geokst/ natoms,labels(numatm),
     1                na(numatm),nb(numatm),nc(numatm)
      common /elemts/ elemnt(107)
      character koment*81, title*81
      common /titles/ koment,title
      common /path/ latom,lparam,react(200)
      common /mesh/ latom1,lpara1,latom2,lpara2
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),
     1                nlast(numatm), norbs, nelecs,nalpha,nbeta,
     2                nclose,nopen,ndumy,fract
      common /fmatrx/ hesinv(maxpar**2+maxpar*3+1), idumy2(4)
      common /errfn/ errfn(maxpar), aicorr(maxpar)
      common /numcal/ numcal
      common/iofile/mfgr,mfgw
      dimension coord(3,numatm)
      dimension profil(200)
      dimension surf(23*23)
      character elemnt*2, keywrd*241, getmop*80
      save first
      logical first, intxyz
      data icalcn/0/
      first=(icalcn.eq.numcal)
_IF(ipsc,tools)
      if(oroot().and.odumpm) then
_ELSE
      if(odumpm) then
_ENDIF
      open(unit=9,file=getmop(3)
     +                     ,status='unknown',form='unformatted')
      rewind 9
      open(unit=10,file=getmop(4)
     +                     ,status='unknown',form='unformatted')
      rewind 10
      endif
      ir=9
      if(mdfp(9) .ne. 0) then
         if(mdfp(9) .eq. 1) then
_IF(ipsc,tools)
         if (oroot().and.odumpm) then
_ELSE
         if (odumpm) then
_ENDIF
            write(mfgw,
     +      '(//10x,''- - - - - - - time up - - - - - - -'',//)')
            if(index(keywrd,'saddle') .ne. 0) then
               write(mfgw,'(//10x,'' no restart exists for saddle'',//
     1  10x,'' here is a data-file files that might be suitable'',/
     2  10x,'' for restarting the calculation'',///)')
               write(mfgw,'(a)')keywrd,koment,title
               intxyz=(na(1).eq.0)
               do 30 iloop=1,2
                  if(intxyz)then
                     geo(2,1)=0.0d0
                     geo(3,1)=0.0d0
                     geo(1,1)=0.0d0
                     geo(2,2)=0.0d0
                     geo(3,2)=0.0d0
                     geo(3,3)=0.0d0
                     do 10 i=1,natoms
                        do 10 j=1,3
   10                coord(j,i)=geo(j,i)
                  else
                     call mopxyz(geo,numat,na,nb,nc,1.d0,coord)
                  endif
                  call geout(-6)
                  do 20 i=1,natoms
                     do 20 j=1,3
   20             geo(j,i)=geoa(j,i)
                  na(1)=99
   30          continue
               write(mfgw,'(///10x,''calculation terminated here'')')
_IF(ipsc,tools)
               call pend
_ELSE
               stop
_ENDIF
            endif
            write(mfgw,'(//10x,
     +         '' - the calculation is being dumped to disk'',  /10x,
     +         ''   restart it using the magic word "restart"'')')
            write(mfgw,'(//10x,''current value of heat of formation =''
     1  ,f12.6)')funct1
         endif
         if(mdfp(9) .eq. 1)then
            if(na(1) .eq. 99) then
c
c  convert from cartesian coordinates to internal
c
               do 40 i=1,natoms
                  do 40 j=1,3
   40          coord(j,i)=geo(j,i)
               call mopxyz(coord,numat,na,nb,nc,1.d0,geo)
            endif
            geo(2,1)=0.0d0
            geo(3,1)=0.0d0
            geo(1,1)=0.0d0
            geo(2,2)=0.0d0
            geo(3,2)=0.0d0
            geo(3,3)=0.0d0
            na(1)=0
            call geout(6)
         endif
         write(ir)mdfp,xdfp,totime,funct1
         write(ir)(xparam(i),i=1,nvar),(gd(i),i=1,nvar)
         write(ir)(xlast(i),i=1,nvar),(grad(i),i=1,nvar)
         linear=(nvar*(nvar+1))/2
         write(ir)(hesinv(i),i=1,linear)
         linear=(norbs*(norbs+1))/2
         write(10)(pa(i),i=1,linear)
         if(nalpha.ne.0)write(10)(pb(i),i=1,linear)
         if(latom.ne.0)then
            if(index(keywrd,'step').ne.0)then
               write(ir) kloop
               write(ir) currt
               write(ir) (profil(i),i=1,kloop)
            else
               write(ir)((alparm(j,i),j=1,3),i=1,nvar)
               write(ir)iloop,x0, x1, x2
            endif
         endif        
         if(index(keywrd,'step1').ne.0)then
            write(ir)ijlp, ilp,jlp,jlp1,ione
            write(ir) currt1,currt2
            write(ir) (surf(i),i=1,ijlp)
         endif
         write(ir)(errfn(i),i=1,nvar)
         close (9)
         close (10)
       endif
      else
         if (first) 
     +    write(mfgw,'(//10x,'' restoring data from disk''/)')
_IF(ipsc,tools)
         if(oroot()) then
_ENDIF
         read(ir,end=60,err=60)mdfp,xdfp,totime,funct1
         if (first) write(mfgw,'(10x,''function ='',f13.6//)')
     +    funct1
         read(ir)(xparam(i),i=1,nvar),(gd(i),i=1,nvar)
         read(ir)(xlast(i),i=1,nvar),(grad(i),i=1,nvar)
         linear=(nvar*(nvar+1))/2
         read(ir)(hesinv(i),i=1,linear)
         linear=(norbs*(norbs+1))/2
         read(10)(pa(i),i=1,linear)
         if(nalpha.ne.0)read(10)(pb(i),i=1,linear)
         if(latom.ne.0)then
            if(index(keywrd,'step').ne.0)then
               read(ir) kloop
               read(ir) currt
               read(ir) (profil(i),i=1,kloop)
            else
               read(ir)((alparm(j,i),j=1,3),i=1,nvar)
               read(ir)iloop,x0, x1, x2
            endif
         endif        
         if(index(keywrd,'step1').ne.0)then
            read(ir)ijlp, ilp,jlp,jlp1,ione
            read(ir) currt1,currt2
            read(ir) (surf(i),i=1,ijlp)
         endif
         read(ir)(errfn(i),i=1,nvar)
         first=.false.
_IF(ipsc,tools)
      else
         write(mfgw,*)' restarts not implemented in dfpsav'
         go to 61
      endif
_ENDIF
         return
   60    write(mfgw,'(//10x,''no restart file exists!'')')
_IF(ipsc,tools)
   61    call pend
_ELSE
         stop
_ENDIF
      endif
      end
      subroutine dhc (p,pa,pb,xi,nat,if,im,il,jf,jm,jl,dener,mode)
      implicit REAL (a-h,o-z)
      dimension p(*), pa(*), pb(*)
      dimension xi(3,*),nfirst(2),nmidle(2),nlast(2),nat(*)
c***********************************************************************
c
c  dhc calculates the energy contributions from those pairs of atoms
c         that have been moved by subroutine mopdv.
c
c***********************************************************************
      common /keywrd/ keywrd
      common /cmpone/ uss(107),upp(107),udd(107)
      common /euler/ tvec(3,3), id
      common /numcal/ numcal
      save icalcn, wlim, uhf
      character*241 keywrd
      logical uhf, cutoff
      dimension h(171), shmat(9,9), f(171),
     1          wj(100), e1b(10), e2a(10), wk(100), w(100),
     2          wjs(100), wks(100)
      REAL wjs, wks
      data icalcn /0/
      if( icalcn.ne.numcal) then
         icalcn=numcal
         wlim=4.d0
         if(id.eq.0)wlim=0.0d0
         uhf=(index(keywrd,'uhf') .ne. 0)
      endif
      nfirst(1)=1
      nmidle(1)=im-if+1
      nlast(1)=il-if+1
      nfirst(2)=nlast(1)+1
      nmidle(2)=nfirst(2)+jm-jf
      nlast(2)=nfirst(2)+jl-jf
      linear=(nlast(2)*(nlast(2)+1))/2
      do 10 i=1,linear
         f(i)=0.0d0
   10 h(i)=0.0d00
      do 20 i=1,linear
   20 f(i)=h(i)
      ja=nfirst(2)
      jb=nlast(2)
      jc=nmidle(2)
      ia=nfirst(1)
      ib=nlast(1)
      ic=nmidle(1)
      j=2
      i=1
      nj=nat(2)
      ni=nat(1)
      call h1elec(ni,nj,xi(1,1),xi(1,2),shmat)
      if(nat(1).eq.102.or.nat(2).eq.102) then
         k=(jb*(jb+1))/2
         do 30 j=1,k
   30    h(j)=0.0d0
      else
         j1=0
         do 40 j=ja,jb
            jj=j*(j-1)/2
            j1=j1+1
            i1=0
            do 40 i=ia,ib
               jj=jj+1
               i1=i1+1
               h(jj)=shmat(i1,j1)
               f(jj)=shmat(i1,j1)
   40    continue
      endif
      kr=1
      if(id.eq.0)then
         call moprat(nj,ni,xi(1,2),xi(1,1),w(kr),kr,e2a,e1b,enuclr,
     +               100.d0)
      else
         call solrot(nj,ni,xi(1,2),xi(1,1),wj,wk,kr,e2a,e1b,enuclr,
     +               100.d0)
      if(mode.eq.1)cutoff=(wj(1).lt.wlim)
         if(cutoff)then
            do 50 i=1,kr-1
   50       wk(i)=0.0d0
         endif
         do 60 i=1,kr-1
            wjs(i)=wj(i)
            wks(i)=wk(i)
   60    continue
      endif
c
c    * enuclr is summed over core-core repulsion integrals.
c
      i2=0
      do 70 i1=ia,ic
         ii=i1*(i1-1)/2+ia-1
         do 70 j1=ia,i1
            ii=ii+1
            i2=i2+1
            h(ii)=h(ii)+e1b(i2)
   70 f(ii)=f(ii)+e1b(i2)
      do  80 i1=ic+1,ib
         ii=(i1*(i1+1))/2
         f(ii)=f(ii)+e1b(1)
   80 h(ii)=h(ii)+e1b(1)
      i2=0
      do 90 i1=ja,jc
         ii=i1*(i1-1)/2+ja-1
         do 90 j1=ja,i1
            ii=ii+1
            i2=i2+1
            h(ii)=h(ii)+e2a(i2)
   90 f(ii)=f(ii)+e2a(i2)
      do 100 i1=jc+1,jb
         ii=(i1*(i1+1))/2
         f(ii)=f(ii)+e2a(1)
  100 h(ii)=h(ii)+e2a(1)
      call fock2(f,p,pa,w, wjs, wks,2,nat,nfirst,nmidle,nlast)
      ee=helect(nlast(2),pa,h,f)
      if( uhf ) then
         do 110 i=1,linear
  110    f(i)=h(i)
         call fock2(f,p,pb,w, wjs, wks,2,nat,nfirst,nmidle,nlast)
         ee=ee+helect(nlast(2),pb,h,f)
      else
         ee=ee*2.d0
      endif
      dener=ee+enuclr
      return
c
      end
      subroutine dhcore (coord,h,w,enuclr,nati,natx,step)
      implicit REAL  (a-h,o-z)
INCLUDE(common/sizes)
      dimension coord(3,*),h(*),w(*)
c
c  dhcore generates the 1-electron  and 2-electron integrals derivatives
c         with respect to the cartesian coordinate coord (natx,nati).
c
c  input
c      coord     : cartesian  coordinates of the molecule.
c      nati,natx : indices of the moving coordinate.
c      step      : step size of the 2-points finite difference.
c  output
c      h         : 1-electron integrals derivatives (packed canonical).
c      w         : 2-electron integrals derivatives (ordered as required
c                             in dfock2 and dijkl1).
c      enuclr    : nuclear energy derivative.
c
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),
     1                nlast(numatm), norbs, nelecs,nalpha,nbeta,
     2                nclose,nopen,ndumy,fract
      common /molorb/ uspd(maxorb),dumy(maxorb)
      common /keywrd/ keywrd
      common /wmatrc/ wdummy(n2elec*2)
      character*241 keywrd
      logical first,mindo
      dimension e1b(10),de1b(10),e2a(10),de2a(10)
     1         ,di(9,9),ddi(9,9),wjd(101),dwjd(101)
     2,nb(0:8)
      data nb/1,0,0,10,0,0,0,0,45/
      save first,cutoff,mindo
      data first/.true./
      if (first) then
         cutoff=1.d10
         first=.false.
         mindo=index(keywrd,'mindo') .ne. 0
      endif
      do 10 i=1,(norbs*(norbs+1))/2
   10 h(i)=0
      enuclr=0.0d0
      kr=1
      nrow=0
      i=nati
      csave=coord(natx,nati)
      ia=nfirst(nati)
      ib=nlast(nati)
      ic=nmidle(nati)
      ni=nat(nati)
      nrow=-nb(ib-ia)
      do 20 j=1,numat
   20 nrow=nrow+nb(nlast(j)-nfirst(j))
c#      ncol=nb(nlast(nati)-nfirst(nati))
      nband2=0
      do 120 j=1,numat
         if (j.eq.nati) go to 120
         ja=nfirst(j)
         jb=nlast(j)
         jc=nmidle(j)
         nj=nat(j)
         coord(natx,nati)=csave+step
         call h1elec(ni,nj,coord(1,nati),coord(1,j),di)
c
c  the following style was necessary to get round a bug in the
c  gould compiler
c
         coord(natx,nati)=csave+step*(-1.d0)
         call h1elec(ni,nj,coord(1,nati),coord(1,j),ddi)
c
c     fill the atom-other atom one-electron matrix.
c
         i2=0
         if (ia.gt.ja) then
            do 30 i1=ia,ib
               ij=i1*(i1-1)/2+ja-1
               i2=i2+1
               j2=0
               do 30 j1=ja,jb
                  ij=ij+1
                  j2=j2+1
   30       h(ij)=h(ij)+(di(i2,j2)-ddi(i2,j2))
         else
            do 40 i1=ja,jb
               ij=i1*(i1-1)/2+ia-1
               i2=i2+1
               j2=0
               do 40 j1=ia,ib
                  ij=ij+1
                  j2=j2+1
   40       h(ij)=h(ij)+(di(j2,i2)-ddi(j2,i2))
         endif
c
c     calculate the two-electron integrals, w; the electron nuclear term
c     e1b and e2a; and the nuclear-nuclear term enuc.
c
         kro=kr
         nband2=nband2+nb(nlast(j)-nfirst(j))
         if (mindo) then
            coord(natx,nati)=csave+step
            call moprat(ni,nj,coord(1,nati),coord(1,j)
     1               ,wjd,kr,e1b,e2a,enuc,cutoff)
            kr=kro
            coord(natx,nati)=csave+step*(-1.d0)
            call moprat(ni,nj,coord(1,nati),coord(1,j)
     1               ,dwjd,kr,de1b,de2a,denuc,cutoff)
            if (kr.gt.kro) then
               do 50 k=1,kr-kro+1
   50          w(kro+k-1)=wjd(k)-dwjd(k)
            endif
         else
            coord(natx,nati)=csave+step
            call moprat(ni,nj,coord(1,nati),coord(1,j)
     1               ,wjd,kr,e1b,e2a,enuc,cutoff)
            kr=kro
            coord(natx,nati)=csave+step*(-1.d0)
            call moprat(ni,nj,coord(1,nati),coord(1,j)
     1               ,dwjd,kr,de1b,de2a,denuc,cutoff)
            if (kr.gt.kro) then
               do 60 k=1,kr-kro+1
   60          wjd(k)=wjd(k)-dwjd(k)
               j7=0
               do 70 i1=kro,kr
                  j7=j7+1
   70          w(i1)=wjd(j7)
            endif
         endif
         coord(natx,nati)=csave
         enuclr = enuclr + enuc-denuc
c
c   add on the electron-nuclear attraction term for atom i.
c
         i2=0
         do 80 i1=ia,ic
            ii=i1*(i1-1)/2+ia-1
            do 80 j1=ia,i1
               ii=ii+1
               i2=i2+1
   80    h(ii)=h(ii)+e1b(i2)-de1b(i2)
c     contrib d, cndo.
         do 90 i1=ic+1,ib
            ii=(i1*(i1+1))/2
   90    h(ii)=h(ii)+e1b(1)-de1b(1)
c
c   add on the electron-nuclear attraction term for atom j.
c
         i2=0
         do 100 i1=ja,jc
            ii=i1*(i1-1)/2+ja-1
            do 100 j1=ja,i1
               ii=ii+1
               i2=i2+1
  100    h(ii)=h(ii)+e2a(i2)-de2a(i2)
c     contrib d, cndo.
         do 110 i1=jc+1,jb
            ii=(i1*(i1+1))/2
  110    h(ii)=h(ii)+e2a(1)-de2a(1)
  120 continue
c
c   'size' of h is nrow * ncol
c
      return
      end
      subroutine diat(ni,nj,xi,xj,di)
      implicit REAL (a-h,o-z)
************************************************************************
*
*   diat calculates the di-atomic overlap integrals between atoms
*        centered at xi and xj.
*
*   on input ni  = atomic number of the first atom.
*            nj  = atomic number of the second atom.
*            xi  = cartesian coordinates of the first atom.
*            xj  = cartesian coordinates of the second atom.
*
*  on output di  = diatomic overlap, in a 9 * 9 matrix. layout of
*                  atomic orbitals in di is
*                  1   2   3   4   5            6     7       8     9
*                  s   px  py  pz  d(x**2-y**2) d(xz) d(z**2) d(yz)d(xy)
*
*   limitations:  in this formulation, ni and nj must be less than 107
*         exponents are assumed to be present in common block expont.
*
************************************************************************
      common /keywrd/keywrd
      character*241 keywrd
      integer a,pq2,b,pq1,aa,bb
      common /numcal/ numcal
      save npq, ival
      logical analyt
      common /expont/ emus(107),emup(107),emud(107)
      dimension di(9,9),s(3,3,3),ul1(3),ul2(3),c(3,5,5),npq(107)
     1          ,xi(3),xj(3), slin(27), ival(3,5)
     2, c1(3,5), c2(3,5), c3(3,5), c4(3,5), c5(3,5)
     3, s1(3,3), s2(3,3), s3(3,3)
      equivalence(slin(1),s(1,1,1))
      equivalence (c1(1,1),c(1,1,1)), (c2(1,1),c(1,1,2)),
     1            (c3(1,1),c(1,1,3)), (c4(1,1),c(1,1,4)),
     2            (c5(1,1),c(1,1,5)), (s1(1,1),s(1,1,1)),
     3            (s2(1,1),s(1,1,2)), (s3(1,1),s(1,1,3))
      data npq/1,0, 2,2,2,2,2,2,2,0, 0,3,3,3,3,3,3,0, 0,4,4,4,4,4,4,4,
     14,4,4,4,4,4,4,4,4,0, 5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5
     2,32*6,15*0,3,5*0/
      data ival/1,0,9,1,3,8,1,4,7,1,2,6,0,0,5/
      save icalcn,analyt
      data icalcn/0/
      if(icalcn.ne.numcal)then
         analyt=(index(keywrd,'analyt').ne.0)
         icalcn=numcal
      endif
      x1=xi(1)
      x2=xj(1)
      y1=xi(2)
      y2=xj(2)
      z1=xi(3)
      z2=xj(3)
      pq1=npq(ni)
      pq2=npq(nj)
      do 20 i=1,9
         do 10 j=1,9
            di(i,j)=0.0d0
   10    continue
   20 continue
      call coe(x1,y1,z1,x2,y2,z2,pq1,pq2,c,r)
      if(pq1.eq.0.or.pq2.eq.0.or.r.ge.10.d0) return
      if(r.lt.0.001d0)then
         return
      endif
      ia=min(pq1,3)
      ib=min(pq2,3)
      a=ia-1
      b=ib-1
      if(analyt)then
         call gover(ni,nj,xi,xj,r,di)
c#      write(mfgw,*)' overlap from gover'
c#      write(mfgw,'(4f15.10)')sg
         return
      endif
      if(ni.lt.18.and.nj.lt.18) then
         call diat2(ni,emus(ni),emup(ni),r,nj,emus(nj),emup(nj),s)
      else
         ul1(1)=emus(ni)
         ul2(1)=emus(nj)
         ul1(2)=emup(ni)
         ul2(2)=emup(nj)
         ul1(3)=dmax1(emud(ni),0.3d0)
         ul2(3)=dmax1(emud(nj),0.3d0)
         do 30 i=1,27
   30    slin(i)=0.0d0
         newk=min(a,b)
         nk1=newk+1
         do 40 i=1,ia
            iss=i
            ib=b+1
            do 40 j=1,ib
               jss=j
               do 40 k=1,nk1
                  if(k.gt.i.or.k.gt.j) goto 40
                  kss=k
                  s(i,j,k)=ss(pq1,pq2,iss,jss,kss,ul1(i),ul2(j),r)
   40    continue
      endif
      do 50 i=1,ia
         kmin=4-i
         kmax=2+i
         do 50 j=1,ib
            if(j.eq.2)then
               aa=-1
               bb=1
            else
               aa=1
               if(j.eq.3) then
                  bb=-1
               else
                  bb=1
               endif
            endif
            lmin=4-j
            lmax=2+j
            do 50 k=kmin,kmax
               do 50 l=lmin,lmax
                  ii=ival(i,k)
                  jj=ival(j,l)
                  di(ii,jj)=s1(i,j)*(c3(i,k)*c3(j,l))*aa+
     1(c4(i,k)*c4(j,l)+c2(i,k)*c2(j,l))*bb*s2(i,j)+(c5(i,k)*c5(j,l)
     2+c1(i,k)*c1(j,l))*s3(i,j)
   50 continue
c#      write(mfgw,*)' overlap from diat2'
c#      do 12 i=1,4
c#  12  write(mfgw,'(4f15.10)')(di(j,i),j=1,4)
      return
      end
      subroutine diat2(na,esa,epa,r12,nb,esb,epb,s)
      implicit REAL (a-h,o-z)
      dimension s(3,3,3)
c***********************************************************************
c
c overlp calculates overlaps between atomic orbitals for pairs of atoms
c        it can handle the orbitals 1s, 2s, 3s, 2p, and 3p.
c
c***********************************************************************
      common /cmops/ a(7),b(7),sa,sb,factor,isp,ips
      dimension inmb(17),iii(78)
      save inmb, iii
      data inmb/1,0,2,2,3,4,5,6,7,0,8,8,8,9,10,11,12/
c     numbering corresponds to bond type matrix given above
c      the code is
c
c     iii=1      first - first  row elements
c        =2      first - second
c        =3      first - third
c        =4      second - second
c        =5      second - third
c        =6      third - third
      data iii/1,2,4,   2,4,4,   2,4,4,4,   2,4,4,4,4,
     1 2,4,4,4,4,4,   2,4,4,4,4,4,4,   3,5,5,5,5,5,5,6,
     2 3,5,5,5,5,5,5,6,6,   3,5,5,5,5,5,5,6,6,6,   3,5,5,5,5,5,5,6,6,6,6
     3, 3,5,5,5,5,5,5,6,6,6,6,6/
c
c      assigns bond number
c
      jmax=max(inmb(na),inmb(nb))
      jmin=min(inmb(na),inmb(nb))
      ii=iii((jmax*(jmax-1))/2+jmin)
      do 10 i=1,3
         do 10 j=1,3
            do 10 k=1,3
   10 s(i,j,k)=0.0d0
      rab=r12/0.529167d0
      goto (20,30,40,50,60,70), ii
c
c     ------------------------------------------------------------------
c *** the ordering of the elements within s is
c *** s(1,1,1)=(s(b)/s(a))
c *** s(1,2,1)=(p-sigma(b)/s(a))
c *** s(2,1,1)=(s(b)/p-sigma(a))
c *** s(2,2,1)=(p-sigma(b)/p-sigma(a))
c *** s(2,2,2)=(p-pi(b)/p-pi(a))
c     ------------------------------------------------------------------
c *** first row - first row overlaps
c
   20 call set (esa,esb,na,nb,rab,ii)
      s(1,1,1)=.25d00*dsqrt((sa*sb*rab*rab)**3)*(a(3)*b(1)-b(3)*a(1))
      return
c
c *** first row - second row overlaps
c
   30 call set (esa,esb,na,nb,rab,ii)
      w=dsqrt((sa**3)*(sb**5))*(rab**4)*0.125d00
      s(1,1,1) = dsqrt(1.d00/3.d00)
      s(1,1,1)=w*s(1,1,1)*(a(4)*b(1)-b(4)*a(1)+a(3)*b(2)-b(3)*a(2))
      if (na.gt.1) call set (epa,esb,na,nb,rab,ii)
      if (nb.gt.1) call set (esa,epb,na,nb,rab,ii)
      w=dsqrt((sa**3)*(sb**5))*(rab**4)*0.125d00
      s(isp,ips,1)=w*(a(3)*b(1)-b(3)*a(1)+a(4)*b(2)-b(4)*a(2))
      return
c
c *** first row - third row overlaps
c
   40 call set (esa,esb,na,nb,rab,ii)
      w=dsqrt((sa**3)*(sb**7)/7.5d00)*(rab**5)*0.0625d00
      sroot3 = dsqrt(3.d00)
      s(1,1,1)=w*(a(5)*b(1)-b(5)*a(1)+
     12.d00*(a(4)*b(2)-b(4)*a(2)))/sroot3
      if (na.gt.1) call set (epa,esb,na,nb,rab,ii)
      if (nb.gt.1) call set (esa,epb,na,nb,rab,ii)
      w=dsqrt((sa**3)*(sb**7)/7.5d00)*(rab**5)*0.0625d00
      s(isp,ips,1)=w*(a(4)*(b(1)+b(3))-b(4)*(a(1)+a(3))+
     1b(2)*(a(3)+a(5))-a(2)*(b(3)+b(5)))
      return
c
c *** second row - second row overlaps
c
   50 call set (esa,esb,na,nb,rab,ii)
      w=dsqrt((sa*sb)**5)*(rab**5)*0.0625d00
      rt3=1.d00/dsqrt(3.d00)
      s(1,1,1)=w*(a(5)*b(1)+b(5)*a(1)-2.0d00*a(3)*b(3))/3.0d00
      call set (esa,epb,na,nb,rab,ii)
      if (na.gt.nb) call set (epa,esb,na,nb,rab,ii)
      w=dsqrt((sa*sb)**5)*(rab**5)*0.0625d00
      d=a(4)*(b(1)-b(3))-a(2)*(b(3)-b(5))
      e=b(4)*(a(1)-a(3))-b(2)*(a(3)-a(5))
      s(isp,ips,1)=w*rt3*(d+e)
      call set (epa,esb,na,nb,rab,ii)
      if (na.gt.nb) call set (esa,epb,na,nb,rab,ii)
      w=dsqrt((sa*sb)**5)*(rab**5)*0.0625d00
      d=a(4)*(b(1)-b(3))-a(2)*(b(3)-b(5))
      e=b(4)*(a(1)-a(3))-b(2)*(a(3)-a(5))
      s(ips,isp,1)=-w*rt3*(e-d)
      call set (epa,epb,na,nb,rab,ii)
      w=dsqrt((sa*sb)**5)*(rab**5)*0.0625d00
      s(2,2,1)=-w*(b(3)*(a(5)+a(1))-a(3)*(b(5)+b(1)))
      hd = .5d00
      s(2,2,2)=hd*w*(a(5)*(b(1)-b(3))-b(5)*(a(1)-a(3))
     1-a(3)*b(1)+b(3)*a(1))
      return
c
c *** second row - third row overlaps
c
   60 call set (esa,esb,na,nb,rab,ii)
      w=dsqrt((sa**5)*(sb**7)/7.5d00)*(rab**6)*0.03125d00
      rt3 = 1.d00 / dsqrt(3.d00)
      td = 2.d00
      s(1,1,1)=w*(a(6)*b(1)+a(5)*b(2)-td*(a(4)*b(3)+
     1a(3)*b(4))+a(2)*b(5)+a(
     21)*b(6))/3.d00
      call set (esa,epb,na,nb,rab,ii)
      if (na.gt.nb) call set (epa,esb,na,nb,rab,ii)
      w=dsqrt((sa**5)*(sb**7)/7.5d00)*(rab**6)*0.03125d00
      td = 2.d00
      s(isp,ips,1)=w*rt3*(a(6)*b(2)+a(5)*b(1)-td*(a(4)*b(4)+a(3)*b(3))
     1+a(2)*b(6)+a(1)*b(5))
      call set (epa,esb,na,nb,rab,ii)
      if (na.gt.nb) call set (esa,epb,na,nb,rab,ii)
      w=dsqrt((sa**5)*sb**7/7.5d00)*(rab**6)*0.03125d00
      td = 2.d00
      s(ips,isp,1)=-w*rt3*(a(5)*(td*b(3)-b(1))-b(5)*(td*a(3)-a(1))-a(2
     1)*(b(6)-td*b(4))+b(2)*(a(6)-td*a(4)))
      call set (epa,epb,na,nb,rab,ii)
      w=dsqrt((sa**5)*sb**7/7.5d00)*(rab**6)*0.03125d00
      s(2,2,1)=-w*(b(4)*(a(1)+a(5))-a(4)*(b(1)+b(5))
     1+b(3)*(a(2)+a(6))-a(3)*(b(2)+b(6)))
      hd = .5d00
      s(2,2,2)=hd*w*(a(6)*(b(1)-b(3))-b(6)*(a(1)-
     1a(3))+a(5)*(b(2)-b(4))-b(5
     2)*(a(2)-a(4))-a(4)*b(1)+b(4)*a(1)-a(3)*b(2)+b(3)*a(2))
      return
c
c *** third row - third row overlaps
c
   70 call set (esa,esb,na,nb,rab,ii)
      w=dsqrt((sa*sb*rab*rab)**7)/480.d00
      rt3 = 1.d00 / dsqrt(3.d00)
      s(1,1,1)=w*(a(7)*b(1)-3.d00*(a(5)*b(3)-a(3)*b(5))-a(1)*b(7))/3.d00
      call set (esa,epb,na,nb,rab,ii)
      if (na.gt.nb) call set (epa,esb,na,nb,rab,ii)
      w=dsqrt((sa*sb*rab*rab)**7)/480.d00
      d=a(6)*(b(1)-b(3))-2.d00*a(4)*(b(3)-b(5))+a(2)*(b(5)-b(7))
      e=b(6)*(a(1)-a(3))-2.d00*b(4)*(a(3)-a(5))+b(2)*(a(5)-a(7))
      s(isp,ips,1)=w*rt3*(d-e)
      call set (epa,esb,na,nb,rab,ii)
      if (na.gt.nb) call set (esa,epb,na,nb,rab,ii)
      w=dsqrt((sa*sb*rab*rab)**7)/480.d00
      d=a(6)*(b(1)-b(3))-2.d00*a(4)*(b(3)-b(5))+a(2)*(b(5)-b(7))
      e=b(6)*(a(1)-a(3))-2.d00*b(4)*(a(3)-a(5))+b(2)*(a(5)-a(7))
      s(ips,isp,1)=-w*rt3*(-d-e)
      call set (epa,epb,na,nb,rab,ii)
      w=dsqrt((sa*sb*rab*rab)**7)/480.d00
      td = 2.d00
      s(2,2,1)=-w*(a(3)*(b(7)+td*b(3))-a(5)*(b(1)+
     1td*b(5))-b(5)*a(1)+a(7)*b(3))
      hd = .5d00
      s(2,2,2)=hd*w*(a(7)*(b(1)-b(3))+b(7)*(a(1)-
     1a(3))+a(5)*(b(5)-b(3)-b(1)
     2)+b(5)*(a(5)-a(3)-a(1))+2.d00*a(3)*b(3))
      return
c
      end
c     ******************************************************************
      function digit(string,istart)
c     fortran function to convert numeric field to double precision
c     number.  the string is assumed to be clean (no invalid digit
c     or character combinations from istart to the first nonspace,
c     nondigit, nonsign, and nondecimal point character).
c
      character string*(*)
      REAL c1,c2,deciml,digit
      logical sign
c
c     define ascii values of numeric field characters
      i0=ichar('0')
      i9=ichar('9')
      ineg=ichar('-')
      ipos=ichar('+')
      idot=ichar('.')
      ispc=ichar(' ')
c
      c1=0.0d0
      c2=0.0d0
      sign=.true.
      l=len(string)
c
c     determine the contribution to the number greater than one
      idig=0
      do 10 i=istart,l
         n=ichar(string(i:i))
         if(n.ge.i0.and.n.le.i9)then
            idig=idig+1
            c1=c1*1.d1+n-i0
         elseif(n.eq.ineg.or.n.eq.ipos.or.n.eq.ispc)then
            if(n.eq.ineg)sign=.false.
         elseif(n.eq.idot)then
            goto 20
         else
            goto 40
         endif
   10 continue
c
c     determine the contribution to the number less than than one
   20 deciml=1.d0
      do 30 j=i+1,l
         n=ichar(string(j:j))
         if(n.ge.i0.and.n.le.i9)then
            deciml=deciml/1.d1
            c2=c2+(n-i0)*deciml
         elseif(n.ne.ispc)then
            goto 40
         endif
   30 continue
c
c     put the pieces together
   40 digit=c1+c2
      if(.not.sign)digit=-digit
      return
      end
      subroutine dihed(xyz,i,j,k,l,angle)
      implicit REAL (a-h,o-z)
      dimension xyz(3,*)
*********************************************************************
*
*      dihed calculates the dihedral angle between atoms i, j, k,
*            and l.  the cartesian coordinates of these atoms
*            are in array xyz.
*
*     dihed is a modified version of a subroutine of the same name
*           which was written by dr. w. theil in 1973.
*
*********************************************************************
      xi1=xyz(1,i)-xyz(1,k)
      xj1=xyz(1,j)-xyz(1,k)
      xl1=xyz(1,l)-xyz(1,k)
      yi1=xyz(2,i)-xyz(2,k)
      yj1=xyz(2,j)-xyz(2,k)
      yl1=xyz(2,l)-xyz(2,k)
      zi1=xyz(3,i)-xyz(3,k)
      zj1=xyz(3,j)-xyz(3,k)
      zl1=xyz(3,l)-xyz(3,k)
c      rotate around z axis to put kj along y axis
      dist= dsqrt(xj1**2+yj1**2+zj1**2)
      cosa=zj1/dist
      if(cosa.gt.1.0d0) cosa=1.0d0
      if(cosa.lt.-1.0d0) cosa=-1.0d0
      ddd=1.0d0-cosa**2
      if(ddd.le.0.0d0) go to 10
      yxdist=dist* dsqrt(ddd)
      if(yxdist.gt.1.0d-6) go to 20
   10 continue
      xi2=xi1
      xl2=xl1
      yi2=yi1
      yl2=yl1
      costh=cosa
      sinth=0.0d0
      go to 30
   20 cosph=yj1/yxdist
      sinph=xj1/yxdist
      xi2=xi1*cosph-yi1*sinph
      xl2=xl1*cosph-yl1*sinph
      yi2=xi1*sinph+yi1*cosph
      yj2=xj1*sinph+yj1*cosph
      yl2=xl1*sinph+yl1*cosph
c      rotate kj around the x axis so kj lies along the z axis
      costh=cosa
      sinth=yj2/dist
   30 continue
      yi3=yi2*costh-zi1*sinth
      yl3=yl2*costh-zl1*sinth
      call dang(xl2,yl3,xi2,yi3,angle)
      if (angle .lt. 0.) angle=4.0d0* dasin(1.0d00)+angle
      if (angle .ge. 6.2831853d0 ) angle=0.0d0
      return
      end
      subroutine diism(xp, xparam, gp, grad, hp, heat, hs, nvar, frst)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      dimension xp(nvar), xparam(nvar), gp(nvar),
     1grad(nvar), hs(nvar*nvar)
      logical frst
************************************************************************
*                                                                      *
*     diism performs direct inversion in the iterative subspace         *
*                                                                      *
*     this involves solving for c in xparam(new) = xparam' - hg'       *
*                                                                      *
*  where xparam' = sum(c(i)xparam(i), the c coefficientes coming from  *
*                                                                      *
*                   | b   1 | . | c | = | 0 |                          *
*                   | 1   0 |   |-l |   | 1 |                          *
*                                                                      *
* where b(i,j) =grad(i)h(t)hgrad(j)  grad(i) = gradient on cycle i     *
*                              h    = inverse hessian                  *
*                                                                      *
*                          reference                                   *
*                                                                      *
*  p. csaszar, p. pulay, j. mol. struct. (theochem), 114, 31 (1984)    *
*                                                                      *
************************************************************************
************************************************************************
*                                                                      *
*     geometry optimization using the method of direct inversion in    *
*     the iterative subspace (gdiis), combined with the bfgs optimizer *
*     (a variable metric method)                                       *
*                                                                      *
*     written by peter l. cummins, university of sydney, australia     *
*                                                                      *
*                              reference                               *
*                                                                      *
*      "computational strategies for the optimization of equilibrium   *
*     geometries and transition-state structures at the semiempirical  *
*     level", peter l. cummins, jill e. gready, j. comp. chem., 10,    *
*     939-950 (1989).                                                  *
*                                                                      *
*     modified by jjps to conform to existing mopac conventions        *
*                                                                      *
************************************************************************
      common /keywrd/ keywrd
      common/iofile/mfgr,mfgw
      parameter (mreset=15, m2=(mreset+1)*(mreset+1))
      common/scrtch/xset(mreset*maxpar),gset(mreset*maxpar), 
     + eset(mreset),dx(maxpar),gsave(maxpar),
     1 err(mreset*maxpar),b(m2),bs(m2),bst(m2)
      logical debug, print
      character*241 keywrd
      save mset
      debug=.false.
      print=(index(keywrd,' diis').ne.0)
      if (print) debug=(index(keywrd,'debug').ne.0)
      if (print)  write(mfgw,'(/,''      ***** begin gdiis ***** '')')
c
c  space simply loads the current values of xparam and gnorm into
c  the arrays xset and gset
c
      call space(mreset,mset,xparam, grad, heat, nvar, xset, gset, eset
     1, frst)
c
c     initialize some variables and constants
c
      ndiis = mset
      mplus = mset + 1
      mm = mplus * mplus
c
c     compute the approximate error vectors
c
      inv=-nvar
      do 30 i=1,mset
         inv = inv + nvar
         do 30 j=1,nvar
            s = 0.d0
            kj=(j*(j-1))/2
            do 10 k=1,j
               kj = kj+1
   10       s = s - hs(kj) * gset(inv+k)
            do 20 k=j+1,nvar
               kj = (k*(k-1))/2+j
   20       s = s - hs(kj) * gset(inv+k)
   30 err(inv+j) = s
c
c     construct the gdiis matrix
c
      do 40 i=1,mm
   40 b(i) = 1.d0
      jj=0
      inv=-nvar
      do 50 i=1,mset
         inv=inv+nvar
         jnv=-nvar
         do 50 j=1,mset
            jnv=jnv+nvar
            jj = jj + 1
            b(jj)=0.0d0
            do 50 k=1,nvar
   50 b(jj) = b(jj) + err(inv+k) * err(jnv+k)
c
      do 60 i=mset-1,1,-1
         do 60 j=mset,1,-1
   60 b(i*mset+j+i) = b(i*mset+j)
      do 70 i=1,mplus
         b(mplus*i) = 1.d0
   70 b(mplus*mset+i) = 1.d0
      b(mm) = 0.d0
c
c     eliminate error vectors with the largest norm
c
   80 continue
      do 90 i=1,mm
   90 bs(i) = b(i)
      if (ndiis .eq. mset) go to 140
      do 130 ii=1,mset-ndiis
         xmax = -1.d10
         itera = 0
         do 110 i=1,mset
            xnorm = 0.d0
            inv = (i-1) * mplus
            do 100 j=1,mset
  100       xnorm = xnorm + dabs(b(inv + j))
            if (xmax.lt.xnorm .and. xnorm.ne.1.0d0) then
               xmax = xnorm
               itera = i
               ione = inv + i
            endif
  110    continue
         do 120 i=1,mplus
            inv = (i-1) * mplus
            do 120 j=1,mplus
               jnv = (j-1) * mplus
               if (j.eq.itera) b(inv + j) = 0.d0
               b(jnv + i) = b(inv + j)
  120    continue
         b(ione) = 1.0d0
  130 continue
  140 continue
c
      if (debug) then
c
c     output the gdiis matrix
c
         write(mfgw,'(/5x,'' gdiis matrix'')')
         ij = 0
         do 150 i=1,mplus
            do 150 j=1,i
               ij = ij + 1
  150    bst(ij) = b( mplus * (j-1) + i)
         call vecprt(bst,mplus)
      endif
c
c     scale diis matrix before inversion
c
      do 160 i=1,mplus
         ii = mplus * (i-1) + i
  160 gsave(i) = 1.d0 / dsqrt(1.d-20+dabs(b(ii)))
      gsave(mplus) = 1.d0
      do 170 i=1,mplus
         do 170 j=1,mplus
            ij = mplus * (i-1) + j
  170 b(ij) = b(ij) * gsave(i) * gsave(j)
c
      if (debug) then
c
c     output scaled gdiis matrix
c
         write(mfgw,'(/5x,'' gdiis matrix (scaled)'')')
         ij = 0
         do 180 i=1,mplus
            do 180 j=1,i
               ij = ij + 1
  180    bst(ij) = b( mplus * (j-1) + i)
         call vecprt(bst,mplus)
      endif
c
c     invert the gdiis matrix
c
      call minv(b,mplus,det)
c
      do 190 i=1,mplus
         do 190 j=1,mplus
            ij = mplus * (i-1) + j
  190 b(ij) = b(ij) * gsave(i) * gsave(j)
c
c     compute the intermediate interpolated parameter and gradient
c     vectors
c
      do 200 k=1,nvar
         xp(k) = 0.d0
         gp(k) = 0.d0
         do 200 i=1,mset
            ink = (i-1) * nvar + k
            xp(k) = xp(k) + b(mplus*mset+i) * xset(ink)
  200 gp(k) = gp(k) + b(mplus*mset+i) * gset(ink)
      hp=0.0d0
      do 210 i=1,mset
  210 hp=hp+b(mplus*mset+i)*eset(i)
c
      do 220 k=1,nvar
  220 dx(k) = xparam(k) - xp(k)
      xnorm = dsqrt(ddot(nvar,dx,1,dx,1))
      if (print) then
         write (mfgw,'(/10x,''deviation in x '',f7.4,8x,
     +   ''determinant '',g9.3)') xnorm,det
         write(mfgw,'(10x,''gdiis coefficients'')')
         write(mfgw,'(10x,5f12.5)') (b(mplus*mset+i),i=1,mset)
      endif
c
c     the following tolerences for xnorm and det are somewhat arbitrary!
c
      thres = dmax1(10.d0**(-nvar), 1.d-25)
      if (xnorm.gt.2.d0 .or. dabs(det).lt. thres) then
         if (print) 
     +   write(mfgw,'(10x,''the diis matrix is ill conditioned''
     1, /10x,'' - probably, vectors are linearly dependent - '',
     2 /10x,''the diis step will be repeated with a smaller space'')')
         do 230 k=1,mm
  230    b(k) = bs(k)
         ndiis = ndiis - 1
         if (ndiis .gt. 0) go to 80
         if (print) write(mfgw,'(10x,''newton-raphson step taken'')')
         do 240 k=1,nvar
            xp(k) = xparam(k)
  240    gp(k) = grad(k)
c
      endif
      if (print)  write(mfgw,'(/,''      ***** end gdiis ***** '',/)')
c
      return
      end
      subroutine dijkl1 (c,n,nati,w,cij,wcij,ckl)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      dimension c(n,*), w(*)
      dimension cij(10*maxorb), wcij(10*maxorb), ckl(10*maxorb)
************************************************************************
*
*   dijkl1 is similar to ijkl.  the main differences are that
*   the array w contains the two electron integrals between
*   one atom (nati) and all the other atoms in the system.
*
*           on exit
*
*   the array xy is filled with the differentials of the
*   two-electron integrals over active-space m.o.s w.r.t. motion
*   of the atom nati.
************************************************************************
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),
     1                nlast(numatm), norbs, nelecs,nalpha,nbeta,
     2                nclose,nopen,ndumy,fract
      common /cibits/ nmos,lab,nelec, nbo(3)
      common /xyijkl/ xy(nmeci,nmeci,nmeci,nmeci)
      dimension nb(0:8)
      data nb /1,0,0,10,0,0,0,0,45/
      na=nmos
      do 110 i=1,na
         do 110 j=1,i
            ipq=0
            do 20 ii=1,numat
               if(ii.eq.nati) goto 20
               do 10 ip=nfirst(ii),nlast(ii)
                  do 10 iq=nfirst(ii),ip
                     ipq=ipq+1
                     cij(ipq)=c(ip,i)*c(iq,j)+c(ip,j)*c(iq,i)
   10          continue
   20       continue
            i77=ipq+1
            do 30 ip=nfirst(nati),nlast(nati)
               do 30 iq=nfirst(nati),ip
                  ipq=ipq+1
                  cij(ipq)=c(ip,i)*c(iq,j)+c(ip,j)*c(iq,i)
   30       continue
            do 40 ii=1,ipq
   40       wcij(ii)=0.0d0
            kr=1
            js=1
            nbj=nb(nlast(nati)-nfirst(nati))
            do 50 ii=1,numat
               if (ii.eq.nati) goto 50
               nbi=nb(nlast(ii)-nfirst(ii))
               call formxy
     1(w(kr), kr, wcij(i77), wcij(js), cij(i77), nbj, cij(js), nbi)
               js=js+nbi
   50       continue
            do 100 k=1,i
               if(k.eq.i) then
                  ll=j
               else
                  ll=k
               endif
               do 100 l=1,ll
                  ipq=0
                  do 70 ii=1,numat
                     if(ii.eq.nati) goto 70
                     do 60 ip=nfirst(ii),nlast(ii)
                        do 60 iq=nfirst(ii),ip
                           ipq=ipq+1
                           ckl(ipq)=c(ip,k)*c(iq,l)+c(ip,l)*c(iq,k)
   60                continue
   70             continue
                  do 80 ip=nfirst(nati),nlast(nati)
                     do 80 iq=nfirst(nati),ip
                        ipq=ipq+1
                        ckl(ipq)=c(ip,k)*c(iq,l)+c(ip,l)*c(iq,k)
   80             continue
                  sum=0.0d0
                  do 90 ii=1,ipq
   90             sum=sum+ckl(ii)*wcij(ii)
                  xy(i,j,k,l)=sum
                  xy(i,j,l,k)=sum
                  xy(j,i,k,l)=sum
                  xy(j,i,l,k)=sum
                  xy(k,l,i,j)=sum
                  xy(k,l,j,i)=sum
                  xy(l,k,i,j)=sum
                  xy(l,k,j,i)=sum
  100       continue
  110 continue
      return
      end
      subroutine dijkl2 (dc,norbs,nmos,dijkl,wijkl,nmeci)
      implicit REAL (a-h,o-z)
************************************************************************
*     relaxation of 2-electrons integrals in m.o basis.
*
*   input
*   dc(norbs,nmos) : c.i-active m.o derivatives in m.o basis, in column.
*   norbs          : total number of m.o.
*   nmos           : number of c.i-active m.o.
*   dijkl(i,j,kl)  : <i(1),j(1)|k(2),l(2)> with
*                     i              over     all    m.o.
*                     j,kl canonical over c.i-active m.o.
*   nmeci          : max. size of wijkl. (nmos <= nmeci).
*   output
*     wijkl(i,j,k,l)= d< i(1),j(1) | k(2),l(2) >
*                   = <di,j|k,l> + <i,dj|k,l> + <i,j|dk,l> + <i,j|k,dl>
*                     with i,j,k,l over all c.i-active m.o.
*     written by daniel liotard
* (note by jjps: as this code is highly efficient, no changes were made)
************************************************************************
      dimension dc(norbs,*),wijkl(nmeci,nmeci,nmeci,nmeci)
      dimension dijkl(norbs,nmos,*)
      logical lij,lkl
c
      ij=0
      do 10 i=1,nmos
         do 10 j=1,i
            ij=ij+1
            lij=i.eq.j
            kl=0
            do 10 k=1,i
               if(k.eq.i) then
                  ll=j
               else
                  ll=k
               endif
               do 10 l=1,ll
                  kl=kl+1
                  lkl=k.eq.l
                  val=  ddot(norbs,dc(1,i),1,dijkl(1,j,kl),1)
                  if(lij.and.lkl.and.j.eq.k) then
                     val=val*4.d0
                  else
                     if(lij) then
                        val=val*2.d0
                     else
                        val=val+ ddot(norbs,dc(1,j),1,dijkl(1,i,kl),1)
                     endif
                     val2= ddot(norbs,dc(1,k),1,dijkl(1,l,ij),1)
                     if(lkl) then
                        val=val+val2*2.d0
                     else
                        val=val+val2+
     +                  ddot(norbs,dc(1,l),1,dijkl(1,k,ij),1)
                     endif
                  endif
                  wijkl(i,j,k,l)=val
                  wijkl(i,j,l,k)=val
                  wijkl(j,i,k,l)=val
                  wijkl(j,i,l,k)=val
                  wijkl(k,l,i,j)=val
                  wijkl(k,l,j,i)=val
                  wijkl(l,k,i,j)=val
   10 wijkl(l,k,j,i)=val
      return
      end
      subroutine dipind (dipvec)
c...............................................................
c  modification of dipole subroutine for use in the calculation
c  of the induced dipoles for polarizabilities.
c...............................................................
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      common /corec/ core(107)
      common /densty/ p(mpack),pa(mpack),pb(mpack)
      common /molmec/ htype(4),nhco(4,20),nnhco,itype
      common /cmpg/ geo(3,numatm)
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),
     1                nlast(numatm),norbs,nelecs,nalpha,nbeta,
     2                nclose,nopen,ndumy,fract
      common /numcal/ numcal
      common /keywrd/ keywrd
      common /istope/ ams(107)
      common/iofile/mfgr,mfgw
      common /multip/ dd(107), qq(107), am(107), ad(107), aq(107)
      dimension q(maxorb),q2(maxorb),dipvec(3),center(3),
     1          coord(3,numatm)
      character*241 keywrd
c
c***********************************************************************
c     dipind calculates dipole moments
c
c  on input p     = density matrix
c           q     = total atomic charges, (nuclear + electronic)
c           numat = number of atoms in molecule
c           nat   = atomic numbers of atoms
c           nfirst= start of atom orbital counters
c           coord = coordinates of atoms
c
c  output  dipole = dipole moment
c***********************************************************************
c
c     in the zdo approximation, only two terms are retained in the
c     calculation of dipole moments.
c     1. the point charge term (independent of parameterization).
c     2. the one-center hybridization term, which arises from matrix
c     elements of the form <ns/r/np>. this term is a function of
c     the slater exponents (zs,zp) and is thus dependent on parameter-
c     ization. the hybridization factors (hyf(i)) used in this sub-
c     routine are calculated from the following formulae.
c     for second row elements <2s/r/2p>
c     hyf(i)= 469.56193322*(sqrt(((zs(i)**5)*(zp(i)**5)))/
c           ((zs(i) + zp(i))**6))
c     for third row elements <3s/r/3p>
c     hyf(i)=2629.107682607*(sqrt(((zs(i)**7)*(zp(i)**7)))/
c           ((zs(i) + zp(i))**8))
c     for fourth row elements and up :
c     hyf(i)=2*(2.10716)*dd(i)
c     where dd(i) is the charge separation in atomic units
c
c
c     references:
c     j.a.pople & d.l.beveridge: approximate m.o. theory
c     s.p.mcglynn, et al: applied quantum chemistry
c
      dimension dip(4,3)
      dimension hyf(107,2)
      save icalcn, hyf, wtmol, chargd
      logical  chargd
      data hyf(1,1)     / 0.0d00           /
      data   hyf(1,2) /0.0d0     /
      data   hyf(5,2) /6.520587d0/
      data   hyf(6,2) /4.253676d0/
      data   hyf(7,2) /2.947501d0/
      data   hyf(8,2) /2.139793d0/
      data   hyf(9,2) /2.2210719d0/
      data   hyf(14,2)/6.663059d0/
      data   hyf(15,2)/5.657623d0/
      data   hyf(16,2)/6.345552d0/
      data   hyf(17,2)/2.522964d0/
      data icalcn/0/
c
c  setup for dipole calculation
c
      call chrge (p,q2)
      do 10 i = 1,numat
         q(i) = core(nat(i)) - q2(i)
   10 continue
      call gmetry (geo,coord)
c
      if (icalcn.ne.numcal) then
         do 20 i=2,107
   20    hyf(i,1)= 5.0832d0*dd(i)
         wtmol=0.0d0
         sum=0.0d0
         do 30 i=1,numat
            wtmol=wtmol+ams(nat(i))
   30    sum=sum+q(i)
         chargd=(dabs(sum).gt.0.5d0)
         icalcn=numcal
         ktype=1
         if(itype.eq.4)ktype=2
      endif
      if(chargd)then
c
c   need to reset ion's position so that the center of mass is at the
c   origin.
c
c$doit asis
         do 40 i=1,3
   40    center(i)=0.0d0
         do 50 i=1,3
c$doit vbest
            do 50 j=1,numat
   50    center(i)=center(i)+ams(nat(j))*coord(i,j)
c$doit asis
         do 60 i=1,3
   60    center(i)=center(i)/wtmol
         do 70 i=1,3
c$doit vbest
            do 70 j=1,numat
   70    coord(i,j)=coord(i,j)-center(i)
      endif
c$doit asis
      do 80 i=1,4
c$doit asis
         do 80 j=1,3
   80 dip(i,j)=0.0d00
c$doit asis
      do 100 i=1,numat
         ni=nat(i)
         ia=nfirst(i)
         l=nlast(i)-ia
c$doit asis
         do 90 j=1,l
            k=((ia+j)*(ia+j-1))/2+ia
   90    dip(j,2)=dip(j,2)-hyf(ni,ktype)*p(k)
c$doit asis
         do 100 j=1,3
  100 dip(j,1)=dip(j,1)+4.803d00*q(i)*coord(j,i)
c$doit asis
      do 110 j=1,3
  110 dip(j,3)=dip(j,2)+dip(j,1)
c$doit asis
      do 120 j=1,3
  120 dip(4,j)=dsqrt(dip(1,j)**2+dip(2,j)**2+dip(3,j)**2)
      dipvec(1)= -dip(1,3)
      dipvec(2)= -dip(2,3)
      dipvec(3)= -dip(3,3)
c      write (mfgw,60) ((dip(i,j),i=1,4),j=1,3)
c   60 format (3(4f10.3))
      return
c
      end
      function dipmop (p,q,coord,dipvec, mode)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      common /molkst/ numat,nat(numatm),nfirst(numatm), nmidle(numatm),
     1                nlast(numatm), norbs, nelecs,nalpha,nbeta,
     2                nclose,nopen,ndumy,fract
      common /dipsto/ ux,uy,uz,ch(numatm)
      common /keywrd/ keywrd
      common /molmec/ htype(4),nhco(4,20),nnhco,itype
      common /istope/ ams(107)
      common /multip/ dd(107), qq(107), am(107), ad(107), aq(107)
      common /numcal/ numcal
      common /iofile/ mfgr,mfgw
      dimension p(*),q(*),coord(3,*),dipvec(3), center(3)
      character*241 keywrd
c***********************************************************************
c     dipmop calculates dipole moments
c
c  on input p     = density matrix
c           q     = total atomic charges, (nuclear + electronic)
c           numat = number of atoms in molecule
c           nat   = atomic numbers of atoms
c           nfirst= start of atom orbital counters
c           coord = coordinates of atoms
c
c  output  dipmop = dipole moment
c***********************************************************************
c
c     in the zdo approximation, only two terms are retained in the
c     calculation of dipole moments.
c     1. the point charge term (independent of parameterization).
c     2. the one-center hybridization term, which arises from matrix
c     elements of the form <ns/r/np>. this term is a function of
c     the slater exponents (zs,zp) and is thus dependent on parameter-
c     ization. the hybridization factors (hyf(i)) used in this sub-
c     routine are calculated from the following formulae.
c     for second row elements <2s/r/2p>
c     hyf(i)= 469.56193322*(sqrt(((zs(i)**5)*(zp(i)**5)))/
c           ((zs(i) + zp(i))**6))
c     for third row elements <3s/r/3p>
c     hyf(i)=2629.107682607*(sqrt(((zs(i)**7)*(zp(i)**7)))/
c           ((zs(i) + zp(i))**8))
c     for fourth row elements and up :
c     hyf(i)=2*(2.10716)*dd(i)
c     where dd(i) is the charge separation in atomic units
c
c
c     references:
c     j.a.pople & d.l.beveridge: approximate m.o. theory
c     s.p.mcglynn, et al: applied quantum chemistry
c
      dimension dip(4,3)
      dimension hyf(107,2)
      save first, hyf, dip, wtmol, chargd, force, ktype
      logical first, force, chargd
      data hyf(1,1)     / 0.0d00           /
      data   hyf(1,2) /0.0d0     /
      data   hyf(5,2) /6.520587d0/
      data   hyf(6,2) /4.253676d0/
      data   hyf(7,2) /2.947501d0/
      data   hyf(8,2) /2.139793d0/
      data   hyf(9,2) /2.2210719d0/
      data   hyf(14,2)/6.663059d0/
      data   hyf(15,2)/5.657623d0/
      data   hyf(16,2)/6.345552d0/
      data   hyf(17,2)/2.522964d0/
      save icalcn
      data icalcn/0/
      first=(icalcn.ne.numcal)
      icalcn=numcal
      if (first) then
         do 10 i=2,107
   10    hyf(i,1)= 5.0832d0*dd(i)
         wtmol=0.0d0
         sum=0.0d0
         do 20 i=1,numat
            wtmol=wtmol+ams(nat(i))
   20    sum=sum+q(i)
         chargd=(dabs(sum).gt.0.5d0)
         force=(index(keywrd,'force') +index(keywrd,'irc').ne. 0)
         ktype=1
         if(itype.eq.4)ktype=2
      endif
      if(.not.force.and.chargd)then
c
c   need to reset ion's position so that the center of mass is at the
c   origin.
c
         do 30 i=1,3
   30    center(i)=0.0d0
         do 40 i=1,3
            do 40 j=1,numat
   40    center(i)=center(i)+ams(nat(j))*coord(i,j)
         do 50 i=1,3
   50    center(i)=center(i)/wtmol
         do 60 i=1,3
            do 60 j=1,numat
   60    coord(i,j)=coord(i,j)-center(i)
      endif
      do 70 i=1,4
         do 70 j=1,3
   70 dip(i,j)=0.0d00
      do 90 i=1,numat
         ni=nat(i)
         ia=nfirst(i)
         l=nlast(i)-ia
         do 80 j=1,l
            k=((ia+j)*(ia+j-1))/2+ia
   80    dip(j,2)=dip(j,2)-hyf(ni,ktype)*p(k)
         do 90 j=1,3
   90 dip(j,1)=dip(j,1)+4.803d00*q(i)*coord(j,i)
      do 100 j=1,3
  100 dip(j,3)=dip(j,2)+dip(j,1)
      do 110 j=1,3
  110 dip(4,j)=dsqrt(dip(1,j)**2+dip(2,j)**2+dip(3,j)**2)
      if( force) then
         dipvec(1)=dip(1,3)
         dipvec(2)=dip(2,3)
         dipvec(3)=dip(3,3)
      endif
      if(mode.eq.1)write (mfgw,130) ((dip(i,j),i=1,4),j=1,3)
c     store dipole moment components in ux,uy,uz for use in
c     assigning charges determined from the esp. bhb
      ux=dip(1,3)
      uy=dip(2,3)
      uz=dip(3,3)
c
c     store charges q in array ch for use in assigning symmetry to
c     charges. bhb
      do 120 i=1,numat
  120 ch(i)=q(i)
      dipmop = dip(4,3)
      return
c
  130 format (' dipole',11x,'x         y         z       total',/,
     1' point-chg.',4f10.3/,' hybrid',4x,4f10.3/,' sum',7x,4f10.3)
c
      end
c****************************************************************
      function dist2m(a,b)
c
c     determine distances between neighboring atoms
c
      implicit REAL (a-h,o-z)
      dimension a(3)
      dimension b(3)
      dist2m = (a(1)-b(1))**2 + (a(2)-b(2))**2 + (a(3)-b(3))**2
      return
      end
      subroutine dofs(eref,mono3,n,dd,m,bottom,top)
      implicit REAL (a-h,o-z)
      common/iofile/mfgr,mfgw
      dimension eref(mono3,n), dd(m)
************************************************************************
*                                                                      *
* dofs forms a normalised, slightly smoothed density of states for a   *
*      1-d density of states                                           *
*  on input eref = reference energy levels                             *
*           p    = population of energy levels (=1 for energy d.o.s.   *
*                  or atomic orbital population for partial d.o.s.)    *
*           n    = number of energy levels supplied                    *
*           m    = size of d.o.s. vector                               *
*           d    = array to hold d.o.s.                                *
*           bottom = bottom of d.o.s. vector                           *
*           top    = top of d.o.s. vector                              *
*                                                                      *
*   on output d = density of states.  this analyses is independent of n*
*                 roughness will occur if n < ca. 30.                  *
*                                                                      *
************************************************************************
c
c  first, empty the density-of-states (dos) bins
c
      do 10 i=1,500
   10 dd(i)=0.0d0
c
c   spread out the energies over the energy spectrum, top to bottom
c
      range=(m+1)/(top-bottom)
      do 20 j=1,mono3
         do 20 i=1,n
            x=eref(j,i)
            if(x.lt.bottom.or.x.gt.top) x=-1.d7
   20 eref(j,i)=(x-bottom)*range
      do 40 ii=1,mono3
         do 40 i=2,n
            b=eref(ii,i-1)
            if(b.lt.1) goto 40
            a=eref(ii,i)
            if(a.lt.1) goto 40
            if(b .gt. a) then
               x=b
               b=a
               a=x
            endif
            j=b
            k=a
c
c if j equals k the interval falls within one bin
c
            if(j.eq.k) then
               dd(k)=dd(k)+1.d0
            else
               spread=1.d0/(a-b+1.d-12)
               partj=(j+1-b)*spread
               partk=(a-k)*spread
               dd(j)=dd(j)+partj
               dd(k)=dd(k)+partk
c
c if k equals j+1 the interval straddles two bins
c
               if(k .ne. j+1) then
c
c if k is greater than j+1 the interval covers more than two bins
c
                  j=j+1
                  k=k-1
                  do 30 l=j,k
   30             dd(l)=dd(l)+spread
               endif
            endif
   40 continue
      x=m/((n-1)*(top-bottom))
      do 50  i=1,m
   50 dd(i)=dd(i)*x
      write(mfgw,'(a)')' normalized density of states'
c
c  the first 'bin' has lower bound at bottom and upper bound
c  at bottom+range, therefore the first 'bin' is for bottom+0.5*range
c  the last 'bin' has bounds top-range and top,
c  therefor the last 'bin' is for top-0.5*range
      range=m/(top-bottom)
      do 60 i=1,m
   60 write(mfgw,'(f9.2,f12.6)')bottom+(i-0.5d0)/range,dd(i)
      return
      end
      subroutine drc(startv, startk)
      implicit REAL (a-h,o-z)
_IF(ipsc,tools)
      logical oroot
_ENDIF
      dimension startv(*), startk(*)
************************************************************************
*                                                                      *
*    drc is designed to follow a reaction path from the transition     *
*    state.  two modes are supported, first: gas phase:- as the system *
*    moves from the t/s the momentum of the atoms is stored and the    *
*    position of the atoms is related to the old position by (a) the   *
*    current velocity of the atom, and (b) the forces acting on that   *
*    atom.  the second mode is condensed phase, in which the atoms move*
*    in response to the forces acting on them. i.e. infinitely damped  *
*                                                                      *
************************************************************************
INCLUDE(common/sizes)
INCLUDE(../m4/common/utilc)
      common /keywrd/ keywrd
      common /timdmp/ tleft, tdump
      common /densty/ p(mpack),pa(mpack),pb(mpack)
      common /gradnt/ grad(maxpar),gnorm
      common /numcal/ numcal
      common /geosym/ ndep,locpar(maxpar),idepfn(maxpar),locdep(maxpar)
      common /cmpg/ geo(3,numatm)
      common /atmass/ atmass(numatm)
      common /geovar/ nvar, loc(2,maxpar), idumy, xparam(maxpar)
      common /geokst/ natoms,labels(numatm),
     1                na(numatm),nb(numatm),nc(numatm)
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),
     1                nlast(numatm), norbs, nelecs,nalpha,nbeta,
     2                nclose,nopen,ndumy,xract
      common /drccom/ mcoprt(2,maxpar), ncoprt, prtmax
      common/iofile/mfgr,mfgw
      character keywrd*241, getmop*80
      dimension  velo0(maxpar), velo1(maxpar),
     1velo2(maxpar), velo3(maxpar), gerror(maxpar),
     2coord(3,numatm), grold2(maxpar), past10(10),
     3grold(maxpar), georef(3,numatm)
      logical  addk, letot, let, velred,prtmax
      data velo0/maxpar*0.d0/
      data addk/.true./
      tnow=secmop()
      oldtim=secmop()
      delold=10.d0
      gtot=0.0d0
      open(unit=7,status='scratch')
      if(index(keywrd,' prec').ne.0)then
         accu=0.25d0
      else
         accu=1.d0
      endif
      gnlim=1.d0
      past10(5)=100.d0
      i=index(keywrd,'gnorm')
      if(i.ne.0)gnlim=reada(keywrd,i)
      velred=(index(keywrd,'velo').ne.0)
      if(ddot(3*numat,startv,1,startv,1).gt.0.001d0)then
c
c     print out initial velocities
c
         write(mfgw,'(a)')' initial velocity in drc'
         write(mfgw,'(3f13.5)')(startv(i),i=1,numat*3)
      endif
      let=(index(keywrd,' geo-ok').ne.0.or.velred)
      if(index(keywrd,' sym').ne.0)then
         write(mfgw,*)
     +   '  symmetry specified, but cannot be used in drc'
         ndep=0
      endif
c
c      convert to cartesian coordinates, if not already done.
c
      if(index(keywrd,' xyz').eq.0)then
         na(1)=0
         call gmetry(geo,coord)
         l=0
c
         do 30 j=1,3
            do 20 i=1,numat
               geo(j,i)=coord(j,i)
               coord(j,i)=0.0d0
   20       continue
   30    continue
c
         na(1)=99
      endif
c
c  transfer coordinates to xparam and loc
c
      if(index(keywrd,' drc').ne.0)then
         prtmax=(loc(1,1).eq.1)
         if(prtmax)then
            j=1
         else
            j=0
         endif
         nvar=nvar-j
         do 40 i=1,nvar
            mcoprt(1,i)=loc(1,i+j)
   40    mcoprt(2,i)=loc(2,i+j)
         if(loc(1,1).eq.0)nvar=0
         ncoprt=nvar
      else
         ncoprt=0
      endif
      l=0
      do 50 i=1,numat
         loc(1,l+1)=i
         loc(2,l+1)=1
         georef(1,i)=geo(1,i)
         xparam(l+1)=geo(1,i)
c
         loc(1,l+2)=i
         loc(2,l+2)=2
         georef(2,i)=geo(2,i)
         xparam(l+2)=geo(2,i)
c
         loc(1,l+3)=i
         loc(2,l+3)=3
         georef(3,i)=geo(3,i)
         xparam(l+3)=geo(3,i)
c
         l=l+3
   50 continue
      nvar=numat*3
c
c determine damping factor
c
      if(index(keywrd,'drc=').ne.0) then
         half=reada(keywrd,index(keywrd,'drc='))
         write(mfgw,'(//10x,
     +    '' damping factor for kinetic energy ='',f12.6)')half
      elseif (index(keywrd,'drc').eq.0) then
         half=0.0d0
      else
         half=1.d6
      endif
c
c  letot is true if corrections are not to be made part way into
c        the calculation
c
c  usage of letot:
c (1) while letot is false, no damping will be done
c (2) when letot is turned true,
c     if an irc, then etot is reset so the error is zero.
c     if a  drc, excess kinetic energy used to start the run is removed.
c
      letot=(index(keywrd,'irc=').eq.0 .and. .not. let)
      half=dsign(dmax1(0.000001d0,dabs(half)),half)
c
c determine excess kinetic energy
c
      iskin=0
      if(index(keywrd,'kine').ne.0) then
         iskin=1
         addonk=reada(keywrd,index(keywrd,'kine'))
         write(mfgw,
     + '(//10x,'' excess kinetic energy entered into system ='',f12.6)')
     +  addonk
      else
         addonk=0.0d0
      endif
c
c   loop over time-intervals of deltat second
c
      deltat=1.d-16
      quadr=1.d0
      etot=0.0d0
      escf=0.0d0
      const=1.d0
      if( index(keywrd,'restart').ne.0.and.
     +    index(keywrd,'irc=').eq.0) then
c
c  restart from a previous run
c
_IF(ipsc,tools)
       if(oroot()) then
_ENDIF
         open(unit=9,file=getmop(3),status='unknown',
     +form='formatted')
         rewind 9
         open(unit=10,file=getmop(4),status='unknown',
     +form='unformatted')
         rewind 10
         read(9,'(a80)')alpha
         read(9,'(3f19.13)')(xparam(i),i=1,nvar)
         read(9,'(a80)')alpha
         read(9,'(3f19.3)')(velo0(i),i=1,nvar)
         read(9,'(a80)')alpha
         read(9,*)(grad(i),i=1,nvar)
         read(9,*)(grold(i),i=1,nvar)
         read(9,*)(grold2(i),i=1,nvar)
         read(9,*)etot,escf,ekin,delold,deltat,dlold2,iloop,
     1gnorm,letot,elost1,gtot
         write(mfgw,'(//10x,''calculation restarted, current'',
     1'' kinetic energy='',f10.5,//)')ekin
_IF(ipsc,tools)
      else
       write(mfgw,*)' restarts not implemented in drc'
       call pend
      endif
_ENDIF
         goto 100
      else
c                         not a restart
         iloop=1
         if(index(keywrd,'irc=').ne.0.or.velred)then
c
c  get hold of velocity vector
c
            if(index(keywrd,'irc=').ne.0)then
               k=reada(keywrd,index(keywrd,'irc='))
            else
               k=1
            endif
            if(k.lt.0)then
               k=-k
               one=-1.d0
            else
               one=1.d0
            endif
            kl=(k-1)*nvar
            summ=0.0d0
            velo1(1)=0
            velo1(2)=0
            velo1(3)=0
            summas=0.0d0
            i=0
            do 60 ii=1,numat
               ams=atmass(ii)
               summas=summas+ams
               velo0(i+1)=startv(kl+i+1)*one
               velo1(1)=velo1(1)+velo0(i+1)*ams
c
               velo0(i+2)=startv(kl+i+2)*one
               velo1(2)=velo1(2)+velo0(i+2)*ams
c
               velo0(i+3)=startv(kl+i+3)*one
               velo1(3)=velo1(3)+velo0(i+3)*ams
c
               i=i+3
   60       continue
c$doit asis
            do 70 i=1,3
   70       velo1(i)=-velo1(i)/summas
            i=0
c$doit asis
            do 80 ii=1,numat
               ams=atmass(ii)
c$doit asis
               do 80 i1=1,3
                  i=i+1
                  if(addonk.gt.1.d-5.or.
     +            .not.velred)velo0(i)=velo0(i)+velo1(i1)
   80       summ=summ+velo0(i)**2*ams
            if(addonk.lt.1.d-5.and.velred)addonk=0.5d0*summ/4.184d10
            if(addonk.lt.1.d-5.and..not.velred)then
               if(dabs(half).gt.1.d-3.and.startk(k).gt.105.d0)then
               write(mfgw,'(a,f10.3,a,/,a)')
     +         ' by default, one quantum of energy,'//
     +         ' equivalent to',startk(k),' cm(-1)',
     +         ' will be used to start the drc'
c
c    2.8585086d-3 converts cm(-1) into kcal/mole
c
                  addonk=startk(k)*2.8585086d-3
                  write(mfgw,'(a,f7.2,a)')
     +           ' this represents an energy of',addonk,' kcals/mole'
               elseif(dabs(half).gt.1.d-3)then
                  write(mfgw,
     +            '(a,f9.2,a)')' the vibrational frequency (',
     +            startk(k),'cm(-1)) is too small',
     +                      ' for one quantum to be used'
                  write(mfgw,'(a)')
     1' instead 0.3kcal/mole will be used to start the irc'
                  addonk=0.3d0
               else
                  addonk=0.3d0
               endif
            endif
c
c   at this point addonk is in kcal/mole
c   normalize so that total k.e. = one quantum (default) (drc only)
c                              or 0.3kcal/mole (irc only)
c                              or addonk if kinetic=nn supplied
c
            if(summ.lt.1.d-4) then
               write(mfgw,'(a)')' system is apparently not moving!'
               return
            endif
c
c  addonk is excess kinetic energy.  if the calculation is an irc,
c  this energy must be removed after a short 'time'.
c
c  make an ad-hoc correction: if addonk is non-zero and half is larger
c  than 0.1, modify addonk to reflect errors due to start-up.
c
            if(half.gt.0.1d0.and.half.lt.10000.d0)
     1addonk=addonk*(1.d0+0.06972d0/half)
c
c  make an ad-hoc correction: if addonk is non-zero and half is less
c  than -0.1, modify addonk to reflect errors due to start-up.
c
            if(half.lt.-0.1d0.and.half.gt.-10000.d0)
     1addonk=addonk*(1.d0+0.06886d0/half)
            summ=dsqrt(addonk/(0.5d0*summ/4.184d10))
            addk=.false.
            if(summ.gt.1.d-10)then
               do  90 i=1,nvar
   90          velo0(i)=velo0(i)*summ
c
c  if it is a drc, destroy addonk.  the kinetic energy used will come
c  from the velocity only.
c
               if(half.gt.1.d-3)addonk=0.0d0
            endif
         endif
      endif
  100 continue
      iupper=iloop+4999
      ilp=iloop
      one=0.0d0
      if(index(keywrd,'restart').ne.0.and.index(keywrd,'irc=').eq.0)
     1one=1.d0
      do 190 iloop=ilp,iupper
c
c  movement of atoms will be proportional to the average velocities
c  of the atoms before and after time interval
c
c
c  rapid change in gradient implies small step size for deltat
c
c   kinetic energy = 1/2 * m * v * v
c                  = 0.5 / (4.184d10) * m * v * v
c   new velocity = old velocity + gradient * time / mass
c                = kcal/angstrom*second/(atomic weight)
c                =4.184*10**10(ergs)*10**8(per cm)*deltat(seconds)
c   new position = old position - average velocity * time interval
c
c
c   establish reference total energy
c
         error=(etot-(ekin+escf))
         if(iloop.gt.2)then
            quadr = 1.d0+error/(ekin*const+0.001d0)*0.5d0
            quadr = dmin1(1.3d0,dmax1(0.8d0,quadr))
         else
            quadr=1.d0
         endif
         if((let.or.ekin.gt.0.2d0).and.addk)then
c
c   dump in excess kinetic energy
c
            etot=etot+addonk
            addk=.false.
            addonk=0.0d0
         endif
c
c  calculate the duration of the next step.
c  step size is that required to produce a constant change in geometry
c
c
c  if damping is used, calculate the new total energy and
c  the ratio for reducing the kinetic energy
c
         const=dmax1(1.d-36,0.5d0**(deltat*1.d15/half))
         const=dsqrt(const)
         velvec=0.0d0
         ekin=0.0d0
         delta1=delold+dlold2
         elost=0.0d0
         do 110 i=1,nvar
c
c   calculate components of velocity as
c   v = v(0) + v'*t + v"*t*t
c   we need all three terms, v(0), v' and v"
c
            velo1(i) = 1.d0/atmass(loc(1,i))*grad(i)
            if(iloop.gt.3) then
               velo3(i) = 2.d0/atmass(loc(1,i))*
     1(delta1*(grold(i)-grad(i))-delold*(grold2(i)-grad(i)))/
     2(delta1*(delold**2*1.d30)-delold*(delta1**2*1.d30))
               velo2(i)=1.d0/atmass(loc(1,i))*
     1(grad(i)-grold(i)-0.5d0*velo3(i)*
     +(1.d30*delold**2))/(delold*1.d15)
            else
               velo2(i) = 1.d0/atmass(loc(1,i))*
     1                 (grad(i)-grold(i))/(1.d15*delold)
               velo3(i)=0.0d0
            endif
c
c  move atoms through distance equal to velocity * delta-time, note
c  velocity changes from start to finish, therefore average.
c
            xparam(i)=xparam(i)
     1        -1.d8*(deltat*velo0(i)*one
     2        +0.5d0*deltat**2*velo1(i)
     3        +0.16666d0*(deltat**2*1.d15)*deltat*velo2(i)
     4        +0.0416666d0*deltat**2*(1.d30*deltat**2)*velo3(i))
c
c   correct errors due to cubic components in energy gradient,
c   also to add on excess energy, if necessary.
c
            velvec=velvec+velo0(i)**2
c
c   modify velocity in light of current energy gradients.
c
c   velocity = old velocity + (delta-t / atomic mass) * current gradient
c                           + 1/2 *(delta-t * delta-t /atomic mass) *
c                             (slope of gradient)
c              slope of gradient = (grad(i)-grold(i))/delold
c
c
c   this expression is accurate to second order in time.
c
            velo0(i) = velo0(i) + 
     +      deltat*velo1(i) + 0.5d0*deltat**2*velo2(i)*1.0d15 
     +      + 0.166666d0*deltat*(1.d30*deltat**2)*velo3(i)
            if(let.or.gnorm.gt.3.d0)then
               let=.true.
               elost=elost+velo0(i)**2*atmass(loc(1,i))*(1-const**2)
               velo0(i)=velo0(i)*const*quadr
            endif
c
c  calculate kinetic energy (in 2*ergs at this point)
c
            ekin=ekin+velo0(i)**2*atmass(loc(1,i))
  110    continue
         one=1.d0
         if(let.or.gnorm.gt.3.d0)then
            if(.not.letot) then
               if(dabs(half).lt.1.d-3)then
c
c  it is an irc, so reset the total energy
c
                  etot=escf+elost1
                  addonk=0.0d0
                  elost1=0.0d0
                  elost=0.0d0
               elseif(iskin.eq.0)then
c
c  it is a drc and kinetic not used, so remove extra kinetic energy
c
                  etot=etot-addonk
               endif
            endif
            letot=.true.
         endif
c
c  convert energy into kcal/mole
c
         ekin=0.5d0*ekin/4.184d10
c
c  if it is a damped drc, modify etot to reflect loss of kinetic energy
c
         if(letot.and.dabs(half).gt.0.00001d0)
     1etot=etot-ekin/const**2+ekin
         elost1=elost1+0.5d0*elost/4.184d10
c
c store old gradients for delta - velocity calculation
c
         do 120 i=1,nvar
            grold2(i)=grold(i)
            grold(i)=grad(i)
  120    grad(i)=0.0d0
c
c   calculate energy and gradients
c
         scfold=escf
         call compfg(xparam,.true.,escf,.true.,grad,.true.)
         if(iloop.gt.2)then
            gnorm=0.0d0
            do 140 i=1,nvar,3
            sum=dsqrt(ddot(3,grad(i),1,grad(i),1)/
     1               (ddot(3,velo0(i),1,velo0(i),1)+1.d-20))
               do 130 j=i,i+2
  130          gerror(j)=gerror(j)+grad(j)+velo0(j)*sum
  140       continue
            gnorm=dsqrt(ddot(nvar,gerror,1,gerror,1))
            gtot=gnorm
         endif
         gnorm=dsqrt(ddot(nvar,grad,1,grad,1))
c
c   convert gradients into ergs/cm
c
         do 150 i=1,nvar
  150    grad(i)=grad(i)*4.184d18
c
c   special treatment for first point - set "old" gradients equal to
c   current gradients.
c
         if(iloop.eq.1) then
            do 160 i=1,nvar
  160       grold(i)=grad(i)
         endif
         dlold2=delold
         delold=deltat
         sum=0.0d0
         do 170 i=1,nvar
  170    sum=sum + ((grad(i)-grold(i))/4.184d18)**2
         if(dabs(half).lt.0.001d0)then
            deltat= deltat*
     1      dmin1(2.d0, (5.d-5*accu/(dabs(escf+elost1-etold)+1.d-20)))
     +         **0.25d0

            etold=escf+elost1
            if(iloop.gt.5.and.scfold-escf.lt.-1.d-3 .or.
     1      iloop.gt.30.and.scfold-escf.lt.0.d0)  then
               write(mfgw,'(//,'' irc calculation complete '')')
               return
            endif
         else
            deltat= deltat*dmin1(1.05d0, 10.d0*accu/(sum+1.d-4))
            deltat=dmin1(deltat,3.d-15*accu)
            past10(10)=gnorm
            sum=0.0d0
            do 180 i=1,9
               sum=sum+dabs(past10(i)-past10(i+1))
  180       past10(i)=past10(i+1)
            if(sum.lt.gnlim)then
               write(mfgw,
     +         '(//,a)')' gradient constant and small -- assume'
     1           //' all motion stopped'
               return
            endif
            deltat=dmin1(deltat,2.d-15)
************************************************************************
*
*         testing code - remove before final version assembled
c#          (iloop/400)*400.eq.iloop)deltat=-deltat
*
************************************************************************
         endif
         deltat=dmax1(1.d-16,deltat)
         if(dabs(half).lt.0.00001d0)then
c
c   for the irc:
c
c escf   = potential energy
c elost1 = energy lost (in drc, this would have been the kinetic energy)
c etot   = computed total energy = starting potential energy
c
c   in drcout  'total' = escf + elost1
c              'error' = escf + elost1 - etot
c
            call prtdrc(escf,deltat,xparam,georef,
     1elost1,gtot,etot,velo0,nvar)
         else
c
c   for the drc:
c
c escf   = potential energy
c ekin   = current kinetic energy
c etot   = computed total energy = starting potential energy -
c          kinetic energy lost through damping, if present.
c
c   in drcout  'total' = escf + ekin
c              'error' = escf + ekin - etot
c
            call prtdrc(escf,deltat,xparam,georef,
     1ekin,dummy,etot,velo0,nvar)
         endif
         tnow=secmop()
         tcycle=tnow-oldtim
         oldtim=tnow
         tleft=tleft-tcycle
         if (iloop.eq.iupper.or.tleft.lt.3*tcycle) then
_IF(ipsc,tools)
          if(oroot().and.odumpm) then
_ELSE
          if(odumpm) then
_ENDIF
  46        open(unit=9,file=getmop(3),status='new',
     +form='formatted',err=45)
            goto 47
  45        open(unit=9,file=getmop(3),status='old')
            close(9,status='delete')
            goto 46
  47        continue
            rewind 9
            open(unit=10,file=getmop(4),status='unknown',
     +form='unformatted')
            rewind 10
            write(9,'(a)')' cartesian geometry parameters in angstroms'
            write(9,'(3f19.13)')(xparam(i),i=1,nvar)
            write(9,'(a)')' velocity for each cartesian coordinate, in c
     1m/sec'
            write(9,'(3f19.3)')(velo0(i),i=1,nvar)
            write(9,'(a)')' first, second, and third-order gradients, et
     1c'
            write(9,*)(grad(i),i=1,nvar)
            write(9,*)(grold(i),i=1,nvar)
            write(9,*)(grold2(i),i=1,nvar)
            i=iloop+1
            write(9,*)etot,escf,ekin,delold,deltat,dlold2,i,
     1gnorm,letot,elost1,gtot
            escf=-1.d9
            call prtdrc(escf,deltat,xparam,georef,
     1ekin,elost,etot,velo0,nvar)
            linear=(norbs*(norbs+1))/2
            write(10)(pa(i),i=1,linear)
            if(nalpha.ne.0)write(10)(pb(i),i=1,linear)
            write(mfgw,
     +   '(//10x,'' running out of time, restart file written'')')
            write(mfgw,
     +      '(a)')' geometry and velocity are in restart file'
     1    //' in ascii'
            return
          endif
         endif
  190 continue
      end
      subroutine drcout(xyz3,geo3,vel3,nvar,time,escf3,ekin3,
     1gtot3,etot3,xtot3,iloop,charge,fract,text1,text2,ii,jloop)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      character text1*3,text2*2
      dimension xyz3(3,nvar), vel3(3,nvar), escf3(3), ekin3(3)
      dimension xyz(3,numatm), vel(3,numatm), charge(numatm),
     1 geo3(3,numatm), etot3(3), gtot3(3), xtot3(3)
*************************************************************
*                                                           *
*    drcout prints the geometry, etc. for a drc at a        *
*    position determined by fract.                          *
*    on input xyz3  = quadratic expression for the geometry *
*             vel3  = quadratic expression for the velocity *
*             escf3 = quadratic expression for the p.e.     *
*             ekin3 = quadratic expression for the k.e.     *
*                                                           *
*************************************************************
      common /keywrd/ keywrd
      common /geokst/ natoms,labels(numatm),
     1                na(numatm),nb(numatm),nc(numatm)
      common /elemts/ elemnt(107)
      common /geovar/ iivar, loc(2,maxpar), idumy, xparam(maxpar)
      common /titles/ koment,title
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),
     1                nlast(numatm), norbs, nelecs,nalpha,nbeta,
     2                nclose,nopen,ndumy,xract
      common /numcal/ numcal
      common/iofile/mfgr,mfgw
      dimension  iel1(3), gg(3)
      character keywrd*241,koment*81,title*81, alpha*2, elemnt*2
      save prtkey, prtkom, prtitl, i, drc
      integer prtkom, prtitl, prtkey
      logical large, drc
      save icalcn
      data icalcn/0/
      if (icalcn.ne.numcal) then
         icalcn=numcal
         if( index(keywrd,'restart').eq.0.or.index(keywrd,'irc=').ne.0)
     1then
            jloop=0
         endif
         do 10 i=80,1,-1
   10    if(keywrd(i:i).ne.' ')goto 20
         i=1
   20    prtkey=i
         do 30 i=80,1,-1
   30    if(koment(i:i).ne.' ')goto 40
         i=1
   40    prtkom=i
         do 50 i=80,1,-1
   50    if(title(i:i).ne.' ')goto 60
         i=1
   60    prtitl=i
         drc=(index(keywrd,'drc').ne.0)
         i=index(keywrd,'large')
         iprint=10000
         if(i.ne.0)then
            iprint=1
            i=i+5
            large=(keywrd(i:i).eq.' '.or.keywrd(i+1:i+1).eq.'-')
            if(keywrd(i:i).eq.'=') iprint=dabs(reada(keywrd,i))
         endif
      endif
      if(jloop.eq.0.or.(jloop/iprint)*iprint.eq.jloop) then
         if(drc) then
            write(mfgw,'(//,'' femtoseconds  point  potential +''
     1,'' kinetic  =  total     error    ref%   movement'')')
         else
            write(mfgw,'(//,''     point   potential  +  ''
     1,''energy lost   =   total      error    ref%   movement'')')
         endif
      endif
      jloop=jloop+1
c#      fract=0.0d0
      escf=escf3(1)+escf3(2)*fract+escf3(3)*fract**2
      ekin=ekin3(1)+ekin3(2)*fract+ekin3(3)*fract**2
      etot=etot3(1)+etot3(2)*fract+etot3(3)*fract**2
c#      gtot=gtot3(1)+gtot3(2)*fract+gtot3(3)*fract**2
      xtot=xtot3(1)+xtot3(2)*fract+xtot3(3)*fract**2
      errr=dmin1(9999.99999d0,dmax1(-999.99999d0,escf+ekin-etot))
      if(ii.ne.0)then
         if(drc) then
            write(mfgw,'(f10.3,i8,f12.5,f11.5,f11.5,
     1f10.5,'' '',i5,3x,''%'',a,a,i3)')time, iloop-2, escf, ekin,
     2 escf+ekin,errr,jloop,text1,text2,ii
        write(mfgw,
     +  '(9x,a,f9.4,a)')' movement from start =',xtot,' angstroms'
         else
            write(mfgw,'(i8,f14.5,f13.5,f17.5,
     1f10.5,'' '',i5,3x,''%'',a,a,i3)') iloop-2, escf, ekin,
     2 escf+ekin,errr,jloop,text1,text2,ii
c#      write(6,'(24x,'' integrated gradient error ='',g10.3,
c#     1'' kcals/angstrom'')')gtot
        write(mfgw,'(9x,a,f9.4,a)')' movement from start =',xtot,' angs
     1troms'
         endif
      else
         if(drc) then
            if(text1.eq.' '.and.text2.eq.' ')then
               write(mfgw,'(f10.3,i8,f12.5,f11.5,f11.5,
     1f10.5,'' '',i5,3x,''%'',f8.4)')time, iloop-2, escf, ekin,
     2 escf+ekin,errr,jloop,xtot
            else
               write(mfgw,'(f10.3,i8,f12.5,f11.5,f11.5,
     1f10.5,'' '',i5,3x,''%'',a,a,i3)')time, iloop-2, escf, ekin,
     2 escf+ekin,errr,jloop,text1,text2
            endif
         else
            if(text1.eq.' '.and.text2.eq.' ')then
               write(mfgw,'(i8,f14.5,f13.5,f17.5,
     1f10.5,'' '',i5,3x,''%'',f8.4)') iloop-2, escf, ekin,
     2 escf+ekin,errr,jloop,xtot
            else
               write(mfgw,'(i8,f14.5,f13.5,f17.5,
     1f10.5,'' '',i5,3x,''%'',a,a,i3)') iloop-2, escf, ekin,
     2 escf+ekin,errr,jloop,text1,text2
            endif
         endif
      endif
      natoms=nvar/3
      l=0
      do 80 i=1,natoms
         do 70 j=1,3
            l=l+1
            vel(j,i)=vel3(1,l)+vel3(2,l)*fract+vel3(3,l)*fract**2
   70    xyz(j,i)=xyz3(1,l)+xyz3(2,l)*fract+xyz3(3,l)*fract**2
   80 continue
      if(large.and.(jloop/iprint)*iprint.eq.jloop)then
         write(mfgw,*)'                cartesian geometry           '
     1//'velocity (in cm/sec)'
         write(mfgw,*)'  atom        x          y          z'
     1      //'                x          y          z'
         do 90 i=1,numat
            ll=(i-1)*3+1
            write(mfgw,'(i4,3x,a2,3f11.5,2x,3f11.1)')
     1i, elemnt(nat(i)),(xyz(j,i),j=1,3),(vel(j,i),j=1,3)
   90    continue
      endif
      if((jloop/iprint)*iprint.eq.jloop)then
         ivar=1
         na(1)=0
         l=0
         write(mfgw,
     +  '(//10x,''final geometry obtained'',33x,''charge'')')
         write(mfgw,
     +  '(a)')keywrd(:prtkey),koment(:prtkom),title(:prtitl)
         l=0
         do 120 i=1,numat
            j=i/26
            alpha(1:1)=char(ichar('a')+j)
            j=i-j*26
            alpha(2:2)=char(ichar('a')+j-1)
c$doit asis
            do 100 j=1,3
  100       iel1(j)=0
  110       continue
            if(loc(1,ivar).eq.i) then
               iel1(loc(2,ivar))=1
               ivar=ivar+1
               goto 110
            endif
            if(i.lt.4) then
               iel1(3)=0
               if(i.lt.3) then
                  iel1(2)=0
                  if(i.lt.2) then
                     iel1(1)=0
                  endif
               endif
            endif
            if(labels(i).lt.99)then
               l=l+1
               gg(1)=geo3(1,i*3-2)+geo3(2,i*3-2)*fract+geo3(3,i*3-2)*
     +               fract**2
               gg(2)=geo3(1,i*3-1)+geo3(2,i*3-1)*fract+geo3(3,i*3-1)*
     +               fract**2
               gg(3)=geo3(1,i*3  )+geo3(2,i*3  )*fract+geo3(3,i*3  )*
     +               fract**2
               write(mfgw,'(2x,a2,3(f12.6,i3),i4,2i3,f13.4,i5,a)')
     1    elemnt(labels(i)),(gg(k),iel1(k),k=1,3),
     2    na(i),nb(i),nc(i),charge(l),jloop,alpha//'*'
            else
               write(mfgw,'(2x,a2,3(f12.6,i3),i4,2i3,13x,i5,a)')
     1    elemnt(labels(i)),(gg(k),iel1(k),k=1,3),
     2na(i),nb(i),nc(i),jloop,alpha//'%'
            endif
  120    continue
         na(1)=99
      endif
      return
      end
      subroutine ea08c(a,b,value,vec,m,iv,w)
      implicit REAL (a-h,o-z)
c  standard fortran 66 (a verified pfort subroutine)
      common/iofile/mfgr,mfgw
      dimension a(*),b(*),value(*),vec(*),w(*)
      data eps/1.d-6/,a34/0.0d0/
c     this uses qr iteration to find the eigenvalues and eigenvectors
c  of the symmetric tridiagonal matrix whose diagonal elements are
c  a(i),i=1,m and off-diagonal elements are b(i),i=2,m.  the array
c  w is used for workspace and must have dimension at least 2*m.
c  we treat vec as if it had dimensions (iv,m).
      sml=eps*dfloat(m)
      call ea09c(a,b,w(m+1),m,w)
c     set vec to the identity matrix.
      do 20 i=1,m
         value(i)=a(i)
         w(i)=b(i)
         k=(i-1)*iv+1
         l=k+m-1
         do 10 j=k,l
   10    vec(j)=0.d0
         ki=k+i-1
   20 vec(ki)=1.d0
      k=0
      if(m.eq.1)return
      do 100 n3=2,m
         n2=m+2-n3
c     each qr iteration is performed of rows and columns n1 to n2
         mn2=m+n2
         root=w(mn2)
         do 80 iter=1,20
            bb=(value(n2)-value(n2-1))*0.5d0
            cc=w(n2)*w(n2)
            a22=value(n2)
            if(cc.ne.0.0d0)
     +      a22=a22+cc/(bb+dsign(1.0d0,bb)*dsqrt(bb*bb+cc))
            do 30 i=1,n2
               mi=m+i
               if(dabs(root-a22).le.dabs(w(mi)-a22))go to 30
               root=w(mi)
               mn=m+n2
               w(mi)=w(mn)
               w(mn)=root
   30       continue
            do 40 ii=2,n2
               n1=2+n2-ii
               if(dabs(w(n1)).le.
     +           (dabs(value(n1-1))+dabs(value(n1)))*sml) go to 50
   40       continue
            n1=1
   50       if(n2.eq.n1) go to 100
            n2m1=n2-1
            if(iter.ge.3)root=a22
            k=k+1
            a22=value(n1)
            a12=a22-root
            a23=w(n1+1)
            a13=a23
            do70 i=n1,n2m1
               a33=value(i+1)
               if(i.ne.n2m1)a34=w  (i+2)
               s=dsign(dsqrt(a12*a12+a13*a13),a12)
               si=a13/s
               co=a12/s
               jk=i*iv+1
               j1=jk-iv
               j2=j1+min(m,i+k)-1
               do 60 ji=j1,j2
                  v1=vec(ji)
                  v2=vec(jk)
                  vec(ji)=v1*co+v2*si
                  vec(jk)=v2*co-v1*si
   60          jk=jk+1
               if(i.ne.n1)  w(i)=s
               a11=co*a22+si*a23
               a12=co*a23+si*a33
               a13=si*a34
               a21=co*a23-si*a22
               a22=co*a33-si*a23
               a23=co*a34
               value(i)=a11*co+a12*si
               a12=-a11*si+a12*co
               w(i+1)=a12
   70       a22=a22*co-a21*si
   80    value(n2)=a22
         write(mfgw,90)
   90    format(48h1cycle detected in subroutine ea08 -stopping now)
_IF(ipsc,tools)
         call pend
_ELSE
         stop
_ENDIF
  100 continue
c     rayleigh quotient
      do 120 j=1,m
         k=(j-1)*iv
         xx=vec(k+1)**2
         xax=xx*a(1)
         do 110 i=2,m
            ki=k+i
            xx=xx+vec(ki)**2
  110    xax=xax+vec(ki)*(2.0d0*b(i)*vec(ki-1)+a(i)*vec(ki))
  120 value(j)=xax/xx
      return
      end
      subroutine ea09c(a,b,value,m,off)
      implicit REAL (a-h,o-z)
c  standard fortran 66 (a verfied pfort subroutine)
      common/iofile/mfgr,mfgw
      dimension a(*),b(*),value(*),off(*)
      data a34/0.0d0/,eps/1.0d-6/
      sml=eps*dfloat(m)
      value(1)=a(1)
      if(m.eq.1)return
      do 10 i=2,m
         value(i)=a(i)
   10 off(i)=b(i)
c     each qr iteration is performed of rows and columns n1 to n2
      maxit=10*m
      do 80 iter=1,maxit
         do 40 n3=2,m
            n2=m+2-n3
            do 20 ii=2,n2
               n1=2+n2-ii
               if(dabs(off(n1)).le.
     +          (dabs(value(n1-1))+dabs(value(n1)))*sml)go to 30
   20       continue
            n1=1
   30       if(n2.ne.n1) go to 50
   40    continue
         return
c     root  is the eigenvalue of the bottom 2*2 matrix that is nearest
c     to the last matrix element and is used to accelerate the
c     convergence
   50    bb=(value(n2)-value(n2-1))*0.5d0
         cc=off(n2)*off(n2)
         sbb=1.0d0
         if(bb.lt.0.0d0)sbb=-1.0d0
         root=value(n2)+cc/(bb+sbb*dsqrt(bb*bb+cc))
         n2m1=n2-1
   60    a22=value(n1)
         a12=a22-root
         a23=off(n1+1)
         a13=a23
         do 70 i=n1,n2m1
            a33=value(i+1)
            if(i.ne.n2m1)a34=off(i+2)
            s=dsqrt(a12*a12+a13*a13)
            si=a13/s
            co=a12/s
            if(i.ne.n1)off(i)=s
            a11=co*a22+si*a23
            a12=co*a23+si*a33
            a13=si*a34
            a21=co*a23-si*a22
            a22=co*a33-si*a23
            a23=co*a34
            value(i)=a11*co+a12*si
            a12=-a11*si+a12*co
            off(i+1)=a12
   70    a22=a22*co-a21*si
   80 value(n2)=a22
      write(mfgw,90)
   90 format(39h1looping detected in ea09-stopping now )
_IF(ipsc,tools)
      call pend
_ELSE
      stop
_ENDIF
      end
      subroutine ec08c(a,b,value,vec,n,iv,w)
c
c to find the eigenvalues and vectors of a tri-diagonal
c  hermitian matrix.
      REAL value(*),w(*),pck(2),one,zero,vec(*)
      COMPLEX a(*),b(*),dn,upck
      equivalence (pck(1),upck)
c  we treat vec as if it is defined as complex vec(iv,n)
c  in the calling program.
      data one, zero/1.0d0,0.0d0/
      iv2=iv+iv
      n2=n+n
      il=iv2*(n-1)+1
      w(1)=a(1)
c
c  the hermitian form is transformed into a real form
      if(n-1)80,80,10
   10 do 20 i=2,n
         w(i)=a(i)
   20 w(i+n)=cdabs(b(i))
c
c  find the eigenvalues and vectors of the real form
   30 call ea08c(w,w(n+1),value,vec,n,iv2,w(n2+1))
c
c the vectors in vec at this point are real,we now expand them
c into vec as though they were complex.
      do 50 i=1,il,iv2
         do 40 j=1,n
            k=n-j
            l=k+k
   40    vec(i+l)=vec(i+k)
   50 vec(i+1)=zero
      if(n.le.1)go to 80
      dn=one
      k=1
c
c transform vectors of real form to those of complex form.
      do 70 i=4,n2,2
         k=k+1
         upck=one
         if(w(k+n).ne.zero)upck=dn*conjg(b(k))/w(k+n)
         i1=il-1+i
         do 60 j=i,i1,iv2
            vec(j)=vec(j-1)*pck(2)
   60    vec(j-1)=vec(j-1)*pck(1)
   70 dn=upck
   80 return
      end
      subroutine ef(xparam, nvar, funct)
      implicit REAL (a-h,o-z)
      REAL lamda,lamda0
INCLUDE(common/sizes)
      common /iofile/ mfgr,mfgw
      dimension xparam(maxpar)
**********************************************************************
*
*   ef is a quasi newton raphson optimization routine based on
*      jacs simons p-rfo algorithm as implemented by jon baker
*      (j.comp.chem. 7, 385). step scaling to keep length within
*      trust radius is taken from culot et al. (theo. chim. acta 82, 189)
*      the trust radius can be updated dynamically according to fletcher.
*      safeguards on valid step for ts searches based on actual/predicted
*      function change and change in ts mode are own modifications
*
*  on entry xparam = values of parameters to be optimised.
*           nvar   = number of parameters to be optimised.
*
*  on exit  xparam = optimised parameters.
*           funct  = heat of formation in kcal/mol.
*
*  current version implementing combined nr, p-rfo and qa algorithm
*      together with thrust radius update and step rejection was
*      made october 1992 by f.jensen, odense, dk
*
**********************************************************************
c
      common /mesage/ iflepo,iscf
      common /geovar/ ndum,loc(2,maxpar), idumy, xaram(maxpar)
      common /cmpg/ geo(3,numatm)
      common /geosym/ ndep,locpar(maxpar),idepfn(maxpar),locdep(maxpar)
      common /istope/ ams(107)
      common /last  / last
      common /keywrd/ keywrd
      common /timem/ time0
      common /gradnt/ grad(maxpar),gnfina
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),
     1                nlast(numatm), norbs, nelecs,nalpha,nbeta,
     2                nclose,nopen,ndumy,fract
      common /numcal/ numcal
      common /timdmp/ tleft, tdump
      common /sigma2/ gnext1(maxpar), gmin1(maxpar)
convex      common /nllcom/ hess(maxpar,maxpar),bmat(maxpar,maxpar),
convex     1pmat(maxpar*maxpar)
      common /nllcom/ hess(maxpar,maxpar),bmat(maxpar,maxpar),
     1pmat(maxhes)
convex      common /scrach/ pvec
      common /scftyp/ emin, limscf
      common/fmatrx/oldf(maxpar),d(maxpar),vmode(maxpar),
     $u(maxpar,maxpar),dd,rmin,rmax,omin,xlamd,xlamd0,skal,
     $mode,nstep,negreq,iprnt
      common/threads/num_threads
      common/flushx/nflush

      dimension ipow(9), eigval(maxpar),tvec(maxpar),svec(maxpar),
     1fx(maxpar),hessc(maxhes),uc(maxpar**2),oldfx(maxpar),
     1oldeig(maxpar),
     $oldhss(maxpar,maxpar),oldu(maxpar,maxpar),ooldf(maxpar)
      dimension bb(maxpar,maxpar) 

      logical restrt,scf1,limscf,log
      logical lupd,lts,lrjk,lorjk,rrscal,donr,gnmin 
      character keywrd*241
      equivalence(ipow(1),ihess)
c
      save
c
      data  icalcn,zero,one,two    /0,0.d0,1.d0,2.d0/
      data tmone /1.0d-1/, tmtwo/1.0d-2/, tmsix/1.0d-06/
      data three/3.0d0/, four/4.0d0/, 
     1pt25/0.25d0/, pt5/0.50d0/, pt75/0.75d0/
      data demin/2.0d-2/, gmin/5.0d0/
c
c     get all initialization data
      if(icalcn.ne.numcal) 
     1call efstr(xparam,funct,ihess,ntime,iloop,igthes,
     $mxstep,ireclc,iupd,dmax,ddmax,dmin,tol2,totime,time1,time2,nvar,
     $scf1,lupd,ldump,log,rrscal,donr,gnmin)
      lts=.false.
      if (negreq.eq.1) lts=.true.
      lorjk=.false.
c     osmin is smallest step for which a ts-mode overlap less than omin
c     will be rejected. for updated hessians there is little hope of
c     better overlap by reducing the step below 0.005. for exact hessian
c     the overlap should go toward one as the step become smaller, but
c     don't allow very small steps 
      osmin=0.005d0
      if(ireclc.eq.1)osmin=0.001d0
      if (scf1) then
         gnfina=dsqrt(ddot(nvar,grad,1,grad,1))
         iflepo=1
         return
      endif
c     check that geometry is not already optimized
         rmx=dsqrt(ddot(nvar,grad,1,grad,1))
         if (rmx.lt.tol2) then
            iflepo=2
            last=1
            return
         endif
c     get initial hessian. if iloop is .le.0 this is an optimization restart 
c     and hessian should already be available                                   
      if (iloop .gt. 0) call gethesm(xparam,igthes,nvar,iloop,totime)

c     start of main loop
c     we now have gradients and a hessian. if this is the first
c     time through don't update the hessian. for later loops also
c     check if we need to recalculate the hessian
      iflepo=0
      itime=0
   10 continue
c     store various things for possibly omin rejection
      do 30 i=1,nvar
         oldfx(i)=fx(i)
         ooldf(i)=oldf(i)
         oldeig(i)=eigval(i)
         do 20 j=1,nvar
            oldhss(i,j)=hess(i,j)
            oldu(i,j)=u(i,j)
20       continue
30    continue
      if (ihess.ge.ireclc.and.iflepo.ne.15) then
         iloop=1
         ihess=0
         if (igthes.ne.3)igthes=1
         call gethesm(xparam,igthes,nvar,iloop,totime)
      endif
         if (ihess.gt.0) call mophes(svec,tvec,nvar,iupd)
         if(iprnt.ge.2) call geout(mfgw)
         if(iprnt.ge.2) then
            write(mfgw,'('' xparam '')')
            write(mfgw,
     +      '(5(2i3,f10.4))')(loc(1,i),loc(2,i),xparam(i),i=1,nvar)
            write(mfgw,'('' gradients'')')
            write(mfgw,'(3x,8f9.3)')(grad(i),i=1,nvar)
         endif
c
c        print results in cycle
         gnfina=dsqrt(ddot(nvar,grad,1,grad,1))
c
      time2=secmop()
      if (itime.eq.0) time1=time0
      tstep=time2-time1
      if (tstep.lt.zero)tstep=zero
      tleft=tleft-tstep
      time1=time2
      itime=itime+1
      if (tleft .lt. tstep*two) goto 280
         if(ldump.eq.0)then
            write(mfgw,40)nstep+1,dmin1(tstep,9999.99d0),
     1                            dmin1(tleft,9999999.9d0),
     +                            dmin1(gnfina,999999.999d0),funct
            if(log)write(11,40)nstep+1,
     +                         dmin1(tstep,9999.99d0),
     +                         dmin1(tleft,9999999.9d0),
     +                         dmin1(gnfina,999999.999d0),funct
   40       format(' cycle:',i4,' time:',f7.2,' time left:',f9.1,
     1' grad.:',f10.3,' heat:',g13.7)
            if ( nflush.ne.0 ) then
               if ( mod(nstep+1,nflush).eq.0) then
                  call flushm(mfgw)
                  call flushm(11)
               endif
            endif
         else
            write(mfgw,50)dmin1(tleft,9999999.9d0),
     1                    dmin1(gnfina,999999.999d0),funct
            if(log)write(11,50)dmin1(tleft,9999999.9d0),
     1                         dmin1(gnfina,999999.999d0),funct
   50       format(' restart file written,   time left:',f9.1,
     1             ' grad.:',f10.3,' heat:',g13.7)
            if ( nflush.ne.0 ) then
               if ( mod(nstep+1,nflush).eq.0) then
                  call flushm(mfgw)
                  call flushm(11)
               endif
            endif
         endif
         ihess=ihess+1
         nstep=nstep+1
c
c        test for convergence
c
         rmx=dsqrt(ddot(nvar,grad,1,grad,1))
         if (rmx.lt.tol2)goto 250

      olde  = funct
      oldgn = rmx
      do 60 i=1,nvar
         oldf(i)=grad(i)
60    continue
c
c     if the optimization is in cartesian coordinates, we should remove
c     translation and rotation modes. possible problem if run is in
c     internal but with exactly 3*natoms variable (i.e. dummy atoms
c     are also optimized).
      if (nvar.eq.3*numat) then
         if (nstep.eq.1) write(mfgw,70)
70       format(1x,'warning! exactly 3n variables. ef assumes this is a'
     $  ,' cartesian optimization.',/,1x,'if the optimization is',
     $  ' in internal coordinates, ef will not work')
         call prjfc(hess,xparam,nvar)
      endif
      ij=0
      do 80 i=1,nvar
         do 80 j=1,i
            ij=ij+1
            hessc(ij)=hess(j,i)
   80 continue
convex      call hqrii(hessc,nvar,nvar,eigval,uc)
      call rsp(hessc,nvar,nvar,eigval,uc)
      ij=0
      do 90 i=1,nvar
         if (dabs(eigval(i)).lt.tmsix) eigval(i)=zero
         do 90 j=1,nvar
            ij=ij+1
            u(j,i)=uc(ij)
   90 continue
      if (iprnt.ge.3) call prthes(eigval,nvar)
      if (mxstep.eq.0) nstep=0
      if (mxstep.eq.0) goto 280                                                 

      neg=0                                                                     
      do 100 i=1,nvar                                                           
         if (eigval(i) .lt. zero)neg=neg+1                                     
  100 continue                                                                  
      if (iprnt.ge.1)write(mfgw,110)neg,(eigval(i),i=1,neg)
  110 format(/,10x,'hessian has',i3,' negative eigenvalue(s)',6f7.1,/)
c     if an eigenvalue has been zero out it is probably one of the t,r modes
c     in a cartesian optimization. zero corresponding fx to allow formation
c     of step without these contributions. a more safe criteria for deciding
c     whether this actually is a cartesian optimization should be put in 
c     some day...
      do 120 i=1,nvar                                                           
         fx(i)=ddot(nvar,u(1,i),1,grad,1)                                            
         if (dabs(eigval(i)).eq.zero) fx(i)=zero
  120 continue                                                                  
        
c     form geometry step d
130   call mopfd(eigval,fx,nvar,dmax,osmin,lts,lrjk,lorjk,rrscal,donr) 
c     if lorjk is true, then ts mode overlap is less than omin, reject prev step
      if (lorjk) then
         if (iprnt.ge.1)write(mfgw,*)'      now undoing previous step'
         dmax=odmax
         dd=odd
         olde=oolde
         do i=1,nvar
            fx(i)=oldfx(i)
            oldf(i)=ooldf(i)
            eigval(i)=oldeig(i)
            do j=1,nvar
               hess(i,j)=oldhss(i,j)
               u(i,j)=oldu(i,j)
            enddo
         enddo
         do 140 i=1,nvar
            xparam(i)=xparam(i)-d(i)
            k=loc(1,i)
            l=loc(2,i)
            geo(l,k)=xparam(i)
140      continue
         if(ndep.ne.0) call mopsym()
         dmax=dmin1(dmax,dd)/two
         odmax=dmax
         odd=dd
         nstep=nstep-1
         if (dmax.lt.dmin) goto 230
          if (iprnt.ge.1)write(mfgw,*)
     1    '      finish undoing, now going for new step'
         goto 130
      endif
c
c  form new trial xparam and geo
c
      do 150 i=1,nvar
         xparam(i)=xparam(i)+d(i)
         k=loc(1,i)
         l=loc(2,i)
         geo(l,k)=xparam(i)
  150 continue
      if(ndep.ne.0) call mopsym()
c
c     compare predicted e-change with actual 
c
      depre=zero
      imode=1
      if (mode.ne.0)imode=mode
      do 160 i=1,nvar
         xtmp=xlamd
         if (lts .and. i.eq.imode) xtmp=xlamd0
         if (dabs(xtmp-eigval(i)).lt.tmtwo) then
         ss=zero
         else
         ss=skal*fx(i)/(xtmp-eigval(i))
         endif
         frodo=ss*fx(i) + pt5*ss*ss*eigval(i)
c        write(mfgw,88)i,fx(i),ss,xtmp,eigval(i),frodo
         depre=depre+frodo
160   continue
c88   format(i3,f10.3,f10.6,f10.3,4f10.6)
c
c     get gradient for new geometry 
c
      call compfg(xparam, .true., funct, .true., grad, .true.)                  
      if(gnmin)gntest=dsqrt(ddot(nvar,grad,1,grad,1))
      deact = funct-olde
      ratio = deact/depre
      if(iprnt.ge.1)write(mfgw,170)deact,depre,ratio       
  170 format(5x,'actual, predicted energy change, ratio',2f10.3,f10.5)

      lrjk=.false.
c     if this is a minimum search, don't allow the energy to raise
      if (.not.lts .and. funct.gt.olde) then
         if (iprnt.ge.1)write(mfgw,180)funct,min(dmax,dd)/two
180      format(1x,'energy raises ',f10.4,' rejecting step, ',
     $             'reducing dmax to',f7.4)
         lrjk=.true.
      endif
      if (gnmin .and. gntest.gt.oldgn) then
         if (iprnt.ge.1)write(mfgw,181)gntest,min(dmax,dd)/two
181      format(1x,'gradient norm raises ',f10.4,' rejecting step, ',
     $             'reducing dmax to',f7.4)
         lrjk=.true.
      endif
      if (lts .and. (ratio.lt.rmin .or. ratio.gt.rmax) .and.
     $(dabs(depre).gt.demin .or.dabs(deact).gt.demin)) then
         if (iprnt.ge.1)write(mfgw,190)dmin1(dmax,dd)/two
190   format(1x,'unacceptable ratio,',
     $          ' rejecting step, reducing dmax to',f7.4)
         lrjk=.true.
      endif
      if (lrjk) then
         do 200 i=1,nvar
            xparam(i)=xparam(i)-d(i)
            k=loc(1,i)
            l=loc(2,i)
            geo(l,k)=xparam(i)
200      continue
         if(ndep.ne.0) call mopsym()
         dmax=dmin1(dmax,dd)/two
         if (dmax.lt.dmin) goto 230
         goto 130
      endif
      if(iprnt.ge.1)write(mfgw,210)dd
  210 format(5x,'stepsize used is',f9.5)
      if(iprnt.ge.2) then
         write(mfgw,'('' calculated step'')')
         write(mfgw,'(3x,8f9.5)')(d(i),i=1,nvar)
      endif
c
c     possible use dynamical trust radius
      odmax=dmax
      odd=dd
      oolde=olde
      if (lupd .and. ( (rmx.gt.gmin) .or.
     $   (dabs(depre).gt.demin .or.dabs(deact).gt.demin) ) ) then
c     fletcher recommend dmax=dmax/4 and dmax=dmax*2
c     these are are a little more conservative since hessian is being updated
c     don't reduce trust radius due to ratio for min searches
      if (lts .and. ratio.le.tmone .or. ratio.ge.three)
     $    dmax=dmin1(dmax,dd)/two
      if (lts .and. ratio.ge.pt75 .and. ratio.le.(four/three) 
     $                  .and. dd.gt.(dmax-tmsix)) 
     $   dmax=dmax*dsqrt(two)
c     allow wider limits for increasing trust radius for min searches
      if (.not.lts .and. ratio.ge.pt5 
     $                  .and. dd.gt.(dmax-tmsix)) 
     $   dmax=dmax*dsqrt(two)
c     be brave if  0.90 < ratio < 1.10 ...
      if (dabs(ratio-one).lt.tmone) dmax=dmax*dsqrt(two)
      dmax=dmax1(dmax,dmin-tmsix)
      dmax=dmin1(dmax,ddmax)
      endif
c     allow stepsize up to 0.1 in the end-game where changes are less 
c     than demin and gradient is less than gmin
      if (lupd .and. rmx.lt.gmin .and.
     $   (dabs(depre).lt.demin .and.dabs(deact).lt.demin) )
     $    dmax=dmax1(dmax,tmone)
      if(iprnt.ge.1)write(mfgw,220)dmax
 220  format(5x,'current trust radius = ',f7.5)                  
230   if (dmax.lt.dmin) then
         write(mfgw,240)dmin
240      format(/,5x,'trust radius now less than ',f7.5,' optimization',
     $   ' terminating',/,5x,
     1' geometry may not be completely optimized')
         goto 270
      endif

c     check steps and enough time for another pass
      if (nstep.ge.mxstep) goto 280
c     in user unfriendly enviroment, save results every 1 cpu hrs
      ittest=aint((time2-time0)/tdump)
      if (ittest.gt.ntime) then
         ldump=1
         ntime=max(ittest,(ntime+1))
         ipow(9)=2
         tt0=secmop()-time0
         call bkrsav(tt0,hess,funct,grad,xparam,pmat,-nstep,nstep,bmat,i
     1pow)
      else
         ldump=0
      endif
c     return for another cycle
      goto 10                                                                  
c
c     ****** optimization termination ******
c
  250 continue
      write(mfgw,260)rmx,tol2
  260 format(/,5x,'rms gradient =',f9.5,'  is less than cutoff =',
     1f9.5,//)
  270 iflepo=15
      last=1
c     save hessian on file 9
      ipow(9)=2
      tt0=secmop()-time0
      call bkrsav(tt0,hess,funct,grad,xparam,pmat,-nstep,nstep,bmat,i
     1pow)
c     call compfg to calculate energy for fixing mo-vector bug
      call compfg(xparam, .true., funct, .true., grad, .false.)
      return
  280 continue
c     we ran out of time or too many iterations. dump results
      if (tleft .lt. tstep*two) then
         write(mfgw,290)
  290    format(/,5x,'not enough time for another cycle')
      endif
      if (nstep.ge.mxstep) then
         write(mfgw,300)
  300    format(/,5x,'excess number of optimization cycles')
      endif
      ipow(9)=1
      tt0=secmop()-time0
      call bkrsav(tt0,hess,funct,grad,xparam,pmat,-nstep,nstep,bmat,i
     1pow)
_IF(ipsc,tools)
      call pend
_ELSE
      stop
_ENDIF
      end
      subroutine elesp
      implicit REAL (a-h,o-z)
c***********************************************************************
c     elesp loads the sto-6g basis set onto the atoms, perfoms the
c     deorthogonalization of the coefficients and evaluates the
c     electronic contribution to the esp. it was written by b.h.besler
c     and k.m.merz in feb. 1989 at ucsf.
c
c***********************************************************************
      character*241 keywrd
      character getmop*80
      REAL norm,ovl
      logical called,potwrt,rst,sto3g
_IF(ipsc,tools)
      logical oroot
_ENDIF
INCLUDE(common/sizes)
      common/espf/ al((numatm+4)**2),a(numatm,numatm),b(numatm),
     1q(numatm+4),cespm(maxorb,maxorb)
      common /densty/ p(mpack),pa(mpack),pb(mpack)
      common /potesp/ xc,yc,zc,espnuc,espele,nesp
      common /abc/    co(3,numatm),ian(numatm),natom
      common /work1/
     +    potpt(3,mesp), es(mesp), esp(mesp), work1d(2*mesp)
      common /sto6g/  allc(6,5,2),allz(6,5,2)
      common /vector/ c(morb2*2+maxorb*2)
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),
     1                nlast(numatm), norbs, nelecs,nalpha,nbeta,
     2                nclose,nopen,ndumy,fract
      common /keywrd/ keywrd
      common /espc/  cc(maxpr),cen(maxpr,3),iam(maxpr,2),ind(maxpr),
     1                ex(maxpr),espi(maxorb,maxorb),
     2                fv(0:8,821),fac(0:7),
     3                dex(-1:96),tf(0:2),temp(maxpr),itemp(maxpr),
     4                ovl(maxorb,maxorb),fc(maxpr*6)
      common /corec/ tore(107)
      common /expont/ zs(107),zp(107),zd(107)
*
*  end of mindo/3 common blocks
*
      common /indx/   indc(maxorb)
      dimension cespm2(maxorb,maxorb),sla(10)
      dimension cespml(maxorb*maxorb),cesp(maxorb*maxorb)
      data bohr/0.529167d0/
      pi=4.d0*datan(1.d0)
c
c     put sto-6g basis set on atom centers
c
      do 10 i=-1,10
         dex(i)=dex2(i)
   10 continue
      do 20   i=0,7
         fac(i)=1.d0/fac(i)
   20 continue
      do 30 m=0,8
         fv(m,1)=1.d0/(2.d0*m+1.d0)
         do 30 it=1,41*20
            t=0.05d0*it
            call fsub(m,t,fval)
            fv(m,it+1)=fval
   30 continue
c
c     load basis functions into arrays
c
      sto3g=(index(keywrd,'sto3g') .ne. 0)
      if(sto3g) then
         icd=3
         call setup3
      else
         icd=6
         call setupg
      endif
      nc=0
      npr=0
      do 80 i=1,natom
         if (ian(i) .le. 2) then
            do 40 j=1,icd
               cc(npr+j)=allc(j,1,1)
               ex(npr+j)=allz(j,1,1)*zs(1)**2
               cen(npr+j,1)=co(1,i)/bohr
               cen(npr+j,2)=co(2,i)/bohr
               cen(npr+j,3)=co(3,i)/bohr
               iam(npr+j,1)=0
               iam(npr+j,2)=0
               fc(npr+j)=i
   40       continue
            nc=nc+1
            npr=npr+icd
         else
c        determine principal quantum number(nqn)
c        of orbitals to be used
c
            nqn=2
            if(ian(i) .gt. 10 .and. ian(i) .le. 18) nqn=3
            if(ian(i) .gt. 18 .and. ian(i) .le. 36) nqn=4
            if(ian(i) .gt. 36 .and. ian(i) .le. 54) nqn=5
c
            do 50 j=1,icd
               cc(npr+j)=allc(j,nqn,1)
               ex(npr+j)=allz(j,nqn,1)*zs(ian(i))**2
               cen(npr+j,1)=co(1,i)/bohr
               cen(npr+j,2)=co(2,i)/bohr
               cen(npr+j,3)=co(3,i)/bohr
               iam(npr+j,1)=0
               iam(npr+j,2)=0
   50       continue
            nc=nc+1
            npr=npr+icd
            do 70 k=1,3
               do 60  j=1,icd
                  cc(npr+j)=allc(j,nqn,2)
                  ex(npr+j)=allz(j,nqn,2)*zp(ian(i))**2
                  cen(npr+j,1)=co(1,i)/bohr
                  cen(npr+j,2)=co(2,i)/bohr
                  cen(npr+j,3)=co(3,i)/bohr
                  iam(npr+j,1)=1
                  iam(npr+j,2)=k
   60          continue
               nc=nc+1
               npr=npr+icd
   70       continue
         endif
   80 continue
c
c     calculate normalization constants and include
c     them in the contraction coefficients
c
      do 90 i=1,npr
         norm=(2.d0*ex(i)/pi)**0.75d0*(4.d0*ex(i))**(iam(i,1)/2.d0)/
     1   dsqrt(dex(2*iam(i,1)-1))
         cc(i)=cc(i)*norm
   90 continue
      ipr=0
c
c     perform sort of primitives by angular momentum
c
      is=0
      ip=0
      ipc=0
      isc=0
      j=0
      do 100 i=1,npr
         if (iam(i,1) .eq. 0) then
            is=is+1
            ind(is)=i
         endif
  100 continue
      ip=is
      do 110 i=1,npr
         if (iam(i,1) .eq. 1 .and. iam(i,2) .eq. 1) then
            ip=ip+1
            ind(ip)=i
         endif
  110 continue
      do 120 i=1,npr
         if (iam(i,1) .eq. 1 .and. iam(i,2) .eq. 2) then
            ip=ip+1
            ind(ip)=i
         endif
  120 continue
      do 130 i=1,npr
         if (iam(i,1) .eq. 1 .and. iam(i,2) .eq. 3) then
            ip=ip+1
            ind(ip)=i
         endif
  130 continue
      do 140 i=1,nc
         in=i*icd-icd+1
         if (iam(in,1) .eq. 0) then
            isc=isc+1
            indc(isc)=i
         endif
  140 continue
      ipc=isc
      do 150 i=1,nc
         in=i*icd-icd+1
         if (iam(in,1) .eq. 1 .and. iam(in,2) .eq. 1) then
            ipc=ipc+1
            indc(ipc)=i
         endif
  150 continue
      do 160 i=1,nc
         in=i*icd-icd+1
         if (iam(in,1) .eq. 1 .and. iam(in,2) .eq. 2) then
            ipc=ipc+1
            indc(ipc)=i
         endif
  160 continue
      do 170 i=1,nc
         in=i*icd-icd+1
         if (iam(in,1) .eq. 1 .and. iam(in,2) .eq. 3) then
            ipc=ipc+1
            indc(ipc)=i
         endif
  170 continue
      do 180 i=1,npr
         temp(i)=cc(ind(i))
  180 continue
      do 190 i=1,npr
         cc(i)=temp(i)
  190 continue
      do 200 i=1,npr
         temp(i)=ex(ind(i))
  200 continue
      do 210 i=1,npr
         ex(i)=temp(i)
  210 continue
      do 220 i=1,npr
         temp(i)=cen(ind(i),1)
  220 continue
      do 230 i=1,npr
         cen(i,1)=temp(i)
  230 continue
      do 240 i=1,npr
         temp(i)=cen(ind(i),2)
  240 continue
      do 250 i=1,npr
         cen(i,2)=temp(i)
  250 continue
      do 260 i=1,npr
         temp(i)=cen(ind(i),3)
  260 continue
      do 270 i=1,npr
         cen(i,3)=temp(i)
  270 continue
      do 280 i=1,npr
         itemp(i)=iam(ind(i),1)
  280 continue
      do 290 i=1,npr
         iam(i,1)=itemp(i)
  290 continue
      do 300 i=1,npr
         itemp(i)=iam(ind(i),2)
  300 continue
      do 310 i=1,npr
         iam(i,2)=itemp(i)
  310 continue
c     calculate overlap matrix of sto-6g functions
c
      do 320 j=1,nc
         call ovlp(j,1,is,ip,npr,nc,icd)
  320 continue
c
      do 330 j=1,nc
         do 330 k=1,nc
            cespm2(indc(j),indc(k))=ovl(j,k)
  330 continue
      do 340 j=1,nc
         do 340 k=1,nc
            ovl(j,k)=cespm2(j,k)
  340 continue
      l=0
      do 350 i=1,nc
         do 350 j=1,i
            l=l+1
            cesp(l)=ovl(i,j)
  350 continue
c
c     deorthogonalize the coefficients and reform the density matrix
c
      call rsp(cesp,nc,1,temp,cespml)
      do 360 i=1,nc
         do 360 j=1,i
            sum=0.0d0
            do 360 k=1,nc
               sum=sum+cespml(i+(k-1)*nc)/
     +         dsqrt(temp(k))*cespml(j+(k-1)*nc)
               cesp(i+(j-1)*nc)=sum
               cesp(j+(i-1)*nc)=sum
  360 continue
      call mult(c,cesp,cespml,nc)
      call densit(cespml,nc,nc,nclose,nopen,fract,cesp,2)
c
c     now calculate the electronic contribution to the electrostatic pot
c
      l=0
      do 370 i=1,nc
         do 370 j=1,i
            l=l+1
            cespm(i,j)=cesp(l)
            cespm(j,i)=cesp(l)
  370 continue
      ipx=(npr-is)/3
      ipe=is+ipx
      do 380 i=1,nesp
         es(i)=0.0d0
  380 continue
      call naicas(isc,is,ip,npr,nc,ipe,ipx,icd)
      call naicap(isc,is,ip,npr,nc,ipe,ipx,icd)
c     calculate total esp and form arrays for espfit
      do 400 i=1,nesp
         esp(i)=0.0d0
         do 390 j=1,natom
            ra=dsqrt((co(1,j)-potpt(1,i))**2+
     +               (co(2,j)-potpt(2,i))**2+
     +               (co(3,j)-potpt(3,i))**2)
            esp(i)=esp(i)+tore(ian(j))/(ra/bohr)
  390    continue
         esp(i)=esp(i)-es(i)
         do 400  j=1,natom
           rij=dsqrt((co(1,j)-potpt(1,i))**2+
     +               (co(2,j)-potpt(2,i))**2+
     +               (co(3,j)-potpt(3,i))**2)/bohr
            b(j)=b(j)+esp(i)*1.d0/rij
  400 continue
c
c     if requested write out electric potential data to
c     unit 21
c
      potwrt=(index(keywrd,'potwrt') .ne. 0)
_IF(ipsc,tools)
      if(potwrt.and.oroot() ) then
_ELSE
      if(potwrt) then
_ENDIF
         open(21,file=getmop(10),status='unknown')
         write(21,'(i5)') nesp
         do 410 i=1,nesp
  410    write(21,420) esp(i),potpt(1,i)/bohr,potpt(2,i)/bohr,
     1potpt(3,i)
      endif
  420 format(1x,4e16.7)
      return
      end
      function emsiab(ialpha,ibeta,eiga,xy,nmos)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      dimension xy(nmeci,nmeci,nmeci,nmeci), eiga(nmeci),
     1ialpha(nmos), ibeta(nmos)
************************************************************************
*
*  calculates the energy of a microstate defined by ialpha and ibeta
*
************************************************************************
      x=0.0d0
      do 20 i=1,nmos
         if (ialpha(i).ne.0)then
            x=x+eiga(i)
            do 10  j=1,nmos
               x=x+((xy(i,i,j,j)-xy(i,j,i,j))*ialpha(j)*0.5d0 +
     1        (xy(i,i,j,j))*ibeta(j))
   10       continue
         endif
   20 continue
      do 40 i=1,nmos
         if (ibeta(i).ne.0) then
            x=x+eiga(i)
            do 30 j=1,i
   30       x=x+(xy(i,i,j,j)-xy(i,j,i,j))*ibeta(j)
         endif
   40 continue
      emsiab=x
      return
      end
      subroutine enpart(uhf,h,alpha,beta,p,q,coord)
c----------------------------------------------------------*
c
c     new sub. enpart,  modified by tsuneo hirano 1986/6/3/
c
c---------------------------------------------------------*
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      common/iofile/mfgr,mfgw
      parameter (natms2 = (numatm*(numatm+1))/2)
      common /elemts/ elemnt(107)
      dimension h(*), alpha(*), beta(*), p(*), q(*), coord(3,*)
c--- defined here, and to be used for enpart-print only ---*
      dimension ex(natms2,3)
c--- end of dimension definition ----------------- by th --*
      logical uhf, mindo3, am1
      character*241 keywrd
      character*2 elemnt
c***********************************************************************
c
c *** energy partitioning within the umindo/3 and umndo scheme
c     routine written by s.olivella, barcelona nov. 1979.
c     extended to am1 and pm3 by jjps.
c
c   on input uhf     = .true. if a u.h.f. calculation.
c            h       = one-electron matrix.
c            alpha   = alpha electron density.
c            beta    = beta electron density.
c            p       = total electron density.
c            q       = atom electron densities.
c
c    nothing is changed on exit.
c
c***********************************************************************
      common /cmpone/ uss(107), upp(107), udd(107)
      common /corec/ core(107)
      common /ideas/ fn1(107,10),fn2(107,10),fn3(107,10)
      common /alpha3/ alp3(153)
      common /twoel3/ f03(107)
      common /alpha/ alp(107)
      common /twoele/ gss(107),gsp(107),gpp(107),gp2(107),hsp(107)
     1                ,gsd(107),gpd(107),gdd(107)
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm)
     1               ,nlast(numatm),norbs,nelecs,
     2                nalpha,nbeta,nclose,nopen,ndumy,fract
      common /wmatrc/ w(n2elec*2)
      common /keywrd/ keywrd
      parameter (mdumy=maxpar*maxpar-numatm*3-natms2*4)
      common /scrach/ ea(numatm,2),eat(numatm), e(natms2,4),
     1xdumy(mdumy)
      mindo3=(index(keywrd,'mindo').ne.0)
c *** recalculate the density matrices in the uhf scheme
c
      linear=norbs*(norbs+1)/2
      if( .not. uhf) then
         do 20 i=1,linear
   20    beta(i)=alpha(i)
      endif
c
c *** one-center energies
      k=0
      do 40 i=1,numat
         ia=nfirst(i)
         ib=nlast(i)
         ni=nat(i)
         ea(i,1)=0.0d0
         do 30 j=ia,ib
            k=k+j
            t=upp(ni)
            if(j.eq.ia) t=uss(ni)
   30    ea(i,1)=ea(i,1)+p(k)*t
         iss=(ia*(ia+1))/2
         ea(i,2)=0.5d0*gss(ni)*p(iss)*p(iss)
     1  -0.5d0*gss(ni)*(alpha(iss)*alpha(iss)+beta(iss)*beta(iss))
         if(ia.eq.ib) go to 40
         ia1=ia+1
         ia2=ia+2
         ixx=ia1*ia2/2
         iyy=ia2*ib/2
         izz=(ib*(ib+1))/2
         ixy=ia1+ia2*ia1/2
         ixz=ia1+ib*ia2/2
         iyz=ia2+ib*ia2/2
         isx=ia+ia1*ia/2
         isy=ia+ia2*ia1/2
         isz=ia+ib*ia2/2
         ss1=p(ixx)*p(ixx)+p(iyy)*p(iyy)+p(izz)*p(izz)
         ss2=p(iss)*(p(ixx)+p(iyy)+p(izz))
         ss3=p(ixx)*p(iyy)+p(ixx)*p(izz)+p(iyy)*p(izz)
         ss4=p(isx)*p(isx)+p(isy)*p(isy)+p(isz)*p(isz)
         ss5=p(ixy)*p(ixy)+p(ixz)*p(ixz)+p(iyz)*p(iyz)
         tt1=alpha(ixx)*alpha(ixx)+alpha(iyy)*alpha(iyy)
     1+alpha(izz)*alpha(izz)+beta(ixx)*beta(ixx)
     2+beta(iyy)*beta(iyy)+beta(izz)*beta(izz)
         tt2=alpha(iss)*(alpha(ixx)+alpha(iyy)+alpha(izz))
     1   +beta(iss)*(beta(ixx)+beta(iyy)+beta(izz))
         tt3=alpha(ixx)*alpha(iyy)+alpha(ixx)*alpha(izz)
     1+alpha(iyy)*alpha(izz)+beta(ixx)*beta(iyy)
     2+beta(ixx)*beta(izz)+beta(iyy)*beta(izz)
         tt4=alpha(isx)*alpha(isx)+alpha(isy)*alpha(isy)
     1+alpha(isz)*alpha(isz)+beta(isx)*beta(isx)
     2+beta(isy)*beta(isy)+beta(isz)*beta(isz)
         tt5=alpha(ixy)*alpha(ixy)+alpha(ixz)*alpha(ixz)
     1+alpha(iyz)*alpha(iyz)+beta(ixy)*beta(ixy)
     2+beta(ixz)*beta(ixz)+beta(iyz)*beta(iyz)
         ea(i,2)=ea(i,2)+0.5d0*gpp(ni)*ss1+gsp(ni)*ss2
     1+gp2(ni)*ss3+hsp(ni)*ss4*2.0d0+0.5d0*(gpp(ni)-gp2(ni))*ss5*2.0d0
     2                -0.5d0*gpp(ni)*tt1-gsp(ni)*tt4-gp2(ni)*tt5-
     3        hsp(ni)*(tt2+tt4)-0.5d0*(gpp(ni)-gp2(ni))*(tt3+tt5)
   40 continue
      am1=(index(keywrd,'am1')+index(keywrd,'pm3').ne.0)
      if(mindo3) then
      write(mfgw,'(///,10x,''total energy partitioning in mindo/3'')')
      elseif( index(keywrd,'pm3').ne.0 ) then
      write(mfgw,'(///,10x,''total energy partitioning in pm3'')')
      elseif( index(keywrd,'am1').ne.0 ) then
      write(mfgw,'(///,10x,''total energy partitioning in am1'')')
      else
      write(mfgw,'(///,10x,''total energy partitioning in mndo'')')
      endif
      write(mfgw,'(/10x,''all energies are in electron volts'')')
      kl=0
   50 k=kl+1
      kl=kl+10
      kl=min(kl,numat)
      do 60 i=k,kl
   60 eat(i)=ea(i,1)+ea(i,2)
      if(numat.gt.kl) go to 50
   70 eau=0.0d0
      eae=0.0d0
      do 80 i=1,numat
         eau=eau+ea(i,1)
   80 eae=eae+ea(i,2)
      tone=eau+eae
c *** two-center energies
c     resonance (e(n,1)) terms
      n=1
      do 100 ii=2,numat
         e(n,1)=0.0d0
         ia=nfirst(ii)
         ib=nlast(ii)
         iminus=ii-1
         oneii=1.d0
         if(nat(ii).eq.102)oneii=0.0d0
         do 90 jj=1,iminus
            n=n+1
            ja=nfirst(jj)
            jb=nlast(jj)
            onejj=1.d0
            if(nat(jj).eq.102)onejj=0.0d0
            e(n,1)=0.0d0
            do 90 i=ia,ib
               ka=(i*(i-1))/2
               do 90 k=ja,jb
                  ik=ka+k
   90    e(n,1)=e(n,1)+2.0d0*p(ik)*h(ik)*oneii*onejj
  100 n=n+1
c
c     the code that follows applies only to mndo
c
      if(.not.mindo3) then
c     core-core repulsion (e(n,2)) and core-elec. attraction (e(n,3)).
         n=1
         kk=0
         do 180 ii=2,numat
            e(n,2)=0.0d0
            e(n,3)=0.0d0
            ia=nfirst(ii)
            ib=nlast(ii)
            ni=nat(ii)
            iss=(ia*(ia+1))/2
            iminus=ii-1
            do 170 jj=1,iminus
               n=n+1
               ja=nfirst(jj)
               jb=nlast(jj)
               nj=nat(jj)
               jss=(ja*(ja+1))/2
               kk=kk+1
               g=w(kk)
               r=dsqrt((coord(1,ii)-coord(1,jj))**2+
     +                 (coord(2,ii)-coord(2,jj))**2+
     +                 (coord(3,ii)-coord(3,jj))**2)
               scale=1.0d0+dexp(-alp(ni)*r)+dexp(-alp(nj)*r)
               nt=ni+nj
               if(nt.lt.8.or.nt.gt.9) go to 110
               if(ni.eq.7.or.ni.eq.8) 
     +          scale=scale+(r-1.0d0)*dexp(-alp(ni)*r)
               if(nj.eq.7.or.nj.eq.8) 
     +          scale=scale+(r-1.0d0)*dexp(-alp(nj)*r)
  110          e(n,2)=core(ni)*core(nj)*g*scale
               if( am1 )then
                  scale=0.0d0
                  do 120 ig=1,10
                     if(dabs(fn1(ni,ig)).gt.0.d0)
     1scale=scale +core(ni)*core(nj)/r*
     2fn1(ni,ig)*dexp(-fn2(ni,ig)*(r-fn3(ni,ig))**2)
                     if(dabs(fn1(nj,ig)).gt.0.d0)
     1scale=scale +core(ni)*core(nj)/r*
     2fn1(nj,ig)*dexp(-fn2(nj,ig)*(r-fn3(nj,ig))**2)
  120             continue
                  e(n,2)=e(n,2)+scale
               endif
               e(n,3)=-(p(iss)*core(nj)+p(jss)*core(ni))*g
               if(nj.lt.3) go to 140
               kinc=9
               jap1=ja+1
               do 130 k=jap1,jb
                  kc=(k*(k-1))/2
                  do 130 l=ja,k
                     kl=kc+l
                     bb=2.0d0
                     if(k.eq.l) bb=1.0d0
                     kk=kk+1
  130          e(n,3)=e(n,3)-p(kl)*core(ni)*bb*w(kk)
               go to 150
  140          kinc=0
  150          if(ni.lt.3) go to 170
               iap1=ia+1
               do 160 i=iap1,ib
                  ka=(i*(i-1))/2
                  do 160 j=ia,i
                     ij=ka+j
                     aa=2.0d0
                     if(i.eq.j) aa=1.0d0
                     kk=kk+1
                     e(n,3)=e(n,3)-p(ij)*core(nj)*aa*w(kk)
  160          kk=kk+kinc
  170       continue
  180    n=n+1
c     coulomb (e(n,4)) and exchange (ex(n)) terms
         n=1
         kk=0
         do 200 ii=2,numat
            e(n,4)=0.0d0
            ex(n,1)=0.0d0
            ia=nfirst(ii)
            ib=nlast(ii)
            iminus=ii-1
            do 190 jj=1,iminus
               ja=nfirst(jj)
               jb=nlast(jj)
               n=n+1
               e(n,4)=0.0d0
               ex(n,1)=0.0d0
               do 190 i=ia,ib
                  ka=(i*(i-1))/2
                  do 190 j=ia,i
                     kb=(j*(j-1))/2
                     ij=ka+j
                     aa=2.0d0
                     if(i.eq.j) aa=1.0d0
                     pij=p(ij)
                     do 190 k=ja,jb
                        kc=(k*(k-1))/2
                        ik=ka+k
                        jk=kb+k
                        do 190 l=ja,k
                           il=ka+l
                           jl=kb+l
                           kl=kc+l
                           bb=2.0d0
                           if(k.eq.l) bb=1.0d0
                           kk=kk+1
                           g=w(kk)
                           e(n,4)=e(n,4)+aa*bb*g*pij*p(kl)
  190       ex(n,1) = ex(n,1)
     1    -0.5d0*aa*bb*g*(alpha(ik)*alpha(jl)+alpha(il)*alpha(jk)+
     2    beta(ik)*beta(jl)+beta(il)*beta(jk))
  200    n=n+1
      else
         n=1
         do 260 i=2,numat
            e(n,2)=0.0d0
            e(n,3)=0.0d0
            e(n,4)=0.0d0
            ex(n,1)=0.0d0
            ia=nfirst(i)
            ib=nlast(i)
            ni=nat(i)
            iminus=i-1
            do 250 j=1,iminus
               n=n+1
               ja=nfirst(j)
               jb=nlast(j)
               nj=nat(j)
               rij=(coord(1,i)-coord(1,j))**2+
     +             (coord(2,i)-coord(2,j))**2+
     +             (coord(3,i)-coord(3,j))**2
               gij=14.399d0/dsqrt(rij+
     +             (7.1995d0/f03(ni)+7.1995d0/f03(nj))**2)
               pab2=0.0d0
               ij=max(ni,nj)
               nbond=(ij*(ij-1))/2+ni+nj-ij
               rij=dsqrt(rij)
               if(nbond.eq.22 .or. nbond .eq. 29) go to 210
               go to 220
  210          scale=alp3(nbond)*dexp(-rij)
               go to 230
  220          scale=dexp(-alp3(nbond)*rij)
  230          continue
               e(n,2)=core(ni)*core(nj)*gij+
     1     dabs(core(ni)*core(nj)*(14.399d0/rij-gij)*scale)
               e(n,3)=(-q(i)*core(nj)-q(j)*core(ni))*gij
               e(n,4)=q(i)*q(j)*gij
               do 240 k=ia,ib
                  kk=(k*(k-1))/2
                  do 240 l=ja,jb
                     lk=kk+l
  240          pab2=pab2+alpha(lk)*alpha(lk)+beta(lk)*beta(lk)
  250       ex(n,1) = -pab2*gij
  260    n=n+1
      endif
      numat1=(numat*(numat+1))/2
      do 270 i=1,4
  270 e(numat1,i)=0.0d0
      do 280 i=1,3
  280 ex(numat1,i)=0.0d0
c@ --------------------------*
c-----print out one and two center energies
c
c     e(i,1):     resonance energy
c     e(i,2):     nuclear-nuclear repulsion energy
c     e(i,3):     electron-nuclear attraction energy
c     e(i,4):     electron-electron repulsion energy
c     ex(i,1):    exchange  energy
c     ex(i,2):    exchange + resonance energy
c#      write(mfgw,'(//,''       one and two center energies (ev) '')')
c
c#      write(mfgw,'(/,''  [resonance term] (ev)'')')
c#      call vecprt(e,numat)
c
c#      write(mfgw,'(/,''  [exchange term] (ev)'')')
c#      call vecprt(ex,numat)
c
c#      write(mfgw,'(/,''  [resonance + exchange] (ev)'')')
      do 290 n=1,numat1
  290 ex(n,2) =e(n,1) + ex(n,1)
c
c   add in monocentric exchange and coulombic term
c
      do 300 i=1,numat
  300 ex((i*(i+1))/2,2)=ea(i,2)
c#      call vecprt(ex(1,2),numat)
c
c#      write(mfgw,'(/,''  [electron - electron repulsion] (ev)'')')
c#      call vecprt(e(1,4),numat)
c
c#      write(mfgw,'(/,''  [electron-nuclear attraction] (ev)'')')
      do 310 i=1,numat
  310 e((i*(i+1))/2,3)=ea(i,1)
c#      call vecprt(e(1,3),numat)
c
c#      write(mfgw,'(/,''  [nuclear-nuclear repulsion] (ev)'')')
c#      call vecprt(e(1,2),numat)
c
      do 320 n=1,numat1
  320 ex(n,3) =e(n,4) + e(n,3) + e(n,2)
c     print out of total coulomb term
c#      write(mfgw,'(/,''  [total coulomb term (e-e, e-n, and n-n)] (ev)'')
c#      call vecprt(ex(1,3),numat)
c     print out of two-center sum(off-diagonal) +
c                  one-center sum(diagonal).
c#      write(mfgw,'(/,''  [two-center sum (off-diagonal), and  '',
c#     1''one-center sum (diagonal)] (ev)'')')
c#      do 340 n=1,numat1
c#  340 ex(n,3)=ex(n,3)+ex(n,2)
c#      call vecprt(ex(1,3),numat)
      write(mfgw,'(/,8(10x,a,/))')
     1'  one-center terms',' ',
     2'e-e:  electron-electron repulsion',
     3'e-n:  electron-nuclear attraction'
      write(mfgw,'(/,''   atom     e-e       e-n    (e-e + e-n)'')')
      do 330 i=1,numat
         j=(i*(i+1))/2
         write(mfgw,'(2x,a2,i3,1x,2f10.4,f10.4)')
     1elemnt(nat(i)),i, ex(j,2), e(j,3), ex(j,2)+e(j,3)
  330 continue
      write(mfgw,'(/,8(10x,a,/))')
     1'    two-center terms',' ',
     2'j:   resonance energy          e-e: electron-electron repulsion',
     3'k:   exchange energy           e-n: electron-nuclear attraction',
     4'                               n-n: nuclear-nuclear repulsion',
     5'c:   coulombic interaction = e-e + e-n + n-n',
     6'ee:  total of electronic and nuclear energies'
      write(mfgw,'(/,''   atom          j        k       e-'',
     1''e       e-n      n-n      c        ee'')')
      write(mfgw,'(''   pair'')')
      ij=0
      do 340 i=1,numat
         do 340 j=1,i
            ij=ij+1
            if(i.ne.j) then
               write(mfgw,'(1x,a2,i3,1x,a2,i3,1x,2f9.4,f9.4,f10.4,
     +         f9.4,f8.4,f9.4)')
     +         elemnt(nat(i)),i,elemnt(nat(j)),j, e(ij,1), ex(ij,1),
     2e(ij,4), e(ij,3), e(ij,2), ex(ij,3), ex(ij,2)+ex(ij,3)
            else
               if(i.lt.6.or.i.eq.numat)then
                  write(mfgw,*)
               else
                write(mfgw,'(/,''   atom          j        k       e-'',
     1''e       e-n      n-n      c        ee'')')
                  write(mfgw,'(''   pair'')')
               endif
            endif
  340 continue
c
c     ++++   totals   ++++
c
      eabr=0.0d0
      eabx=0.0d0
      eabee=0.0d0
      eaben=0.0d0
      eabnn=0.0d0
      do 350 i=1,numat
  350 e((i*(i+1))/2,3)=0.0d0
      do 360 i=1,numat1
         eabr=eabr+e(i,1)
         eabx=eabx+ex(i,1)
         eabee=eabee+e(i,4)
         eaben=eaben+e(i,3)
         eabnn=eabnn+e(i,2)
  360 continue
      eabrx=eabr+eabx
      eabe=eabee+eaben+eabnn
      ttwo=eabrx+eabe
      et=tone+ttwo
c@ ***************************************************************
      write(mfgw,370)
  370 format(///,'***  summary of energy partition  ***')
      write(mfgw,380)
  380 format(1h ,'---------------------------------------')
      write(mfgw,'(''     one-center terms'')')
      write(mfgw,390) eau
  390 format(/,' electron-nuclear  (one-electron) ',f17.4,' ev')
      write(mfgw,400) eae
  400 format(' electron-electron (two-electron) ',f17.4,' ev')
      write(mfgw,410) tone
  410 format(/,' total of one-center terms        ',18x,f15.4,' ev')
      write(mfgw,380)
      write(mfgw,'(''     two-center terms'')')
      write(mfgw,420) eabr
  420 format(/,' resonance energy',8x,f15.4,' ev')
      write(mfgw,430) eabx
  430 format(' exchange energy ',8x,f15.4,' ev')
      write(mfgw,440) eabrx
  440 format(/,' exchange + resonance energy:       ',f15.4,' ev')
      write(mfgw,450) eabee
  450 format(/,' electron-electron repulsion',f12.4,' ev')
      write(mfgw,460) eaben
  460 format(  ' electron-nuclear attraction',f12.4,' ev')
      write(mfgw,470) eabnn
  470 format(  ' nuclear-nuclear repulsion  ',f12.4,' ev')
      write(mfgw,480) eabe
  480 format(/,' total electrostatic interaction    ',f15.4,' ev',/)
      write(mfgw,490) ttwo
  490 format(' grand total of two-center terms   ',17x,f15.4,' ev')
      write(mfgw,380)
      write(mfgw,500) et
  500 format(' etot (eone + etwo)   ',30x,f15.4,' ev'//)
      return
      end
      subroutine epseta(eps,eta)
      implicit REAL (a-h,o-z)
c
c     compute and return eta, the smallest representable number,
c     and eps is the smallest number for which 1+eps.ne.1.
c
c
      eta = 1.d0
   10 if((eta/2.d0).eq.0.d0) goto 20
      if(eta.lt.1.d-38) goto 20
      eta = eta / 2.d0
      goto 10
   20 eps = 1.d0
   30 if((1.d0+(eps/2.d0)).eq.1.d0) goto 40
      if(eps.lt.1.d-17) goto 40
      eps = eps / 2.d0
      goto 30
   40 return
      end
      subroutine esp
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
c***********************************************************************
c
c     this is a driver routine for electrostatic potential generation
c     written by k.m.merz feb. 1989 at ucsf
c
c***********************************************************************
      common/iofile/mfgr,mfgw
      common /keywrd/ keywrd
      character*241 keywrd
c
c     set standard parameters for the surface generation
c
      if(index(keywrd,'scale=') .ne. 0)then
         scale = reada(keywrd,index(keywrd,'scale='))
      else
         scale = 1.4d0
      endif
c
      if(index(keywrd,'den=') .ne. 0)then
         den = reada(keywrd,index(keywrd,'den='))
      else
         den = 1.0d0
      endif
c
      if(index(keywrd,'scincr=') .ne. 0)then
         scincr = reada(keywrd,index(keywrd,'scincr='))
      else
         scincr = 0.20d0
      endif
c
      if(index(keywrd,'nsurf=') .ne. 0)then
         n = reada(keywrd,index(keywrd,'nsurf='))
      else
         n = 4
      endif
c
      time1=secmop()
c
c     now calculate the surface points
c
      if(index(keywrd,'williams') .ne. 0) then
         call pdgrid
      else
         do 10 i = 1,n
            call surfac(scale,den,i)
            scale = scale + scincr
   10    continue
      endif
c
c     next calculate the esp at the points calculated by surfac
c
      call potcal
c
c     end of calculation
c
      time1=secmop()-time1
      write(mfgw,20) 'time to calculate esp:',time1,' seconds'
   20 format(/9x,a,f8.2,a)
      return
      end
      block data espblo
      implicit REAL (a-h, o-z)
INCLUDE(common/sizes)
      common /espc/  cc(maxpr),cen(maxpr,3),iam(maxpr,2),ind(maxpr),
     1                ex(maxpr),espi(maxorb,maxorb),
     2                fv(0:8,821),fac(0:7),
     3                dex(-1:96),tf(0:2),temp(maxpr),itemp(maxpr),
     4                ovl(maxorb,maxorb),fc(maxpr*6)
      data tf/33.d0,37.d0,41.d0/
      data fac/1.d0,1.d0,2.d0,6.d0,24.d0,120.d0,720.d0,5040.d0/
      end
c***********************************************************************
      subroutine espfit(idip,natom,nesp,iz,esp,potpt,co,
     1dx,dy,dz,rms,rrms)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
c***********************************************************************
c
c     this routine fits the electrostatic potential to a monopole
c     expansion. fitting to the dipole monent can also be done.
c     this routine was written by b.h.besler and k.m.merz
c     in feb. 1989 at ucsf.
c
c     on input:  idip = flag to indicate if the dipole is fit
c                natom = number of atoms
c                nesp = number of esp points
c                iz = molecular charge
c                esp = total esp at the points
c                potpt = esp points
c                co = coordinates
c                dx = x component of the dipole
c                dy = y component of the dipole
c                dz = z component of the dipole
c
c     on output: q = esp charges
c                rms = root mean square fit
c                rrms = relative root mean square fit
c
c     for more details see: besler,merz,kollman j. comput. chem.
c     (in press)
c***********************************************************************
      common/espf/ al((numatm+4)**2),a(numatm,numatm),b(numatm),
     1q(numatm+4),qsc(numatm+4),cf, espfd(maxorb**2-numatm-5)
      dimension co(3,*),esp(*),potpt(3,*)
      bohr = 0.529167d00
c     conversion factor for debye to atomic units
      cf=5.2917715d-11*1.601917d-19/3.33564d-30
c
c     the following sets up the linear equation a*q=b
c     set up the a(j,k) array
c
      do 20  k=1,natom
         do 10  j=1,natom
            do 10  i=1,nesp
               rik=dsqrt((co(1,k)-potpt(1,i))**2+
     +                   (co(2,k)-potpt(2,i))**2+
     +                   (co(3,k)-potpt(3,i))**2)/bohr
               rij=dsqrt((co(1,j)-potpt(1,i))**2+
     +                   (co(2,j)-potpt(2,i))**2+
     +                   (co(3,j)-potpt(3,i))**2)/bohr
               a(j,k)=a(j,k)+1.d0/rik*1.d0/rij
   10    continue
         a(natom+1,k)=1.d0
         a(k,natom+1)=1.d0
         a(natom+1,natom+1)=0.0d0
         if(idip .eq. 1) then
            a(natom+2,k)=co(1,k)/bohr
            a(k,natom+2)=co(1,k)/bohr
            a(natom+2,natom+2)=0.0d0
            a(natom+3,k)=co(2,k)/bohr
            a(k,natom+3)=co(2,k)/bohr
            a(natom+3,natom+3)=0.0d0
            a(natom+4,k)=co(3,k)/bohr
            a(k,natom+4)=co(3,k)/bohr
            a(natom+4,natom+4)=0.0d0
         endif
   20 continue
      b(natom+1)=dfloat(iz)
      b(natom+2)=dx/cf
      b(natom+3)=dy/cf
      b(natom+4)=dz/cf
c
c     insert charge and dipolar (if desired) constraints
c
      if(idip .eq. 1) then
         l=0
         do 30 i=1,natom+4
            do 30 j=1,natom+4
               l=l+1
   30    al(l)=a(i,j)
      else
         l=0
         do 40 i=1,natom+1
            do 40 j=1,natom+1
               l=l+1
   40    al(l)=a(i,j)
      endif
      if (idip .eq. 1) then
         call osinv(al,natom+4,det)
      else
         call osinv(al,natom+1,det)
      endif
      if(idip .eq. 1) then
         l=0
         do 50 i=1,natom+4
            do 50 j=1,natom+4
               l=l+1
   50    a(i,j)=al(l)
      else
         l=0
         do 60 i=1,natom+1
            do 60 j=1,natom+1
               l=l+1
   60    a(i,j)=al(l)
      endif
c
c     solve for the charges
c
      if(idip .eq. 1) then
         do 70 i=1,natom+4
            do 70 j=1,natom+4
               q(i)=q(i)+a(i,j)*b(j)
   70    continue
      else
         do 80 i=1,natom+1
            do 80 j=1,natom+1
               q(i)=q(i)+a(i,j)*b(j)
   80    continue
      endif
c
c     calculate root mean square fits and relative root mean square fits
c
      ctot=0.0d0
      do 100 i=1,nesp
         espc=0.0d0
         do 90 j=1,natom
            rij=dsqrt((co(1,j)-potpt(1,i))**2+
     +                (co(2,j)-potpt(2,i))**2+
     +                (co(3,j)-potpt(3,i))**2)/bohr
   90    espc=espc+q(j)/rij
         rms=rms+(espc-esp(i))**2
  100 rrms=rrms+esp(i)**2
      rms=dsqrt(rms/nesp)
      rrms=rms/dsqrt(rrms/nesp)
      rms=rms*627.51d0
      return
      end
      subroutine ffhpol (heat0,atpol)
      implicit REAL (a-h,o-z)
      character*1 axis(3)
      logical debug
INCLUDE(common/sizes)
c***********************************************************************
c  routine for the finite field calculation of electric response
c  properties (dipole moment, polarizability, and 1st and 2nd
c  hyperpolarizability.
c
c  henry a. kurtz, department of chemistry
c                  memphis state university
c                  memphis, tn   38152
c
c***********************************************************************
      common /corec/ core(107)
      common /cmpg/ geo(3,numatm)
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),
     1                nlast(numatm),nors,nelecs,nalpha,nbeta,
     2                nclose,nopen,ndumy,fract
      common /coord/ coord(3,numatm)
      common/iofile/mfgr,mfgw
      common /keywrd/ keywrd
      common /cmpfd/ efield(3)
      common /euler/ tvec(3,3),idtvec
      character*241 keywrd
c
c
c     dipe4 and dipdp hold the calculated dipole moments
c
c     apole4 and apoldp hold the polarizability tensor as
c                                a packed array xx,xy,yy,xz,yz,zz
c
c     betae4 and betaep hold the first hyperpolarizability
c                                1. xxx
c                                2. yyy     6. yxx
c                                3. zzz     7. yzz
c                                4. xyy     8. zxx
c                                5. xzz     9. zyy
c
      dimension heate(3,2),
     1          dipe4(3),apole4(6),betae4(9),gamme4(6),
     2          dipdp(3),apoldp(6),betadp(9),gammdp(6),
     3          dip1p(3),dip1m(3),dip2p(3),dip2m(3)
      dimension iptbd(6)
      data iptbd /5,7,4,9,6,8/
c energy: a.u. to kcal/mole
      autokc = 23.061d+00*27.2107d+00
c dipole: a.u. to debye
      autodb = 2.541563d+00
c electric field: a.u. to volt/meter
      autovm = 51.4257d+00
      nbdip = 1
      nbcnt = 4
      ngcnt = 4
c
      data axis/'x','y','z'/
      debug = (index(keywrd,'debug').ne.0)
c
c  field strength in a.u.
c
      efval=0.001d0
      idip=1
c modification for variable field strength
      if(index(keywrd,'polar=').ne.0)
     1efval=reada(keywrd,index(keywrd,'polar='))
      write (mfgw,10) efval
   10 format (//' applied electric field magnitude: ',f15.5)
      sfe = 1.d00/efval
      write (mfgw,20) 6.74834d0*atpol
   20 format (//' atomic contribution to the polarizability: ',f15.6,/,
     1          '  (it is only applied to the e4 result)')
c.......................................................................
c  calculate the polarizability and hyperpolarizabilities along
c  the three principle axes.  (these axes depend on your arbitrary
c  orientation and may not be the true principle axes.)
c.......................................................................
      do 150 id = 1,3
         if (debug) then
            write (mfgw,30) axis(id)
   30       format (//,' ****** field in ',a1,' direction *****',/)
         endif
c
c zero the field
c
         do 40 i = 1,3
            efield(i) = 0.0d00
   40    continue
         hnuc = 0.0d00
         do 50 i = 1,numat
            hnuc = hnuc + efval*geo(id,i)*core(nat(i))*autovm
   50    continue
         hnuc = hnuc*23.061d00
c +e(id)
         efield(id) = efval
         call compfg(geo,.true.,heat1p,.true.,grad,.false.)
         call dipind (dip1p)
         diip = dip1p(id)
c -e(id)
         efield(id) = -efval
         call compfg(geo,.true.,heat1m,.true.,grad,.false.)
         call dipind (dip1m)
         diim = dip1m(id)
c +2e(id)
         efield(id) = 2.0d00*efval
         call compfg(geo,.true.,heat2p,.true.,grad,.false.)
         call dipind (dip2p)
c -2e(id)
         efield(id) = -2.0d00*efval
         call compfg(geo,.true.,heat2m,.true.,grad,.false.)
         call dipind (dip2m)
c
c  correct for electric field - nuclear interactions
c
         heat1p = heat1p + hnuc
         heate(id,1) = heat1p
         heat1m = heat1m - hnuc
         heate(id,2) = heat1m
         heat2p = heat2p + hnuc*2.d00
         heat2m = heat2m - hnuc*2.d00
c
         if (debug) then
            write (mfgw,60)
   60       format (' fields of: ',5x,'f',21x,'2f')
            write (mfgw,70) heat1p,heat2p,heat1m,heat2m,
     1                dip1p(id),dip2p(id),dip1m(id),dip2m(id)
   70       format ('  energy:'/,
     1           '   + ',2(f20.10,3x),/,'   - ',2(f20.10,3x),/,
     2           '  dipole:'/,
     3           '   + ',2(f20.10,3x),/,'   - ',2(f20.10,3x))
         endif
c
c dipole
c
         eterm = (1.0d00/12.d00)*(heat2p - heat2m)
     1        - (2.0d00/3.0d00)*(heat1p - heat1m)
         dipe4(id) = eterm*sfe/autokc
c
c alpha
c
         ivl = (id*(id+1))/2
         eterm = 2.5d00*heat0 - (4.d00/3.d00)*(heat1p + heat1m)
     1        + (1.d00/12.0d00)*(heat2p + heat2m)
         apole4(ivl) = eterm*sfe*sfe/autokc + atpol*6.74834d0
c
c beta
c
         eterm = (heat1p - heat1m) - 0.5d00*(heat2p - heat2m)
         betae4(id) = eterm*sfe*sfe*sfe/autokc
c
c gamma
c
         eterm = 4.0d00*(heat1p + heat1m) - (heat2p + heat2m)
     1        - 6.0d00*heat0
         gamme4(id) = eterm*sfe*sfe*sfe*sfe/autokc
c
c dipole calculations
c
         dmu = (2.0d00/3.0d00)*(dip1p(id) + dip1m(id))
     1      - (1.d00/6.0d00)*(dip2p(id) + dip2m(id))
         dipdp(id) = dmu/autodb
         ae = (2.0d00/3.0d00)*(dip1p(id) - dip1m(id))
     1     - (1.0d00/12.d00)*(dip2p(id) - dip2m(id))
         apoldp(ivl) = ae*sfe/autodb
         be = (1.d00/3.0d00)*(dip2p(id) + dip2m(id)
     1                     - dip1p(id) - dip1m(id))
         betadp(id) = be*sfe*sfe/autodb
         ge = 0.5d00*(dip2p(id) - dip2m(id))
     1     - (dip1p(id) - dip1m(id))
         gammdp(id) = ge*sfe*sfe*sfe/autodb
         do 80 kd = 1,3
            if (kd.lt.id) then
               kvl = (id*(id-1))/2 + kd
               aki = (2.0d00/3.0d00)*(dip1p(kd) - dip1m(kd))
     1         - (1.0d00/12.0d00)*(dip2p(kd) - dip2m(kd))
               apoldp(kvl) = aki*sfe/autodb
            endif
            if (kd.ne.id) then
               bkii = (1.0d00/3.0d00)*(dip2p(kd) + dip2m(kd)
     1                           - dip1p(kd) - dip1m(kd))
               nbd = iptbd(nbdip)
               betadp(nbd) = bkii*sfe*sfe/autodb
               nbdip = nbdip + 1
            endif
   80    continue
c.......................................................................
c
c  now calculate the off axis results.
c
c.......................................................................
         idm1 = id - 1
         do 140 jd = 1,idm1
            hnucj = 0.0d00
            do 90 i = 1,numat
               hnucj = hnucj + efval*geo(jd,i)*core(nat(i))*
     +                         51.4257d0
   90       continue
            hnucj = hnucj*23.061d0
            do 100 i = 1,3
               efield(i) = 0.0d00
  100       continue
c
c diagonal fields with components equal to efval
c
            efield(id) = efval
            efield(jd) = efval
            call compfg(geo,.true.,hpp,.true.,grad,.false.)
            call dipind (dip1p)
            dpp = dip1p(id)
            efield(jd) = -efval
            call compfg(geo,.true.,hpm,.true.,grad,.false.)
            call dipind (dip1p)
            dpm = dip1p(id)
            efield(id) = -efval
            call compfg(geo,.true.,hmm,.true.,grad,.false.)
            call dipind (dip1p)
            dmm = dip1p(id)
            efield(jd) = efval
            call compfg(geo,.true.,hmp,.true.,grad,.false.)
            call dipind (dip1p)
            dmp = dip1p(id)
            hpp = hpp + hnuc + hnucj
            hpm = hpm + hnuc - hnucj
            hmm = hmm - hnuc - hnucj
            hmp = hmp - hnuc + hnucj
            if (debug) then
               write (mfgw,110)
  110          format (/,' ',12x,'+,+',15x,'+,-',15x,'-,+',15x,'-,-')
               write (mfgw,120) hpp,hpm,hmp,hmm
  120          format ('  e ',4f15.6)
            endif
c
c  diagonal fields with components equal to 2*efval
c
            efield(id) = efval*2.d00
            efield(jd) = efval*2.d00
            call compfg(geo,.true.,h2pp,.true.,grad,.false.)
            efield(jd) = -efval*2.d00
            call compfg(geo,.true.,h2pm,.true.,grad,.false.)
            efield(id) = -efval*2.d00
            call compfg(geo,.true.,h2mm,.true.,grad,.false.)
            efield(jd) = efval*2.d00
            call compfg(geo,.true.,h2mp,.true.,grad,.false.)
            h2pp = h2pp + 2.0d00*(hnuc + hnucj)
            h2pm = h2pm + 2.0d00*(hnuc - hnucj)
            h2mm = h2mm - 2.0d00*(hnuc + hnucj)
            h2mp = h2mp - 2.0d00*(hnuc - hnucj)
            if (debug) then
               write (mfgw,130) h2pp,h2pm,h2mp,h2mm
  130          format (' 2e ',4f15.6)
            endif
c
            aterm = (1.0d00/48.0d00)*(h2pp - h2pm - h2mp + h2mm)
     1          - (1.0d00/3.0d00)*(hpp - hpm - hmp + hmm)
            aij = aterm*sfe*sfe/autokc
            ivl = (id*(id-1))/2 + jd
            apole4(ivl) = aij
            bterm = 0.5d00*(hmm - hpp + hpm - hmp)
     1          + heate(jd,1) - heate(jd,2)
            bjii = bterm*sfe*sfe*sfe/autokc
            betae4(nbcnt) = bjii
            nbcnt = nbcnt + 1
            bterm = 0.5d00*(hmm - hpp + hmp - hpm)
     1          + heate(id,1) - heate(id,2)
            bijj = bterm*sfe*sfe*sfe/autokc
            betae4(nbcnt) = bijj
            nbcnt = nbcnt + 1
c
            gterm = -(hpp + hmm + hpm + hmp) - 4.0d00*heat0
     1           + 2.0d00*(heate(id,1) + heate(id,2))
     2           + 2.0d00*(heate(jd,1) + heate(jd,2))
            giijj = gterm*sfe*sfe*sfe*sfe/autokc
            gamme4(ngcnt) = giijj
            gdip = 0.5d00*(dpp - dmp + dpm - dmm) - (diip - diim)
            gammdp(ngcnt) = gdip*sfe*sfe*sfe/autodb
            ngcnt = ngcnt + 1
  140    continue
c
  150 continue
c-----------------------------------------------------------------------
c  summarize the results
c-----------------------------------------------------------------------
      write (mfgw,160)
  160 format (//,' ',30('*'),' dipole ',30('*'),//)
      dipe4t = dsqrt(dipe4(1)*dipe4(1) + dipe4(2)*dipe4(2)
     1              + dipe4(3)*dipe4(3))
      dipe4d = dipe4t*autodb
      dipdpt = dsqrt(dipdp(1)*dipdp(1) + dipdp(2)*dipdp(2)
     1              + dipdp(3)*dipdp(3))
      dipdpd = dipdpt*autodb
      write (mfgw,170)
  170 format (21x,'e4',13x,'dip',/)
      write (mfgw,180) 'x',dipe4(1),dipdp(1)
      write (mfgw,180) 'y',dipe4(2),dipdp(2)
      write (mfgw,180) 'z',dipe4(3),dipdp(3)
  180 format (5x,a1,7x,2f15.6)
      write (mfgw,190) dipe4t,dipdpt,
     1               dipe4d,dipdpd
  190 format (//' magnitude:  ',2f15.6,'  (a.u.)',/,
     1          ' ',12x,2f15.6,'  (debye)')
c
c find eigenvalues and eigenvectors of polarization matrix.
c
      write (mfgw,200)
  200 format (//,' ',22('*'),' polarizability (alpha)',21('*'),//)
      avgpe4 = (apole4(1)+apole4(3)+apole4(6))/3.0d00
      avga3 = avgpe4*0.14818d00
      avgesu = avgpe4*0.296352d-24
      avgpdp = (apoldp(1)+apoldp(3)+apoldp(6))/3.0d00
      avga3d = avgpdp*0.14818d00
      avgesd = avgpdp*0.296352d-24
      write (mfgw,210)
  210 format ('  component',12x,'e4',13x,'dip',/)
      write (mfgw,220) 'xx',apole4(1),apoldp(1),
     1              'yy',apole4(3),apoldp(3),
     2              'zz',apole4(6),apoldp(6),
     3              'xy',apole4(2),apoldp(2),
     4              'xz',apole4(4),apoldp(4),
     5              'yz',apole4(5),apoldp(5)
  220 format (' ',5x,a4,5x,2f15.6)
      write (mfgw,230) avgpe4,avgpdp,avga3,avga3d,avgesu,avgesd
  230 format (//,' average polarizability:',8x,'e4',13x,'dip',/,
     1           ' ',24x,2f15.6,'  a.u.',/,
     2           ' ',24x,2f15.6,'  ang.**3',/,
     3           ' ',24x,2(1pd15.6),'  esu')
c
c  calculate "experimental" hyperpolarizabilities
c
c   8.65710d-33 is a.u. to e.s.u. conversion
      write (mfgw,240)
  240 format (//,' ',30('*'),' second-order (beta)',25('*'),//)
      bx4 = 0.6d00*(betae4(1) + betae4(4) + betae4(6))
      by4 = 0.6d00*(betae4(2) + betae4(5) + betae4(8))
      bz4 = 0.6d00*(betae4(3) + betae4(7) + betae4(9))
      b4mu = (bx4*dipe4(1) + by4*dipe4(2) + bz4*dipe4(3))/dipe4t
      b4esu = b4mu*8.65710d-03
      bxd = 0.6d00*(betadp(1) + betadp(4) + betadp(6))
      byd = 0.6d00*(betadp(2) + betadp(5) + betadp(8))
      bzd = 0.6d00*(betadp(3) + betadp(7) + betadp(9))
      bdmu = (bxd*dipdp(1) + byd*dipdp(2) + bzd*dipdp(3))/dipdpt
      bdesu = bdmu*8.65710d-03
c
      write(mfgw,'(29x,a2,25x,a6)')'1x','(1/2)x'
      write (mfgw,250)
  250 format ('  component',2(12x,'e4',10x,'dip',2x),/)
      write (mfgw,260) 
     +   'xxx',betae4(1),betadp(1),betae4(1)/2,betadp(1)/2
      write (mfgw,260)
     +   'xyy',betae4(4),betadp(4),betae4(4)/2,betadp(4)/2
      write (mfgw,260)
     +   'xzz',betae4(6),betadp(6),betae4(6)/2,betadp(6)/2
      write (mfgw,260)
     +   'yyy',betae4(2),betadp(2),betae4(2)/2,betadp(2)/2
      write (mfgw,260)
     +   'yxx',betae4(5),betadp(5),betae4(5)/2,betadp(5)/2
      write (mfgw,260)
     +   'yzz',betae4(8),betadp(8),betae4(8)/2,betadp(8)/2
      write (mfgw,260)
     +   'zzz',betae4(3),betadp(3),betae4(3)/2,betadp(3)/2
      write (mfgw,260)
     +   'zxx',betae4(7),betadp(7),betae4(7)/2,betadp(7)/2
      write (mfgw,260)
     +   'zyy',betae4(9),betadp(9),betae4(9)/2,betadp(9)/2
  260 format (' ',5x,a4,2(5x,2f12.3))
      write (mfgw,270)
  270 format (//,' vector components given by:',/,
     1          '      bi = (2/5)*(bi11+bi22+bi33)'/)
      write (mfgw,280) 'bx',bx4,bxd,bx4/2,bxd/2
      write (mfgw,280) 'by',by4,byd,by4/2,byd/2
      write (mfgw,280) 'bz',bz4,bzd,bz4/2,bzd/2
  280 format (' ',6x,a2,2(6x,2f12.3))
      write (mfgw,290)
  290 format (//'  value of beta along the dipole moment:'/)
      write (mfgw,300) 
     +  b4mu,bdmu,b4mu/2,bdmu/2,b4esu,bdesu,b4esu/2,bdesu/2
  300 format (' ',4x,'b(au)',2(5x,2f12.3,2x),/,
     1        ' ',4x,'b(esu)',4x,2f12.3,7x,2f12.3,' (x10-30)')
c
      write (mfgw,310)
  310 format (//' ',24('*'),' third-order (gamma)',24('*'),//)
      gamval = (gamme4(1) + gamme4(2) + gamme4(3))
      gamval = gamval + 2.0d00*(gamme4(4) + gamme4(5) + gamme4(6))
      gamval = gamval/5.0d00
c  5.05116d-40 is the a.u. to e.s.u. conversion
      gamesu = gamval*5.05116d-04
      gamdip = (gammdp(1) + gammdp(2) + gammdp(3))
      gamdip = gamdip + 2.0d00*(gammdp(4) + gammdp(5) + gammdp(6))
      gamdip = gamdip/5.0d00
      gamdes = gamdip*5.05116d-04
      write(mfgw,'(23x,a2,25x,a6)')'1x','(1/6)x'
      write (mfgw,320)
  320 format (' ',17x,'e4',8x,'dip',16x,'e4',8x,'dip',/)
      write (mfgw,330)
     +  'xxxx',gamme4(1),gammdp(1),gamme4(1)/6,gammdp(1)/6
      write (mfgw,330)
     +  'yyyy',gamme4(2),gammdp(2),gamme4(2)/6,gammdp(2)/6
      write (mfgw,330)
     +  'zzzz',gamme4(3),gammdp(3),gamme4(3)/6,gammdp(3)/6
      write (mfgw,330)
     +  'xxyy',gamme4(4),gammdp(4),gamme4(4)/6,gammdp(4)/6
      write (mfgw,330)
     +  'xxzz',gamme4(5),gammdp(5),gamme4(5)/6,gammdp(5)/6
      write (mfgw,330)
     +  'yyzz',gamme4(6),gammdp(6),gamme4(6)/6,gammdp(6)/6
  330 format (5x,a4,2f12.3,5x,2f12.3)
      write (mfgw,340)
  340 format (//' average gamma given by:',/,
     1 '    (1/5)*[gxxx + gyyy + gzzz + 2.0*(gxxyy + gxxzz + gyyzz)]')
      write(mfgw,'(/,20x,a2,22x,a6)')'1x','(1/6)x'
      write (mfgw,350) gamval,gamdip,gamval/6,gamdip/6,
     1              gamesu,gamdes,gamesu/6,gamdes/6
  350 format (/' <gamma> ',1pd12.5,1pd12.5,5x,1pd12.5,1pd12.5,'  a.u.'/,
     1       ' ',8x,1pd12.5,1pd12.5,5x,1pd12.5,1pd12.5,'  esu (x10-36)')
c
      return
      end
      subroutine flepo (xparam,nvar,funct1)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      dimension xparam(*)
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),
     1                nlast(numatm), norbs, nelecs,nalpha,nbeta,
     2                nclose,nopen,ndumy,fract
      common /keywrd/ keywrd
      common /numscf/ nscf
      common /last/ last
      common /gravec/ cosine
      common /path/ latom,lparam,react(200)
      common /gradnt/ grad(maxpar),gnorm
      common /mesage/ iflepo,iscf
      common /timem/ time0
      common /fmatrx/ hesinv(maxpar**2+maxpar*3+1), idumy(4)
      common /scftyp/ emin, limscf
      common /timdmp/ tleft, tdump
      common /numcal/ numcal
c     patas
      common /xxxxxx/ icompf
c     patas
      common/iofile/mfgr,mfgw
      character*241 keywrd
c
c
c     *
c     this routine attempts to minimize a real-valued function of
c     the n-component real vector xparam according to the
c     bfgs formula. relevant references are
c
c     broyden, c.g., journal of the institute for mathematics and
c                     applications, vol. 6 pp 222-231, 1970.
c     fletcher, r., computer journal, vol. 13, pp 317-322, 1970.
c
c     goldfarb, d. mathematics of computation, vol. 24, pp 23-26, 1970.
c
c     shanno, d.f. mathematics of computation, vol. 24, pp 647-656
c                    1970.
c
c   see also summary in
c
c    head, j.d.; and zerner, m.c., chemical physics letters, vol. 122,
c          264 (1985).
c    shanno, d.f., j. of optimization theory and applications
c          vol.46, no 1 pp 87-94 1985.
c     *
c     the function can also be minimized using the
c     davidon-fletcher-powell algorithm (computer journal, vol. 6,
c     p. 163).
c
c     the user must supply the subroutine
c     compfg(xparam,.true.,funct,.true.,grad,lgrad)
c     which computes function values  funct at given values for the
c     variables xparam, and the gradient grad if lgrad=.true.
c     the minimization proceeds by a sequence of one-dimensional
c     minimizations.  these are carried out without gradient computation
c     by the subroutine linmin, which solves the subproblem of
c     minimizing the function funct along the line xparam+alpha*pvect,
c     where xparam
c     is the vector of current variable values,  alpha is a scalar
c     variable, and  pvect  is a search-direction vector provided by the
c     bfgs or davidon-fletcher-powell algorithm.  each iteration step ca
c     out by flepo proceeds by letting linmin find a value for alpha
c     which minimizes  funct  along  xparam+alpha*pvect, by
c     updating the vector  xparam  by the amount alpha*pvect, and
c     finally by generating a new vector  pvect.  under
c     certain restrictions (powell, j.inst.maths.applics.(1971),
c     v.7,21-36)  a sequence of funct values converging to some
c     local minimum value and a sequence of
c     xparam vectors converging to the corresponding minimum point
c     are produced.
c                          convergence tests.
c
c     herberts test: the estimated distance from the current point
c                    point to the minimum is less than tolera.
c
c                    "herberts test satisfied - geometry optimized"
c
c     gradient test: the gradient norm has become less than tolerg
c                    times the square root of the number of variables.
c
c                    "test on gradient satisfied".
c
c     xparam test:  the relative change in xparam, measured by its norm,
c                   over any two successive iteration steps drops below
c                   tolerx.
c
c                    "test on xparam satisfied".
c
c     function test: the calculated value of the heat of formation
c                    between any two cycles is within tolerf of
c                    each other.
c
c                    "heat of formation test satisfied"
c
c     for the gradient, function, and xparam tests a further condition,
c     that no individual component of the gradient is greater
c     than tolerg, must be satisfied, in which case the
c     calculation exits with the message
c
c                     "peters test satisfied"
c
c     will be printed, and funct and xparam will contain the last
c     function value cum variable values reached.
c
c
c     the broyden-fletcher-goldfarb-shanno and davidon-fletcher-powell
c     algorithms choose search directions
c     on the basis of local properties of the function.  a matrix  h,
c     which in flepo is preset with the identity, is maintained and
c     updated at each iteration step.  the matrix describes a local
c     metric on the surface of function values above the point xparam.
c     the search-direction vector  pvect  is simply a transformation
c     of the gradient  grad  by the matrix h.
c
      dimension xvar(maxpar), gvar(maxpar), xd(maxpar), gd(maxpar),
     1glast(maxpar), xlast(maxpar), gg(maxpar), pvect(maxpar)
      dimension mdfp(9),xdfp(9), xtemp(maxpar), gtemp(maxpar)
      save
*******
*     save  icalcn
*     save  rst, tdel, sfact, dell, einc, igg1, del
*     save  restrt, geook, dfp, const
*     save  saddle, minprt, rootv, print, delhof, tolerf, tolerg
*     save  tolerx, drop, frepf, ihdim, cncadd, absmin, itry1
*     save  okf, jcyc, lnstop, irepet, alpha, pnorm, jnrst, cycmx
*     save  cos, ncount, resfil, mdfp, tx1, tx2, tlast
*     save  totime
*******
      logical okf, print,  restrt, minprt, saddle, geook, log
     1        ,resfil, lgrad, dfp, ldiis, thiel, diisok, frst,
     2         limscf
      equivalence (mdfp(1),jcyc  ),(mdfp(2),jnrst),(mdfp(3),ncount),
     1            (mdfp(4),lnstop),(xdfp(1),alpha),(xdfp(2),cos   ),
     2            (xdfp(3),pnorm ),(xdfp(4),drop ),(xdfp(5),del   ),
     3            (xdfp(6),frepf ),(xdfp(7),cycmx),(xdfp(8),totime)
      data icalcn /0/
c
c   start of once-only section
c
      emin=0.0d0
      if (icalcn.ne.numcal) then
c
c   the following constants should be set by the user.
c
         rst   = 0.05d0
         iprt  = mfgw
         tdel  = 0.06d0
         nrst  = 30
         sfact = 1.5d0
         dell  = 0.01d0
         einc  = 0.3d0
         igg1  = 3
         del=dell
c
c    these constants should be set by the program.
c
         restrt = index(keywrd,'restar').ne.0
         thiel  = index(keywrd,'nothie').eq.0
         geook  = index(keywrd,'geo-ok').ne.0
         log    = index(keywrd,'nolog').eq.0
         ldiis  = index(keywrd,'nodiis').eq.0
         saddle = index(keywrd,'saddle').ne.0
         minprt = .not.saddle
         const=1.d0
c
c      the davidon-fletcher-powell method is not recommended
c      but can be invoked by using the keyword 'dfp'
c
         dfp=index(keywrd,'dfp').ne.0
c
c  order of precision:   'gnorm' takes precedence over 'force', which
c                        takes precedence over 'precise'.
         tolerg=1.0d0
         if(index(keywrd,'prec') .ne. 0) tolerg=0.2d0
         if (index(keywrd,'force') .ne. 0) tolerg = 0.1d0
c
c      read in the gradient-norm limit, if specified
c
         if(index(keywrd,'gnorm=').ne.0) then
            rootv=1.d0
            const=1.d-20
            tolerg=reada(keywrd,index(keywrd,'gnorm='))
            if(index(keywrd,' let').eq.0.and.tolerg.lt.1.d-2)then
            write(mfgw,'(/,a)')'  gnorm has been set too low, reset to 0
     1.01'
               tolerg=1.d-2
            endif
         else
            rootv=dsqrt(nvar+1.d-5)
         endif
         tolerx = 0.0001d0*const
         delhof = 0.0010d0*const
         tolerf = 0.002d0*const
         tolrg  = tolerg
c
c  minor book-keeping
c
         tlast=tleft
         tx2=secmop()
         tleft=tleft-tx2+time0
         print  = (index(keywrd,'flepo').ne.0)
c
c   the following constants should be set to some arbitary large value.
c
         drop  = 1.d15
         frepf = 1.d15
c
c     and finally, the following constants are calculated.
c
         ihdim=(nvar*(nvar+1))/2
         cncadd=1.0d00/rootv
         if (cncadd.gt.0.15d00) cncadd=0.15d00
         icalcn=numcal
         if (restrt) then
            jnrst=1
            mdfp(9)=0
            call dfpsav(totime,xparam,gd,xlast,funct1,mdfp,xdfp)
            i=totime/1000000.d0
            totime=totime-i*1000000.d0
            time0=time0-totime
            nscf=mdfp(5)
            write(iprt,'(//10x,''total time used so far:'',
     1    f13.2,'' seconds'')')totime
            if(index(keywrd,'1scf') .ne. 0) then
               last=1
               lgrad= index(keywrd,'grad').ne.0
               call compfg (xparam,.true.,funct1,.true.,grad,lgrad)
               iflepo=13
               emin=0.0d0
               return
            endif
         endif
c
c   end of once-only setup
c
      endif
c
c     first, we initialize the variables.
c
      diisok=.false.
      ireset=0
      absmin=1.d6
      frst=.true.
      itry1=0
      jcyc=0
      lnstop=1
      irepet=1
      limscf=.true.
      alpha = 1.0d00
      pnorm=1.0d00
      jnrst=0
      cycmx=0.0d0
      cos=0.0d00
      totime=0.0d0
      ncount=1
      if( saddle) then
*
*   we don't need high precision during a saddle-point calculation.
*
         if(nvar.gt.0)gnorm=
     +      dsqrt(ddot(nvar,grad,1,grad,1))-3.d0
         if(gnorm.gt.10.d0)gnorm =10.d0
         if(gnorm.gt.1.d0) tolerg=tolrg*gnorm
         write(iprt,'('' gradient criterion in flepo ='',f12.5)')tole
     1rg
      endif
      if(nvar.eq.1) then
         pvect(1)=0.01d0
         alpha=1.d0
         goto 300
      endif
      totime=0.0d0
c
c calculate the value of the function -> funct1, and gradients -> grad.
c normal set-up of funct1 and grad, done once only.
c
      icompf=1
      call compfg (xparam,.true.,funct1,.true.,grad,.true.)
      call dcopy(nvar,grad,1,gd,1)
      if (nvar.ne.0) then
         gnorm=dsqrt(ddot(nvar,grad,1,grad,1))
         gnormr=gnorm
         if (lnstop.ne.1.and.cos.gt.rst.and.(jnrst.lt.nrst.or..not.dfp)
     1     .and.restrt)then
            call dcopy(nvar,gd,1,glast,1)
         else
            call dcopy(nvar,grad,1,glast,1)
         endif
      endif
      if(gnorm.lt.tolerg.or.nvar.eq.0) then
         iflepo=2
         if(restrt) then
            call compfg (xparam,.true.,funct1,.true.,grad,.true.)
         else
      icompf=1+icompf
            call compfg (xparam,.true.,funct1,.true.,grad,.false.)
         endif
         emin=0.0d0
         return
      endif
      tx1 =  secmop()
      tleft=tleft-tx1+tx2
c     *
c     start of each iteration cycle ...
c     *
c
      gnorm=dsqrt(ddot(nvar,grad,1,grad,1))
      if(gnormr.lt.1.d-10)gnormr=gnorm
      goto 30
   10 continue
      if(cos .lt. rst) then
         do 20 i=1,nvar
   20    gd(i)=0.5d0
      endif
   30 continue
      jcyc=jcyc+1
      jnrst=jnrst+1
      i80=0
   40 continue
      if (i80.eq.1.or.
     1lnstop.eq.1.or.cos.le.rst.or.(jnrst.ge.nrst.and.dfp))then
c
c     *
c     restart section
c     *
c
         do 50 i=1,nvar
c
c  make the first step a weak function of the gradient
c
            step=dabs(grad(i))*0.0002d0
            step=dmax1(0.01d0,dmin1(0.04d0,step))
c#         xd(i)=xparam(i)-dsign(step,grad(i))
            xd(i)=xparam(i)-dsign(del,grad(i))
   50    continue
c#      write(6,'(10f8.3)')(xd(i)-xparam(i),i=1,nvar)
c
c this call of compfg is used to calculate the second-order matrix in h
c if the new point happens to improve the result, then it is kept.
c otherwise it is scrapped, but still the second-order matrix is o.k.
c
c#      write(6,*)' reset hessian'
         call compfg (xd,.true.,funct2,.true.,gd,.true.)
         if(.not. geook .and. dsqrt(ddot(nvar,gd,1,gd,1))/
     +   gnorm.gt.10.0d0.and.gnorm.gt.20.0d0.and.jcyc.gt.2)then
c
c  the geometry is badly specified in that minor changes in internal
c  coordinates lead to large changes in cartesian coordinates, and these
c  large changes are between pairs of atoms that are chemically bonded
c  together.
            write(iprt,'('' gradients of old geometry, gnorm='',f13.6)')
     1              gnorm
            write(iprt,'(6f12.6)')(grad(i),i=1,nvar)
            gdnorm=dsqrt(ddot(nvar,gd,1,gd,1))
            write(iprt,'('' gradients of new geometry, gnorm='',f13.6)')
     1              gdnorm
            write(iprt,'(6f12.6)')(gd(i),i=1,nvar)
            write(iprt,'(///20x,''calculation abandoned at this point!''
     1)')
            write(iprt,'(//10x,'' small changes in internal coordinates
     1are   '',/10x,'' causing a large change in the distance between'',
     2/   10x,'' chemically-bound atoms. the geometry optimization'',/
     3   10x,'' procedure would likely produce incorrect results'')')
            call geout(1)
_IF(ipsc,tools)
            call pend
_ELSE
            stop
_ENDIF
         endif
         ncount=ncount+1
         do 60 i=1,ihdim
   60    hesinv(i)=0.0d00
         ii=0
         do 90 i=1,nvar
            ii=ii+i
            deltag=grad(i)-gd(i)
            deltax=xparam(i)-xd(i)
            if (dabs(deltag).lt.1.d-12) go to 70
            ggd=dabs(grad(i))
            if (funct2.lt.funct1) ggd=dabs(gd(i))
            hesinv(ii)=deltax/deltag
            if (hesinv(ii).lt.0.0d00.and.ggd.lt.1.d-12) go to 70
            if (hesinv(ii).lt.0.0d00) hesinv(ii)=tdel/ggd
            go to 80
   70       hesinv(ii)=0.01d00
   80       continue
            if (ggd.lt.1.d-12) ggd=1.d-12
            pmstep=dabs(0.1d0/ggd)
            if (hesinv(ii).gt.pmstep) hesinv(ii)=pmstep
   90    continue
         jnrst=0
         if(jcyc.lt.2)cosine=1.d0
         if(funct2 .ge. funct1) then
            if(print)write (iprt,100) funct1,funct2
  100       format (' function value=',f13.7,
     1           '  will not be replaced by value=',f13.7,/10x,
     2           'calculated by restart procedure',/)
            cosine=1.d0
         else
            if( print ) write (iprt,110) funct1,funct2
  110       format (' function value=',f13.7,
     1           ' is being replaced by value=',f13.7,/10x,
     2           ' found in restart procedure',/,6x,'the corresponding',
     3           ' x values and gradients are also being replaced',/)
            funct1=funct2
            call dcopy(nvar,xd,1,xparam,1)
            call dcopy(nvar,gd,1,grad  ,1)
            gnorm=dsqrt(ddot(nvar,grad,1,grad,1))
            if(gnormr.lt.1.d-10)gnormr=gnorm
         endif
      else
c
c     *
c     update variable-metric matrix
c     *
c
         do 120 i=1,nvar
            xvar(i)=xparam(i)-xlast(i)
  120    gvar(i)=grad(i)-glast(i)
         call supdot(gg,hesinv,gvar,nvar,1)
         yhy=ddot(nvar,gg,1,gvar,1)
         sy =ddot(nvar,xvar,1,gvar,1)
         k=0
c
c    update according to davidon-fletcher-powell
c
         if(dfp)then
            do 130 i=1,nvar
               xvari=xvar(i)/sy
               ggi=gg(i)/yhy
               do 130 j=1,i
                  k=k+1
  130       hesinv(k)=hesinv(k)+xvar(j)*xvari-gg(j)*ggi
c
c     update using the bfgs formalism
c
         else
            yhy=1.0d0 + yhy/sy
            do 140 i=1,nvar
               xvari=xvar(i)/sy
               ggi=gg(i)/sy
               do 140 j=1,i
                  k=k+1
  140       hesinv(k)=hesinv(k)-gg(j)*xvari-xvar(j)*ggi + yhy*xvar(j)*xv
     1ari
         endif
      endif
c#      do 191 i=1,ihdim
c#  191 htemp(i)=hesinv(i)
c#      call hqrii(htemp, nvar, nvar, xtemp, vects)
c#      j=0
c#      do 193 i=1,nvar
c#      if(xtemp(i).lt.0.0d0)then
c#      j=j+1
c#      xtemp(i)=0.00002d0
c#      endif
c#  193 continue
c#      if(j.ne.0)then
c#      do 194 i=1,ihdim
c#  194 htemp(i)=hesinv(i)
c#      call hrefm(nvar,vects,xtemp,hesinv)
c#      write(6,*)' original hessian'
c#      call vecprt(htemp,nvar)
c#      write(6,*)' reformed hessian'
c#      call vecprt(hesinv,nvar)
c#      endif
c#      write(6,*)' eigenvalues of hessian matrix'
c#      write(6,'(1x,5g12.6)')(6.951d-3/xtemp(i),i=1,nvar)
c
c     *
c     establish new search direction
c     *
      pnlast=pnorm
c#      call vecprt(hesinv,nvar)
      call supdot(pvect,hesinv,grad,nvar,1)
      pnorm=dsqrt(ddot(nvar,pvect,1,pvect,1))
      if(pnorm.gt.1.5d0*pnlast)then
c
c  trim pvect back
c
         do 150 i=1,nvar
  150    pvect(i)=pvect(i)*1.5d0*pnlast/pnorm
         pnorm=1.5d0*pnlast
      endif
      dott=-ddot(nvar,pvect,1,grad,1)
      do 160 i=1,nvar
  160 pvect(i)=-pvect(i)
      cos=-dott/(pnorm*gnorm)
      if (jnrst.eq.0) go to 190
      if (cos.le.cncadd.and.drop.gt.1.0d00) go to 170
      if (cos.le.rst) go to 170
      go to 190
  170 continue
c#      k=0
c#      do 222 i=1,nvar
c#      do 223 j=1,i-1
c#      k=k+1
c#  223 hesinv(k)=hesinv(k)*0.75d0
c#      k=k+1
c#  222 hesinv(k)=hesinv(k)+0.005d0
c#      goto 241
      pnorm=pnlast
      if( print )write(iprt,180) cos
  180 format (//,5x, 'since cos=',f9.3,5x,'the program will go to re',
     1'start section',/)
      i80=1
      go to 40
  190 continue
      if ( print ) write (iprt,200) jcyc,funct1
  200 format (1h , 'at the beginning of cycle',i5, '  the function va
     1lue is ',f13.6/, '  the current point is ...')
      if(print)write (iprt,210) gnorm,cos
  210 format ( '  gradient norm = ',f10.4/,'  angle cosine =',f10.4)
      if( print )then
         write (mfgw,220)
  220    format ('  the current point is ...')
         nto6=(nvar-1)/6+1
         iinc1=-5
         do 270 i=1,nto6
            write (mfgw,'(/)')
            iinc1=iinc1+6
            iinc2=min(iinc1+5,nvar)
            write (mfgw,230) (j,j=iinc1,iinc2)
            write (mfgw,240) (xparam(j),j=iinc1,iinc2)
            write (mfgw,250) (grad(j),j=iinc1,iinc2)
            write (mfgw,260) (pvect(j),j=iinc1,iinc2)
  230       format (1h ,3x,  1hi,9x,i3,9(8x,i3))
  240       format (1h ,1x, 'xparam(i)',1x,f9.4,2x,9(f9.4,2x))
  250       format (1h ,1x, 'grad  (i)',f10.4,1x,9(f10.4,1x))
  260       format (1h ,1x, 'pvect (i)',2x,f10.6,1x,9(f10.6,1x))
  270    continue
      endif
      lnstop=0
      alpha=alpha*pnlast/pnorm
      call dcopy(nvar,grad,  1,glast,1)
      call dcopy(nvar,xparam,1,xlast,1)
      if (jnrst.eq.0) alpha=1.0d00
      drop=dabs(alpha*dott)
      if(print)write (iprt,280) drop
  280 format (1h , 13h -alpha.p.g =,f18.6,/)
      if (jnrst.ne.0.and.drop.lt.delhof)then
c
c   herbert's test: the predicted drop in energy is less than delhof
c   if passed, call compfg to get a good set of eigenvectors, then exit
c
         if(minprt)write (iprt,290)
  290    format(//,10x,'herberts test satisfied - geometry optimized')
c
c   flepo is ending properly. this is immediately before the return.
c
         last=1
         call compfg (xparam,.true.,funct,.true.,grad,.false.)
         iflepo=3
         time0=time0-totime
         emin=0.0d0
         return
      endif
      beta =alpha
      smval=funct1
      dropn=-dabs(drop/alpha)
c
c    update geometry using the g-diis procedure
c
      if(diisok) then
         okf=.true.
         ic=1
      else
         okf=.false.
         ic=2
      endif
  300 call linmin(xparam,alpha,pvect,nvar,funct1,okf,ic,dropn)
      if(nvar.eq.1)then
         write(mfgw,
     +    '('' only one variable, therefore energy a minimum'')')
         last=1
         lgrad=(index(keywrd,'grad').ne.0)
         call compfg (xparam,.true.,funct,.true.,grad,lgrad)
         iflepo=14
         emin=0.0d0
         return
      endif
c   we want accurate derivatives at this point
c
c   linmin does not generate any derivatives, therefore compfg must be
c   called to end the line search
c
c  if the derivatives are to be calculated using full scf's, then check
c  whether to do full scf's (criterion from flepo: grad is null).
c
      if(ireset.gt.10.or.gnorm.lt.40.d0.and.gnorm/gnormr.lt.0.33d0)then
         ireset=0
         gnormr=0.0d0
         do 310 i=1,nvar
  310    grad(i)=0.0d0
      endif
      ireset=ireset+1
c
c
c     restore to standard value before computing the gradient
      if(thiel)then
         call compfg (xparam, ic.ne.1,  scrap, .true. ,grad,.true.)
      else
         call compfg (xparam, .true.,  funct1, .true. ,grad,.true.)
      endif
      if(ldiis) then
c
c  update geometry and gradient after making a step using linmin
c
         do 320 i=1,nvar
            xtemp(i)=xparam(i)
  320    gtemp(i)=grad(i)
         call diism(xtemp, xparam, gtemp, grad, hdiis, funct1,hesinv, 
     +              nvar, frst)
         if(hdiis.lt.funct1.and.
     1      dsqrt(ddot(nvar,gtemp,1,gtemp,1)) .lt. 
     +      dsqrt(ddot(nvar,grad,1,grad,1)))then
            do 330 i=1,nvar
               xparam(i)=xtemp(i)
  330       grad(i)=gtemp(i)
            diisok=.true.
         else
            diisok=.false.
         endif
      endif
      gnorm=dsqrt(ddot(nvar,grad,1,grad,1))
      if(gnormr.lt.1.d-10)gnormr=gnorm
      ncount=ncount+1
      if ( .not. okf) then
         lnstop = 1
         if(minprt)write (iprt,'(/,20x, ''no point lower in energy '',
     1    ''than the starting point '',/,20x,''could be found '',
     2    ''in the line minimization'')')
         funct1=smval
         alpha=beta
         call dcopy(nvar,glast,1,grad  ,1)
         call dcopy(nvar,xlast,1,xparam,1)
         if (jnrst.eq.0)then
            write (iprt,340)
  340       format (1h ,//,20x, 'since cos was just reset,the search',
     1        ' is being ended')
c
c           flepo is ending badly. this is immediately before the return
c
            last=1
            call compfg (xparam, .true., funct, .true. ,grad,.true.)
            iflepo=4
            time0=time0-totime
            emin=0.0d0
            return
         endif
         if(print)write (iprt,350)
  350    format (1h ,20x, 'cos will be reset and another '
     1    ,'attempt made')
         cos=0.0d00
         go to 470
      endif
      xn=dsqrt(ddot(nvar,xparam,1,xparam,1))
      tx=dabs(alpha*pnorm)
      if (xn.ne.0.0d00) tx=tx/xn
      tf=dabs(smval-funct1)
      if(absmin-smval.lt.1.d-7)then
         itry1=itry1+1
         if(itry1.gt.10)then
            write(mfgw,
     +   '(//,'' heat of formation is essentially stationary'')')
            goto 460
         endif
      else
         itry1=0
         absmin=smval
      endif
      if (print) write (mfgw,360) 
     +  ncount,cos,tx*xn,alpha,-drop,-tf,gnorm
  360 format (/,'           number of counts =',i6,
     1'         cos    =',f11.4,/,
     2        '  absolute  change in x     =',f13.6,
     3'  alpha  =',f11.4,/,
     4        '  predicted change in f     =  ',g11.4,
     5'  actual =  ',g11.4,/,
     6        '  gradient norm             =  ',g11.4,//)
      if (tx.le.tolerx) then
         if(minprt) write (iprt,370)
  370    format (' test on x satisfied')
         goto 400
      endif
      if (tf.le.tolerf) then
c#         write(6,*)tf,tolerf
         if(minprt) write (iprt,380)
  380    format (' heat of formation test satisfied')
         goto 400
      endif
      if (gnorm.le.tolerg*rootv) then
         if(minprt) write (iprt,390)
  390    format (' test on gradient satisfied')
         goto 400
      endif
      go to 470
  400 do 440 i=1,nvar
         if (dabs(grad(i)).gt.tolerg)then
            irepet=irepet+1
            if (irepet.gt.1) go to 410
            frepf=funct1
            cos=0.0d00
  410       if(minprt) write (iprt,420)tolerg
  420       format (20x,'however, a component of gradient is ',
     1     'larger than',f6.2 ,/)
            if (dabs(funct1-frepf).gt.einc) irepet=0
            if (irepet.gt.igg1) then
               write (iprt,430)igg1,einc
  430          format (10x,' there have been',i2,' attempts to reduce th
     1e ',' gradient.',/10x,' during these attempts the energy dropped',
     2' by less than',f4.1,' kcal/mole',/
     310x,' further calculation is not justified at this time.',/
     410x,' to continue, start again with the word "precise"' )
               last=1
               call compfg (xparam,.true.,funct,.true.,grad,.false.)
               iflepo=8
               time0=time0-totime
               emin=0.0d0
               return
            else
               goto 470
            endif
         endif
  440 continue
      if(minprt) write (iprt,450)
  450 format ( 23h peters test satisfied )
  460 last=1
      call compfg (xparam,.true.,funct,.true.,grad,.false.)
      iflepo=6
      time0=time0-totime
      emin=0.0d0
      return
c
c   all tests have failed, we need to do another cycle.
c
  470 continue
      bsmvf=dabs(smval-funct1)
      if (bsmvf.gt.10.d00) cos = 0.0d00
      del=0.002d00
      if (bsmvf.gt.1.0d00) del=dell/2.0d00
      if (bsmvf.gt.5.0d00) del=dell
      tx2 = secmop ()
      tcycle=tx2-tx1
      tx1=tx2
c
c end of iteration loop, everything is still o.k. so go to
c next iteration, if there is enough time left.
c
      if(tcycle.lt.100000.d0)cycmx=dmax1(cycmx,tcycle)
      tleft=tleft-tcycle
      if(tleft.lt.0)tleft=-0.1d0
      if(tcycle.gt.1.d5)tcycle=0.0d0
      if(tlast-tleft.gt.tdump)then
         totim=totime   +   secmop()-time0
         tlast=tleft
         mdfp(9)=2
         resfil=.true.
         mdfp(5)=nscf
         call dfpsav(totim,xparam,gd,xlast,funct1,mdfp,xdfp)
      endif
      if(resfil)then
         if(minprt) write(mfgw,480)dmin1(tleft,9999999.9d0),
     1dmin1(gnorm,999999.999d0),funct1
  480    format(' restart file written,   time left:',f9.1,
     1' grad.:',f10.3,' heat:',g13.7)
         resfil=.false.
      else
         if(minprt) write(mfgw,490)jcyc,dmin1(tcycle,9999.99d0),
     1dmin1(tleft,9999999.9d0),dmin1(gnorm,999999.999d0),funct1
         if(log) write(11,490)jcyc,dmin1(tcycle,9999.99d0),
     1dmin1(tleft,9999999.9d0),dmin1(gnorm,999999.999d0),funct1
  490    format(' cycle:',i4,' time:',f7.2,' time left:',f9.1,
     1' grad.:',f10.3,' heat:',g13.7)
      endif
      if (tleft.gt.sfact*cycmx) go to 10
      write(iprt,500)
  500 format (20x, 42hthere is not enough time for another cycle,/,30x,
     118hnow going to final)
      totim=totime   +   secmop()-time0
      mdfp(9)=1
      mdfp(5)=nscf
      call dfpsav(totim,xparam,gd,xlast,funct1,mdfp,xdfp)
      iflepo=-1
      return
c
c
      end
      function fm06as(n,a,ia,b,ib)
      implicit COMPLEX (a-h,o-z)
      COMPLEX a(*), b(*)
*******************************************************
*
*    fm06as - a function routine to compute the value of the
*      inner product, or dot product, of two single precision
*      complex vectors, accumulating the intermediate products
*      double precision.  the elements of each vector can be
*      stored in any fixed displacement from neighbouring
*      elements.
*
*    computes: sum(j=1,n) a((j-1)*ia+1)*b((j-1)*ib+1)
*
*          w = fm06as(n,a,ia,b,ib)
*
*    n   integer scalar; (user:*); length of the vectors a and b.
*        if n <= 0 the inner product value is defined to be zero.
*    a   complex*8 array((n-1)*iabs(ia)+1); (user:*); the array
*        containing the 1st vector.  the fortran convention of storing
*        real and imaginary parts in adjacent words is assumed.
*    ia  integer scalar; (user:*); the subscript displacement of
*        an element in the array a to its neighbour, i.e. the vector
*        elements are in a(1), a(ia+1), a(2*ia+1),...
*        if ia < 0 the elements are assumed to be stored in
*        a(1-(n-1)*ia), a(1-(n-2)*ia),..., a(1-ia), a(1).
*    b   complex*8 array((n-1)*iabs(ia)+1); (user:*); the array
*        containing the second vector.  treat like a.
*    ib  integer scalar; (user:*); the subscript displacement of
*        an element in b to its neighbour. treat like ia.
*    fm06as  complex function; (*:fm06as); the inner product value.
*        it is returned double precision, the real part in flt pnt
*        reg 0 and the imaginary part in flt pnt reg 2.
*
*    this routine is written in fortran.
*
*--------------------------------------------------------*
      sum=(0.0d0,0.0d0)
      do 10 i=1,n
   10 sum=sum+a((i-1)*ia+1)*b((i-1)*ib+1)
      fm06as=sum
      return
      end
      function fm06bs(n,a,ia,b,ib)
      implicit COMPLEX (a-h,o-z)
      COMPLEX a(*), b(*)
*******************************************************
*
*    fm06bs - a function routine to compute the value of the
*      inner product, or dot product, of a sigle    precision
*      complex vectors, accumulating the intermediate products
*      double precision.  the elements of each vector can be
*      stored in any fixed displacement from neighbouring
*      elements.
*
*    computes: sum(j=1,n) a((j-1)*ia+1)*b((j-1)*ib+1)
*
*          w = fm06bs(n,a,ia,b,ib)
*
*    n   integer scalar; (user:*); length of the vectors a and b.
*        if n <= 0 the inner product value is defined to be zero.
*    a   complex*8 array((n-1)*iabs(ia)+1); (user:*); the array
*        containing the 1st vector.  the fortran convention of storing
*        real and imaginary parts in adjacent words is assumed.
*    ia  integer scalar; (user:*); the subscript displacement of
*        an element in the array a to its neighbour, i.e. the vector
*        elements are in a(1), a(ia+1), a(2*ia+1),...
*        if ia < 0 the elements are assumed to be stored in
*        a(1-(n-1)*ia), a(1-(n-2)*ia),..., a(1-ia), a(1).
*    b   complex*8 array((n-1)*iabs(ia)+1); (user:*); the array
*        containing the second vector.  treat like a.
*    ib  integer scalar; (user:*); the subscript displacement of
*        an element in b to its neighbour. treat like ia.
*    fm06bs  complex function; (*:fm06bs); the inner product value.
*        it is returned double precision, the real part in flt pnt
*        reg 0 and the imaginary part in flt pnt reg 2.
*
*    this routine is written in fortran.
*
*--------------------------------------------------------*
      sum=(0.0d0,0.0d0)
      do 10 i=1,n
   10 sum=sum+a((i-1)*ia+1)*conjg(b((i-1)*ib+1))
      fm06bs=sum
      return
      end
      subroutine fmat(fmatrx, nreal, tscf, tder, deldip, heat)
      implicit REAL (a-h,o-z)
_IF(ipsc,tools)
      logical oipsci
_ENDIF
INCLUDE(common/sizes)
      common /symops/ r(14,120), nsym, ipo(numatm,120)
      dimension fmatrx(*), deldip(3,*)
***********************************************************************
*
*  value calculates the second-order of the energy with
*        respect to the cartesian coordinates i and j and places it
*        in fmatrx
*
*  on input natoms  = number of atoms in the system.
*           xparam  = internal coordinates of molecule stored linearly
*
*  variables used
*           coordl  = array of cartesian coordinates, stored linearly.
*           i       = index of cartesian coordinate.
*           j       = index of cartesian coordinate.
*
*  on output fmatrx = second derivative of the energy with respect to
*                    cartesian coordinates i and j.
***********************************************************************
      common /keywrd/ keywrd
      common /geokst/ natoms,labels(numatm),
     1                na(numatm),nb(numatm),nc(numatm)
      common /geovar/ nvar,loc(2,maxpar),idumy, dumy(maxpar)
      common /densty/ p(mpack),pdumy(2,mpack)
      common /timdmp/ tleft, tdump
      common /atmass/ atmass(numatm)
      common /timem/ time0
      common /iofile/ mfgr,mfgw
_IF(ipsc,tools)
      common/nodinf/mpid,minode,mihost,dim,nnodes
_ENDIF
      common /corec/ core(107)
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),
     1                nlast(numatm), norbs, nelecs,nalpha,nbeta,
     2                nclose,nopen,ndumy,fract
      common /coord/ coord(3,numatm)
      common /nllcom/ evecs(maxpar*maxpar),bmat(maxpar,maxpar*2)
      dimension grad(maxpar),
     1grold(maxpar), coordl(maxpar), q(numatm), del2(3), g2old(maxpar)
     2, eigs(maxpar), g2rad(maxpar),
     3 fconst(maxpar)
_IF(ipsc,tools)
      common /junk/ gdumy(maxpar*(maxpar+1)/2)
_ENDIF
      character*241 keywrd
      save  fact 
      logical debug, restrt, prnt, resfil, precis, big, log, group
      equivalence (coord(1,1),coordl(1))
      data fact/6.95125d-3/
c
c    fact is the conversion factor from kcal/mole to ergs
c
c set up constants and flags
      na(1)=99
c
c  set up the variables in xparam andloc,these are in cartesian coordina
c
      numat=0
c$doit asis
      do 10 i=1,natoms
         if(labels(i).ne.99.and.labels(i).ne.107) then
            numat=numat+1
            labels(numat)=labels(i)
         endif
   10 continue
      natoms=numat
c
c   this is a quick, if clumsy, way to calculate numat, and to remove
c   the dummy atoms from the array labels.
c
      nvar=numat*3
      do 20 i=1,numat
         loc(1,(i-1)*3+1)=i
         loc(2,(i-1)*3+1)=1
c
         loc(1,(i-1)*3+2)=i
         loc(2,(i-1)*3+2)=2
c
         loc(1,(i-1)*3+3)=i
         loc(2,(i-1)*3+3)=3
   20 continue
      lin=(nvar*(nvar+1))/2
      do 30 i=1,lin
   30 fmatrx(i)=0.0d0
      prnt   =(index(keywrd,'irc=') .eq. 0)
      log    =(index(keywrd,'nolog') .eq. 0)
      precis =(index(keywrd,'prec') .ne. 0)
      restrt =(index(keywrd,'restart') .ne. 0)
      group  =(index(keywrd,' group').ne.0)
      if(index(keywrd,'nllsq') .ne. 0) restrt=.false.
      debug =(index(keywrd,'fmat') .ne. 0)
      big    =(index(keywrd,'large') .ne. 0 .and. debug)
      if(prnt)
     +   write(mfgw,'(//4x,
     + ''first derivatives will be used in the'',
     1 '' calculation of second derivatives'')')
      tlast=tleft
      resfil=.false.
      if(restrt) then
         istart = 0
         i=0
         call forsav(totime,deldip,istart,fmatrx, coord, nvar,heat,
     1                evecs,jstart,fconst)
         kountf=(istart*(istart+1))/2
         istart=istart+1
         jstart=jstart+1
         time2 = secmop()
      else
         kountf=0
         totime=0.0d0
         if (tscf.gt.0.d0)tleft=tleft-tscf-tder
         istart=1
      endif
c calculate fmatrx
      if(istart.gt.1) then
         estime=(nvar-istart+1)*totime/(istart-1.d0)
      else
         estime=nvar*(tscf+tder)*2.d0
         if (precis) estime=estime*2.d0
      endif
      if(tscf.gt.0)
     1write(mfgw,
     +'(/10x,''estimated time to complete calculation =''
     2,f9.2,'' seconds'')')estime
      if(restrt) then
         if(istart.le.nvar)
     1   write(mfgw,
     +   '(/10x,''starting again at line'',18x,i4)')istart
         write(mfgw,
     +   '(/10x,''time used up to restart ='',f22.2)')totime
      endif
      lu=kountf
      numat=nvar/3
      do 40 i=1,nvar
   40 eigs(i)=0.0d0
c
c  read in the symmetry operations, if present
c
      if(group) call symr
      iskip=0
_IF(ipsc,tools)
c *** MPP ***
_IF(ipsc)
      call gsync
_ELSE
      call synch(11111)
_ENDIF
      iflop = iipsci()
c *** MPP ***
_ENDIF
      do 110 i=istart,nvar
         if(group .and. ((i-1)/3)*3.eq.i-1)then
c
c  start of a new atom.  does a symmetry operation relate an already
c  calculated atom to this one
c
            j=(i+2)/3
            call sympop(fmatrx, j, iskip, deldip)
         endif
         if(iskip.gt.0) then
            write(mfgw,
     +      '('' step:'',i4,''       '',9x,  ''       integral ='',
     +       f10.2,'' time left:'',f10.2)')i,totime,tleft
            iskip=iskip-1
            lu=lu+i
            goto 110
         endif
         time2 = secmop()
         delta=1.d0/120.d0
_IF(ipsc,tools)
c *** MPP ***
         if(oipsci()) go to 110
c *** MPP ***
_ENDIF
         if(precis)then
c
c   determine a good step size
c
            g2old(1)=100.d0
            coordl(i)=coordl(i)+delta
            call compfg(coordl, .true., escf, .true., g2old, .true.)
            coordl(i)=coordl(i)-delta
            delta=delta*10.d0/dsqrt(ddot(nvar,g2old,1,g2old,1))
c
c   constrain delta to a 'reasonable' value
c
            delta=dmin1(0.05d0,dmax1(0.005d0,delta))
            if(debug)write(mfgw,
     +      '(a,i3,a,f12.5)')' step:',i,' delta :',delta
            g2old(1)=100.d0
            coordl(i)=coordl(i)+delta
            call compfg(coordl, .true., escf, .true., g2old, .true.)
            if(debug)write(mfgw,
     +     '(a,f12.5)')' gnorm +1.0*delta',
     +       dsqrt(ddot(nvar,g2old,1,g2old,1))
            coordl(i)=coordl(i)-delta*2.d0
            g2rad(1)=100.d0
            call compfg(coordl, .true., heataa, .true., g2rad, .true.)
            coordl(i)=coordl(i)+delta
            if(debug)write(mfgw,'(a,f12.5)')' gnorm -1.0*delta',
     1            dsqrt(ddot(nvar,g2rad,1,g2rad,1))
         else
            if(debug)write(mfgw,
     +      '(a,i3,a,f12.5)')' step:',i,' delta :',delta
         endif
         coordl(i)=coordl(i)+0.5d0*delta
         grold(1)=100.d0
         call compfg(coordl, .true., escf, .true., grold, .true.)
         if(debug)write(mfgw,'(a,f12.5)')' gnorm +0.5*delta',
     1              dsqrt(ddot(nvar,grold,1,grold,1))
         call chrge(p,q)
         do 50 ii=1,numat
   50    q(ii)=core(labels(ii))-q(ii)
         sum = dipmop(p,q,coordl,deldip(1,i),0)
         coordl(i)=coordl(i)-delta
         grad(1)=100.d0
         call compfg(coordl, .true., heataa, .true., grad, .true.)
         if(debug)write(mfgw,'(a,f12.5)')' gnorm -0.5*delta',
     1              dsqrt(ddot(nvar,grad,1,grad,1))
         call chrge(p,q)
         do 60 ii=1,numat
   60    q(ii)=core(labels(ii))-q(ii)
         sum = dipmop(p,q,coordl,del2,0)
         coordl(i)=coordl(i)+delta*0.5d0
         deldip(1,i)=(deldip(1,i)-del2(1))*0.5d0/delta
         deldip(2,i)=(deldip(2,i)-del2(2))*0.5d0/delta
         deldip(3,i)=(deldip(3,i)-del2(3))*0.5d0/delta
         ll=lu+1
         lu=ll+i-1
         l=0
         if(precis)then
            do 70 kountf=ll,lu
               l=l+1
c
c       g2old = x + 1.0*delta
c       grold = x + 0.5*delta
c       grad  = x - 0.5*delta
c       g2rad = x - 1.0*delta
c
               dumy(l)= (8.d0*(grold(l)-grad(l))-(g2old(l)-g2rad(l)))
     1          /delta*fact/24.d0
               eigs(l)=(2.d0*(grold(l)-grad(l))-(g2old(l)-g2rad(l)))
     1          /delta**3*fact/56.d0
c
c  correct for 4'th order contamination
c
c#             corr=dmin1(abs(dumy(l)),abs(eigs(l))*0.0001d0)
c#             dumy(l)=dumy(l)-dsign(corr,dumy(l))
               fmatrx(kountf)=fmatrx(kountf)+dumy(l)
   70       continue
            l=l-1
            do 80 k=i,nvar
               l=l+1
               kk=(k*(k-1))/2+i
               dumy(l)=(8.d0*(grold(l)-grad(l))-(g2old(l)-g2rad(l)))
     1          /delta*fact/24.d0
               eigs(l)=(2.d0*(grold(l)-grad(l))-(g2old(l)-g2rad(l)))
     1          /delta**3*fact/56.d0
c
c  correct for 4'th order contamination
c
c#             corr=dmin1(abs(dumy(l)),abs(eigs(l))*0.0001d0)
c#             dumy(l)=dumy(l)-dsign(corr,dumy(l))
               fmatrx(kk)=fmatrx(kk)+dumy(l)
   80       continue
         else
            do 90 kountf=ll,lu
               l=l+1
               dumy(l)=((grold(l)-grad(l)))*0.25d0/delta*fact
               fmatrx(kountf)=fmatrx(kountf)+dumy(l)
   90       continue
            l=l-1
            do 100 k=i,nvar
               l=l+1
               kk=(k*(k-1))/2+i
               dumy(l)=((grold(l)-grad(l)))*0.25d0/delta*fact
               fmatrx(kk)=fmatrx(kk)+dumy(l)
  100       continue
         endif
         if(big)then
            write(mfgw,'(a)')' contributions to f-matrix'
            write(mfgw,'(a)')
     +      ' element  +1.0*delta  +0.5*delta  -0.5*del'//
     +      'ta  -1.0*delta   2','nd order 4th order'
            write(mfgw,
     +'(i7,6f12.6)')(l,g2old(l),grold(l),grad(l),g2rad(l),
     1dumy(l),eigs(l),l=1,nvar)
         endif
         time3 = secmop()
         tstep=time3-time2
         tleft= dmax1(0.1d0,tleft-tstep)
         if(tstep.gt.1.d6)tstep=tstep-1.d6
         totime= totime+tstep
         if(resfil)then
            write(mfgw,
     +      '('' step:'',i4,'' restart file written, integral ='',
     +        f10.2,'' time left:'',f10.2)')i,totime,tleft
            if(log)write(11,
     +      '('' step:'',i4,'' restart file written, '',''integral =''
     +      ,f10.2,'' time left:'',f10.2)')i,totime,tleft
            resfil=.false.
         else
            write(mfgw,
     + '('' step:'',i4,'' time ='',f9.2,'' secs, integral =
     1'',f10.2,'' time left:'',f10.2)')i,tstep,totime,tleft
            if(log) write(11,'('' step:'',i4,'' time ='',
     +      f9.2,'' secs, '',
     +''integral ='',f10.2,'' time left:'',f10.2)')i,tstep,totime,tleft
         endif
         estim = totime/i
         if(tlast-tleft.gt.tdump)then
            tlast=tleft
            resfil=.true.
            jstart=1
            ii=i
            call forsav(totime,deldip,ii,fmatrx, coord,nvar,heat,
     1                evecs,jstart,fconst)
         endif
         if(i.ne.nvar.and.tleft-10.d0 .lt. estim) then
            write(mfgw,
     +      '(//10x,''- - - - - - - time up - - - - - - -'',//)')
            write(mfgw,'(/10x,'' point reached ='',i4)')i
            write(mfgw,'(/10x,'' restart using key-word "restart"'')')
            write(mfgw,'(10x,''estimated time for the next step ='',
     +            f8.2,'' seconds'')')estim
            jstart=1
            ii=i
            call forsav(totime,deldip,ii,fmatrx, coord,nvar,heat,
     1                evecs,jstart,fconst)
            write(mfgw,'(//10x,''force matrix written to disk'')')
            nreal=-1
            return
         endif
  110 continue
_IF(ipsc,tools)
_IF(ipsc)
      call gsync
c *** MPP ***
       call gdsum(fmatrx,lin,gdumy)
c *** MPP ***
_ELSE
      call synch(22222)
c *** MPP ***
      call dgop(200,fmatrx,lin,'+',gdumy)
c *** MPP ***
_ENDIF
_ENDIF
      do 120 i=1,natoms
         if(atmass(i).lt.1.d-20.and.labels(i).lt.99)then
            call forsav(totime,deldip,nvar,fmatrx, coord,nvar,heat,
     1                evecs,iloop,fconst)
            write(mfgw,'(a)')
     +      ' at least one atom has a zero mass. a restart'
            write(mfgw,'(a)')
     +      ' file has been written and the job stopped'
_IF(ipsc,tools)
            call pend
_ELSE
            stop
_ENDIF
         endif
  120 continue
      if(istart.le.nvar .and. index(keywrd,'isot') .ne. 0)
     1call forsav(totime,deldip,nvar,fmatrx, coord,nvar,heat,
     2                evecs,iloop,fconst)
      return
      end
      subroutine fock1(f, ptot, pa, pb)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      dimension f(*), ptot(*), pa(*), pb(*)
c *********************************************************************
c
c *** compute the remaining contributions to the one-centre elements.
c
c *********************************************************************
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),
     1                nlast(numatm), norbs, nelecs,nalpha,nbeta,
     2                nclose,nopen,ndumy,fract
      common /cmpga/ fn1(107),fn2(107)
      common /molorb/ uspd(maxorb),dumy(maxorb)
      common /twoele/ gss(107),gsp(107),gpp(107),gp2(107),hsp(107)
     1                ,gsd(107),gpd(107),gdd(107)
      dimension qtot(numatm), qa(numatm)
      common /keywrd/ keywrd
      character*241 keywrd
      call chrge(ptot,qtot)
      call chrge(pa,qa)
      do 100 ii=1,numat
         ia=nfirst(ii)
         ib=nmidle(ii)
         ic=nlast(ii)
         ni=nat(ii)
         dtpop=0.0d0
         dapop=0.0d0
         ptpop=0.0d0
         papop=0.0d0
         goto (100,40,30,30,30,20,20,20,20,20)ic-ia+2
   20    dtpop=ptot((ic*(ic+1))/2)+ptot(((ic-1)*(ic))/2)
     1        +ptot(((ic-2)*(ic-1))/2)+ptot(((ic-3)*(ic-2))/2)
     2        +ptot(((ic-4)*(ic-3))/2)
         dapop=pa((ic*(ic+1))/2)+pa(((ic-1)*(ic))/2)
     1        +pa(((ic-2)*(ic-1))/2)+pa(((ic-3)*(ic-2))/2)
     2        +pa(((ic-4)*(ic-3))/2)
   30    ptpop=ptot((ib*(ib+1))/2)+ptot(((ib-1)*(ib))/2)
     1        +ptot(((ib-2)*(ib-1))/2)
         papop=pa((ib*(ib+1))/2)+pa(((ib-1)*(ib))/2)
     1        +pa(((ib-2)*(ib-1))/2)
   40    if(ni.eq.1)then
            sum=0.0d0
         else
            sum2=0.0d0
            sum1=0.0d0
            do 60 i=ia,ib
               im1=i-1
               do 50 j=ia,im1
   50          sum1=sum1+ptot(j+(i*(i-1))/2)**2
   60       sum2=sum2+ptot((i*(i+1))/2)**2
            sum=sum1*2.d0+sum2
            sum=dsqrt(sum)-qtot(ii)*0.5d0
         endif
         sum=sum*fn1(ni)
c
c     f(s,s)
c
         ka=(ia*(ia+1))/2
         f(ka)=f(ka)+pb(ka)*gss(ni)+ptpop*gsp(ni)
     1         -papop*hsp(ni) + dtpop*gsd(ni)
         if (ni.lt.3) go to 100
         iplus=ia+1
         l=ka
         do 70 j=iplus,ib
            m=l+ia
            l=l+j
c
c     f(p,p)
c
            f(l)=f(l)+ptot(ka)*gsp(ni)-pa(ka)*hsp(ni)+
     1      pb(l)*gpp(ni)+(ptpop-ptot(l))*gp2(ni)
     2      -0.5d0*(papop-pa(l))*(gpp(ni)-gp2(ni))
     3      +dtpop*gpd(ni)
c
c     f(s,p)
c
   70    f(m)=f(m)+2.d0*ptot(m)*hsp(ni)-pa(m)*(hsp(ni)+gsp(ni))
c
c     f(p,p*)
c
         iminus=ib-1
         do 80 j=iplus,iminus
            icc=j+1
            do 80 l=icc,ib
               m=(l*(l-1))/2+j
   80    f(m)=f(m)+ptot(m)*(gpp(ni)-gp2(ni))
     1      -0.5d0*pa  (m)*(gpp(ni)+gp2(ni))
         do 90 j=ib+1,ic
            m=(j*(j+1))/2
   90    f(m)=f(m)+ptot(ka)*gsd(ni)
     1         +ptpop*gpd(ni)
     2         +(dtpop-pa(m))*gdd(ni)
  100 continue
      return
      end
      subroutine fock2(f, ptot, p, w, wj, wk, numat, nat, nfirst,
     1nmidle, nlast)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      dimension f(*), ptot(*), wj(*), wk(*), nfirst(*), nmidle(*),
     1          nlast(*), p(*), w(*)
      REAL wj,wk
c***********************************************************************
c
c fock2 forms the two-electron two-center repulsion part of the fock
c matrix
c on input  ptot = total density matrix.
c           p    = alpha or beta density matrix.
c           w    = two-electron integral matrix.
c
c  on output f   = partial fock matrix
c***********************************************************************
      common /euler/ tvec(3,3), id
      common /molmec/ htype(4),nhco(4,20),nnhco,itype
      common /numcal/ numcal
      common /keywrd/ keywrd
      common /work4/ ptot2(numatm,16)
c cosmo change
      logical iseps, useps, upda
      common /iseps/  iseps, useps, upda
c end of cosmo change
      common /work5/ ifact(maxorb),i1fact(maxorb), jindex(256),
     + kindex(256), ijperm(10), llperm(10),
     + pk(16), pja(16), pjb(16), mmperm(10), jjndex(256), ione, lid

      character*241 keywrd
      logical lid
      save icalcn
      data icalcn/0/
      if(icalcn.ne.numcal) then
         icalcn=numcal
c
c   set up array of lower half triangle indices (pascal's triangle)
c
         do 10 i=1,maxorb
            ifact(i)=(i*(i-1))/2
   10    i1fact(i)=ifact(i)+i
c
c   set up gather-scatter type arrays for use with two-electron
c   integrals.  jindex are the indices of the j-integrals for atom i
c   integrals.  jjndex are the indices of the j-integrals for atom j
c               kindex are the indices of the k-integrals
c
         m=0
         do 20 i=1,4
            do 20 j=1,4
               ij=min(i,j)
               ji=i+j-ij
               do 20 k=1,4
                  ik=min(i,k)
                  ki=i+k-ik
                  do 20 l=1,4
                     m=m+1
                     kl=min(k,l)
                     lk=k+l-kl
                     jl=min(j,l)
                     lj=j+l-jl
                     kindex(m)= ifact(lj) +jl + 10*( ifact(ki) +ik) -10
   20    jindex(m)=(ifact(ji) + ij)*10 + ifact(lk) + kl - 10
         l=0
         do 30 i=1,4
            i1=(i-1)*4
            do 30 j=1,i
               i1=i1+1
               l=l+1
               ijperm(l)=i1
               mmperm(l)=ijperm(l)-16
               llperm(l)=(i1-1)*16
   30    continue
         l=0
         do 40 i=1,10
            m=mmperm(i)
            l=llperm(i)
            do 40 k=1,16
               l=l+1
               m=m+16
   40    jjndex(l)=jindex(m)
         lid=(id.eq.0)
         ione=1
         if(id.ne.0)ione=0
c
c      end of initialization
c
      endif
      if(itype.eq.4) goto 200
c
c     start of mndo, am1, or pm3 option
c
      kk=0
      l=0
      do 60 i=1,numat
         ia=nfirst(i)
         ib=nlast(i)
         m=0
         do 50 j=ia,ib
            do 50 k=ia,ib
               m=m+1
               jk=min(j,k)
               kj=k+j-jk
               jk=jk+(kj*(kj-1))/2
               ptot2(i,m)=ptot(jk)
   50    continue
   60 continue
      do 190 ii=1,numat
         ia=nfirst(ii)
         ib=nlast(ii)
c
c  if numat=2 then we are in a derivative or in a molecule calculation
c
         if(numat.ne.2)then
            iminus=ii-ione
         else
            iminus=ii-1
         endif
         do 180 jj=1,iminus
            ja=nfirst(jj)
            jb=nlast(jj)
            jc=nmidle(jj)
            if(lid) then
               if(ib-ia.ge.3.and.jb-ja.ge.3)then
c
c                         heavy-atom  - heavy-atom
c
c   extract coulomb terms
c
                  do 70 i=1,16
                     pja(i)=ptot2(ii,i)
   70             pjb(i)=ptot2(jj,i)
c
c  coulomb terms
c
                  call jab(ia,ja,llperm,jindex, jjndex, pja,pjb,w(kk+1),
     1f)
c
c  exchange terms
c
c
c  extract intersection of atoms ii and jj in the spin density matrix
c
                  l=0
                  do 80 i=ia,ib
                     i1=ifact(i)+ja
                     do 80 j=i1,i1+3
                        l=l+1
   80             pk(l)=p(j)
                  call kab(ia,ja, pk, w(kk+1), kindex, f)
                  kk=kk+100
               elseif(ib-ia.ge.3.and.ja.eq.jb)then
c
c                         light-atom  - heavy-atom
c
c
c   coulomb terms
c
                  sumdia=0.0d0
                  sumoff=0.0d0
                  ll=i1fact(ja)
                  k=0
                  do 100 i=0,3
                     j1=ifact(ia+i)+ia-1
                     do 90 j=0,i-1
                        k=k+1
                        j1=j1+1
                        f(j1)=f(j1)+ptot(ll)*w(kk+k)
   90                sumoff=sumoff+ptot(j1)*w(kk+k)
                     j1=j1+1
                     k=k+1
                     f(j1)=f(j1)+ptot(ll)*w(kk+k)
  100             sumdia=sumdia+ptot(j1)*w(kk+k)
                  f(ll)=f(ll)+sumoff*2.d0+sumdia
c
c  exchange terms
c
c
c  extract intersection of atoms ii and jj in the spin density matrix
c
                  k=0
                  do 120 i=ia,ib
                     i1=ifact(i)+ja
                     sum=0.0d0
                     do 110 j=ia,ib
                        k=k+1
                        j1=ifact(j)+ja
  110                sum=sum+p(j1)*w(kk+jindex(k))
  120             f(i1)=f(i1)-sum
                  kk=kk+10
               elseif(jb-ja.ge.3.and.ia.eq.ib)then
c
c                         heavy-atom - light-atom
c
c
c   coulomb terms
c
                  sumdia=0.0d0
                  sumoff=0.0d0
                  ll=i1fact(ia)
                  k=0
                  do 140 i=0,3
                     j1=ifact(ja+i)+ja-1
                     do 130 j=0,i-1
                        k=k+1
                        j1=j1+1
                        f(j1)=f(j1)+ptot(ll)*w(kk+k)
  130                sumoff=sumoff+ptot(j1)*w(kk+k)
                     j1=j1+1
                     k=k+1
                     f(j1)=f(j1)+ptot(ll)*w(kk+k)
  140             sumdia=sumdia+ptot(j1)*w(kk+k)
                  f(ll)=f(ll)+sumoff*2.d0+sumdia
c
c  exchange terms
c
c
c  extract intersection of atoms ii and jj in the spin density matrix
c
                  k=ifact(ia)+ja
                  j=0
                  do 160 i=k,k+3
                     sum=0.0d0
                     do 150 l=k,k+3
                        j=j+1
  150                sum=sum+p(l)*w(kk+jindex(j))
  160             f(i)=f(i)-sum
                  kk=kk+10
               elseif(jb.eq.ja.and.ia.eq.ib)then
c
c                         light-atom - light-atom
c
                  i1=i1fact(ia)
                  j1=i1fact(ja)
                  ij=i1+ja-ia
                  f(i1)=f(i1)+ptot(j1)*w(kk+1)
                  f(j1)=f(j1)+ptot(i1)*w(kk+1)
                  f(ij)=f(ij)-p   (ij)*w(kk+1)
                  kk=kk+1
               endif
            else
               do 170 i=ia,ib
                  ka=ifact(i)
                  do 170 j=ia,i
                     kb=ifact(j)
                     ij=ka+j
                     aa=2.0d00
                     if (i.eq.j) aa=1.0d00
                     do 170 k=ja,jc
                        kc=ifact(k)
                        if(i.ge.k) then
                           ik=ka+k
                        else
                           ik=0
                        endif
                        if(j.ge.k) then
                           jk=kb+k
                        else
                           jk=0
                        endif
                        do 170 l=ja,k
                           if(i.ge.l) then
                              il=ka+l
                           else
                              il=0
                           endif
                           if(j.ge.l) then
                              jl=kb+l
                           else
                              jl=0
                           endif
                           kl=kc+l
                           bb=2.0d00
                           if (k.eq.l) bb=1.0d00
                           kk=kk+1
                           aj=wj(kk)
                           ak=wk(kk)
c
c     a  is the repulsion integral (i,j/k,l) where orbitals i and j are
c     on atom ii, and orbitals k and l are on atom jj.
c     aa and bb are correction factors since
c     (i,j/k,l)=(j,i/k,l)=(i,j/l,k)=(j,i/l,k)
c     ij is the location of the matrix elements between atomic orbitals
c     i and j.  similarly for ik etc.
c
c this forms the two-electron two-center repulsion part of the fock
c matrix.  the code here is hard to follow, and impossible to modify!,
c but it works,
                           if(kl.le.ij)then
                              if(i.eq.k.and.aa+bb.lt.2.1d0)then
                                 bb=bb*0.5d0
                                 aa=aa*0.5d0
                                 f(ij)=f(ij)+bb*aj*ptot(kl)
                                 f(kl)=f(kl)+aa*aj*ptot(ij)
                              else
                                 f(ij)=f(ij)+bb*aj*ptot(kl)
                                 f(kl)=f(kl)+aa*aj*ptot(ij)
                                 a=ak*aa*bb*0.25d0
                                 f(ik)=f(ik)-a*p(jl)
                                 f(il)=f(il)-a*p(jk)
                                 f(jk)=f(jk)-a*p(il)
                                 f(jl)=f(jl)-a*p(ik)
                              endif
                           endif
  170          continue
            endif
  180    continue
  190 continue
c cosmo change
c the following routine adds the dielectric corretion to f
      if (useps) call addfck (f,p,numat,nat,nfirst,nlast)
c a. klamt 18.7.91
c end of cosmo change
      return
c
c                    start of mindo/3 option
c
  200 kr=0
      do 230 ii=1,numat
         ia=nfirst(ii)
         ib=nlast(ii)
         im1=ii-ione
         do 220 jj=1,im1
            kr=kr+1
            if(lid)then
               elrep=w(kr)
               elexc=elrep
            else
               elrep=wj(kr)
               elexc=wk(kr)
            endif
            ja=nfirst(jj)
            jb=nlast(jj)
            do 210 i=ia,ib
               ka=ifact(i)
               kk=ka+i
               do 210 k=ja,jb
                  ll=i1fact(k)
                  ik=ka+k
                  f(kk)=f(kk)+ptot(ll)*elrep
                  f(ll)=f(ll)+ptot(kk)*elrep
  210       f(ik)=f(ik)-p(ik)*elexc
  220    continue
  230 continue
      return
      end
      subroutine force
      implicit REAL (a-h,o-z)
      logical oprint
INCLUDE(common/sizes)
      common/prints/oprint(60)
      common /geovar/ nvar,loc(2,maxpar),idumy,dumy(maxpar)
      common /geosym/ ndep,locpar(maxpar),idepfn(maxpar),
     1                     locdep(maxpar)
      common /geokst/ natoms,labels(numatm),
     1na(numatm),nb(numatm),nc(numatm)
      common /fmatrx/ fmatrx(maxpar**2+maxpar*3+1),idumy2(4)
      common /keywrd/ keywrd
      common /gradnt/ grad(maxpar),gnorm
      parameter (ipadd=2*morb2+2*maxorb-maxpar-maxpar*maxpar)
      common /vector/ cnorml(maxpar*maxpar),freq(maxpar),dummy(ipadd)
      common /elemts/ elemnt(107)
      common /last/ last
      common /mesage/ iflepo,iscf
      common /symops/ r(14,120), nsym, ipo(numatm,120)
      common /simbol/ simbol(maxpar)
      common /cmpg/ geo(3,numatm)
      common /coord/ coord(3,numatm)
***********************************************************************
*
*   force calculates the force constants for the molecule, and the
*         vibrational frequencies.  isotopic substitution is allowed.
*
***********************************************************************
      common /euler/ tvec(3,3), id
      common /scftyp/ emin, limscf
      common /scrach/ store(maxpar**2)
      common /iofile/ mfgr,mfgw
      dimension xparam(maxpar), gr(3,numatm),
     1deldip(3,maxpar), trdip(3,maxpar),locold(2,maxpar)
     2,redmas(maxpar), shift(6), dipt(maxpar), travel(maxpar)
     3, rot(3,3), georef(3,numatm), nar(numatm), nbr(numatm),ncr(numatm)
      character keywrd*241, keys(241)*1, elemnt*2, simbol*10
      logical restrt, linear, debug, bartel, prnt, large, limscf
      equivalence (grad(1), gr(1,1)), (keywrd,keys(1))
c
c test geometry to see if it is optimized
      time2=-1.d9
      call gmetry(geo,coord)
      nvaold=nvar
      do 10 i=1,nvar
         locold(1,i)=loc(1,i)
   10 locold(2,i)=loc(2,i)
      nvar=0
      ndeold=ndep
      ndep=0
      numat=0
      if(labels(1) .ne. 99) numat=1
      do 30 i=2,natoms
         if(labels(i).eq.99) goto 30
         if(i.eq.2)ilim=1
         if(i.eq.3)ilim=2
         if(i.gt.3)ilim=3
c
c  is it a polymer?
c
         if(labels(i).eq.107) then
            ilim=1
         else
            numat=numat+1
         endif
c$doit asis
         do 20 j=1,ilim
            nvar=nvar+1
            loc(1,nvar)=i
            loc(2,nvar)=j
   20    xparam(nvar)=geo(j,i)
   30 continue
c
c   if a restart, then tscf and tder will be faulty, therefore set to -1
c
      tscf=-1.d0
      tder=-1.d0
      prnt=(index(keywrd,'rc=') .eq. 0)
      debug=(index(keywrd,'dforce') .ne. 0)
      large=(index(keywrd,'large') .ne. 0)
      bartel=(index(keywrd,'nllsq') .ne. 0)
      restrt=(index(keywrd,'restart') .ne. 0)
      time1=secmop()
      if (restrt) then
c
c   check to see if calculation is in nllsq or force.
c
         if(bartel)goto 50
c
c   calculation is in force
c
         goto 90
      endif
      call compfg( xparam, .true., escf, .true., grad, .false.)
      if(prnt)write(mfgw,
     +        '(//10x,''heat of formation ='',f12.6,
     1'' kcals/mole'')')escf
      time2=secmop()
      tscf=time2-time1
      call compfg( xparam, .true., escf1, .false., grad, .true.)
      time3=secmop()
      tder=time3-time2
      if(prnt)write(mfgw,'(//10x,
     +''internal coordinate derivatives'',//3x,
     1''number  atom'',2x,''bond'',9x,''  angle'',10x,''dihedral'',/)')
      l=0
      iu=0
      do 40 i=1,natoms
         if(labels(i).eq.99) goto 40
         l=l+1
         il=iu+1
         if(i .eq. 1) iu=il-1
         if(i .eq. 2) iu=il
         if(i .eq. 3) iu=il+1
         if(i .gt. 3) iu=il+2
         if(labels(i).eq.107)iu=il
         if(prnt)write(mfgw,'(i6,4x,a2,f13.6,2f13.6)')
     1l,elemnt(labels(i)),(grad(j),j=il,iu)
   40 continue
c   test sum of gradients
      gnorm=dsqrt(ddot(nvar,grad,1,grad,1))
      if(prnt)write(mfgw,'(//10x,''gradient norm ='',f10.5)') gnorm
      if(gnorm.lt.10.d0) goto 70
      if(index(keywrd,' let ') .ne. 0) then
         write(mfgw,
     +   '(///1x,''** gradient is very large, but since "let"'',
     1   '' is used, calculation will continue'')')
         goto 90
      endif
      write(mfgw,
     +    '(///1x,''** gradient is too large to allow '',
     1    ''force matrix to be calculated, (limit=10) **'',//)')
   50 continue
      do 60 i=1,nvar
   60 simbol(i)='---'
      write(mfgw,'(//10x,'' geometry will be optimized first'')')
      if(bartel) then
         write(mfgw,'(15x,''using nllsq'')')
         call nllsq(xparam,nvar)
      else
         write(mfgw,'(15x,''using flepo'')')
         call flepo(xparam,nvar,escf)
c
c  did flepo use all the time allowed?
c
         if(iflepo.eq.-1) return
      endif
      limscf=.false.
      call compfg( xparam, .true., escf, .true., grad, .true.)
      call writmo(time1,escf)
      write(mfgw,
     +  '(//10x,''gradient norm ='',f10.7)') gnorm
      call gmetry(geo,coord)
   70 continue
         do 80 j=1,natoms
      nar(j)=na(j)
      nbr(j)=nb(j)
      ncr(j)=nc(j)
      do 80 i=1,3
   80 georef(i,j)=geo(i,j)
c
c now to calculate the force matrix
c
c check out symmetry
   90 continue
c
c   need to ensure that mopxyz will work correctly before call
c   to drc.
c
      l=0
      do 100 i=1,natoms
         if(labels(i).ne.99)then
            l=l+1
            labels(l)=labels(i)
         endif
  100 continue
      natoms=numat
      call mopxyz(coord,numat,na,nb,nc,1.d0,geo)
      call gmetry(geo,coord)
      if(index(keywrd,'thermo').ne.0 .and.gnorm.gt.1.d0) then
         write(mfgw,'(//30x,''**** warning ****'',//
     110x,'' gradient is very large for a thermo calculation'',/
     210x,'' results are likely to be inaccurate if there are'')')
         write(mfgw,'(10x,
     +   '' any low-lying vibrations (less than about ''
     1,''400cm-1)'')')
         write(mfgw,
     +   '(10x,'' gradient norm should be less than about '',
     1''0.2 for thermo'',/10x,'' to give accurate results'')')
      endif
      if(tscf.gt.0.d0) then
         write(mfgw,
     +   '(//10x,''time for scf calculation ='',f8.2)')tscf
         write(mfgw,
     +   '(//10x,''time for derivatives     ='',f8.2)')tder
      endif
      if(ndep.gt.0) then
         write(mfgw,'(//10x,''symmetry was specified, but '',
     1''cannot be used here'')')
         ndep=0
      endif
      if(prnt.and. .not. oprint(28) )
     +   call axis(coord,numat,a,b,c,wtmol,2,rot)
      nvib=3*numat-6
      if(dabs(c).lt.1.d-20)nvib=nvib+1
      if(id.ne.0)nvib=3*numat-3
      if(prnt.and. .not. oprint(28) ) then
         write(mfgw,
     +   '(/9x,''orientation of molecule in force calculation'')')
         write(mfgw,'(/,4x,''no.'',7x,''atom'',9x,''x'',
     19x,''y'',9x,''z'',/)')
      endif
      l=0
      do 110 i=1,natoms
         if(labels(i) .eq. 99) goto 110
         l=l+1
         if(prnt.and. .not. oprint(28) )
     +   write(mfgw,'(i6,7x,i3,4x,3f10.4)')
     1    l,labels(i),(coord(j,l),j=1,3)
  110 continue
      call fmat(fmatrx, nvib, tscf, tder, deldip,escf)
      na(1)=0
         do 120 j=1,natoms
      na(j)=nar(j)
      nb(j)=nbr(j)
      nc(j)=ncr(j)
      do 120 i=1,3
  120 geo(i,j)=georef(i,j)
      if(nvib.lt.0)then
         ndep=ndeold
         nvar=0
         return
      endif
c
c   the force matrix is printed as an atom-atom matrix rather than
c   as a 3n*3n matrix, as the 3n matrix is very confusing!
c
      ij=0
      iu=0
      do 150 i=1,numat
         il=iu+1
         iu=il+2
         im1=i-1
         ju=0
         do 140 j=1,im1
            jl=ju+1
            ju=jl+2
            sum=0.0d0
c$doit asis
            do 130 ii=il,iu
c$doit asis
               do 130 jj=jl,ju
  130       sum=sum+fmatrx((ii*(ii-1))/2+jj)**2
            ij=ij+1
  140    store(ij)=dsqrt(sum)
         ij=ij+1
  150 store(ij)=dsqrt(
     1fmatrx(((il+0)*(il+1))/2)**2+
     2fmatrx(((il+1)*(il+2))/2)**2+
     3fmatrx(((il+2)*(il+3))/2)**2+2.d0*(
     4fmatrx(((il+1)*(il+2))/2-1)**2+
     5fmatrx(((il+2)*(il+3))/2-2)**2+
     6fmatrx(((il+2)*(il+3))/2-1)**2))
      if(debug) then
         write(mfgw,'(//10x,
     +   '' full force matrix, invoked by "dforce"'')')
         i=-nvar
         call vecprt(fmatrx,i)
      endif
      if(prnt.and. .not. oprint(28) )then
         write(mfgw,
     +   '(//10x,'' force matrix in millidynes/angstrom'')')
         call vecprt(store,numat)
      endif
      l=(nvar*(nvar+1))/2
      do 160 i=1,l
  160 store(i)=fmatrx(i)
      if(prnt) call axis(coord,numat,a,b,c,sum,0,rot)
      if(prnt)write(mfgw,
     +   '(//10x,''heat of formation ='',f12.6,
     1'' kcals/mole'')')escf
      if(large)then
         call mopfr(store,numat,0,shift)
         call rsp(store,nvar,nvar,freq,cnorml)
         do 170 i=nvib+1,nvar
            j=(freq(i)+50.d0)*0.01d0
  170    freq(i)=freq(i)-j*100
         if(prnt)then
            write(mfgw,'(//10x,''trivial vibrations, should be zero'')')
            write(mfgw,'(/, f9.4,''=tx'',f9.4,''=ty'',f9.4,''=tz'',
     1      f9.4,''=rx'',f9.4,''=ry'',f9.4,''=rz'')')
     2(     freq(i),i=nvib+1,nvar)
            write(mfgw,'(//10x,
     +      ''force constants in millidynes/angstrom'',
     +      '' (= 10**5 dynes/cm)'',/)')
            write(mfgw,'(8f10.5)')(freq(i),i=1,nvib)
c convert to weighted fmat
            write(mfgw,'(//10x,'' associated eigenvectors'')')
            i=-nvar
            call mopmat(cnorml,freq,nvib,i,nvar)
         endif
      endif
      call freqcy(fmatrx,freq,cnorml,redmas,travel,.true.,deldip)
c
c  calculate zero point energy
c
c
c  these constants taken from handbook of chemistry and physics 62nd ed.
c   n avogadro's number = 6.022045*10**23
c   h planck's constant = 6.626176*10**(-34)jhz
c   c speed of light    = 2.99792458*10**10 cm/sec
c   const=0.5*n*h*c/(1000*4.184)
      const=1.4295718d-3
      sum=0.0d0
      do 180 i=1,nvar
  180 sum=sum+freq(i)
      sum=sum*const
      if(prnt)
     1write(mfgw,'(//10x,'' zero point energy''
     2, f12.3,'' kilocalories per mole'')')sum
      summ=0.0d0
      do 230 i=1,nvar
         sum1=1.d-20
c$doit vbest
         do 190 j=1,nvar
  190    sum1=sum1+cnorml(j+(i-1)*nvar)**2
         sum1=1.d0/dsqrt(sum1)
c$doit asis
         do 200 k=1,3
  200    grad(k)=0.0d0
c$doit asis
         do 220 k=1,3
            sum=0.0d0
c$doit vbest
            do 210 j=1,nvar
  210       sum=sum+cnorml(j+(i-1)*nvar)*deldip(k,j)
            summ=summ+dabs(sum)
  220    trdip(k,i)=sum*sum1
         dipt(i)=dsqrt(trdip(1,i)**2+trdip(2,i)**2+trdip(3,i)**2)
  230 continue
      if(prnt)then
         write(mfgw,'(//3x,'' the last'',i2,
     +   '' vibrations are the'',
     +'' translation and rotation modes'')')nvar-nvib
         write(mfgw,
     +   '(3x,'' the first three of these being translations'',
     +'' in x, y, and z, respectively'')')
      endif
      if(prnt.and.large.and.oprint(28))then
         write(mfgw,'(//10x,'' frequencies, reduced masses and '',
     1''vibrational dipoles''/)')
         nto6=nvar/6
         nrem6=nvar-nto6*6
         iinc1=-5
         if (nto6.lt.1) go to 250
         do 240 i=1,nto6
            write (mfgw,'(/)')
            iinc1=iinc1+6
            iinc2=iinc1+5
            write (mfgw,'(3x,''i'',10i10)') (j,j=iinc1,iinc2)
            write (mfgw,'('' freq(i)'',6f10.4,/)') 
     +      (freq(j),j=iinc1,iinc2)
            write (mfgw,'('' mass(i)'',6f10.5,/)') 
     +      (redmas(j),j=iinc1,iinc2)
            write (mfgw,'('' dipx(i)'',6f10.5)') 
     +      (trdip(1,j),j=iinc1,iinc2)
            write (mfgw,'('' dipy(i)'',6f10.5)') 
     +      (trdip(2,j),j=iinc1,iinc2)
            write (mfgw,'('' dipz(i)'',6f10.5,/)') 
     +      (trdip(3,j),j=iinc1,iinc2)
            write (mfgw,'('' dipt(i)'',6f10.5)')
     1   (dipt(j),j=iinc1,iinc2)
  240    continue
  250    continue
         if (nrem6.lt.1) go to 260
         write (mfgw,'(/)')
         iinc1=iinc1+6
         iinc2=iinc1+(nrem6-1)
         write (mfgw,'(3x,''i'',10i10)') (j,j=iinc1,iinc2)
         write (mfgw,'('' freq(i)'',6f10.4)') (freq(j),j=iinc1,iinc2)
         write (mfgw,'(/,'' mass(i)'',6f10.5)') 
     +   (redmas(j),j=iinc1,iinc2)
         write (mfgw,'(/,'' dipx(i)'',6f10.5)') 
     +   (trdip(1,j),j=iinc1,iinc2)
         write (mfgw,'('' dipy(i)'',6f10.5)') (trdip(2,j),j=iinc1,iinc2)
         write (mfgw,'('' dipz(i)'',6f10.5)') (trdip(3,j),j=iinc1,iinc2)
         write (mfgw,'(/,'' dipt(i)'',6f10.5)')
     1   (dipt(j),j=iinc1,iinc2)
  260    continue
      endif
      if(prnt.and. .not. oprint(28) )then
         write(mfgw,'(//10x,'' normal coordinate analysis'')')
         i=-nvar
         call mopmat(cnorml,freq,nvar,i,nvar)
      endif
c
c   carry out irc if requested.
c
      if(index(keywrd,'irc')+index(keywrd,'drc').ne.0)then
         do 270 i=1,nvar
            loc(1,i)=0
  270    loc(2,i)=0
         nvar=nvaold
         do 280 i=1,nvar
            loc(1,i)=locold(1,i)
  280    loc(2,i)=locold(2,i)
         call mopxyz(coord,numat,na,nb,nc,1.d0,geo)
         last=1
         call drc(cnorml,freq)
         na(1)=0
         ndep=ndeold
         nvar=0
         do 290 i=1,3
            do 290 j=1,natoms
  290    geo(i,j)=georef(i,j)
         return
      endif
      call freqcy(fmatrx,freq,cnorml,deldip,deldip,.false.,deldip)
      if( .not. oprint(28) )
     +write(mfgw,
     +    '(//10x,'' mass-weighted coordinate analysis'')')
      i=-nvar
      if( .not. oprint(28) ) then
      call mopmat(cnorml,freq,nvar,i,nvar)
      call anavib(coord,freq,dipt,nvar,cnorml,store,
     1fmatrx,travel,redmas)
      endif
      if(index(keywrd,'thermo').ne.0) then
         call gmetry(geo,coord)
         i=index(keywrd,' rot')
         if(i.ne.0) then
            sym=reada(keywrd,i)
         else
            sym=1
         endif
         linear=(dabs(a*b*c) .lt. 1.d-10)
         i=index(keywrd,' trans')
c
c   "i" is going to mark the beginning of the genuine vibrations.
c
         if(i.ne.0)then
            i=index(keywrd,' trans=')
            if(i.ne.0)then
               i=1+reada(keywrd,i)
               j=nvib-i+1
               write(mfgw,'(//1x,''the lowest'',i3,
     +         '' vibrations are not'',
     1/,'' to be used in the thermo calculation'')')i-1
            else
               write(mfgw,'(//10x,''system is a transition state'')')
               i=2
               j=nvib-1
            endif
         else
            write(mfgw,'(//10x,''system is a ground state'')')
            i=1
            j=nvib
         endif
         call moptho(a,b,c,linear,sym,wtmol,freq(i),j,escf)
      endif
      na(1)=0
      nvar=0
      ndep=ndeold
      do 300 i=1,3
         do 300 j=1,natoms
  300 geo(i,j)=georef(i,j)
      return
      end
      subroutine formxy(w,kr,wca,wcb,ca,na,cb,nb)
      implicit REAL (a-h,o-z)
      dimension w(100), wca(na), wcb(nb), ca(na), cb(nb)
c***********************************************************************
c
c    each of the na elements of wca will add on the nb electrostatic
c    terms from atom b in cb
c
c    each of the nb elements of wcb will add on the na electrostatic
c    terms from atom a in ca
c
c    both sums will involve the na*nb terms in array w.  once used,
c    w will be incremented by na*nb.
c
c na=1 if atom 'a' is a hydrogen, na=10 if atom 'a' is not a hydrogen
c nb=1 if atom 'b' is a hydrogen, nb=10 if atom 'b' is not a hydrogen
c
c***********************************************************************
      common /keywrd/ keywrd
      common /numcal/ numcal
      logical mindo3
      character keywrd*241
      data icalcn/0/
      if(icalcn.ne.numcal)then
         icalcn=numcal
         mindo3=(index(keywrd,'mindo').ne.0)
      endif
      if(mindo3)then
         w1=w(1)*0.25d0
c
c   calculate the total number of electrons on atoms a and b
c
         pa=ca(1)
         pb=cb(1)
         if(na.gt.1.and.nb.gt.1)then
            pwa=(pa+ca(3)+ca(6)+ca(10))*w1
            pwb=(pb+cb(3)+cb(6)+cb(10))*w1
            wca(1)=wca(1)+pwb
            wca(3)=wca(3)+pwb
            wca(6)=wca(6)+pwb
            wca(10)=wca(10)+pwb
            wcb(1)=wcb(1)+pwa
            wcb(3)=wcb(3)+pwa
            wcb(6)=wcb(6)+pwa
            wcb(10)=wcb(10)+pwa
         elseif(na.gt.1)then
            pwb=pb*w1
            wca(1)=wca(1)+pwb
            wca(3)=wca(3)+pwb
            wca(6)=wca(6)+pwb
            wca(10)=wca(10)+pwb
            wcb(1)=wcb(1)+(pa+ca(3)+ca(6)+ca(10))*w1
         elseif(nb.gt.1)then
            pwa=pa*w1
            wca(1)=wca(1)+(pb+cb(3)+cb(6)+cb(10))*w1
            wcb(1)=wcb(1)+pwa
            wcb(3)=wcb(3)+pwa
            wcb(6)=wcb(6)+pwa
            wcb(10)=wcb(10)+pwa
         else
            wca(1)=wca(1)+pb*w1
            wcb(1)=wcb(1)+pa*w1
         endif
         kr=kr+1
         return
      endif
      if(na.gt.1.and.nb.gt.1)then
c
c   both atoms 'a' and 'b' are heavy atoms
c
c
c  this commented-out code runs slower on a scalar machine than the
c  explicit code actually used here.  the code commented out is provided
c  for users who want to vectorize the code
c
c#         ijp=0
c#         do 3 ii=1,4
c#         do 4 jj=1,ii
c#         ij=ijp*10
c#         ijp=ijp+1
c#         kl=-10+ijp
c#         sum1=0.0d0
c#         sum2=0.0d0
c#         ji=0
c#         do 10 i=1,4
c#            do 10 j=1,i
c#               ji=ji+1
c#               ij=ij+1
c#               kl=kl+10
c#               fact=1.d0
c#               if(i.eq.j)fact=0.5d0
c#               sum1=sum1+cb(ji)*w(ij)*fact
c#   10    sum2=sum2+ca(ji)*w(kl)*fact
c#      if(ii.eq.jj)then
c#      sum1=sum1*0.5d0
c#      sum2=sum2*0.5d0
c#      endif
c#      wca(ijp)=wca(ijp)+sum1
c#      wcb(ijp)=wcb(ijp)+sum2
c#   4  continue
c#   3  continue
c
c   start of explicit code
c
         wca(1)=wca(1)+
     10.25d0*(cb(1)*w(1) + cb(3)*w(3) + cb(6)*w(6) + cb(10)*w(10)) +
     20.5d0*( cb(2)*w(2) + cb(4)*w(4) + cb(5)*w(5) +
     3        cb(7)*w(7) + cb(8)*w(8) + cb(9)*w(9))
         wca(2)=wca(2)+
     10.5d0*(cb(1)*w(11) + cb(3)*w(13) + cb(6)*w(16) + cb(10)*w(20)) +
     2cb(2)*w(12) + cb(4)*w(14) + cb(5)*w(15) +
     3cb(7)*w(17) + cb(8)*w(18) + cb(9)*w(19)
         wca(3)=wca(3)+
     10.25d0*(cb(1)*w(21) + cb(3)*w(23) + cb(6)*w(26) + cb(10)*w(30)) +
     20.5d0*(cb(2)*w(22) + cb(4)*w(24) + cb(5)*w(25) +
     3       cb(7)*w(27) + cb(8)*w(28) + cb(9)*w(29))
         wca(4)=wca(4)+
     10.5d0*(cb(1)*w(31) + cb(3)*w(33) + cb(6)*w(36) + cb(10)*w(40)) +
     2cb(2)*w(32) + cb(4)*w(34) + cb(5)*w(35) +
     3cb(7)*w(37) + cb(8)*w(38) + cb(9)*w(39)
         wca(5)=wca(5)+
     10.5d0*(cb(1)*w(41) + cb(3)*w(43) + cb(6)*w(46) + cb(10)*w(50)) +
     2cb(2)*w(42) + cb(4)*w(44) + cb(5)*w(45) +
     3cb(7)*w(47) + cb(8)*w(48) + cb(9)*w(49)
         wca(6)=wca(6)+
     10.25d0*(cb(1)*w(51) + cb(3)*w(53) + cb(6)*w(56) + cb(10)*w(60)) +
     20.5d0*(cb(2)*w(52) + cb(4)*w(54) + cb(5)*w(55) +
     3       cb(7)*w(57) + cb(8)*w(58) + cb(9)*w(59))
         wca(7)=wca(7)+
     10.5d0*(cb(1)*w(61) + cb(3)*w(63) + cb(6)*w(66) + cb(10)*w(70)) +
     2cb(2)*w(62) + cb(4)*w(64) + cb(5)*w(65) +
     3cb(7)*w(67) + cb(8)*w(68) + cb(9)*w(69)
         wca(8)=wca(8)+
     10.5d0*(cb(1)*w(71) + cb(3)*w(73) + cb(6)*w(76) + cb(10)*w(80)) +
     2cb(2)*w(72) + cb(4)*w(74) + cb(5)*w(75) +
     3cb(7)*w(77) + cb(8)*w(78) + cb(9)*w(79)
         wca(9)=wca(9)+
     10.5d0*(cb(1)*w(81) + cb(3)*w(83) + cb(6)*w(86) + cb(10)*w(90)) +
     2cb(2)*w(82) + cb(4)*w(84) + cb(5)*w(85) +
     3cb(7)*w(87) + cb(8)*w(88) + cb(9)*w(89)
         wca(10)=wca(10)+
     10.25d0*(cb(1)*w(91) + cb(3)*w(93) + cb(6)*w(96) + cb(10)*w(100)) +
     20.5d0*(cb(2)*w(92) + cb(4)*w(94) + cb(5)*w(95) +
     3       cb(7)*w(97) + cb(8)*w(98) + cb(9)*w(99))
         wcb(1)=wcb(1)+
     10.25d0*(ca(1)*w(1) + ca(3)*w(21) + ca(6)*w(51) + ca(10)*w(91)) +
     20.5d0*(ca(2)*w(11) + ca(4)*w(31) + ca(5)*w(41) +
     3       ca(7)*w(61) + ca(8)*w(71) + ca(9)*w(81))
         wcb(2)=wcb(2)+
     10.5d0*(ca(1)*w(2) + ca(3)*w(22) + ca(6)*w(52) + ca(10)*w(92)) +
     2ca(2)*w(12) + ca(4)*w(32) + ca(5)*w(42) +
     3ca(7)*w(62) + ca(8)*w(72) + ca(9)*w(82)
         wcb(3)=wcb(3)+
     10.25d0*(ca(1)*w(3) + ca(3)*w(23) + ca(6)*w(53) + ca(10)*w(93)) +
     20.5d0*(ca(2)*w(13) + ca(4)*w(33) + ca(5)*w(43) +
     3       ca(7)*w(63) + ca(8)*w(73) + ca(9)*w(83))
         wcb(4)=wcb(4)+
     10.5d0*(ca(1)*w(4) + ca(3)*w(24) + ca(6)*w(54) + ca(10)*w(94)) +
     2ca(2)*w(14) + ca(4)*w(34) + ca(5)*w(44) +
     3ca(7)*w(64) + ca(8)*w(74) + ca(9)*w(84)
         wcb(5)=wcb(5)+
     10.5d0*(ca(1)*w(5) + ca(3)*w(25) + ca(6)*w(55) + ca(10)*w(95)) +
     2ca(2)*w(15) + ca(4)*w(35) + ca(5)*w(45) +
     3ca(7)*w(65) + ca(8)*w(75) + ca(9)*w(85)
         wcb(6)=wcb(6)+
     10.25d0*(ca(1)*w(6) + ca(3)*w(26) + ca(6)*w(56) + ca(10)*w(96)) +
     20.5d0*(ca(2)*w(16) + ca(4)*w(36) + ca(5)*w(46) +
     3       ca(7)*w(66) + ca(8)*w(76) + ca(9)*w(86))
         wcb(7)=wcb(7)+
     10.5d0*(ca(1)*w(7) + ca(3)*w(27) + ca(6)*w(57) + ca(10)*w(97)) +
     2ca(2)*w(17) + ca(4)*w(37) + ca(5)*w(47) +
     3ca(7)*w(67) + ca(8)*w(77) + ca(9)*w(87)
         wcb(8)=wcb(8)+
     10.5d0*(ca(1)*w(8) + ca(3)*w(28) + ca(6)*w(58) + ca(10)*w(98)) +
     2ca(2)*w(18) + ca(4)*w(38) + ca(5)*w(48) +
     3ca(7)*w(68) + ca(8)*w(78) + ca(9)*w(88)
         wcb(9)=wcb(9)+
     10.5d0*(ca(1)*w(9) + ca(3)*w(29) + ca(6)*w(59) + ca(10)*w(99)) +
     2ca(2)*w(19) + ca(4)*w(39) + ca(5)*w(49) +
     3ca(7)*w(69) + ca(8)*w(79) + ca(9)*w(89)
         wcb(10)=wcb(10)+
     10.25d0*(ca(1)*w(10) + ca(3)*w(30) + ca(6)*w(60) + ca(10)*w(100)) +
     20.5d0*(ca(2)*w(20) + ca(4)*w(40) + ca(5)*w(50) +
     3       ca(7)*w(70) + ca(8)*w(80) + ca(9)*w(90))
c
c   end of explicit code
c
      elseif(na.gt.1)then
c
c   atom 'a' is not a hydrogen, atom 'b' is a hydrogen
c
         sum=0.0d0
         ij=0
         do 20 i=1,4
            do 10 j=1,i-1
               ij=ij+1
               sum=sum+ca(ij)*w(ij)
   10       wca(ij)=wca(ij)+cb(1)*w(ij)*0.5d0
            ij=ij+1
            sum=sum+ca(ij)*w(ij)*0.5d0
   20    wca(ij)=wca(ij)+cb(1)*w(ij)*0.25d0
         wcb(1) =wcb(1)+sum*0.5d0
      elseif(nb.gt.1)then
c
         sum=0.0d0
         ij=0
         do 40 i=1,4
            do 30 j=1,i-1
               ij=ij+1
               sum=sum+cb(ij)*w(ij)
   30       wcb(ij)=wcb(ij)+ca(1)*w(ij)*0.5d0
            ij=ij+1
            sum=sum+cb(ij)*w(ij)*0.5d0
   40    wcb(ij)=wcb(ij)+ca(1)*w(ij)*0.25d0
         wca(1) =wca(1)+sum*0.5d0
      elseif(nb.gt.1)then
c
c   atom 'a' is a hydrogen, atom 'b' is not a hydrogen
c
      else
c
c   both atoms 'a' and 'b' are hydrogens
c
         wcb(1)=wcb(1)+ca(1)*w(1)*0.25d0
         wca(1)=wca(1)+cb(1)*w(1)*0.25d0
      endif
      kr=kr+na*nb
      return
      end
      subroutine forsav(time,deldip,ipt,fmatrx,coord,nvar,refh,
     1                  evecs,jstart,fconst)
      implicit REAL (a-h,o-z)
_IF(ipsc,tools)
      logical oroot
_ENDIF
INCLUDE(common/sizes)
INCLUDE(../m4/common/utilc)
      dimension fmatrx(*), deldip(3,*), coord(*), evecs(*), fconst(*)
************************************************************************
*
*  forsav saves and restores data used in the force calculation.
*
* on input time = total time elapsed since the start of the calculation.
*          ipt  = line of force matrix reached, if in write mode,
*               = 0 if in read mode.
*        fmatrx = force matrix
************************************************************************
      common /densty/ p(mpack), pa(mpack), pb(mpack)
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),
     1                nlast(numatm), norbs, nelecs,nalpha,nbeta,
     2                nclose,nopen,ndumy,fract
      common /iofile/ mfgr,mfgw
      character*80 getmop
_IF(ipsc,tools)
      if(oroot().and.odumpm) then
_ELSE
      if(odumpm) then
_ENDIF
      open(unit=9,file=getmop(3)
     +              ,status='unknown',form='unformatted')
      rewind 9
      open(unit=10,file=getmop(4)
     +              ,status='unknown',form='unformatted')
      rewind 10
      endif
      ir=9
      iw=9
      if( ipt .eq. 0 ) then
c
c   read in force data
c
_IF(ipsc,tools)
      if( oroot()) then
_ENDIF
         read(ir,end=20,err=20)time,ipt,refh
         linear=(nvar*(nvar+1))/2
         read(ir)(coord(i),i=1,nvar)
         read(ir,end=10,err=10)(fmatrx(i),i=1,linear)
         read(ir)((deldip(j,i),j=1,3),i=1,ipt)
         n33=nvar*nvar
         read(ir)(evecs(i),i=1,n33)
         read(ir)jstart,(fconst(i),i=1,nvar)
_IF(ipsc,tools)
       else
         write(mfgw,*)' restart not implemented in forsav'
         go to 21
       endif
_ENDIF
         return
      else
c
c    write force data
c
_IF(ipsc,tools)
        if(oroot().and.odumpm) then
_ELSE
        if(odumpm) then
_ENDIF
         rewind iw
         if(time.gt.1.d6)time=time-1.d6
         write(iw)time,ipt,refh
         linear=(nvar*(nvar+1))/2
         write(iw)(coord(i),i=1,nvar)
         write(iw)(fmatrx(i),i=1,linear)
         write(iw)((deldip(j,i),j=1,3),i=1,ipt)
         n33=nvar*nvar
         write(ir)(evecs(i),i=1,n33)
         write(ir)jstart,(fconst(i),i=1,nvar)
         linear=(norbs*(norbs+1))/2
         write(10)(pa(i),i=1,linear)
         if(nalpha.ne.0)write(10)(pb(i),i=1,linear)
         close(9)
         close(10)
         endif
      endif
      return
   10 write(mfgw,
     +'(10x,''insufficient data on disk files for a force '',
     1''calculation'',/10x,''restart. perhaps this started of as a '',
     2''force calculation '')')
      write(mfgw,'(10x,
     +''but the geometry had to be optimized first, '',
     1''in which case '',/10x,''remove the key-word "force".'')')
_IF(ipsc,tools)
         call pend
_ELSE
         stop
_ENDIF
   20 write(mfgw,'(//10x,''no restart file exists!'')')
_IF(ipsc,tools)
        call pend
_ELSE
        stop
_ENDIF
      end
      subroutine freqcy(fmatrx,freq,cnorml,redmas,travel,eorc,deldip)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      dimension fmatrx(*), redmas(*), freq(*), cnorml(*), travel(*)
     +,deldip(3,*)
      logical eorc
*********************************************************************
*
*  frce calculates the force constants and vibrational frequencies
*       for a molecule.  it uses the isotopic masses to weight the
*       force matrix
*
* on input   fmatrx   =  force matrix, of size numat*3*(numat*3+1)/2.
*
*********************************************************************
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),
     1                nlast(numatm), norbs, nelecs,nalpha,nbeta,
     2                nclose,nopen,ndumy,fract
      common /nllcom/ fmat2d(2*maxpar**2), vec(maxpar**2)
      common /symops/ r(14,120), nsym, ipo(numatm,120)
      common /atmass/ atmass(numatm)
      common /keywrd/ keywrd
      common /scrach/ oldf(maxpar**2)
      common /iofile/ mfgr,mfgw
      character keywrd*241
      dimension wtmass(maxpar), shift(6), sec(maxpar**2)
      equivalence (sec,oldf)
      save fact
      data fact/6.023d23/
c
c    conversion factor for speed of light and 2 pi.
c
      c2pi=1.d0/(2.998d10*3.141592653598d0*2.d0)
c now to calculate the vibrational frequencies
c
c   find conversion constants for mass weighted system
      if(index(keywrd,' group').ne.0) then
         call symt(fmatrx, deldip)
         if(index(keywrd,' freqcy').ne.0)then
         write(mfgw,'(a)')' symmetrized hessian matrix'
c#         i=-n3
c#         call vecprt(fmatrx,i)
   
c
c   the force matrix is printed as an atom-atom matrix rather than
c   as a 3n*3n matrix, as the 3n matrix is very confusing!
c
      ij=0
      iu=0
      do 159 i=1,numat
         il=iu+1
         iu=il+2
         im1=i-1
         ju=0
         do 149 j=1,im1
            jl=ju+1
            ju=jl+2
            sum=0.0d0
c$doit asis
            do 139 ii=il,iu
c$doit asis
               do 139 jj=jl,ju
  139       sum=sum+fmatrx((ii*(ii-1))/2+jj)**2
            ij=ij+1
  149    cnorml(ij)=dsqrt(sum)
         ij=ij+1
  159 cnorml(ij)=dsqrt(
     1fmatrx(((il+0)*(il+1))/2)**2+
     2fmatrx(((il+1)*(il+2))/2)**2+
     3fmatrx(((il+2)*(il+3))/2)**2+2.d0*(
     4fmatrx(((il+1)*(il+2))/2-1)**2+
     5fmatrx(((il+2)*(il+3))/2-2)**2+
     6fmatrx(((il+2)*(il+3))/2-1)**2))
      i=-numat
      call vecprt(cnorml,i)
         endif
      endif
      n3=3*numat
      l=0
      do 10 i=1,numat
         weight=1.4142136d0/dsqrt(atmass(i))
         wtmass(l+1)=weight
         wtmass(l+2)=weight
         wtmass(l+3)=weight
         l=l+3
   10 wtmass(l)=weight
c    convert to mass weighted fmatrx
      linear=0
      do 20 i=1,n3
         do 20 j=1,i
            linear=linear+1
            oldf(linear)=  fmatrx(linear)*1.d5
   20 fmatrx(linear)=fmatrx(linear)*wtmass(i)*wtmass(j)
c
c    1.d5 is to convert from millidynes/angstrom to dynes/cm.
c
c    diagonalize
      i=index(keywrd,' k=')
      if(i.ne.0)then
c
c  go into brillouin zone mode
c
         step=reada(keywrd,i)
         mono3=reada(keywrd(i:),index(keywrd(i:),','))*3
         call brlzon(fmatrx, fmat2d, n3, sec, vec, alband, mono3, step,1
     1)
         return
      endif
       call mopfr(fmatrx,numat,1, shift)
      call rsp(fmatrx,n3,n3,freq,cnorml)
      do 30 i=1,n3
         j=(freq(i)+50.d0)*0.01d0
   30 freq(i)=freq(i)-dfloat(j*100)
      do 40 i=1,n3
   40 freq(i)=freq(i)*1.d5
c
c    calculate reduced masses, store in redmas
c
      do 80 i=1,n3
         ii=(i-1)*n3
         sum=0.0d0
         do 70 j=1,n3
            jii=j+ii
            jj=(j*(j-1))/2
            do 50 k=1,j
   50       sum=sum+cnorml(jii)*oldf(jj+k)*cnorml(k+ii)
            do 60 k=j+1,n3
   60       sum=sum+cnorml(jii)*oldf((k*(k-1))/2+j)*cnorml(k+ii)
   70    continue
         sum1=sum*2.d0
         if(dabs(freq(i)).gt.dabs(sum)*1.d-20) then
            sum=1.d0*sum/freq(i)
         else
            sum=0.0d0
         endif
         freq(i)=dsign(dsqrt(fact*dabs(freq(i)))*c2pi,freq(i))
         if(dabs(freq(i)).lt.dabs(sum1)*1.d+20) then
            sum1=dsqrt(dabs(freq(i)/(sum1*1.d-5)))
         else
            sum1=0.0d0
         endif
         if(sum.lt.0.d0.or.sum.gt.100)sum=0.0d0
c
c 0.0063024=sqrt(2*a*b*c/n) where
c         a=1.196d8 = conversion of cm**(-1) to (ergs = dyne.angstroms)
c         b=1000.0  = millidynes to dynes
c         c=1.d8    = centimeters to angstroms
c         n=6.02205d23 = avogadro's number
         travel(i)=sum1*0.0063024d0
         if(travel(i).gt.1.d0)travel(i)=0.0d0
c#      write(6,*)travel(i)
   80 redmas(i)=sum
      if(index(keywrd,' group').ne.0) call syma(freq, cnorml)
      if(eorc) then
c
c    convert normal vectors to cartesian coordinates
c    (deleted) and normalize so that the total movement is 1.0 angstrom.
c
         ij=0
         do 110 i=1,n3
            sum=0.0d0
            j=0
            do 90 jj=1,numat
               sum1=0.0d0
               cnorml(ij+1)=cnorml(ij+1)*wtmass(j+1)
               sum1=sum1+cnorml(ij+1)**2
c
               cnorml(ij+2)=cnorml(ij+2)*wtmass(j+2)
               sum1=sum1+cnorml(ij+2)**2
c
               cnorml(ij+3)=cnorml(ij+3)*wtmass(j+3)
               sum1=sum1+cnorml(ij+3)**2
c
               j=j+3
               ij=ij+3
   90       sum=sum+dsqrt(sum1)
            sum=1.d0/dsqrt(sum)
            ij=ij-n3
            do 100 j=1,n3
               ij=ij+1
  100       cnorml(ij)=cnorml(ij)*sum
  110    continue
c
c          return hessian in millidynes/angstrom in fmatrx
c
         do 120 i=1,linear
  120    fmatrx(i)=oldf(i)*1.d-5
      else
c
c  return hessian as mass-weighted fmatrix
         linear=0
c
         do 130 i=1,n3
            do 130 j=1,i
               linear=linear+1
  130    fmatrx(linear)=oldf(linear)*1.d-5*wtmass(i)*wtmass(j)
      endif
      return
      end
c***********************************************************************
      subroutine fsub(n,x,fval)
      implicit REAL (a-h,o-z)
c***********************************************************************
c
c     calculate the fm(t). kindly supplied by rus pitzer and cleaned up
c     by k.m.merz in feb. 1989 at ucsf.
c
c     on input:  n = index
c                x = exponent
c     on output: fval = value of the function
c
c     for more details see: obara and saika j. chem. phys. 1986,84,3963
c***********************************************************************
      dimension ff(21),term(200),a(10),rt(10)
      data a0, a1s2, pie4, a1
     1   /0.0d0,0.5d0,0.7853981633974483096156608d0,1.0d0/
      data xsw /24.0d0/
      e=a1s2*dexp(-x)
      fac0=n
      fac0=fac0+a1s2
      if(x.gt.xsw) go to 50
c
c     use power series
c
   10 fac=fac0
      term0=e/fac
      sum=term0
      ku=(x-fac0)
      if(ku.lt.1) go to 30
c
c     sum increasing terms forwards
c
      do 20 k=1,ku
         fac=fac+a1
         term0=term0*x/fac
         sum=sum+term0
   20 continue
   30 i=1
      fac=fac+a1
      term(1)=term0*x/fac
      suma=sum+term(1)
      if(sum.eq.suma) go to 90
   40 i=i+1
      fac=fac+a1
      term(i)=term(i-1)*x/fac
      sum1=suma
      suma=suma+term(i)
      if(sum1-suma) 40,90,40
c
c     use asymptotic series
c
   50 sum=dsqrt(pie4/x)
      if(n.eq.0) go to 70
      fac=-a1s2
      do 60 k=1,n
         fac=fac+a1
         sum=sum*fac/x
   60 continue
   70 i=1
      term(1)=-e/x
      suma=sum+term(1)
      if(sum.eq.suma) go to 90
      fac=fac0
      ku=(x+fac0-a1)
      do 80 i=2,ku
         fac=fac-a1
         term(i)=term(i-1)*fac/x
         sum1=suma
         suma=suma+term(i)
         if(sum1.eq.suma) go to 90
   80 continue
c
c     xsw set too low. use power series.
c
      go to 10
c
c     sum decreasing terms backwards
c
   90 sum1=a0
      do 100 k=1,i
         sum1=sum1+term(i+1-k)
  100 continue
      ff(n+1)=sum+sum1
c
c     use recurrence relation
c
      if(n.eq.0) goto 120
      do 110 k=1,n
         fac0=fac0-a1
         ff(n+1-k)=(e+x*ff(n+2-k))/fac0
  110 continue
  120 fval=ff(n+1)
      return
      end
c****************************************************************
      subroutine genunm(u,n)
c****************************************************************
c
c     generate unit vectors over sphere. used by surfac only.
c
c****************************************************************
      implicit REAL (a-h,o-z)
      dimension u(3,n)
      pi=4.d0*datan(1.d0)
      nequat = dsqrt(n * pi)
      nvert = nequat/2
      nu = 0
      do 20 i = 1,nvert+1
         fi = (pi * (i-1)) / nvert
         z = dcos(fi)
         xy = dsin(fi)
         nhor = nequat * xy
         if (nhor .lt. 1) nhor = 1
         do 10 j = 1,nhor
            fj = (2.d0 * pi * (j-1)) / nhor
            x = dcos(fj) * xy
            y = dsin(fj) * xy
            if (nu .ge. n) go to 30
            nu = nu + 1
            u(1,nu) = x
            u(2,nu) = y
            u(3,nu) = z
   10    continue
   20 continue
   30 continue
      n = nu
      return
      end
      subroutine genunt(u,n)
      implicit REAL (a-h,o-z)
c
c     ---- generate unit vectors over sphere ----
c
      dimension u(3,n)
      nequat = dsqrt(n * 3.14159d0)
      nvert = 0.5d0 * nequat
      nu = 0
      do 20 i = 1,nvert+1
         fi = (3.14159d0 * (i-1)) / nvert
         z = dcos(fi)
         xy = dsin(fi)
         nhor = nequat * xy
         if (nhor .lt. 1) nhor = 1
         do 10 j = 1,nhor
            fj = (2.0d0 * 3.14159d0 * (j-1)) / nhor
            x = dcos(fj) * xy
            y = dsin(fj) * xy
            if (nu .ge. n) go to 30
            nu = nu + 1
            u(1,nu) = x
            u(2,nu) = y
            u(3,nu) = z
   10    continue
   20 continue
   30 continue
      n = nu
      return
      end
      subroutine geout(mode1)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
**********************************************************************
*
*   geout prints the current geometry.  it can be called any time,
*         from any point in the program and does not affect anything.
*
**********************************************************************
      common /cmpg/ geo(3,numatm)
      common /geokst/ natoms,labels(numatm),
     1na(numatm),nb(numatm),nc(numatm)
      common /geovar/ nvar,loc(2,maxpar),idumy,xparam(maxpar)
      common /path/ latom,lparam,react(200)
      common /densty/ p(mpack),pa(mpack),pb(mpack)
      common /corec/ core(107)
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),
     1                nlast(numatm), norbs, nelecs,nalpha,nbeta,
     2                nclose,nopen,ndumy,fract
      common /keywrd/ keywrd
      common /titles/ koment,title
      common /atomtx/ ltxt, txtatm(numatm)
      common /geosym/ ndep,locpar(maxpar),idepfn(maxpar),
     1                     locdep(maxpar)
      common /elemts/ elemnt(107)
      common /iofile/ mfgr,mfgw
      dimension coord(3,numatm), q2(numatm), loctmp(2,maxpar)
      character q(3)*2, elemnt*2, flag1*2, flag0*2, flagn*2, txtatm*8
      character keywrd*241, koment*81, title*81, blank*80, ltxt*1
      logical cart
      mode=mode1
      if(mode.eq.1)then
         flag1=' *'
         flag0='  '
         flagn=' +'
         iprt=6
      else
         flag1=' 1'
         flag0=' 0'
         flagn='-1'
         iprt=iabs(mode)
      endif
c
c *** output the parameter data.
c
      cart=.false.
      if(na(1).ne.0) then
         cart=.true.
         call mopxyz(geo,natoms,na,nb,nc,1.d0,coord)
         loctmp(1,1)=2
         loctmp(2,1)=1
         loctmp(1,2)=3
         loctmp(2,2)=1
         loctmp(1,3)=3
         loctmp(2,3)=2
         nvartm=0
         do 10 i=4,natoms
            nvartm=nvartm+3
            do 10 j=1,3
               loctmp(1,nvartm+j)=i
   10    loctmp(2,nvartm+j)=j
         nvartm=nvartm+3
      else
         do 20 i=1,nvar
            loctmp(1,i)=loc(1,i)
   20    loctmp(2,i)=loc(2,i)
         nvartm=nvar
         do 30 j=1,3
c$dout vbest
            do 30 i=1,natoms
   30    coord(j,i)=geo(j,i)
      endif
      degree=57.29577951d00
      maxtxt=ichar(ltxt)
      blank=' '
      if(mode.eq.1)then
         write (mfgw,40)blank(:max(2,maxtxt-4)),
     1                  blank(:max(4,maxtxt-2)),
     2                  blank(:max(18,maxtxt+12))
   40    format (/4x,'atom',3x,'chemical',a ,'bond length',4x,'bond angl
     1e',4x ,' twist angle',/3x,'number',2x,'symbol', a,'(angstroms)',5
     2x,'(degrees)',5x,' (degrees)',/4x,'(i)',a,'na:i',10x,'nb:na:i',5
     3x,' nc:nb:na:i',5x,'na',3x,'nb',3x,'nc',/)
      else
         if(mode.gt.0)call wrttxt(iprt)
      endif
      if(mode.ne.1)then
         call chrge(p,q2)
         do 50 i=1,numat
            l=nat(i)
   50    q2(i)=core(l) - q2(i)
      endif
      n=1
      ia=loctmp(1,1)
      ii=0
      do 80 i=1,natoms
         do 60 j=1,3
            q(j)=flag0
            if (ia.ne.i) go to 60
            if (j.ne.loctmp(2,n).or.n.gt.nvartm) go to 60
            q(j)=flag1
            n=n+1
            ia=loctmp(1,n)
   60    continue
         w = coord(2,i) * degree
         x = coord(3,i) * degree
c
c  constrain angle to domain 0 - 180 degrees
c
         w=w - aint(w/360.d0)*360.d0
         if(w.lt.0)w=w+360.d0
         if(w .gt. 180.d0) then
            x=x+180.d0
            w=360.d0-w
         endif
c
c  constrain dihedral to domain -180 - 180 degrees
c
         x=x - aint(x/360.d0+dsign(0.5d0-1.d-9,x)-1.d-9)*360.d0
         if (latom.ne.i) go to 70
         j=lparam
         q(j)=flagn
   70    continue
         blank=elemnt(labels(i))//txtatm(i)//'  '
         if(mode.ne.1)then
            j=max(4,maxtxt+2)
            k=max(0,8-j)
         else
            j=max(9,maxtxt+3)
         endif
         if(labels(i).ne.0)then
            if(mode.ne.1)then
               if(labels(i).ne.99.and.labels(i).ne.107)then
                  ii=ii+1
                  write (iprt,'(1x,a,f11.7,1x,a2,f14.6,1x,a2,f14.6,1x,
     1a2,3i5,a,f7.4)') blank(:j),coord(1,i),q(1),w,q(2),x,q(3),
     2na(i),nb(i),nc(i),blank(20:20+k),q2(ii)
               else
                  write (iprt,'(1x,a,f11.7,1x,a2,f14.6,1x,a2,f14.6,1x,
     1a2,3i5)') blank(:j),coord(1,i),q(1),w,q(2),x,q(3),
     2na(i),nb(i),nc(i)
               endif
            elseif(i.gt.3)then
               write (mfgw,
     +         '(3x,i4 ,5x,a,f9.5,1x,a2,f14.5,1x,a2,f11.5,1x,
     1a2,i4,2i5)') i,blank(:j),coord(1,i),q(1),w,q(2),x,q(3),
     2na(i),nb(i),nc(i)
            elseif(i.eq.3)then
               write (mfgw,
     +         '(''      3'',5x,a,f9.5,1x,a2,f14.5,1x,a2,13x,
     12i5)') blank(:j),coord(1,3),q(1),w,q(2),na(3),nb(3)
            elseif(i.eq.2)then
               write (mfgw,
     +         '(''      2'',5x,a,f9.5,1x,a2,30x,i5)')
     1 blank(:j),coord(1,2),q(1),na(2)
            else
               write (mfgw,'(''      1'',5x,a)') blank(:j)
            endif
         endif
   80 continue
      if(cart) na(1)=99
      if(mode.eq.1) return
      write (iprt,*)
      if(ndep.eq.0) return
c
c   output symmetry data.
c
      i=1
   90 j=i
  100 if(j.eq.ndep) goto 110
      if(locpar(j).eq.locpar(j+1).and.idepfn(j).eq.idepfn(j+1)
     1.and.j-i.lt.15)then
         j=j+1
         goto 100
      else
         write(iprt,'(i4,i3,i5,15i4)')
     1locpar(i),idepfn(i),(locdep(k),k=i,j)
      endif
      i=j+1
      goto 90
  110 continue
      write(iprt,'(i4,i3,i5,15i4)')
     1locpar(i),idepfn(i),(locdep(k),k=i,j)
      return
      end
      subroutine geoutg(iprt,style)
      implicit REAL (a-h,o-z)
      logical style
INCLUDE(common/sizes)
      common /geokst/ natoms,labels(numatm),
     1                na(numatm),nb(numatm),nc(numatm)
      common /geovar/ nvar,loc(2,maxpar),idumy,dumy(maxpar)
      common /simbol/ simbol(maxpar)
      common /geosym/ ndep,locpar(maxpar),idepfn(maxpar),locdep(maxpar)
      common /atomtx/ ltxt, txtatm(numatm)
      common /cmpg/ geo(3,numatm)
************************************************************************
*
*   geoutg writes out the geometry in gaussian-8x (style = .false.)
*   or gamess-uk style (style=.true)
*
************************************************************************
      dimension igeo(3,numatm)
      character line(3,numatm)*15, type(3)*1, optdat(maxpar)*14
      character txtatm*8, blank*80, elemnt(107)*2, simbol*10, ltxt*1
      data elemnt/' h','he',
     1 'li','be',' b',' c',' n',' o',' f','ne',
     2 'na','mg','al','si',' p',' s','cl','ar',
     3 ' k','ca','sc','ti',' v','cr','mn','fe','co','ni','cu',
     4 'zn','ga','ge','as','se','br','kr',
     5 'rb','sr',' y','zr','nb','mo','tc','ru','rh','pd','ag',
     6 'cd','in','sn','sb','te',' i','xe',
     7 'cs','ba','la','ce','pr','nd','pm','sm','eu','gd','tb','dy',
     8 'ho','er','tm','yb','lu','hf','ta',' w','re','os','ir','pt',
     9 'au','hg','tl','pb','bi','po','at','rn',
     1 'fr','ra','ac','th','pa',' u','np','pu','am','cm','bk','cf','xx',
     2 'fm','md','cb','++',' +','--',' -','tv'/
      data type/'r','a','d'/
      do 10 i=1,natoms
         do 10 j=1,3
   10 igeo(j,i)=-1
      do 20 i=1,nvar
   20 igeo(loc(2,i),loc(1,i))=-2
      do 30 i=1,ndep
         if(idepfn(i).eq.14)then
            igeo(3,locdep(i))=-locpar(i)
         else
            if(idepfn(i).gt.3) goto 30
            igeo(idepfn(i),locdep(i))=locpar(i)
         endif
   30 continue
      open(unit=21,status='unknown')
      degree=90.d0/dasin(1.d0)
      maxtxt=ichar(ltxt)
      nopt=0
      if(style) write (iprt,'(a)')'zmatrix angstrom'
      do 50 i=1,natoms
         do 40 j=1,3
            line(j,i)=' '
            if(igeo(j,i).eq.-1)then
               rewind 21
               if(j.ne.1)then
                  write(21,'(f12.6)')geo(j,i)*degree
               else
                  write(21,'(f12.6)')geo(j,i)
               endif
               rewind 21
               read(21,'(a)')line(j,i)
            elseif(igeo(j,i).eq.-2)then
               nopt=nopt+1
               if(simbol(nopt).ne.'---')then
               if(simbol(nopt)(1:1).eq.'-') then
                 line(j,i)(4:)=simbol(nopt)(2:)
               else
                 line(j,i)(4:)=simbol(nopt)
               endif
               else
                  nbi=nb(i)
                  nci=nc(i)
                  if(j.ne.3)nci=0
                  if(j.eq.1)nbi=0
                  call xxx(type(j),i,na(i),nbi,nci,line(j,i)(4:))
               endif
               optdat(nopt)=line(j,i)
            elseif(igeo(j,i).lt.0)then
               line(3,i)=line(3,-igeo(j,i))
               line(3,i)(3:3)='-'
            else
               line(j,i)=line(j,igeo(j,i))
            endif
   40    continue
         blank=elemnt(labels(i))//txtatm(i)//'  '
         if(labels(i).eq.99)blank(1:1)=' '
         j=max(4,maxtxt+2)
         if(i.eq.1)then
            write(iprt,'(1x,a,i4,a,i4,a,i4,a,i4)')blank(:j)
         elseif(i.eq.2)then
            write(iprt,'(1x,a,i4,a,i4,a,i4,a,i4)')blank(:j),na(i),line(1
     1,i)
         elseif(i.eq.3)then
            write(iprt,'(1x,a,i4,a,i4,a,i4,a,i4)')blank(:j),
     1na(i),line(1,i),nb(i), line(2,i)
         else
            l=0
            write(iprt,'(1x,a,i4,a,i4,a,i4,a,i4)')blank(:j),
     1na(i),line(1,i),nb(i), line(2,i), nc(i), line(3,i), l
         endif
   50 continue
      if (style) then
       write(iprt,'(a)')'variables'
      else
       write(iprt,*)
      endif
      do 70 l=1,3
         do 60 i=1,nopt
            if(loc(2,i).eq.l)then
               if(loc(2,i).ne.1)then
                  write(iprt,'(a,f12.6)')optdat(i),geo(loc(2,i),loc(1,i)
     1)*degree
               else
                  write(iprt,'(a,f12.6)')optdat(i),geo(loc(2,i),loc(1,i)
     1)
               endif
            endif
   60    continue
   70 continue
      if (style) write(iprt,'(a)')'end'
      end
_IFN(ipsc,tools)
      subroutine getdat(gamess)
      implicit REAL (a-h,o-z)
      logical gamess
      common / readme / ird
      common/iofile/iread,iwrite
      character line*80
************************************************************************
*
*   getdat reads all the data in on channel iread, and writes it to scratch
*   channel 99.  this way the original data-set is freed up as soon as
*   the job starts.
*
************************************************************************
      data i,iiread/0,0/
      save i,iiread
c#      write(6,*)getmop('for005')
      ird = 99
      open(unit=ird,form='formatted',status='scratch')
c
c  close unit 5 in case it was already pre-assigned.
c
c     close (5)
c     open(unit=5,status='scratch')
c     rewind 5
c     rewind 2
      rewind ird
c  10 read(2,'(a80)',end=20,err=20)line
      rewind iread
   10 read(iread,'(a80)',end=20,err=20)line
      iiread = iiread + 1
      if(index(line,'mopac').eq.0) go to 10
c  30 read(5,'(a80)',end=20,err=20)line
   30 read(iread,'(a80)',end=20,err=20)line
      if(index(line(1:10),'gamess').eq.0) go to 35
      gamess = .true.
      rewind iread
      do 37 loop = 1,iiread+1
   37 read(iread,'(a80)')line
      goto 20
c   re-position gamess input file
   35 iiread = iiread + 1
      i=i+1
       call lcase(line(1:80))
      write(ird,'(a80)')line
      goto 30
   20 rewind ird
      if(i.lt.3)then
         write(6,'(a)')' input file missing or empty'
         call caserr('input file missing or empty')
      endif
c     close (2)
      return
      end
_ELSE
_IF(ipsc)
      subroutine getdat(gamess)
      implicit REAL (a-h,o-z)
      logical gamess,oroot
      common/nodinf/mpid,minode,mihost,dim,nnodes
      common / readme / ird
      common/iofile/iread,iwrite
      character line*80
************************************************************************
*
*   getdat reads all the data in on channel iread, and writes
*   it to scratch channel 99.  this way the input data-set is
*   freed up as soon as  the job starts.
*
************************************************************************
      data i,iiread/0,0/
      save i,iiread
c
      ird = 99
      if(oroot()) then
      print *,' just opened datain  for node ',minode
      open(unit=ird,form='formatted',status='unknown',file='datain')
      rewind ird
   30 read(5,'(a80)',end=20,err=20)line
      i=i+1
      write(ird,'(a80)')line
      goto 30
   20 rewind ird
      if(i.lt.3)then
         write(6,'(a)')' input file missing or empty'
         call caserr('input file missing or empty')
      endif
      endif
c
      call gsync
c
      if(.not.oroot()) then
        open(unit=ird,iostat=ioerr,form='formatted',access='sequential',
     * status='unknown',file='datain')
        if(ioerr.ne.0) call caserr(
     + 'error opening  data input file')
        print *,' just opened datain  for node ',minode
        rewind ird
      endif
c
      call gsync
      return
      end
_ELSE
      subroutine getdat(gamess)
      implicit REAL  (a-h,p-w),integer   (i-n),logical    (o)
      implicit character *8 (z),character *1 (x)
      implicit character *4 (y)
      logical gamess
      common/nodinf/mpid,minode,mihost,ldim,nnodes
      common / readme / ird
      common/iofile/iread,iwrite
      character *10 chpid
      character *80 rec80,ginput
      integer pid,getpid
      dimension ibuff(80)
************************************************************************
*
*   getdat reads all the data in on channel iread, and writes
*   it to scratch channel 99.  this way the input data-set is
*   freed up as soon as  the job starts.
*
************************************************************************
      data irec/0/
      save irec
c
      ird = 99
c
c --- write a copy of the input to unit ird
c
      pid=getpid()
      write(chpid,'(i10)')pid
      do 1020 i=1,10
      if(chpid(i:i).ne.' ') then
      length=i
      go to 1030
      endif
1020  continue
1030  ginput='mopac_input.'//chpid(length:10)
      open(unit=ird,form='formatted',file=ginput,status='unknown')
c
      call synch(22222)
c
c broadcast input file
c
 1060 continue
      if(oroot())then
         read(iread,1080,end=1091) rec80
         do 10 i=1,nnodes-1
            call chtoi(ibuff(1),rec80)
            call snd(150,ibuff,80*4,i,0)
 10      continue
      else
         call rcv(150,ibuff,80*4,il,0,if,0)
         if(ibuff(1).eq.0)goto 1090
         call itoch(ibuff(1),rec80)
      endif
      write(ird,1080)rec80
      irec = irec + 1
      go to 1060
1080  format(a80)
 1091 continue
      ibuff(1)=0
      do 11 i=1,nnodes-1
         call snd(150,ibuff,80*4,i,0)
 11   continue
 1090 continue
      if(irec.lt.3)then
         write(6,'(a)')' input file missing or empty'
         call caserr('input file missing or empty')
      endif
      call synch(33333)
      rewind ird
      return
      end
_ENDIF
_ENDIF
      subroutine getgeg(iread,labels,geo,na,nb,nc,ams,natoms,int)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      dimension geo(3,*),na(*),nb(*),nc(*),ams(*)
     1,labels(*)
      common /geosym/ ndep, locpar(maxpar), idepfn(maxpar),
     1                locdep(maxpar)
      common /simbol/ simbol(maxpar)
      common /atmass/ atmass(numatm)
      common /atomtx/ ltxt, txtatm(numatm)
      common /geovar/ nvar, loc(2,maxpar), idumy, xparam(maxpar)
      common /iofile/ mfgr,mfgw
      dimension istart(20), lgeo(3,100)
      character line*80, tgeo(3,100)*12, txtatm*8, string*80, simbol*10
      logical leadsp, int
      character elemnt(107)*2, ltxt*1
      data (elemnt(i),i=1,107)/' h','he',
     1 'li','be',' b',' c',' n',' o',' f','ne',
     2 'na','mg','al','si',' p',' s','cl','ar',
     3 'k ','ca','sc','ti',' v','cr','mn','fe','co','ni','cu',
     4 'zn','ga','ge','as','se','br','kr',
     5 'rb','sr',' y','zr','nb','mo','tc','ru','rh','pd','ag',
     6 'cd','in','sn','sb','te',' i','xe',
     7 'cs','ba','la','ce','pr','nd','pm','sm','eu','gd','tb','dy',
     8 'ho','er','tm','yb','lu','hf','ta',' w','re','os','ir','pt',
     9 'au','hg','tl','pb','bi','po','at','rn',
     1 'fr','ra','ac','th','pa','u','np','pu','am','cm','bk','cf','xx',
     2 'fm','md','cb','++',' +','--',' -','tv'/
      nerr=0
      int=.true.
      numat=0
      na(1)=0
      nb(1)=0
      nc(1)=0
      nb(2)=0
      nc(2)=0
      nc(3)=0
      maxtxt=0
      do 60 natoms=1,100
         read(iread,'(a)',end=70,err=70)line
         if(line.eq.' ')goto 70
c
c   see if text is associated with this element
c
         i=index(line,'(')
         if(i.ne.0)then
c
c  yes, element is labelled.
c
            k=index(line,')')
            txtatm(natoms)=line(i:k)
            maxtxt=max(maxtxt,k-i+1)
            string=line(1:i-1)//line(k+1:)
            line=string
         else
            txtatm(natoms)=' '
         endif
************************************************************************
         do 10 i=1,80
            iline=ichar(line(i:i))
            if(iline.ge.ichar('a').and.iline.le.ichar('z')) then
               line(i:i)=char(iline+ichar('a')-ichar('a'))
            endif
   10    continue
************************************************************************
         nvalue=0
         leadsp=.true.
         do 20 i=1,80
            if (leadsp.and.line(i:i).ne.' ') then
               nvalue=nvalue+1
               istart(nvalue)=i
            end if
            leadsp=(line(i:i).eq.' ')
   20    continue
         do 30 j=1,107
   30    if(index(' '//line(istart(1):istart(1)+2),elemnt(j)//' ').ne.0)
     1 goto 40
         if(index(' '//line(istart(1):istart(1)+2),' x').ne.0) then
            j=99
            goto 40
         endif
         write(mfgw,'(2a)')' element not recognized: ',
     1line(istart(1):istart(1)+2)
         nerr=nerr+1
   40    labels(natoms)=j
         if(j.ne.99)then
            numat=numat+1
            atmass(numat)=reada(line(1:max(istart(2)-1,1)),istart(1))
            if(atmass(numat).gt.1.d-15)then
               write(mfgw,'('' for atom'',i4,''  isotopic mass:''
     1    ,f15.5)')natoms, atmass(numat)
            else
               atmass(numat)=ams(j)
            endif
c#         write(6,*)natoms,numat,atmass(numat)
         endif
         tgeo(1,natoms)=' '
         tgeo(2,natoms)=' '
         tgeo(3,natoms)=' '
         if(natoms.eq.1) goto 50
         na(natoms)=reada(line,istart(2))
         call getval(line(istart(3):),geo(1,natoms),tgeo(1,natoms))
         if(natoms.eq.2) goto 50
         nb(natoms)=reada(line,istart(4))
         call getval(line(istart(5):),geo(2,natoms),tgeo(2,natoms))
         if(natoms.eq.3) goto 50
         nc(natoms)=reada(line,istart(6))
         call getval(line(istart(7):),geo(3,natoms),tgeo(3,natoms))
   50    continue
   60 continue
   70 natoms=natoms-1
      do 80 i=1,natoms
         do 80 j=1,3
   80 lgeo(j,i)=-1
      ivar=-1
      nvar=0
      ndep=0
      kerr=0
   90 read(iread,'(a)',end=180,err=180)line
      if(line.eq.' ')then
         if(ivar.eq.-1)then
            merr=0
            do 110 i=1,natoms
               do 100 j=1,3
  100          if(geo(j,i).lt.-998)merr=merr+1
  110       continue
c
c  if all symbols are defined, then do not read 'fixed' symbols
c
            if(merr.eq.0) goto 180
            ivar=nvar
            goto 90
         else
            goto 180
         endif
      endif
************************************************************************
      do 120 i=1,80
         iline=ichar(line(i:i))
         if(iline.ge.ichar('a').and.iline.le.ichar('z')) then
            line(i:i)=char(iline+ichar('a')-ichar('a'))
         endif
  120 continue
************************************************************************
      do 130 i=1,80
  130 if(line(i:i).ne.' ')goto 140
  140 do 150 l=i,i+12
  150 if(line(l:l).eq.' ')goto 160
  160 sum=reada(line,l)
      n=0
      lerr=0
      do 170 j=1,natoms
         do 170 k=1,3
            if(tgeo(k,j).eq.line(i:l) .or.
     1tgeo(k,j)(2:).eq.line(i:l).and.tgeo(k,j)(1:1).eq.'-')then
               if(lgeo(k,j).ne.-1)lerr=1
               lgeo(k,j)=lgeo(k,j)+1
               n=n+1
               geo(k,j)=sum
               if(n.eq.1)then
                  nvar=nvar+1
                  loc(1,nvar)=j
                  loc(2,nvar)=k
                  xparam(nvar)=sum
                  simbol(nvar)=tgeo(k,j)
                  if(simbol(nvar)(1:1).eq.'-')then
      write(mfgw,'(a)')' negative symbolics must be preceeded by '
     +//' the positive equivalent'
                  write(mfgw,
     +            '(a)')' faulty symbolic:  '//simbol(nvar)
_IF(ipsc,tools)
               call pend
_ELSE
               stop
_ENDIF
               endif
               endif
               if(n.gt.1)then
                  ndep=ndep+1
                  locpar(ndep)=loc(1,nvar)
                  idepfn(ndep)=loc(2,nvar)
                  if(tgeo(k,j)(1:1).eq.'-')then
                     idepfn(ndep)=14
                     if(loc(2,nvar).ne.3) then
                        kerr=kerr+1
                        write(mfgw,
     +                  '(2a)')' only dihedral symbolics can be'
     1//' preceeded by a "-" sign'
                     endif
                  endif
                  locdep(ndep)=j
               endif
            endif
  170 continue
      kerr=kerr+lerr
      if(lerr.eq.1)then
         write(mfgw,'(2a)')
     +' the following symbol has been defined more'//
     1' than once:',line(i:l)
         nerr=nerr+1
      endif
      if(n.eq.0)then
         write(mfgw,
     +   '(2a)')' the following symbolic was not used:',line(i:l)
         nerr=nerr+1
      endif
      goto 90
  180 continue
      merr=0
      do 200 i=1,natoms
         do 190 j=1,3
  190    if(geo(j,i).lt.-998)merr=merr+1
c#     write(mfgw,'(2x,a,3f12.6,3i4)')elemnt(labels(i)),
c#     1(geo(j,i),j=1,3), na(i), nb(i), nc(i)
  200 continue
      if(merr.ne.0)write(mfgw,
     +'(i4,a)')merr, ' geometry variables were not'
     1//' defined'
      if(merr+kerr+nerr.ne.0)then
         write(mfgw,'(a,i3,a)')
     1' the geometry data-set contained',merr+kerr+nerr,' errors'
_IF(ipsc,tools)
         call pend
_ELSE
         stop
_ENDIF
      endif
c
c  sort parameters to be optimized into increasing order of atoms
c
      if(ivar.ne.-1)nvar=ivar
      do 230 i=1,nvar
         j=100000
         do 210 l=i,nvar
            if(j.gt.loc(1,l)*4+loc(2,l))then
               k=l
               j=loc(1,l)*4+loc(2,l)
            endif
  210    continue
         string(1:10)=simbol(i)
         simbol(i)=simbol(k)
         simbol(k)=string
         sum=xparam(i)
         xparam(i)=xparam(k)
         xparam(k)=sum
         do 220 j=1,2
            l=loc(j,i)
            loc(j,i)=loc(j,k)
  220    loc(j,k)=l
  230 continue
c#      if(nvar.ne.0)write(mfgw,
c    +  '(//,''    parameters to be optimized'')')
      degree=dasin(1.d0)/90
      do 240 i=1,nvar
c#      write(6,'(2i6,f12.6)')loc(1,i),loc(2,i),xparam(i)
  240 if(loc(2,i).ne.1)xparam(i)=xparam(i)*degree
c#      if(ndep.ne.0)write(6,'(//,''   symmetry functions  '')')
c#      do 28 i=1,ndep
c#   28 write(6,'(3i6)')locpar(i),idepfn(i),locdep(i)
      ltxt=char(maxtxt)
      return
      end
      subroutine getgeo(iread,labels,geo,lopt,na,nb,nc,ams,natoms,int)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      dimension geo(3,*),na(*),nb(*),nc(*),ams(*), lopt(3,*)
     1,labels(*)
      logical int
************************************************************************
*
*   getgeo reads in the geometry. the element is specified by it's
*          chemical symbol, or, optionally, by it's atomic number.
*
*  on input   iread  = channel number for read, normally 5
*             ams    = default atomic masses.
*
* on output labels = atomic numbers of all atoms, including dummies.
*           geo    = internal coordinates, in angstroms, and degrees.
*           lopt   = integer array, a '1' means optimize this parameter,
*                    '0' means do not optimize, and a '-1' labels the
*                    reaction coordinate.
*           na     = integer array of atoms (see data input)
*           nb     = integer array of atoms (see data input)
*           nc     = integer array of atoms (see data input)
*           atmass = atomic masses of atoms.
************************************************************************
      common /path/ idum(2),react(3,66), dumm1,dumm2
      common /simbol/ simbol(maxpar)
      common /atmass/ atmass(numatm)
      common /atomtx/ ltxt, txtatm(numatm)
      common /keywrd/ keywrd
      common /iofile/ mfgr,mfgw
      dimension istart(40), xyz(3,numatm), value(4)
      logical leadsp, ircdrc
      character keywrd*241, txtatm*8, simbol*10, ltxt*1
      character elemnt(107)*2, line*80, space*1, nine*1,zero*1,
     1tab*1, comma*1, string*80, ele*2, turn*1
      save elemnt, comma, space, nine, zero
      data (elemnt(i),i=1,107)/'h','he',
     1 'li','be','b','c','n','o','f','ne',
     2 'na','mg','al','si','p','s','cl','ar',
     3 'k','ca','sc','ti','v','cr','mn','fe','co','ni','cu',
     4 'zn','ga','ge','as','se','br','kr',
     5 'rb','sr','y','zr','nb','mo','tc','ru','rh','pd','ag',
     6 'cd','in','sn','sb','te','i','xe',
     7 'cs','ba','la','ce','pr','nd','pm','sm','eu','gd','tb','dy',
     8 'ho','er','tm','yb','lu','hf','ta','w','re','os','ir','pt',
     9 'au','hg','tl','pb','bi','po','at','rn',
     1 'fr','ra','ac','th','pa','u','np','pu','am','cm','bk','cf','xx',
     2 'fm','md','cb','++','+','--','-','tv'/
      data comma,space,nine,zero/',',' ','9','0'/
      tab=char(9)
      ircdrc=(index(keywrd,'irc')+index(keywrd,'drc') .ne.0)
      ilowa = ichar('a')
      ilowz = ichar('z')
      icapa = ichar('a')
      icapz = ichar('z')
      maxtxt=0
      natoms=0
      numat=0
      iserr=0
      do 10 i=1,maxpar
   10 simbol(i)= '---'
   20 read(iread,'(a)',end=130,err=230)line
      if(line.eq.' ') go to 130
      natoms=natoms+1
c
c   see if text is associated with this element
c
      i=index(line,'(')
      if(i.ne.0)then
c
c  yes, element is labelled.
c
         k=index(line,')')
         txtatm(natoms)=line(i:k)
         maxtxt=max(maxtxt,k-i+1)
         string=line(1:i-1)//line(k+1:)
         line=string
      else
         txtatm(natoms)=' '
      endif
*   clean the input data
************************************************************************
      do 30 i=1,80
         iline=ichar(line(i:i))
         if(iline.ge.ilowa.and.iline.le.ilowz) then
            line(i:i)=char(iline+ilowa-icapa)
         endif
   30 continue
************************************************************************
      icomma=ichar(comma)
      itab=ichar(tab)
      do 40 i=1,80
         khar=ichar(line(i:i))
         if(khar.eq.icomma.or.khar.eq.itab)line(i:i)=space
   40 continue
*
*   initialize istart to interpret blanks as zero's
      do 50 i=1,10
   50 istart(i)=80
*
* find initial digit of all numbers, check for leading spaces followed
*     by a character and store in istart
      leadsp=.true.
      nvalue=0
      do 60 i=1,80
         if (leadsp.and.line(i:i).ne.space) then
            nvalue=nvalue+1
            istart(nvalue)=i
         end if
         leadsp=(line(i:i).eq.space)
****  THIS LINE leads to an error in mopac_2 ... WHY
****  if(leadsp.and.natoms.eq.1.and.nvalue.eq.1)line(i:)=' '
   60 continue
*
* establish the element's name and isotope, check for errors or e.o.data
*
      weight=0.0d0
      string=line(istart(1):istart(2)-1)
      if( string(1:1) .ge. zero .and. string(1:1) .le. nine) then
*  atomic number used: no isotope allowed
         label=reada(string,1)
         if (label.eq.0) go to 120
         if (label.lt.0.or.label.gt.107) then
            write(mfgw,'(''  illegal atomic number'')')
            go to 240
         end if
         go to 80
      end if
*  atomic symbol used
      real=dabs(reada(string,1))
      if (real.lt.1.d-15) then
*   no isotope
         ele=string(1:2)
      else
         weight=real
         if( string(2:2) .ge. zero .and. string(2:2) .le. nine) then
            ele=string(1:1)
         else
            ele=string(1:2)
         end if
      end if
*   check for error in atomic symbol
      if(ele(1:1).eq.'-'.and.ele(2:2).ne.'-')ele(2:2)=' '
      do 70 i=1,107
         if(ele.eq.elemnt(i)) then
            label=i
            go to 80
         end if
   70 continue
      if(ele(1:1).eq.'x')then
         label=99
         goto 80
      endif
      write(mfgw,
     +   '(''  unrecognized element name: ('',a,'')'')')ele
      goto 240
*
* all o.k.
*
   80 if (label.ne.99) numat=numat+1
      if(weight.ne.0.d0)then
         write(mfgw,'('' for atom'',i4,''  isotopic mass:''
     1    ,f15.5)')natoms, weight
         atmass(numat)=weight
      else
         if(label .ne. 99)  atmass(numat)=ams(label)
      endif
      if(natoms.gt.numatm)then
         write(mfgw,
     +   '(//10x,''****  max. number of atoms allowed:'',i4)')
     1numatm
_IF(ipsc,tools)
         call pend
_ELSE
         stop
_ENDIF
      endif
      labels(natoms)   =label
      geo(1,natoms)    =reada(line,istart(2))
      geo(2,natoms)    =reada(line,istart(4))
      geo(3,natoms)    =reada(line,istart(6))
      if(ircdrc)then
         turn=line(istart(3):istart(3))
         if(turn.eq.'t')then
            lopt(1,natoms)=1
            if(natoms.eq.1)write(mfgw,
     +      '(a)')' in drc monitor potential energy'//
     +      ' turning points'
         else
            lopt(1,natoms)=0
         endif
         turn=line(istart(5):istart(5))
         if(turn.eq.'t')then
            lopt(2,natoms)=1
         else
            lopt(2,natoms)=0
         endif
         turn=line(istart(7):istart(7))
         if(turn.eq.'t')then
            lopt(3,natoms)=1
         else
            lopt(3,natoms)=0
         endif
      else
         lopt(1,natoms)   =reada(line,istart(3))
         lopt(2,natoms)   =reada(line,istart(5))
         lopt(3,natoms)   =reada(line,istart(7))
         do 90 i=3,7,2
            if(ichar(line(istart(i):istart(i))).ge.icapa.and.
     1ichar(line(istart(i):istart(i))).le.icapz)iserr=1
   90    continue
      endif
      na(natoms)       =reada(line,istart(8))
      nb(natoms)       =reada(line,istart(9))
      nc(natoms)       =reada(line,istart(10))
c
c  special case of users forgetting to add dihedral data for atom 3
c
      if(natoms.eq.3)then
         if(lopt(3,3).eq.2)then
            na(3)=1
            nb(3)=2
            geo(3,3)=0.0d0
            lopt(3,3)=0
         elseif(lopt(3,3).eq.1.and.dabs(geo(3,3)-2.d0).lt.1.d-4)
     +           then
            na(3)=2
            nb(3)=1
            geo(3,3)=0.0d0
            lopt(3,3)=0
         endif
      endif
***** DEBUG
*     write(mfgw,'('' data line read in is '')')
*      write(mfgw,260)labels(natoms),
*    +                (geo(jj,natoms),lopt(jj,natoms),jj=1,3),
*    +                 na(natoms),nb(natoms),nc(natoms)
*****
      if(lopt(1,natoms).gt.1.or.lopt(2,natoms).gt.1.or.
     1lopt(3,natoms).gt.1)iserr=1
      if(iserr.eq.1) then
c
c  must be gaussian geometry input
c
         do 110 i=2,natoms
            do 110 k=1,3
               j=geo(k,i)+0.4d0
               if(dabs(geo(k,i)-j).gt.1.d-5)then
c
c   geometry cannot be gaussian
c
                  write(mfgw,'(a)')
     +            ' geometry is faulty.  geometry read inis'
                  const=3.141592653598d0/180.d0
                  do 100 l=1,natoms
                     geo(2,l)=geo(2,l)*const
  100             geo(3,l)=geo(3,l)*const
                  call geout(6)
_IF(ipsc,tools)
                  call pend
_ELSE
                  stop
_ENDIF
               endif
  110    continue
         natoms=-1
         return
      endif
      goto 20
*
* all data read in, clean up and return
*
  120 natoms=natoms-1
  130 na(2)=1
      ltxt=char(maxtxt)
      if(natoms.gt.3)then
         int=(na(4).ne.0)
      else
         if(geo(2,3).lt.10.and.natoms.eq.3)
     1write(mfgw,
     +'(//10x,'' warning: internal coordinates are assumed -'',/
     210x,'' for three-atom systems '',//)')
         int=.true.
      endif
      if(int)geo(2,2)=0
c
c     read in velocity vector, if present
c
      if(index(keywrd,'velo').gt.0)then
         if(int)then
            write(mfgw,
     +'(a)')' coordinates must be cartesian when velocity'
     1//' vector is used.'
_IF(ipsc,tools)
            call pend
_ELSE
            stop
_ENDIF
         endif
c#      write(6,'(/10x,a)')'initial velocity vector for drc'
         do 150 i=1,natoms
            read(5,'(a)') line
            call nuchar(line,value,ndmy)
            if(ndmy.ne.3)then
               write(mfgw,'(/10x,a)')
     1'  there must be exactly three velocity data per line'
_IF(ipsc,tools)
               call pend
_ELSE
               stop
_ENDIF
            endif
            do 140 j=1,3
  140       react(j,i+2)=value(j)
c#      write(6,'(2x,a2,2x,3f13.5)')elemnt(labels(i)),(value(j),j=1,3)
  150    continue
         do 160 i=1,3
            do 160 j=1,2
  160    react(i,j)=geo(i,j+1)-geo(i,1)
c
c  now to rotate velocity vector to suit internal coordinate definition
c
c
c   rotate around the 1-2 x-axis to as to eliminate react(3,2)
c   (put atom 2 in x-y plane)
         sa=react(3,1)/dsqrt(react(2,1)**2+react(3,1)**2+1.d-20)
         ca=dsign(dsqrt(1.d0-sa**2),react(2,1))
c#      labels(natoms+1)=1
c#      labels(natoms+2)=1
c#      write(6,*)' first rotation, about 1-2 x-axis'
         do 170 i=1,natoms+2
            temp1= react(2,i)*ca+react(3,i)*sa
            temp2=-react(2,i)*sa+react(3,i)*ca
            react(2,i)=temp1
            react(3,i)=temp2
c#      write(6,'(2x,a2,2x,3f13.5)')elemnt(labels(i)),(react(j,i),j=1,3)
  170    continue
c   rotate around the 1-2 z-axis to as to eliminate react(2,2)
c   (put atom 2 on x axis)
         ca=react(1,1)/dsqrt(react(2,1)**2+react(1,1)**2+1.d-20)
         sa=dsign(dsqrt(1.d0-ca**2),react(2,1))
c#      write(6,*)' second rotation, about 1-2 z-axis'
         do 180 i=1,natoms+2
            temp1= react(1,i)*ca+react(2,i)*sa
            temp2=-react(1,i)*sa+react(2,i)*ca
            react(1,i)=temp1
            react(2,i)=temp2
c#      write(6,'(2x,a2,2x,3f13.5)')elemnt(labels(i)),(react(j,i),j=1,3)
  180    continue
c   rotate around the 2-3 x-axis to as to eliminate react(3,3)
c   (put atom 3 on x-y plane)
         sa=react(3,2)/dsqrt(react(2,2)**2+react(3,2)**2+1.d-20)
         ca=dsign(dsqrt(1.d0-sa**2),react(2,2))
c#      write(6,*)' third rotation, about 2-3 x-axis'
         do 190 i=1,natoms+2
            temp1= react(2,i)*ca+react(3,i)*sa
            temp2=-react(2,i)*sa+react(3,i)*ca
            react(2,i)=temp1
            react(3,i)=temp2
c#      write(6,'(2x,a2,2x,3f13.5)')elemnt(labels(i)),(react(j,i),j=1,3)
  190    continue
c
c  strip off first two coordinates; these were the coordinate axis
c  definitions
c
         do 200 i=1,natoms
            do 200 j=1,3
  200    react(j,i)=react(j,i+2)
      endif
      if(  .not. int ) then
         do 210 i=1,natoms
            do 210 j=1,3
  210    xyz(j,i)=geo(j,i)
         degree=90.d0/dasin(1.d0)
         call mopxyz(xyz,natoms,na,nb,nc,degree,geo)
         if(index(keywrd,' xyz').eq.0)then
c
c  unconditionally set flags for internal coordinates
c
            do 220 i=1,3
               do 220 j=i,3
  220       lopt(j,i)=0
         endif
         if(dabs(geo(2,3)-180.d0).lt.1.d-4.or.dabs(geo(2,3)).lt.1.d-4)
     1then
            write(mfgw,'(a)')
     +      ' due to program bug, the first three atoms ',
     +      ' must not lie in a straight line.'
_IF(ipsc,tools)
            call pend
_ELSE
            stop
_ENDIF
         endif
      elseif (.not.ircdrc) then
         lopt(2,2)=0
         if(lopt(1,1)+lopt(2,1)+lopt(3,1)+lopt(3,2)+
     1        lopt(3,3) .gt. 0)then
            lopt(1,1)=0
            lopt(2,1)=0
            lopt(3,1)=0
            lopt(3,2)=0
            lopt(3,3)=0
            write(mfgw,
     +      '(//10x,'' an unoptimizable geometric parameter has''
     1 ,/10x,'' been marked for optimization. this is a non-fatal ''
     2,''error'')')
         endif
      endif
      if(na(3).eq.0) then
         nb(3)=1
         na(3)=2
      endif
***** DEBUG
*     write(mfgw,'('' data currently read in are '')')
*     do k=1,natoms
*      write(mfgw,260)labels(k),(geo(jj,k),lopt(jj,k),jj=1,3),
*    +  na(k),nb(k),nc(k)
*     enddo
*****
      return
* error conditions
  230 if(iread.eq.5) then
         write(mfgw,
     +   '( '' error during read at atom number '', i3 )')natoms
      else
         natoms=0
         return
      endif
  240 j=natoms-1
      write(mfgw,'('' data currently read in are '')')
      do 250 k=1,j
  250 write(mfgw,260)labels(k),(geo(jj,k),lopt(jj,k),jj=1,3),
     1na(k),nb(k),nc(k)
  260 format(i4,2x,3(f10.5,2x,i2,2x),3(i2,1x))
_IF(ipsc,tools)
      call pend
_ELSE
      stop
_ENDIF
      end
      function getmop(in)
c
c    this function is designed for use on a unix system.
c    gtnv will consult the environment
c    for the current alias of the character string contained in
c    'namein'.  the alias, if it exists, or the original name in namein
c    will be returned.
c
      integer in
      character*(80) nameout, zdef1(60), zdef2(60),getmop
      data zdef1/
     *'fort.1', 'fort.2','restart','density','logfile','archive',
     *'DENSITY', 'sybyl', 'fort.9', 'fort.10','fort.11',
     *'fort.12','fort.13','fort.14','fort.16','fort.16','fort.17',
     *'fort.18','fort.19','fort.20','fort.21','fort.22','fort.23',
     *'fort.24','fort.25','fort.26','fort.27','fort.28','fort.29',
     *'fort.30','fort.31','fort.32','fort.33','fort.34','fort.35',
     *'fort.36','fort.37','fort.38','fort.39',
     *'fort.40','fort.41','fort.42','fort.43','fort.44','fort.45',
     *'fort.46','fort.47','fort.48','fort.49','fort.50','fort.51',
     *'fort.52','fort.53','fort.54','fort.55','fort.56','fort.57',
     *'fort.58','fort.59','fort.60'/
      data zdef2/
     *'ftn001','ftn002','restart','density','logfile','archive',
     *'DENSITY','sybyl','ftn009','ftn010','ftn011',
     *'ftn012','ftn013','ftn014','ftn015','ftn016','ftn017','ftn018',
     *'ftn019','ftn020','ftn021','ftn022','ftn023','ftn024','ftn025',
     *'ftn026','ftn027','ftn028','ftn029','ftn030','ftn031',
     *'ftn032','ftn033','ftn034','ftn035','ftn036','ftn037','ftn038',
     *'ftn039',
     *'ftn040','ftn041','ftn042','ftn043','ftn044','ftn045',
     *'ftn046','ftn047','ftn048','ftn049','ftn050','ftn051',
     *'ftn052','ftn053','ftn054','ftn055','ftn056','ftn057',
     *'ftn058','ftn059','ftn060'/
      nameout = ' '
      iunit = in
      call gtnv(zdef1(iunit),nameout)
      if(nameout.eq.' ')  then
       call gtnv(zdef2(iunit),nameout)
       if (nameout .eq. ' ') nameout = zdef1(iunit)
      endif
      do 10 loop = len(nameout), 1, -1
        if(nameout(loop:loop).ne.' ') goto 20
 10   continue
 20   getmop = nameout
      return
      end
      subroutine gtsymm
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      common /geosym/ ndep, locpar(maxpar), idepfn(maxpar),
     1                locdep(maxpar)
      common /iofile/ mfgr,mfgw
      common / readme / ird
c***********************************************************************
c
c   gtsymm reads in the symmetry dependence relationships.
c
c   on exit     ndep    = number of symmetry relations.
c               locpar  = array of reference function indices.
c               idepfn  = array of reference atom locations.
c               locdep  = array of dependent atom locations.
c
c***********************************************************************
c
c     locdep is the atom whose coordinates depend on the coordinates of
c     locpar.
c     locpar is the atom whose coordinates are used to calculate those
c     of locdep
c     idepfn points to the particular function to be used (see nddo)
c
c***********************************************************************
      dimension ivalue(40),value(40)
      character  text(18)*60, line*80
      save text
      data text/
     1' bond length    is set equal to the reference bond length   ',
     2' bond angle     is set equal to the reference bond angle    ',
     3' dihedral angle is set equal to the reference dihedral angle',
     4' dihedral angle varies as  90 degrees - reference dihedral  ',
     5' dihedral angle varies as  90 degrees + reference dihedral  ',
     6' dihedral angle varies as 120 degrees - reference dihedral  ',
     7' dihedral angle varies as 120 degrees + reference dihedral  ',
     8' dihedral angle varies as 180 degrees - reference dihedral  ',
     9' dihedral angle varies as 180 degrees + reference dihedral  ',
     1' dihedral angle varies as 240 degrees - reference dihedral  ',
     2' dihedral angle varies as 240 degrees + reference dihedral  ',
     3' dihedral angle varies as 270 degrees - reference dihedral  ',
     4' dihedral angle varies as 270 degrees - reference dihedral  ',
     5' dihedral angle varies as - reference dihedral              ',
     6' bond length varies as half the reference bond length       ',
     7' bond angle varies as half the reference bond angle         ',
     8' bond angle varies as 180 degrees - reference bond angle    ',
     9' the user has to supply this function in depvar             '/
c
c title output
      write (mfgw,10)
   10 format (///5x,25hparameter dependence data//
     1'        reference atom      function no.    dependent atom(s)')
c
c input symmetry : function, referance parameter, and dependent atoms
c
      ndep=0
   20 read(ird,'(a)',end=70) line
      call nuchar(line,value,nvalue)
c   integer values
      do 30 i=1,nvalue
   30 ivalue(i)=value(i)
c   fill the locdep array
      if(nvalue.eq.0.or.ivalue(3).eq.0) go to 70
      do 40 i=3,nvalue
         if(ivalue(i).eq.0) goto 50
         ndep=ndep+1
         locdep(ndep)=ivalue(i)
         locpar(ndep)=ivalue(1)
         idepfn(ndep)=ivalue(2)
   40 continue
   50 ll=i-1
      write(mfgw,60)ivalue(1),ivalue(2),(ivalue(j),j=3,ll)
   60 format(i13,i19,i14,11i3,10(/,43x,12i3))
      go to 20
c
c clean up
   70 continue
      write(mfgw,80)
   80 format(/10x,'   descriptions of the functions used',/)
      do 120 j=1,18
         do 90 i=1,ndep
            if(idepfn(i).eq.j) goto 100
   90    continue
         goto 120
  100    write(mfgw,110)j,text(j)
  110    format(i4,5x,a)
  120 continue
      return
      end
      subroutine gettxt
      common /keywrd/ keywrd
      common /titles/ koment,title
      common /iofile/ mfgr,mfgw
      common / readme / ird
      dimension is(3)
      character keywrd*241, koment*81, title*81, ch*1, ch2*1, filen*50
     +,getmop*80, oldkey*80
      is(1)=161
      is(2)=81
      is(3)=1
      keywrd=' '
      koment='    null  '
      title ='    null  '
      read(ird,'(a)',end=100,err=90)keywrd(:80)
      oldkey=keywrd
      call upcase(keywrd(1:80))
      if(index(keywrd,'setup').ne.0)then
         i=index(keywrd,'setup=')
         if(i.ne.0)then
            j=index(keywrd(i:),' ')
            filen=oldkey(i+6:i+j-1)
         else
            filen='setup'
         endif
         open(unit=4,file=getmop(12),
     +        status='unknown',form='formatted')
         rewind 4
         read(4,'(a)',end=40,err=40)keywrd(81:160)
         call upcase(keywrd(81:160))
         read(4,'(a)',end=10,err=10)keywrd(161:240)
         call upcase(keywrd(161:240))
   10    continue
         read(ird,'(a)',end=100,err=90)koment,title
      elseif(index(keywrd(1:80),' +') .ne.0)then
c
c  read second keyword line
c
         read(ird,'(a)',end=100,err=90)keywrd(81:160)
         oldkey=keywrd(81:160)
         call upcase(keywrd(81:160))
         if(index(keywrd(81:160),'setup').ne.0)then
            i=index(keywrd,'setup=')
            if(i.ne.0)then
               j=index(keywrd(i:),' ')
               filen=oldkey(i-74:i+j-80)
            else
               filen='setup'
            endif
            open(unit=4,file=getmop(12)
     +          ,status='unknown',form='formatted')
            rewind 4
            read(4,'(a)',end=20,err=20)keywrd(161:240)
            call upcase(keywrd(161:240))
   20       continue
         elseif(index(keywrd(81:160),' +') .ne.0)then
c
c  read third keyword line
c
            read(ird,'(a)',end=100,err=90)keywrd(161:240)
            call upcase(keywrd(161:240))
         endif
c
c  read title line
c
         read(ird,'(a)',end=100,err=90)koment,title
      elseif(index(keywrd(:80),'&').ne.0)then
         read(ird,'(a)',end=100,err=90)keywrd(81:160)
         oldkey=keywrd(81:160)
         call upcase(keywrd(81:160))
         if(index(keywrd(81:160),'setup').ne.0)then
            i=index(keywrd,'setup=')
            if(i.ne.0)then
               j=index(keywrd(i:),' ')
               filen=oldkey(i-74:i+j-80) 
c               write(*,*)' <'//filen//'>'
c               stop
            else
               filen='setup'
            endif
            open(unit=4,file=getmop(12),
     +           status='unknown',form='formatted')
            rewind 4
            read(4,'(a)',end=30,err=30)keywrd(161:240)
            call upcase(keywrd(161:240))
            read(ird,'(a)',end=100,err=90)title
   30       continue
         elseif(index(keywrd(81:160),'&').ne.0)then
            read(ird,'(a)',end=100,err=90)keywrd(161:240)
         else
            read(ird,'(a)',end=100,err=90)title
         endif
      else
         read(ird,'(a)',end=100,err=90)koment,title
      endif
      goto 50
   40 write(mfgw,'(a)')' setup file missing or corrupt'
   50 do 80 j=1,3
         if(keywrd(is(j):is(j)) .ne. ' ') then
            ch=keywrd(is(j):is(j))
            keywrd(is(j):is(j))=' '
            do 60 i=is(j)+1,239
               ch2=keywrd(i:i)
               keywrd(i:i)=ch
               ch=ch2
               if(keywrd(i+1:i+2) .eq. '  ') then
                  keywrd(i+1:i+1)=ch
                  goto 70
               endif
   60       continue
            write(mfgw,
     +      '(a,i2,a)')' line',j,' of keywords does not have enough'
            write(mfgw,
     +      '(a)')' spaces for parsing.  please correct line.'
_IF(ipsc,tools)
            call pend
_ELSE
            stop
_ENDIF
   70       continue
         endif
   80 continue
      return
   90 write(mfgw,'(a)')' error in read of first three lines'
  100 continue
_IF(ipsc,tools)
      call pend
_ELSE
      stop
_ENDIF
      end
      subroutine getval(line,x,t)
      implicit REAL (a-h,o-z)
      character line*80, t*12, ch1*1, ch2*1
      ch1=line(1:1)
      ch2=line(2:2)
      if((ichar(ch1).lt.ichar('a').or.ichar(ch1).gt.ichar('z')) .and.
     1(ichar(ch2).lt.ichar('a').or.ichar(ch2).gt.ichar('z')))then
c
c   is a number
c
         x=reada(line,1)
         t=' '
      else
         i=index(line,' ')
         t=line(:i)
         x=-999.d0
      endif
      return
      end
      subroutine gmetry(geo,coord)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      common /geokst/ natoms,labels(numatm),
     1na(numatm),nb(numatm),nc(numatm)
      common /euler/ tvec(3,3), id
      common /reactn/ step, geoa(3,numatm), geovec(3,numatm),colcst
      common /geook/ igeook
      common /numcal/ numcal
      common /keywrd/ keywrd
      common /iofile/ mfgr,mfgw
      dimension geo(3,*),coord(3,*)
      character *15 ndimen(4), keywrd*241
      logical geook
      save icalcn, ndimen, geook
      data icalcn/0/
      data ndimen/' molecule     ',' polymer       ',
     1'layer structure',' solid         '/
c***********************************************************************
c
c    gmetry  computes coordinates from bond-angles and lengths.
c *** it is adapted from the program written by m.j.s. dewar.
c
c     three separate options exist within gmetry. these are:
c    (a) if na(1) is equal to 99 (impossible under normal circumstances)
c        then geo is assumed to be in cartesian rather than internal
c        coordinates, and coord is then set equal to geo.
c    (b) if step is non-zero (this is the case when "saddle" is used)
c        then geo is first modified by shifting the internal coordinates
c        along a radius from geoa to place geo at adistancestepfromgeoa.
c    (c) normal conversion from internal to cartesian coordinatesisdone.
c
c  on input:
c         geo    = array of internal coordinates.
c         natoms = number of atoms, including dummies.
c         na     = array of atom labels for bond lengths.
c
c  on output:
c         coord  = array of cartesian coordinates
c
c***********************************************************************
c                                     option (b)
c     former form of next line was
c     geook=(igeook.eq.99)
c     hacked by hbb 11.3.91
c
      geook=((igeook.eq.99).or.(index(keywrd,'geo-ok').ne.0))
      if(dabs(step) .gt. 1.d-4) then
         sum=0.0d0
         do 10 j=1,3
c$doit vbest
          do 10 i=1,natoms
           geovec(j,i)=geo(j,i)-geoa(j,i)
   10    sum=sum+geovec(j,i)**2
         sum=dsqrt(sum)
         error=(sum-step)/sum
      else
         error=0.0d0
      endif
      do 20 j=1,3
c$doit vbest
         do 20 i=1,natoms
   20 geo(j,i)=geo(j,i)-error*geovec(j,i)
c                                     option (a)
c     geometry fix added by s.green - 15.3.91
c      if((na(1).eq.99).or.(index(keywrd, 'fix').ne.0)) then
      if(na(1).eq.99) then
         do 30 i=1,3
c$doit vbest
            do 30 j=1,natoms
   30    coord(i,j)=geo(i,j)
         goto 100
      endif
c                                     option (c)
      coord(1,1)=0.0d00
      coord(2,1)=0.0d00
      coord(3,1)=0.0d00
      coord(1,2)=geo(1,2)
      coord(2,2)=0.0d00
      coord(3,2)=0.0d00
      if(natoms.eq.2) goto 100
      ccos=dcos(geo(2,3))
      if(na(3).eq.1)then
         coord(1,3)=coord(1,1)+geo(1,3)*ccos
      else
         coord(1,3)=coord(1,2)-geo(1,3)*ccos
      endif
      coord(2,3)=geo(1,3)*dsin(geo(2,3))
      coord(3,3)=0.0d00
      do 90 i=4,natoms
         cosa=dcos(geo(2,i))
         mb=nb(i)
         mc=na(i)
         xb=coord(1,mb)-coord(1,mc)
         yb=coord(2,mb)-coord(2,mc)
         zb=coord(3,mb)-coord(3,mc)
         rbc=xb*xb+yb*yb+zb*zb
         if(rbc.lt.1.d-16)then
c
c     two atoms are coincident.  a fatal error.
c
            write(mfgw,
     +      '(a,i4,a,i4,a)')' atoms',mb,' and',mc,' are coincident'
            write(mfgw,'(a)')
     +      ' this is a fatal error, run stopped in gmetry'
_IF(ipsc,tools)
            call pend
_ELSE
            stop
_ENDIF
         else
            rbc=1.0d00/dsqrt(rbc)
         endif
         ma=nc(i)
         xa=coord(1,ma)-coord(1,mc)
         ya=coord(2,ma)-coord(2,mc)
         za=coord(3,ma)-coord(3,mc)
c
c     rotate about the z-axis to make yb=0, and xb positive.  if xyb is
c     too small, first rotate the y-axis by 90 degrees.
c
         xyb=dsqrt(xb*xb+yb*yb)
         k=-1
         if (xyb.gt.0.1d00) go to 40
         xpa=za
         za=-xa
         xa=xpa
         xpb=zb
         zb=-xb
         xb=xpb
         xyb=dsqrt(xb*xb+yb*yb)
         k=+1
c
c     rotate about the y-axis to make zb vanish
c
   40    costh=xb/xyb
         sinth=yb/xyb
         xpa=xa*costh+ya*sinth
         ypa=ya*costh-xa*sinth
         sinph=zb*rbc
         cosph=dsqrt(dabs(1.d00-sinph*sinph))
         zqa=za*cosph-xpa*sinph
c
c     rotate about the x-axis to make za=0, and ya positive.
c
         yza=dsqrt(ypa**2+zqa**2)
         if(yza.lt.1.d-4)goto 60
         if(yza.lt.2.d-2 .and. .not.geook)then
            write(mfgw,'(//20x,
     +      '' calculation abandoned at this point'')')
            write(mfgw,'(//10x,
     +      '' three atoms being used to define the'',/
     110x,'' coordinates of a fourth atom, whose bond-angle is'')')
            write(mfgw,'(10x,'' not zero or 180 degreees, are '',
     1''in an almost straight'')')
            write(mfgw,
     +      '(10x,'' line.  there is a high probability that the'',
     +      /10x,'' coordinates of the atom will be incorrect.'')')
            write(mfgw,
     +      '(//20x,''the faulty atom is atom number'',i4)')i
            call geout(1)
            write(mfgw,
     +      '(//20x,''cartesian coordinates up to faulty atom'')')
            write(mfgw,'(//5x,''i'',12x,''x'',12x,''y'',12x,''z'')')
            do 50 j=1,i
   50       write(mfgw,'(i6,f16.5,2f13.5)')j,(coord(k,j),k=1,3)
            write(mfgw,'(//6x,'' atoms'',i3,'','',i3,'', and'',i3,
     1'' are within'',f7.4,'' angstroms of a straight line'')')
     2mc,mb,ma,yza
_IF(ipsc,tools)
            call pend
_ELSE
            stop
_ENDIF
         endif
         coskh=ypa/yza
         sinkh=zqa/yza
         goto 70
   60    continue
c
c   angle too small to be important
c
         coskh=1.d0
         sinkh=0.0d0
   70    continue
c
c     coordinates :-   a=(???,yza,0),   b=(rbc,0,0),  c=(0,0,0)
c     none are negative.
c     the coordinates of i are evaluated in the new frame.
c
         sina=dsin(geo(2,i))
         sind=-dsin(geo(3,i))
         cosd=dcos(geo(3,i))
         xd=geo(1,i)*cosa
         yd=geo(1,i)*sina*cosd
         zd=geo(1,i)*sina*sind
c
c     transform the coordinates back to the original system.
c
         ypd=yd*coskh-zd*sinkh
         zpd=zd*coskh+yd*sinkh
         xpd=xd*cosph-zpd*sinph
         zqd=zpd*cosph+xd*sinph
         xqd=xpd*costh-ypd*sinth
         yqd=ypd*costh+xpd*sinth
         if (k.lt.1) go to 80
         xrd=-zqd
         zqd=xqd
         xqd=xrd
   80    coord(1,i)=xqd+coord(1,mc)
         coord(2,i)=yqd+coord(2,mc)
         coord(3,i)=zqd+coord(3,mc)
   90 continue
c
c *** now remove the translation vectors, if any, from the array coor
c
  100 continue
      k=natoms
  110 if(labels(k).ne.107) goto 120
      k=k-1
      goto 110
  120 k=k+1
      if(k.gt.natoms) goto 170
c
c   system is a solid, of dimension natoms+1-k
c
      l=0
      do 130 i=k,natoms
         l=l+1
         mc=na(i)
         tvec(1,l)=coord(1,i)-coord(1,mc)
         tvec(2,l)=coord(2,i)-coord(2,mc)
         tvec(3,l)=coord(3,i)-coord(3,mc)
  130 continue
      id=l
      if (icalcn.ne.numcal) then
         icalcn=numcal
         write(mfgw,140)ndimen(id+1)
  140    format(/10x,'    the system is a ',a15,/)
         if(id.eq.0) goto 170
         write(mfgw,150)
         write(mfgw,160)(i,(tvec(j,i),j=1,3),i=1,id)
  150    format(/,'                unit cell translation vectors',/
     1/,'              x              y              z')
  160    format('    t',i1,' = ',f11.7,'    ',f11.7,'    ',f11.7)
      endif
  170 continue
      j=0
      do 190 i=1,natoms
         if (labels(i).eq.99.or.labels(i).eq.107) go to 190
         j=j+1
c$doit asis
         do 180 k=1,3
  180    coord(k,j)=coord(k,i)
  190 continue
      return
      end
      subroutine gover(ni,nj,xi,xj,r,sg)
************************************************************************
*                                                                      *
*   gover calculates the overlap integrals using a gaussian expansion  *
*         sto-6g by r.f. stewart, j. chem. phys., 52 431-438, 1970     *
*                                                                      *
*         on input   ni   =  atomic number of first atom               *
*                    nj   =  atomic number of second atom              *
*                    r    =  interatomic distance in angstroms         *
*         on exit    s    =  9x9 array of overlaps, in order s,px,py,  *
*                            pz                                        *
*                                                                      *
************************************************************************
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      common /natype/ nztype(107), mtype(30),ltype
      common /temp/  c(60,6), z(60,6)
      common /cmporb/ natorb(107)
      dimension s(6,6), xi(3),xj(3), sg(9,9)
      save ngauss
      data ngauss/6/
c
c    find start and end of gaussian
c
      ifa=nztype(ni)*4-3
      if(c(ifa+1,1).ne.0.d0)then
         ila=ifa+3
      else
         ila=ifa
      endif
      ifb=nztype(nj)*4-3
      if(c(ifb+1,1).ne.0.d0)then
         ilb=ifb+3
      else
         ilb=ifb
      endif
c
c  convert r into au
c
      r=r/0.529167d0
      r = r**2
      ka=0
      do 80 i=ifa,ila
         ka=ka+1
         nat=ka-1
         kb=0
         do 80 j=ifb,ilb
            kb=kb+1
            nbt=kb-1
c
c         decide is it an s-s, s-p, p-s, or p-p overlap
c
            if(nat.gt.0.and.nbt.gt.0) then
c    p-p
               is=4
               tomb=(xi(nat)-xj(nat))*(xi(nbt)
     1-xj(nbt))*3.5711928576d0
            elseif(nat.gt.0) then
c    p-s
               is=3
               tomb=(xi(nat)-xj(nat))*1.88976d0
            elseif(nbt.gt.0) then
c    s-p
               is=2
               tomb=(xi(nbt)-xj(nbt))*1.88976d0
            else
c    s-s
               is=1
            endif
            do 60 k=1,ngauss
               do 60 l=1,ngauss
                  s(k,l)=0.0d0
                  amb=z(i,k)+z(j,l)
                  apb=z(i,k)*z(j,l)
                  adb=apb/amb
c
c           check of overlap is non-zero before starting
c
                  if((adb*r).lt.90.d0) then
                     abn=1.0d0
                     go to(50,10,20,30),is
   10                abn=2.0d0*tomb*z(i,k)*dsqrt(z(j,l))/amb
                     go to 50
   20                abn=-2.0d0*tomb*z(j,l)*dsqrt(z(i,k))/amb
                     go to 50
   30                abn=-adb*tomb
                     if(nat.eq.nbt) abn=abn+0.5d0
   40                abn=4.0d0*abn*dsqrt(apb)/amb
   50                s(k,l)=dsqrt((2.0d0*dsqrt(apb)/amb)**3)*
     +                      dexp(-adb*r)*abn
                  endif
   60       continue
            sg(ka,kb)=0.0d0
            do 70 k=1,ngauss
               do 70 l=1,ngauss
   70       sg(ka,kb)=sg(ka,kb)+s(k,l)*c(i,k)*c(j,l)
   80 continue
      return
      end
      subroutine h1elec(ni,nj,xi,xj,smat)
      implicit REAL (a-h,o-z)
      dimension xi(3),xj(3),smat(9,9), bi(9), bj(9)
c***********************************************************************
c
c  h1elec forms the one-electron matrix between two atoms.
c
c   on input    ni   = atomic no. of first atom.
c               nj   = atomic no. of second atom.
c               xi   = coordinates of first atom.
c               xj   = coordinates of second atom.
c
c   on output   smat = matrix of one-electron interactions.
c
c***********************************************************************
      common /betas/ betas(107),betap(107),betad(107)
      common /molmec/ htype(4),nhco(4,20),nnhco,itype
      common /beta3/ beta3(153)
      common /keywrd/ keywrd
      common /euler/ tvec(3,3), id
      common /vsips/ vs(107),vp(107),vd(107)
      common /cmporb/ natorb(107)
      common /numcal/ numcal
      common /ucell/ l1l,l2l,l3l,l1u,l2u,l3u
      save sbits, xjuc
      dimension sbits(9,9), lims(3,2), xjuc(3)
      character*241 keywrd
      equivalence (l1l,lims(1,1))
      save icalcn
      data icalcn/0/
      if(ni.eq.102.or.nj.eq.102)then
         if(dsqrt((xi(1)-xj(1))**2+
     1        (xi(2)-xj(2))**2+
     2        (xi(3)-xj(3))**2) .gt.1.8)then
            do 10 i=1,9
               do 10 j=1,9
   10       smat(i,j)=0.0d0
            return
         endif
      endif
      if(id.eq.0) then
         if (icalcn.ne.numcal) icalcn=numcal
         call diat(ni,nj,xi,xj,smat)
      else
         if (icalcn.ne.numcal) then
            icalcn=numcal
            do 20 i=1,id
               lims(i,1)=-1
   20       lims(i,2)= 1
            do 30 i=id+1,3
               lims(i,1)=0
   30       lims(i,2)=0
         endif
         do 40 i=1,9
            do 40 j=1,9
   40    smat(i,j)=0
         do 70 i=l1l,l1u
            do 70 j=l2l,l2u
               do 70 k=l3l,l3u
                  do 50 l=1,3
   50             xjuc(l)=xj(l)+tvec(l,1)*i+tvec(l,2)*j+tvec(l,3)*k
                  call diat(ni,nj,xi,xjuc,sbits)
                  do 60 l=1,9
                     do 60 m=1,9
   60             smat(l,m)=smat(l,m)+sbits(l,m)
   70    continue
      endif
      if(itype.ne.4) goto 80
c
c     start of mndo, am1, or pm3 option
c
      ii=max(ni,nj)
      nbond=(ii*(ii-1))/2+ni+nj-ii
      if(nbond.gt.153)goto 90
      bi(1)=beta3(nbond)*vs(ni)
      bi(2)=beta3(nbond)*vp(ni)
      bi(3)=bi(2)
      bi(4)=bi(2)
      bj(1)=beta3(nbond)*vs(nj)
      bj(2)=beta3(nbond)*vp(nj)
      bj(3)=bj(2)
      bj(4)=bj(2)
      goto 90
   80 continue
      bi(1)=betas(ni)*0.5d0
      bi(2)=betap(ni)*0.5d0
      bi(3)=bi(2)
      bi(4)=bi(2)
      bi(5)=betad(ni)*0.5d0
      bi(6)=bi(5)
      bi(7)=bi(5)
      bi(8)=bi(5)
      bi(9)=bi(5)
      bj(1)=betas(nj)*0.5d0
      bj(2)=betap(nj)*0.5d0
      bj(3)=bj(2)
      bj(4)=bj(2)
      bj(5)=betad(nj)*0.5d0
      bj(6)=bj(5)
      bj(7)=bj(5)
      bj(8)=bj(5)
      bj(9)=bj(5)
   90 continue
      norbi=natorb(ni)
      norbj=natorb(nj)
      if(norbi.eq.9.or.norbj.eq.9) then
c
c    in the calculation of the one-electron terms the geometric mean
c    of the two beta values is being used if one of the atoms
c    contains d-orbitals.
         do 100 j=1,norbj
            do 100 i=1,norbi
  100    smat(i,j)=-2.0d0*smat(i,j)*dsqrt(bi(i)*bj(j))
      else
         do 110 j=1,norbj
            do 110 i=1,norbi
  110    smat(i,j)=smat(i,j)*(bi(i)+bj(j))
      endif
      return
      end
      subroutine haddon (w,l,m,loc,a)
      implicit REAL (a-h,o-z)
      common /iofile/ mfgr,mfgw
      dimension a(3,*)
c**********************************************************************
c
c   haddon calculates the value of a symmetry-dependent variable
c
c  on input: m   = number specifying the symmetry operation
c            loc = address of reference atom
c            a   = array of internal coordinates
c  on output w   = value of dependent function
c            l   = 1 (for bond length), 2 (angle), or 3 (dihedral)
c**********************************************************************
      pi = 3.1415926536d00
      if (m.gt.18 .or. m.lt.1) then
         write(mfgw,'(///10x,''undefined symmetry function used'')')
_IF(ipsc,tools)
         call pend
_ELSE
         stop
_ENDIF
      endif
      i=loc
      go to
     1(140,160,10,20,30,40,50,60,70,80,90,100,110,120,150,170,180,190),
     2m
   10 w=a(3,i)
      go to 130
   20 w=(pi/2.0d00)-a(3,i)
      go to 130
   30 w=(pi/2.0d00)+a(3,i)
      go to 130
   40 w=(2.0d00*pi/3.0d00)-a(3,i)
      go to 130
   50 w=(2.0d00*pi/3.0d00)+a(3,i)
      go to 130
   60 w= pi-a(3,i)
      go to 130
   70 w= pi+a(3,i)
      go to 130
   80 w=(4.0d00*pi/3.0d00)-a(3,i)
      go to 130
   90 w=(4.0d00*pi/3.0d00)+a(3,i)
      go to 130
  100 w=(3.0d00*pi/2.0d00)-a(3,i)
      go to 130
  110 w=(3.0d00*pi/2.0d00)+a(3,i)
      go to 130
  120 w=-a(3,i)
  130 l=3
      return
  140 l=1
      w=a(1,i)
      return
  150 l=1
      w=a(1,i)/2.0d00
      return
  160 l=2
      w=a(2,i)
      return
  170 l=2
      w=a(2,i)/2.0d00
      return
  180 l=2
      w=pi-a(2,i)
      return
  190 call depvar (a,i,w,l)
      return
c
      end
      function helect(n,p,h,f)
      implicit REAL (a-h,o-z)
      dimension p(*), h(*), f(*)
c***********************************************************************
c
c    routine calculates the electronic energy of the system in ev.
c
c    on entry n = number of atomic orbitals.
c             p = density matrix, packed, lower triangle.
c             h = one-electron matrix, packed, lower triangle.
c             f = two-electron matrix, packed, lower triangle.
c    on exit
c        helect = electronic energy.
c
c    no arguments are changed.
c
c***********************************************************************
      ed=0.0d00
      ee=0.0d00
      k=0
      nn=n+1
      do 20 i=2,nn
         k=k+1
         jj=i-1
         ed=ed+p(k)*(h(k)+f(k))
         if (i.eq.nn) go to 20
         do 10 j=1,jj
            k=k+1
   10    ee=ee+p(k)*(h(k)+f(k))
   20 continue
      ee=ee+.5d00*ed
      helect=ee
      return
c
      end
      subroutine hqrii(a,n,m,e,v)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      common /iofile/ mfgr,mfgw
      dimension a(*), e(n), v(n,m)
*************************************************************
*
* hqrii is a diagonalisation routine, written by yoshitaka beppu of
*       nagoya university, japan.
*       for details see 'computers & chemistry' vol.6 1982. page 000.
*
* on input    a       = matrix to be diagonalised (packed canonical)
*             n       = size of matrix to be diagonalised.
*             m       = number of eigenvectors needed.
*             e       = array of size at least n
*             v       = array of size at least nmax*m
*
* on output   e       = eigenvalues
*             v       = eigenvectors in array of size nmax*m
*
************************************************************************
      dimension w(5,maxpar)
      if(n.le.1 .or. m .le.1 .or. m .gt. n) then
         if(n.eq.1 .and. m.eq.1) then
            e(1)=a(1)
            v(1,1)=1.d0
            return
         endif
         write(mfgw,
     +   '(////10x,''in hqrii, n ='',i4,'' m ='',i4)')n,m
_IF(ipsc,tools)
         call pend
_ELSE
         stop
_ENDIF
      endif
*
* eps3 and eps are machine-precision dependent
*
      eps3=1.d-30
      ll=(n*(n+1))/2+1
      eps=1.d-8
      iord=-1
      nm1=n-1
      if(n.eq.2) goto 90
      nm2=n-2
      krank=0
c     householder transformation
      do 80 k=1,nm2
         kp1=k+1
         krank=krank+k
         w(2,k)=a(krank)
         sum=0.0d0
         jrank=krank
         do 10 j=kp1,n
            w(2,j)=a(jrank+k)
_IFN(blas)
            jrank=jrank+j
   10    sum=w(2,j)**2+sum
_ELSE
   10    jrank=jrank+j
_ENDIF
_IF(blas)
         sum=ddot(n-kp1+1,w(2,kp1),5,w(2,kp1),5)
_ENDIF
         s=dsign(dsqrt(sum),w(2,kp1))
         w(1,k)=-s
         w(2,kp1)=w(2,kp1)+s
         a(k+krank)=w(2,kp1)
         h=w(2,kp1)*s
         if(dabs(h).lt.eps3) goto 80
         summ=0.0d0
         irank=krank
         do 50 i=kp1,n
_IFN(blas)
            sum=0.d0
            do 20 j=kp1,i
   20       sum=sum+a(j+irank)*w(2,j)
_ELSE
            sum=ddot(i-kp1+1,a(kp1+irank),1,w(2,kp1),5)
_ENDIF
            if(i.ge.n) goto 40
            ip1=i+1
            jrank=i*(i+3)/2
            do 30 j=ip1,n
               sum=sum+a(jrank)*w(2,j)
   30       jrank=jrank+j
   40       w(1,i)=sum/h
            irank=irank+i
_IFN(blas)
   50    summ=w(1,i)*w(2,i)+summ
_ELSE
   50    continue
         summ=summ+ddot(n-kp1+1,w(1,kp1),5,w(2,kp1),5)
_ENDIF
         u=summ*0.5d0/h
         jrank=krank
         do 70 j=kp1,n
            w(1,j)=w(2,j)*u-w(1,j)
_IFN(blas)
            do 60 i=kp1,j
   60       a(i+jrank)=w(1,i)*w(2,j)+w(1,j)*w(2,i)+a(i+jrank)
_ELSE
            call daxpy(j-kp1+1,w(2,j),w(1,kp1),5,a(kp1+jrank),1)
            call daxpy(j-kp1+1,w(1,j),w(2,kp1),5,a(kp1+jrank),1)
_ENDIF
   70    jrank=jrank+j
   80 a(krank)=h
   90 w(2,nm1)=a((nm1*(nm1+1))/2)
      w(2,n)=a((n*(n+1))/2)
      w(1,nm1)=a(nm1+(n*(n-1))/2)
      w(1,n)=0.0d0
      gersch=dabs(w(2,1))+dabs(w(1,1))
      do 100 i=1,nm1
  100 gersch=dmax1(dabs(w(2,i+1))+dabs(w(1,i))+dabs(w(1,i+1)),gersch)
      del=eps*gersch
_IFN(blas)
      do 110 i=1,n
         w(3,i)=w(1,i)
         e(i)=w(2,i)
  110 v(i,m)=e(i)
_ELSE
      call dcopy(n,w(1,1),5,w(3,1),5)
      call dcopy(n,w(2,1),5,e(1),1)
      call dcopy(n,e(1),1,v(1,m),1)
_ENDIF
      if(dabs(del).lt.eps3)  goto  220
c     qr-method with origin shift
      k=n
  120 l=k
  130 if(dabs(w(3,l-1)).lt.del) goto 140
      l=l-1
      if(l.gt.1)  goto 130
  140 if(l.eq.k)  goto 170
      ww=(e(k-1)+e(k))*0.5d0
      r=e(k)-ww
      z=dsign(dsqrt(w(3,k-1)**2+r*r),r)+ww
      ee=e(l)-z
      e(l)=ee
      ff=w(3,l)
      r=dsqrt(ee*ee+ff*ff)
      j=l
      goto 160
  150 r=dsqrt(e(j)**2+w(3,j)**2)
      w(3,j-1)=s*r
      ee=e(j)*c
      ff=w(3,j)*c
  160 c=e(j)/r
      s=w(3,j)/r
      ww=e(j+1)-z
      e(j)=(ff*c+ww*s)*s+ee+z
      e(j+1)=c*ww-s*ff
      j=j+1
      if(j.lt.k) goto 150
      w(3,k-1)=e(k)*s
      e(k)=e(k)*c+z
      goto 120
  170 k=k-1
      if(k.gt.1) goto 120
*    *    *    *    *    *    *    *    *    *    *    *    *
*
*   at this point the array 'e' contains the un-ordered eigenvalues
*
*    *    *    *    *    *    *    *    *    *    *    *    *
c     straight selection sort of eigenvalues
      srter=1.d0
      if(iord.lt.0) srter=-1.d0
      j=n
  180 l=1
      ii=1
      ll=1
      do 200 i=2,j
         if((e(i)-e(l))*srter .gt. 0.d0) goto 190
         l=i
         goto 200
  190    ii=i
         ll=l
  200 continue
      if(ii.eq.ll) goto 210
      ww=e(ll)
      e(ll)=e(ii)
      e(ii)=ww
  210 j=ii-1
      if(j.ge.2) goto 180
  220 if(m.eq.0) return
***************
*  ordering of eigenvalues complete.
***************
c      inverse-iteration for eigenvectors
      eps1=1.d-5
      eps2=0.05d0
      rn=0.0d0
      ra=eps*0.6180339887485d0
c    0.618... is the fibonacci number (-1+sqrt(5))/2.
      ig=1
_IF(blas)
      onem=-1.d0
_ENDIF
      do 450 i=1,m
         im1=i-1
_IF(blas)
         call dcopy(n,0.d0,0,w(3,1),5)
         call dcopy(n,w(1,1),5,w(4,1),5)
         call dcopy(n,v(1,m),1,w(5,1),5)
         call daxpy(n,onem,e(i),0,w(5,1),5)
_ENDIF
         do 230 j=1,n
_IFN(blas)
            w(3,j)=0.d0
            w(4,j)=w(1,j)
            w(5,j)=v(j,m)-e(i)
_ENDIF
            rn=rn+ra
            if(rn.ge.eps) rn=rn-eps
  230    v(j,i)=rn
         do 260 j=1,nm1
            if(dabs(w(5,j)).ge.dabs(w(1,j))) goto 240
            w(2,j)=-w(5,j)/w(1,j)
            w(5,j)=w(1,j)
            t=w(5,j+1)
            w(5,j+1)=w(4,j)
            w(4,j)=t
            w(3,j)=w(4,j+1)
            if(dabs(w(3,j)).lt.eps3) w(3,j)=del
            w(4,j+1)=0.0d0
            goto 250
  240       if(dabs(w(5,j)).lt.eps3) w(5,j)=del
            w(2,j)=-w(1,j)/w(5,j)
  250       w(4,j+1)=w(3,j)*w(2,j)+w(4,j+1)
  260    w(5,j+1)=w(4,j)*w(2,j)+w(5,j+1)
         if(dabs(w(5,n)) .lt. eps3) w(5,n)=del
         do 320 itere=1,5
            if(itere.eq.1) goto 280
            do 270 j=1,nm1
               if(dabs(w(3,j)).lt.eps3) goto 270
               t=v(j,i)
               v(j,i)=v(j+1,i)
               v(j+1,i)=t
  270       v(j+1,i)=v(j,i)*w(2,j)+v(j+1,i)
  280       v(n,i)=v(n,i)/w(5,n)
            v(nm1,i)=(v(nm1,i)-v(n,i)*w(4,nm1))/w(5,nm1)
            vn=dmax1(dabs(v(n,i)),dabs(v(nm1,i)),1.d-20)
            if(n.eq.2) goto 300
            k=nm2
  290       v(k,i)=(v(k,i)-v(k+1,i)*w(4,k)-v(k+2,i)*w(3,k))/w(5,k)
            vn=dmax1(dabs(v(k,i)),vn,1.d-20)
            k=k-1
            if(k.ge.1) goto 290
  300       s=eps1/vn
_IFN(blas)
            do 310 j=1,n
  310       v(j,i)=v(j,i)*s
_ELSE
            call dscal(n,s,v(1,i),1)
_ENDIF
            if(itere.gt.1 .and. vn.gt.1) goto 330
  320    continue
c     transformation of eigenvectors
  330    if(n.eq.2) goto 380
         krank=nm2*(n+1)/2
         kpiv=nm2*nm1/2
         do 370 k=nm2,1,-1
            kp1=k+1
            if(dabs(a(kpiv)).le.eps3) goto 360
            sum=0.0d0
            do 340 kk=kp1,n
               sum=sum+a(krank)*v(kk,i)
  340       krank=krank+kk
            s=-sum/a(kpiv)
            do 350 kk=n,kp1,-1
               krank=krank-kk
  350       v(kk,i)=a(krank)*s+v(kk,i)
  360       kpiv=kpiv-k
  370    krank=krank-kp1
  380    do 390 j=ig,i
            if(dabs(e(j)-e(i)) .lt. eps2) goto 400
  390    continue
         j=i
  400    ig=j
         if(ig .eq. i) goto 430
c     re-orthogonalisation
         do 420 k=ig,im1
_IFN(blas)
            sum=0.d0
            do 410 j=1,n
  410       sum=v(j,k)*v(j,i)+sum
_ELSE
            sum=ddot(n,v(1,k),1,v(1,i),1)
_ENDIF
            s=-sum
_IFN(blas)
            do 420 j=1,n
  420    v(j,i)=v(j,k)*s+v(j,i)
_ELSE
            call daxpy(n,s,v(1,k),1,v(1,i),1)
  420    continue
_ENDIF
c     normalisation
  430    sum=1.d-24
_IFN(blas)
         do 440 j=1,n
  440    sum=sum+v(j,i)**2
_ELSE
         sum=sum+ddot(n,v(1,i),1,v(1,i),1)
_ENDIF
         sinv=1.d0/dsqrt(sum)
_IFN(blas)
         do 450 j=1,n
  450 v(j,i)=v(j,i)*sinv
_ELSE
         call dscal(n,sinv,v(1,i),1)
  450 continue
_ENDIF
      return
      end
      subroutine interp(n,np,nq,mode,e,fp,cp,vec,fock,p,h,vecl)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      common /iofile/ mfgr,mfgw
      dimension fp(mpack), cp(n,n)
      dimension vec(n,n), fock(n,n),
     1          p(n,n), h(n*n), vecl(n*n)
**********************************************************************
*
* interp: an interpolation procedure for forcing scf convergance
*         original theory and fortran written by r.n. camp and
*         h.f. king, j. chem. phys. 75, 268 (1981)
**********************************************************************
*
* on input n     = number of orbitals
*          np    = number of filled levels
*          nq    = number of empty levels
*          mode  = 1, do not reset.
*          e     = energy
*          fp    = fock matrix, as lower half triangle, packed
*          cp    = eigenvectors of fock matrix of iteration -1
*                  as packed array of n*n coefficients
*
* on output cp   = best guessed set of eigenvectors
*           mode = 2 or 3 - used by calling program
**********************************************************************
      dimension theta(maxorb), ia(maxorb)
      common /keywrd/ keywrd
      common /numcal/ numcal
      common/fit/npnts,idum2,xlow,xhigh,xmin,emin,demin,x(12),f(12),
     1 df(12)
      logical debug
      character*241 keywrd
      save zero, ff, radmax, icalcn, debug, debug1, ia, eold, xold
      data icalcn/0/
      data zero,ff,radmax/0.0d0,0.9d0,1.5708d0/
      if(icalcn.ne.numcal)then
         debug=(index(keywrd,'interp').ne.0)
         icalcn=numcal
         do 10 i=1,maxorb
   10    ia(i)=(i*i-i)/2
      endif
c
c     radmax=maximum rotation angle (radians).  1.5708 = 90 degrees.
c         ff=factor for convergence test for 1d search.
c
      minpq=min(np,nq)
      np1=np+1
      np2=max(1,np/2)
      if(mode.eq.2) go to 110
c
c     (mode=1 or 3 entry)
c     transform fock matrix to current mo basis.
c     only the off diagonal occ-virt block is computed.
c     store in fock array
c
      ii=0
      do 50 i=1,n
         i1=i+1
         do 40 j=1,nq
            dum=zero
            do 20 k=1,i
   20       dum=dum+fp(ii+k)*cp(k,j+np)
            if(i.eq.n) go to 40
            ik=ii+i+i
            do 30 k=i1,n
               dum=dum+fp(ik)*cp(k,j+np)
   30       ik=ik+k
   40    p(i,j)=dum
   50 ii=ii+i
      do 80 i=1,np
         do 70 j=1,nq
            dum=zero
            do 60 k=1,n
   60       dum=dum+cp(k,i)*p(k,j)
            fock(i,j)=dum
   70    continue
   80 continue
      if(mode.eq.3) go to 100
c
c     current point becomes old point (mode=1 entry)
c
      do 90 i=1,n
         do 90 j=1,n
   90 vec(i,j)=cp(i,j)
      eold=e
      xold=1.0d0
      mode=2
      return
c
c     (mode=3 entry)
c     fock corresponds to current point in corresponding representation.
c     vec does not hold current vectors. vec set in last mode=2 entry.
c
  100 npnts=npnts+1
      if(debug)write(mfgw,
     +         '(''   interpolated energy:'',f13.6)')e*23.061d0
      ipoint=npnts
      go to 500
c
c    (mode=2 entry) calculate theta, and u, v, w matrices.
c                   u rotates current into old mo.
c                   v rotates current into corresponding current mo.
c                   w rotates old into corresponding old mo.
c
  110 j1=1
      do 140 i=1,n
         if(i.eq.np1) j1=np1
         do 130 j=j1,n
            p(i,j)=zero
            do 120 k=1,n
  120       p(i,j)=p(i,j)+cp(k,i)*vec(k,j)
  130    continue
  140 continue
c
c     u = cp(dagger)*vec is now in p array.
c     vec is now available for temporary storage.
c
      ij=0
      do 170 i=1,np
         do 160 j=1,i
            ij=ij+1
            h(ij)=0.0d0
            do 150 k=np1,n
  150       h(ij)=h(ij)+p(i,k)*p(j,k)
  160    continue
  170 continue
      call hqrii(h,np,np,theta,vecl)
      do 180 i=np,1,-1
         il=i*np-np
         do 180 j=np,1,-1
  180 vec(j,i)=vecl(j+il)
      do 200 i=1,np2
         dum=theta(np1-i)
         theta(np1-i)=theta(i)
         theta(i)=dum
         do 190 j=1,np
            dum=vec(j,np1-i)
            vec(j,np1-i)=vec(j,i)
  190    vec(j,i)=dum
  200 continue
      do 210 i=1,minpq
         theta(i)=dmax1(theta(i),zero)
         theta(i)=dmin1(theta(i),1.d0)
  210 theta(i)=dasin(dsqrt(theta(i)))
c
c     theta matrix has now been calculated, also unitary vp matrix
c     has been calculated and stored in first np columns of vec matrix.
c     now compute wq
c
      do 240 i=1,nq
         do 230 j=1,minpq
            vec(i,np+j)=zero
            do 220 k=1,np
  220       vec(i,np+j)=vec(i,np+j)+p(k,np+i)*vec(k,j)
  230    continue
  240 continue
      call schmit(vec(1,np1),nq,n)
c
c     unitary wq matrix now in last nq columns of vec matrix.
c     transpose np by np block of u stored in p
c
      do 260 i=1,np
         do 250 j=1,i
            dum=p(i,j)
            p(i,j)=p(j,i)
  250    p(j,i)=dum
  260 continue
c
c     calculate wp matrix and hold in first np columns of p
c
      do 300 i=1,np
         do 270 k=1,np
  270    h(k)=p(i,k)
         do 290 j=1,np
            p(i,j)=zero
            do 280 k=1,np
  280       p(i,j)=p(i,j)+h(k)*vec(k,j)
  290    continue
  300 continue
      call schmib(p,np,n)
c
c     calculate vq matrix and hold in last nq columns of p matrix.
c
      do 340 i=1,nq
         do 310 k=1,nq
  310    h(k)=p(np+i,np+k)
         do 330 j=np1,n
            p(i,j)=zero
            do 320 k=1,nq
  320       p(i,j)=p(i,j)+h(k)*vec(k,j)
  330    continue
  340 continue
      call schmib(p(1,np1),nq,n)
c
c     calculate (de/dx) at old point
c
      dedx=zero
      do 370 i=1,np
         do 360 j=1,nq
            dum=zero
            do 350 k=1,minpq
  350       dum=dum+theta(k)*p(i,k)*vec(j,np+k)
  360    dedx=dedx+dum*fock(i,j)
  370 continue
c
c     store old point information for spline fit
c
      deold=-4.0d0*dedx
      x(2)=xold
      f(2)=eold
      df(2)=deold
c
c     move vp out of vec array into first np columns of p matrix.
c
      do 380 i=1,np
         do 380 j=1,np
  380 p(i,j)=vec(i,j)
      k1=0
      k2=np
      do 410 j=1,n
         if(j.eq.np1) k1=np
         if(j.eq.np1) k2=nq
         do 400 i=1,n
            dum=zero
            do 390 k=1,k2
  390       dum=dum+cp(i,k1+k)*p(k,j)
  400    vec(i,j)=dum
  410 continue
c
c     corresponding current mo vectors now held in vec.
c     compute vec(dagger)*fp*vec
c     store off-diagonal block in fock array.
c
  420 ii=0
      do 460 i=1,n
         i1=i+1
         do 450 j=1,nq
            dum=zero
            do 430 k=1,i
  430       dum=dum+fp(ii+k)*vec(k,j+np)
            if(i.eq.n) go to 450
            ik=ii+i+i
            do 440 k=i1,n
               dum=dum+fp(ik)*vec(k,j+np)
  440       ik=ik+k
  450    p(i,j)=dum
  460 ii=ii+i
      do 490 i=1,np
         do 480 j=1,nq
            dum=zero
            do 470 k=1,n
  470       dum=dum+vec(k,i)*p(k,j)
            fock(i,j)=dum
  480    continue
  490 continue
c
c     set limits on range of 1-d search
c
      npnts=2
      ipoint=1
      xnow=zero
      xhigh=radmax/theta(1)
      xlow=-0.5d0*xhigh
c
c     calculate (de/dx) at current point and
c     store information for spline fit
c     ***** jump point for mode=3 entry *****
c
  500 dedx=zero
      do 510 k=1,minpq
  510 dedx=dedx+theta(k)*fock(k,k)
      denow=-4.0d0*dedx
      enow=e
      if(ipoint.le.12) go to 530
  520 format(//,'excessive data pnts for spline.',/
     1,'ipoint =',i3,'maximum is 12.')
c
c     perform 1-d search and determine exit mode.
c
  530 x(ipoint)=xnow
      f(ipoint)=enow
      df(ipoint)=denow
      call spline
      if((eold-enow).gt.ff*(eold-emin).or.ipoint.gt.10) go to 560
c
c     (mode=3 exit) recompute cp vectors at predicted minimum.
c
      xnow=xmin
      do 550 k=1,minpq
         ck=dcos(xnow*theta(k))
         sk=dsin(xnow*theta(k))
         if(debug)write(mfgw,
     +   '('' rotation angle:'',f12.4)')sk*57.29578d0
         do 540 i=1,n
            cp(i,k)   =ck*vec(i,k)-sk*vec(i,np+k)
  540    cp(i,np+k)=sk*vec(i,k)+ck*vec(i,np+k)
  550 continue
      mode=3
      return
c
c     (mode=2 exit) current vectors give satisfactory energy improvement
c     current point becomes old point for the next 1-d search.
c
  560 if(mode.eq.2) go to 580
      do 570 i=1,n
         do 570 j=1,n
  570 vec(i,j)=cp(i,j)
      mode=2
  580 rold=xold*theta(1)*57.29578d0
      rnow=xnow*theta(1)*57.29578d0
      rmin=xmin*theta(1)*57.29578d0
      if(debug)write(mfgw,600) xold,eold*23.061d0,deold,rold
     1,             xnow,enow*23.061d0,denow,rnow
     2,             xmin,emin*23.061d0,demin,rmin
      eold=enow
      if(npnts.le.200) return
      write(mfgw,610)
      do 590 k=1,npnts
  590 write(mfgw,620) k,x(k),f(k),df(k)
      write(mfgw,630)
      return
  600 format(
     1/14x,3h x ,10x,6h f(x) ,9x,7h df/dx ,21h   rotation (degrees),
     2/10h      old ,f10.5,3f15.10,
     3/10h  current ,f10.5,3f15.10,
     4/10h predicted,f10.5,3f15.10/)
  610 format(3h  k,10h     x(k) ,15h       f(k)    ,10h     df(k))
  620 format(i3,f10.5,2f15.10)
  630 format(10x)
      end
      subroutine iterm (h, w, wj, wk, ee, fulscf,rand)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      REAL meci
_IF(ipsc,tools)
      logical oroot
_ENDIF
      dimension h(*), w(*), wj(*), wk(*)
      common /fokmat/ f(mpack), fb(mpack)
      common /densty/ p(mpack), pa(mpack), pb(mpack)
      common /vector/ c(morb2),eigs(maxorb),cbeta(morb2),eigb(maxorb)
      common /gradnt/ dumy(maxpar),gnorm
      common /last/ last
      common /mesage/ iflepo,iiter
      common /atheat/ atheat
      common /enuclr/ enuclr
      common /citerm/ xi,xj,xk
      common /path/ latom,lparam,react(200)
      common /numcal/ numcal
      common /scftyp/ emin, limscf
      common /timem/ time0
c     patas
      common /xxxxxx/ icompf
      common /mstpo/ hq(mpack),ezq,eeq
      common /mstq/ qs(1500),mflag
      common /iofile/ mfgr,mfgw
c
      logical fulscf, rand, limscf
      REAL wj, wk
c***********************************************************************
c
c     iter generates a scf field and returns the energy in "energy"
c
c the main arrays used in iter are:
c            p      only ever contains the total density matrix
c            pa     only ever contains the alpha density matrix
c            pb     only ever contains the beta density matrix
c            c      only ever contains the eigenvectors
c            h      only ever contains the one-electron matrix
c            f      starts off containing the one-electron matrix,
c                   and is used to hold the fock matrix
c            w      only ever contains the two-electron matrix
c
c the main integers constants in iter are:
c
c            linear size of packed triangle = norbs*(norbs+1)/2
c
c the main integer variables are
c            niter  number of iterations executed
c
c  principal references:
c
c   on mndo: "ground states of molecules. 38. the mndo method.
c             approximations and parameters."
c             dewar, m.j.s., thiel,w., j. am. chem. soc.,99,4899,(1977).
c   on shift: "the dynamic 'level shift' method for improving the
c             convergence of the scf procedure", a. v. mitin, j. comp.
c             chem. 9, 107-110 (1988)
c   on half-electron: "mindo/3 comparison of the generalized s.c.f.
c             coupling operator and "half-electron" methods for
c             calculating the energies and geometries of open shell
c             systems"
c             dewar, m.j.s., olivella, s., j. chem. soc. fara. ii,
c             75,829,(1979).
c   on pulay's converger: "convergance acceleration of iterative
c             sequences. the case of scf iteration", pulay, p.,
c             chem. phys. lett, 73, 393, (1980).
c   on cnvg:  it encorporates the improved iteration scheme (iis) by
c             piotr badziag & fritz solms. accepted for publishing
c             in computers & chemistry
c   on pseudodiagonalisation: "fast semiempirical calculations",
c             stewart. j.j.p., csaszar, p., pulay, p., j. comp. chem.,
c             3, 227, (1982)
c
c***********************************************************************
      dimension pold(mpack), pold2(mpack), pold3(maxorb+400)
      dimension pbold(mpack), pbold2(mpack), pbold3(maxorb+400)
************************************************************************
*                                                                      *
*   pack all the arrays used by pulay into a common block so that they *
*   can be used by the c.i. derivative, if needed                      *
*                                                                      *
************************************************************************
      common /work3/pold,pold2,pbold,pbold2
      common /work1/ ar1,ar2,ar3,ar4,br1,br2,br3,br4
      dimension  ar1(2*npulay), ar2(2*npulay), ar3(2*npulay),
     1 ar4(2*npulay)
      dimension  br1(2*npulay), br2(2*npulay), br3(2*npulay),
     1 br4(7*npulay)
      dimension escf0(10)
c     patas
      dimension pgasa(mpack),pgasb(mpack),psona(mpack),psonb(mpack)
c     patas
      common /preci / selcon
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),
     1                nlast(numatm), norbs, nelecs,
     2                nalpha, nbeta, nclose, nopen, ndumy, fract
      common /molorb/ dummy(maxorb),pdiag(maxorb)
      common /keywrd/ keywrd
      common /numscf/ nscf
      save icalcn, debug, prtfok, prteig, prtden,  prt1el, abprt
      save linear, minprt, newdg, scfcrt, prtpl, prtvec, pl
      save bshift, pltest, itrmax, na2el, na1el, nb2el,nb1el
      save ifill, camkin, ci, okpuly, uhf, scf1, oknewd, times
      save force, allcon, trans, halfe, w1, w2, random
*********
      save eps,eta,shfmax,shift,irrr,plchek,ten,timitr,capps
*********
      character keywrd*241, abprt(3)*5, getmop*80
      logical prtfok,prteig,prtden, debug, times, ci
     1,uhf, newdg, scf1, halfe, force, prt1el,prtpl, oknewd
     2,minprt, frst, bfrst, okpuly, ready, prtvec,
     3camkin, allcon, makea, makeb, incitr, capps, timitr
      data icalcn/0/, debug/.false./, prtfok/.false./
      data prteig/.false./,prtden/.false./
      data prt1el/.false./
      data abprt/'     ','alpha',' beta'/
c
c  initialize
c
      ifill=0
      ihomo=max(1,nclose+nalpha)
      ihomob=max(1,nclose+nbeta)
      eold=1.d2
      ready=.false.
      if (icalcn.ne.numcal) then
         call epseta(eps,eta)
c
c  ultimate scf criterion: heat of formation converged within a factor
c  of 10 of the limiting precision of the computer
c
         eps=23.061d0*eps*10.d0
         irrr=5
         shift=0.0d0
         icalcn=numcal
         shfmax=20.d0
         linear=(norbs*(norbs+1))/2
c
c    debug key-words worked out
c
         debug=( index(keywrd,'debug') .ne. 0 )
         minprt=(index(keywrd,'saddle')+
     1      latom .eq.0 .or. debug)
         prteig=( index(keywrd,'eigs') .ne. 0 )
         prtpl =( index(keywrd,' pl ')  .ne.0 )
         prt1el=( index(keywrd,'1ele') .ne.0 .and. debug)
         prtden=( index(keywrd,' dens').ne.0 .and. debug)
         prtfok=( index(keywrd,'fock') .ne. 0  .and. debug)
         prtvec=( index(keywrd,'vect') .ne. 0  .and. debug)
         debug=( index(keywrd,'iter') .ne. 0 )
c
c initialize some logicals and constants
c
         newdg =.false.
         plchek=0.005d0
         pl    =1.d0
         bshift=0.0d0
         shift=1.d0
*
* scfcrt is machine-precision dependent
*
         scfcrt=1.d-4
         itrmax = 200
         na2el=nclose
         na1el=nalpha+nopen
         nb2el=0
         nb1el=nbeta+nopen
c
c  use key-words to assign various constants
c
         if(index(keywrd,'fill').ne.0)
     1      ifill=-reada(keywrd,index(keywrd,'fill'))
         if(index(keywrd,'shift').ne.0)
     1      bshift=-reada(keywrd,index(keywrd,'shift'))
         if(bshift.ne.0)ten=bshift
         if(index(keywrd,'itry').ne.0)
     1      itrmax=reada(keywrd,index(keywrd,'itry'))
         camkin=(index(keywrd,'king')+index(keywrd,'camp') .ne. 0)
         ci=(index(keywrd,'micros')+index(keywrd,'c.i.') .ne. 0)
         okpuly=.false.
         okpuly=(index(keywrd,'pulay').ne.0)
         uhf=(index(keywrd,'uhf') .ne. 0)
         scf1=(index(keywrd,'1scf') .ne. 0)
         oknewd=dabs(bshift) .lt. 0.001d0
         if(camkin.and.dabs(bshift).gt.1.d-5) bshift=4.44d0
         times=(index(keywrd,'times') .ne. 0)
         timitr=(times.and.debug)
         force=(index(keywrd,'force') .ne. 0)
         allcon=(okpuly.or.camkin)
c
c   do we need a capped atom correction?
c
         j=0
         do 10 i=1,numat
   10    if(nat(i).eq.102)j=j+1
         capps=(j.gt.0)
         iiter=1
         trans=0.1d0
         if(index(keywrd,'restart')+index(keywrd,'oldens')
     1      .ne. 0) then
_IF(ipsc,tools)
         if (oroot()) then
_ENDIF
            if(index(keywrd,'oldens').ne.0)
     +   open(unit=10,file=getmop(4),
     +        status='unknown',form='unformatted')
            rewind 10
            read(10)(pa(i),i=1,linear)
            if( uhf) then
               read(10)(pb(i),i=1,linear)
               do 20 i=1,linear
                  pold(i)=pa(i)
                  pbold(i)=pb(i)
   20          p(i)=pa(i)+pb(i)
            else
               do 30 i=1,linear
                  pb(i)=pa(i)
                  pbold(i)=pa(i)
                  pold(i)=pa(i)
   30          p(i)=pa(i)*2.d0
            endif
_IF(ipsc,tools)
          else
           write(mfgw,*)' restart not available in iter'
           call pend
          endif
_ENDIF
         else
            nscf=0
            do 40 i=1,linear
               p(i)=0.0d0
               pa(i)=0.0d0
   40       pb(i)=0.0d0
            w1=na1el/(na1el+1.d-6+nb1el)
            w2=1.d0-w1
            if(w1.lt.1.d-6)w1=0.5d0
            if(w2.lt.1.d-6)w2=0.5d0
c
c  slightly perturb the density matrix in case the system is
c  trapped in a s**2 = 0 state.
c
            random=1.0d0
            if(uhf.and.na1el.eq.nb1el) random=1.1d0
            do 50 i=1,norbs
               j=(i*(i+1))/2
               p(j)=pdiag(i)
               pa(j)=p(j)*w1*random
               random=1.d0/random
   50       pb(j)=p(j)*w2*random
            do 60 i=1,linear
               pbold(i)=pb(i)
   60       pold(i)=pa(i)
         endif
         halfe=(nopen .ne. nclose.and.fract.ne.2.d0.and.fract.ne.0.d0)
c
c   determine the self-consistency criterion
c
         if(index(keywrd,'prec') .ne. 0)
     1                               scfcrt=scfcrt*0.01d0
         if( index(keywrd,'polar') + index(keywrd,'nllsq') +
     1 index(keywrd,'sigma') .ne. 0) scfcrt=scfcrt*0.001d0
         if(force)                   scfcrt=scfcrt*0.0001d0
         if(nopen-nclose.gt.4)       scfcrt=scfcrt*0.1d0
         scfcrt=dmax1(scfcrt,1.d-12)
         if(index(keywrd,'polar').ne.0)scfcrt=1.d-11
c
c  the user can state the scf criterion, if desired.
c
         i=index(keywrd,'scfcrt')
         if(i.ne.0) then
            scfcrt=reada(keywrd,i)
            write(mfgw,'(''  scf criterion ='',d14.4)')scfcrt
            if(scfcrt.lt.1.d-12) write(mfgw,
     +  '(//2x,'' there is a risk of infinite looping with'',
     2'' the scfcrt less than 1.d-12'')')
         else
            if(debug)write(mfgw,
     +      '(''  scf criterion ='',d14.4)')scfcrt
         endif
         if(.not.scf1)last=0
c
c   end of initialization section.
c
      elseif(force.and.nscf.gt.0.and..not.uhf)then
c
c   reset the density matrix if meci has formed an excited state.  this
c   prevents the scf getting trapped on an excited state, particularly
c   if the pulay converger is used.
c
         do 70 i=1,linear
   70    p(i)=2.d0*pa(i)
      endif
c
c   initialization operations done every time iter is called
c
      makea=.true.
      makeb=.true.
      iemin=0
      iemax=0
c
c  turn off shift if not a full scf.
c
      if(.not.fulscf) shift=0.0d0
      if(newdg) newdg=(dabs(bshift).lt.0.001d0)
      if(last.eq.1) newdg=.false.
c
c   self-consistency criteria: selcon is in kcal/mol, pltest is
c   a less important test to make sure that the selcon test is not
c   passed 'by accident'
c                              if gnorm is large, make selcon bigger
c
      selcon=scfcrt
      if(.not. force .and. .not. halfe) then
         if(gnorm.gt.5.d0) selcon=scfcrt*gnorm*0.2d0
         if(gnorm.gt.200.d0) selcon=scfcrt*40.d0
      endif
      pltest=0.05d0*dsqrt(selcon)
c
c  sometimes heat goes scf but density is still fluctuating in uhf
c  in which case pay less attention to density matrix
c
      if(nalpha.ne.nbeta.and.uhf)pltest=0.001d0
      if(debug)then
         write(mfgw,
     +   '(''  selcon, pltest'',3g16.7)')selcon, pltest
      endif
      if(prt1el) then
         write(mfgw,'(//10x,
     +   ''one-electron matrix at entrance to iter'')')
         call vecprt(h,norbs)
      endif
      iredy=1
   80 niter=0
      frst=.true.
      if(camkin) then
         modea=1
         modeb=1
      else
         modea=0
         modeb=0
      endif
      bfrst=.true.
c     patas
c
c     read density matrix for psi in vacuo
c     to be used when mflag=6
c
      if (index(keywrd,'tom').ne.0.and.mflag.eq.6) then
      do 502 i=1,linear
      pa(i)=psona(i)
  502 continue
      if (uhf) then
         do 503 i=1,linear
         pb(i)=psonb(i)
         pold(i)=pa(i)
         pbold(i)=pb(i)
         p(i)=pa(i)+pb(i)
  503    continue
      else
         do 504 i=1,linear
         pb(i)=pa(i)
         pbold(i)=pa(i)
         pold(i)=pa(i)
         p(i)=pa(i)*2.0d0
  504 continue
      endif
      endif
c
c     read density matrix for psi in solution
c     to be used when mflag=4
c
      if (index(keywrd,'tom').ne.0.and.mflag.eq.4) then
      do 512 i=1,linear
      pa(i)=pgasa(i)
  512 continue
      if (uhf) then
         do 513 i=1,linear
         pb(i)=pgasb(i)
         pbold(i)=pb(i)
         pold(i)=pa(i)
         p(i)=pa(i)+pb(i)
  513    continue
      else
         do 514 i=1,linear
         pb(i)=pa(i)
         pbold(i)=pa(i)
         pold(i)=pa(i)
         p(i)=pa(i)*2.d0
  514 continue
      endif
      endif
c     patas
**********************************************************************
*                                                                    *
*                                                                    *
*                start the scf loop here                             *
*                                                                    *
*                                                                    *
**********************************************************************
      incitr=.true.
   90 incitr=(modea.ne.3.and.modeb.ne.3)
      if(incitr)niter=niter+1
      if(timitr)then
         titer=secmop()
         write(mfgw,*)
         write(mfgw,
     +   '(a,f7.2)')'     time for iteration:', titer-titer0
         titer0=titer
      endif
      if(niter.gt.itrmax-10.and..not.allcon) then
************************************************************************
*                                                                      *
*                   switch on all convergers                           *
*                                                                      *
************************************************************************
         write(mfgw,'(//,'' all convergers are now forced on'',/
     1          '' shift=10, pulay on, camp-king on'',/
     2          '' and iteration counter reset'',//)')
         allcon=.true.
         bshift=4.44d0
         iredy=-4
         eold=100.d0
         okpuly=.true.
         newdg=.false.
         camkin=(.not.halfe)
         goto 80
      endif
************************************************************************
*                                                                      *
*                        make the alpha fock matrix                    *
*                                                                      *
************************************************************************
      if(dabs(shift).gt.1.d-10.and.bshift .ne. 0.d0) then
         l=0
         if(niter.gt.1)then
            if(newdg.and..not.(halfe.or.camkin))then
c
c  shift will apply to the virtual energy levels used in the
c  pseudodiagonaliization. if diff is -ve, good, then lower the
c  homo-lumo gap by 0.1ev, otherwise increase it.
               if(diff.gt.0)then
                  shift=1.d0
c
c if the pseudodiagonalization approximation -- that the wavefunction
c is almost stable -- is invalid, turn off newdg
                  if(diff.gt.1)newdg=.false.
               else
                  shift=-0.1d0
               endif
            else
               shift=ten+eigs(ihomo+1)-eigs(ihomo)+shift
            endif
            if(diff.gt.0.d0) then
               if(shift.gt.4.d0)shfmax=4.5d0
               if(shift.gt.shfmax)shfmax=dmax1(shfmax-0.5d0,0.d0)
            endif
c
c   if system goes unstable, limit shift to the range -infinity - shfmax
c   but if system is stable, limit shift to the range -infinity - +20
c
            shift=dmax1(-20.d0,dmin1(shfmax,shift))
            if(dabs(shift-shfmax).lt.1.d-5)shfmax=shfmax+0.01d0
c
c  the camp-king and pulay converges need a constant shift.
c  if the shift is allowed to vary, these convergers will not
c  work properly.
c
            if(okpuly.or.dabs(bshift-4.44d0).lt.1.d-5)then
               shift=-8.d0
               if(newdg) shift=0
            endif
            if(uhf)then
               if(newdg.and..not.(halfe.or.camkin))then
                  shiftb=ten-tenold
               else
                  shiftb=ten+eigs(ihomob+1)-eigs(ihomob)+shiftb
               endif
               if(diff.gt.0.d0)shiftb=dmin1(4.d0,shiftb)
               shiftb=dmax1(-20.d0,dmin1(shfmax,shiftb))
               if(okpuly.or.dabs(bshift-4.44d0).lt.1.d-5)then
                  shiftb=-8.d0
                  if(newdg)shift=0
               endif
               do 100 i=ihomob+1,norbs
  100          eigb(i)=eigb(i)+shiftb
            else
            endif
         endif
         tenold=ten
         if(pl.gt.plchek)then
            shftbo=shiftb
            shfto=shift
         else
            shiftb=shftbo
            shift=shfto
         endif
         do 110 i=ihomo+1,norbs
  110    eigs(i)=eigs(i)+shift
         do 130 i=1,norbs
            do 120 j=1,i
               l=l+1
  120       f(l)=h(l)+shift*pa(l)
  130    f(l)=f(l)-shift
      elseif (i.eq.77.and.last.eq.0.and.niter.lt.2.and.fulscf)then
c
c  slightly perturb the fock matrix in case the system is
c  trapped in a metastable excited electronic state
c
         random=0.001d0
         do 140 i=1,linear
            random=-random
  140    f(i)=h(i)+random
      else
         do 150 i=1,linear
  150    f(i)=h(i)
      endif
  160 continue
      if(timitr)then
         t0=secmop()
         write(mfgw,
     +   '(a,f7.2)')' load fock mat. integral',t0-titer0
      endif
c#      call timop('before fock2')
      call fock2(f,p,pa,w, wj, wk,numat,nat,nfirst,nmidle,nlast)
c#      call timop('after fock2')
c#      call timop('before fock1')
      call fock1(f,p,pa,pb)
c#      call timop('after fock1')
      if(timitr)then
         t0=secmop()
         tf1=tf1+t0-t1
         write(mfgw,
     +   '(2(a,f7.2))')'  fock1:',t0-t1,'integral:',t0-titer0
      endif
************************************************************************
*                                                                      *
*                        make the beta fock matrix                     *
*                                                                      *
************************************************************************
      if (uhf) then
         if(shiftb .ne. 0.d0) then
            l=0
            do 180 i=1,norbs
               do 170 j=1,i
                  l=l+1
  170          fb(l)=h(l)+shiftb*pb(l)
  180       fb(l)=fb(l)-shiftb
         elseif (rand.and.last.eq.0.and.niter.lt.2.and.fulscf)then
            random=0.001d0
            do 190 i=1,linear
               random=-random
  190       fb(i)=h(i)+random
         else
            do 200 i=1,linear
  200       fb(i)=h(i)
         endif
         call fock2(fb,p,pb,w, wj, wk,numat,nat,nfirst,nmidle,nlast)
         call fock1(fb,p,pb,pa)
      endif
      if( .not. fulscf) goto 380
      if(prtfok) then
         write(mfgw,210)niter
  210    format('   fock matrix on iteration',i3)
         call vecprt (f,norbs)
      endif
c
c   code the following line in properly sometime
c   this operation is believed to give rise to a better fock matrix
c   than the conventional guess.
c
      if(irrr.eq.0)then
         do 220 i=1,norbs
  220   f((i*(i+1))/2)=f((i*(i+1))/2)*0.5d0
         irrr=2
      endif
************************************************************************
*                                                                      *
*                        calculate the energy in kcal/mole             *
*                                                                      *
************************************************************************
      if (niter .ge. itrmax) then
         if(diff.lt.1.d-3.and.pl.lt.1.d-4.and..not.force)then
          write(mfgw,
     +   '('' unable to achieve self-consistence, job continuing'')')
            goto 380
         endif
         if(minprt)write (mfgw,230)
  230    format (//10x,'unable to achieve self-consistence'/)
         write (mfgw,240) diff,pl
  240    format (//,10x,'deltae= ',e12.4,5x,'deltap= ',e12.4,///)
         iflepo=9
         iiter=2
         call writmo(time0,escf)
_IF(ipsc,tools)
         call pend
_ELSE
         stop
_ENDIF
      endif
      ee=helect(norbs,pa,h,f)
      if(uhf)then
         ee=ee+helect(norbs,pb,h,fb)
      else
         ee=ee*2.d0
      endif
      if(capps)ee=ee+capcor(nat,nfirst,nlast,numat,p,h)
      if(bshift.ne.0.d0)
     1scorr=shift*(nopen-nclose)*23.061d0*0.25d0*(fract*(2.d0-fract))
      escf=(ee+enuclr)*23.061d0+atheat+scorr
      if(incitr)then
         diff=escf-eold
         if(diff.gt.0)then
            ten=ten-1.d0
         else
            ten=ten*0.975d0+0.05d0
         endif
c      patas
         if (mflag.eq.0) goto 9999
         if (icompf.eq.2) goto 9999
         if (index(keywrd,'jiali').ne.0.and.niter.eq.1) then
         write(mfgw,*)
         write(mfgw,*) ' iteration: ',niter
         write(mfgw,517) ' electronic energy: ',(ee+scorr)
         write(mfgw,517) ' nuclear energy:    ',enuclr
         write(mfgw,517) ' _______ solute:    ',(enuclr-ezq)
         write(mfgw,517) ' _______ solvent:   ',ezq
  517  format(a20,f16.7)
         emol=ee+scorr+enuclr
         write(mfgw,517) ' solute energy:     ',emol
         if (mflag.eq.6) goto 658
         eed=0.0d0
         eeq=0.0d0
         k=0
         nn=norbs+1
         do 656 i=2,nn
            k=k+1
            jj=i-1
            eed=eed+pa(k)*(hq(k)+hq(k))
            if (i.eq.nn) go to 656
            do 657 j=1,jj
               k=k+1
  657       eeq=eeq+pa(k)*(hq(k)+hq(k))
  656   continue
        eeq=eeq+0.5d0*eed
        eeq=eeq*2.d0
  658   continue
        if (mflag.ge.4) emol1=emol
        este=ezq+eeq
        gele1=emol-0.5d0*este
        write(mfgw,517) ' solvent energy:    ',este
        write(mfgw,517) ' free-energy:       ',gele1
        write(mfgw,517) ' delta energy:      ',(emol-emol0)*23.061d0
        write(mfgw,517) ' delta free energy: ',(gele1-emol0)*23.061d0
        endif
9999    continue
c     patas
c
c make sure self-consistency test is not more stringent than the
c computer can handle
c
         sellim=dmax1(selcon,eps*dmax1(dabs(ee),1.d0))
c
c scf test:  change in heat of formation in kcal/mol should be
c            less than sellim.  the other tests are safety measures
c
         if(.not.(niter.gt.4.and.(pl.eq.0.d0.or.pl.lt.pltest.and.
     1  dabs(diff).lt.sellim) .and. ready)) goto 270
************************************************************************
*                                                                      *
*          self-consistency test, exit mode from iterations            *
*                                                                      *
************************************************************************
  250    if (dabs(shift) .lt. 1.d-10) goto 380
         shift=0.0d0
         shiftb=0.0d0
         do 260 i=1,linear
  260    f(i)=h(i)
         makea=.true.
         makeb=.true.
         goto 160
  270    continue
***********************************************************************
***********************************************************************
         if(limscf.and.emin.ne.0.d0.and..not.(ci.or.halfe))then
c
c  the following tests are intended to allow a fast exit from iter
c  if the result is 'good enough' for the current step in the geometry
c  optimization
c
            if(escf.lt.emin)then
c
c  the energy is lower than the previous minimum.  now check that
c  it is consistently lower.
c
               iemax=0
               iemin=min(5,iemin+1)
               do 280 i=2,iemin
  280          escf0(i-1)=escf0(i)
               escf0(iemin)=escf
c
c  is the difference in energy between two iterations less than 5%
c  of the energy gain for this geometry relative to the previous
c  minimum.
c
               if(iemin.gt.3)then
                  do 290 i=2,iemin
                    if(dabs(escf0(i)-escf0(i-1)).gt.
     +                 0.05d0*(emin-escf))goto 320
  290             continue
c
c is good enough -- rapid exit
c
                  if(debug) write(mfgw,*)
     1' rapid exit because energy is consistently lower'
                  goto 250
               endif
            else
c
c  the energy has risen above that of the previous minimum.
c  we need to check whether this is a fluke or is this really
c  a bad geometry.
c
               iemin=0
               iemax=min(5,iemax+1)
               do 300 i=2,iemax
  300          escf0(i-1)=escf0(i)
               escf0(iemax)=escf
c
c  is the difference in energy between two iterations less than 5%
c  of the energy lost for this geometry relative to the previous
c  minimum.
c
               if(iemax.gt.3)then
                  do 310 i=2,iemax
                    if(dabs(escf0(i)-escf0(i-1)).gt.
     +                 0.05d0*(escf-emin)) goto 320
  310             continue
c
c is good enough -- rapid exit
c
                  if(debug) write(mfgw,*)
     1' rapid exit because energy is consistently higher'
                  goto 250
               endif
            endif
         endif
  320    ready=(iredy.gt.0.and.
     +         (dabs(diff).lt.sellim*10.d0.or.pl.eq.0.d0))
         iredy=iredy+1
      endif
      if(prtpl.or.debug.and.niter.gt.itrmax-20) then
         if(dabs(escf).gt.99999.d0) escf=dsign(9999.d0,escf)
         if(dabs(diff).gt.9999.d0)diff=0.0d0
         if(incitr)
     1    write(mfgw,
     +'('' iteration'',i3,'' pls='',2e10.3,'' energy  '',
     2f14.7,'' deltae'',f13.7)')niter,pl,plb,escf,diff
c     close (6)
c     open(unit=6,file=getnam('for006'),access='append')
      endif
      if(incitr)eold=escf
************************************************************************
*                                                                      *
*                        invoke the camp-king converger                *
*                                                                      *
************************************************************************
      if(niter.gt.2 .and. camkin .and. makea)
     1call interp(norbs,na1el,norbs-na1el, modea, escf/23.061d0,
     2f, c, ar1, ar2, ar3, ar4, ar1)
      makeb=.false.
      if(modea.eq.3)goto 340
      makeb=.true.
      if(timitr)then
         t0=secmop()
         write(mfgw,
     +   '(2(a,f7.2))')' adjust damper  integral',t0-titer0
      endif
      if( newdg ) then
************************************************************************
*                                                                      *
*                        invoke pulay's converger                      *
*                                                                      *
************************************************************************
         if(okpuly.and.makea.and.iredy.gt.1)
     1call pulay(f,pa,norbs,pold,pold2,pold3,jalp,ialp,mpack,frst,pl)
************************************************************************
*                                                                      *
*           diagonalize the alpha or rhf secular determinant           *
* where possible, use the pulay-stewart method, otherwise use beppu's  *
*                                                                      *
************************************************************************
         if (halfe.or.camkin) then
            call hqrii(f,norbs,norbs,eigs,c)
         else
c#      call timop('before diag')
            call mopd(f,c,na1el,eigs,norbs,norbs)
c#      call timop('after diag')
         endif
      else
c#      call timop('before hqrii')
         call hqrii(f,norbs,norbs,eigs,c)
c#      call timop('after hqrii')
         if(timitr)then
            t1=secmop()
            write(mfgw,
     +      '(2(a,f7.2))')'  hqrii:',t1-t0,' integral',t1-titer0
         endif
      endif
      j=1
      if(prtvec) then
         j=1
         if(uhf)j=2
         write(mfgw,'(//10x,a,
     1'' eigenvectors and eigenvalues on iteration'',i3)')
     2   abprt(j),niter
         call mopmat(c,eigs,norbs,norbs,norbs)
      else
         if (prteig) write(mfgw,330)
     +       abprt(j),niter,(eigs(i),i=1,norbs)
      endif
  330 format(10x,a,'  eigenvalues on iteration',i3,/10(6g13.6,/))
  340 if(ifill.ne.0)call mopx(c,norbs,norbs,na2el,ifill)
************************************************************************
*                                                                      *
*            calculate the alpha or rhf density matrix                 *
*                                                                      *
************************************************************************
      if(uhf)then
         call densit( c,norbs, norbs, na2el,na1el, fract, pa, 1)
         if(modea.ne.3.and..not. (newdg.and.okpuly))
     1    call cnvg(pa, pold, pold2, norbs, niter, pl)
      else
c#      call timop('before densit')
         call densit( c,norbs, norbs, na2el,na1el, fract, p, 1)
c#      call timop('after densit')
         if(modea.ne.3.and..not. (newdg.and.okpuly))then
c#      call timop('before cnvg')
            call cnvg(p, pold, pold2, norbs, niter, pl)
c#      call timop('after cnvg')
         endif
      endif
************************************************************************
*                                                                      *
*                       uhf-specific code                              *
*                                                                      *
************************************************************************
      if( uhf )then
************************************************************************
*                                                                      *
*                        invoke the camp-king converger                *
*                                                                      *
************************************************************************
         if(niter.gt.2 .and. camkin .and. makeb )
     1call interp(norbs,nb1el,norbs-nb1el, modeb, escf/23.061d0,
     2fb, cbeta, br1, br2, br3, br4, br1)
         makea=.false.
         if(modeb.eq.3) goto 350
         makea=.true.
         if( newdg ) then
************************************************************************
*                                                                      *
*                        invoke pulay's converger                      *
*                                                                      *
************************************************************************
            if( okpuly.and.makeb.and.iredy.gt.1)
     1call pulay(fb,pb,norbs,pbold,pbold2,
     2pbold3,jbet,ibet,mpack,bfrst,plb)
************************************************************************
*                                                                      *
*           diagonalize the alpha or rhf secular determinant           *
* where possible, use the pulay-stewart method, otherwise use beppu's  *
*                                                                      *
************************************************************************
            if (halfe.or.camkin) then
               call hqrii(fb,norbs,norbs,eigb,cbeta)
            else
               call mopd (fb,cbeta,nb1el,eigb,norbs,norbs)
            endif
         else
            call hqrii(fb,norbs,norbs,eigb,cbeta)
         endif
         if(prtvec) then
            write(mfgw,'(//10x,a,'' eigenvectors and eigenvalues on '',
     1''iteration'',i3)')abprt(3),niter
            call mopmat(cbeta,eigb,norbs,norbs,norbs)
         else
            if (prteig) write(mfgw,330)
     +      abprt(3),niter,(eigb(i),i=1,norbs)
         endif
************************************************************************
*                                                                      *
*                calculate the beta density matrix                     *
*                                                                      *
************************************************************************
  350    call densit( cbeta,norbs, norbs, nb2el, nb1el, fract, pb, 1)
         if( .not. (newdg.and.okpuly))
     1call cnvg(pb, pbold, pbold2, norbs, niter, plb)
      endif
************************************************************************
*                                                                      *
*                   calculate the total density matrix                 *
*                                                                      *
************************************************************************
      if(uhf) then
         do 360 i=1,linear
  360    p(i)=pa(i)+pb(i)
      else
         do 370 i=1,linear
            pa(i)=p(i)*0.5d0
  370    pb(i)=pa(i)
      endif
      if(prtden) then
         write(mfgw,'('' density matrix on iteration'',i4)')niter
         call vecprt (p,norbs)
      endif
      oknewd=(pl.lt.sellim .or. oknewd)
      newdg=(pl.lt.trans .and. oknewd .or. newdg)
      if(pl.lt.trans*0.3333d0)oknewd=.true.
      go to 90
**********************************************************************
*                                                                    *
*                                                                    *
*                      end the scf loop here                         *
*                now calculate the electronic energy                 *
*                                                                    *
*                                                                    *
**********************************************************************
*          self-consistence acheived.
*
  380 ee=helect(norbs,pa,h,f)
      if(uhf) then
         ee=ee+helect(norbs,pb,h,fb)
      else
         ee=ee*2.d0 +
     1shift*(nopen-nclose)*23.061d0*0.25d0*(fract*(2.d0-fract))
      endif
      if(capps)ee=ee+capcor(nat,nfirst,nlast,numat,p,h)
c      patas
      if (mflag.eq.0) emol0=ee+enuclr
      if (icompf.eq.1.or.mflag.eq.0) goto 9998
      if (index(keywrd,'tom').ne.0.and.mflag.ne.6) then
         eed=0.0d0
         eeq=0.0d0
         k=0
         nn=norbs+1
         do 756 i=2,nn
            k=k+1
            jj=i-1
            eed=eed+pa(k)*(hq(k)+hq(k))
            if (i.eq.nn) go to 756
            do 757 j=1,jj
               k=k+1
  757       eeq=eeq+pa(k)*(hq(k)+hq(k))
  756   continue
        eeq=eeq+0.5d0*eed
        eeq=eeq*2.d0
      endif
         if (index(keywrd,'jiali').ne.0) then
         write(mfgw,*)
         write(mfgw,*) ' iteration: ',niter
         write(mfgw,517) ' electronic energy: ',ee
         write(mfgw,517) ' nuclear energy:    ',enuclr
         write(mfgw,517) ' _______ solute:    ',(enuclr-ezq)
         write(mfgw,517) ' _______ solvent:   ',ezq
         emol=ee+enuclr
         write(mfgw,517) ' solute energy:     ',emol
        este=ezq+eeq
        gele=emol-0.5d0*este
        write(mfgw,517) ' solvent energy:    ',este
        write(mfgw,517) ' free-energy:       ',gele
        write(mfgw,*)
        write(mfgw,517) ' delta energy:      ',
     1(emol-emol0)*23.061d0
        write(mfgw,517) ' delta g:           ',
     1(gele-emol0)*23.061d0
        if (mflag.eq.4) write(mfgw,517) ' delta e (pol):     ',
     1(emol-emol1)*23.061d0
        if (mflag.eq.6) write(mfgw,517) ' delta e (dis):     ',
     1(emol-emol1)*23.061d0
        endif
c
c     save psi in vacuo to be used when mflag=4
c
      if (icompf.eq.2) then
      if (index(keywrd,'tom').ne.0.and.mflag.eq.0) then
c     mflag=0: gas phase computation
      do 402 i=1,linear
      pgasa(i)=pa(i)
       if (uhf) pgasb(i)=pb(i)
  402 continue
      endif
c
c     save psi in solution to be used when mflag=6
c
      if (index(keywrd,'tom').ne.0.and.mflag.eq.1) then
c     mflag=1:  solvation computation
      do 405 i=1,linear
      psona(i)=pa(i)
      if (uhf) psonb(i)=pb(i)
  405 continue
      endif
      endif
9998  continue
c     patas
c
c   normally the eigenvalues are incorrect because the
c   pseudodiagonalization has been used.  if this
c   is the last scf, then do an exact diagonalization
      if( nscf.eq.0 .or. last.eq.1 .or. ci .or. halfe ) then
c
c  put f and fb into pold in order to not destroy f and fb
c  and do exact diagonalisations
         do 390 i=1,linear
  390    pold(i)=f(i)
         call hqrii(pold,norbs,norbs,eigs,c)
         if(uhf) then
            do 400 i=1,linear
  400       pold(i)=fb(i)
            call hqrii(pold,norbs,norbs,eigb,cbeta)
            do 410 i=1,linear
  410       pold(i)=pa(i)
         else
            do 420 i=1,linear
  420       pold(i)=p(i)
         endif
         if(ci.or.halfe) then
c#        call timop('before meci')
            sum=meci(eigs,c)
c#        call timop('after meci')
            ee=ee+sum
            if(prtpl)then
               escf=(ee+enuclr)*23.061d0 +atheat
               write(mfgw,
     +         '(27x,''after meci, energy  '',f14.7)')escf
            endif
         endif
      endif
      nscf=nscf+1
      if(debug)write(mfgw,
     +         '('' no. of iterations ='',i6)')niter
c            if(force)  scfcrt=1.d-5
      if(allcon.and.dabs(bshift-4.44d0).lt.1.d-7)then
         camkin=.false.
         allcon=.false.
         newdg=.false.
         bshift=-10.d0
         okpuly=.false.
      endif
      shift=1.d0
      if(emin.eq.0.d0)then
         emin=escf
      else
         emin=dmin1(emin,escf)
      endif
      return
      end
      subroutine jab(ia,ja,llperm,jindex, jjndex,pja,pjb,w, f)
      implicit REAL (a-h,o-z)
      dimension llperm(10), pja(16), pjb(16), w(*), f(*),
     1jindex(256), jjndex(256), suma(10), sumb(10)
c
c  for vector machines, remove the arrays  suma and sumb, uncomment
c  the lines marked cvector, and comment out the second whole part
c  of the subroutine
cvector                  i=0
cvector                  do 100 i5=1,4
cvector                  iia=ia+i5-1
cvector                  ija=ja+i5-1
cvector                  ioff=(iia*(iia-1))/2+ia-1
cvector                  joff=(ija*(ija-1))/2+ja-1
cvector                  do 100 i6=1,i5
cvector                  ioff=ioff+1
cvector                  joff=joff+1
cvector                        i=i+1
cvector                        l=llperm(i)
cvector                        suma=0
cvector                        sumb=0
cvector                        do 90 k=1,16
cvector                           l=l+1
cvector                           sumb=sumb+pja(k)*w(jjndex(l))
cvector   90                   suma=suma+pjb(k)*w(jindex(l))
cvector                        f(ioff)=f(ioff)+suma
cvector  100             f(joff)=f(joff)+sumb
      suma( 1)=
     1+pja( 1)*w(  1)+pja( 2)*w( 11)+pja( 3)*w( 31)+pja( 4)*w( 61)
     2+pja( 5)*w( 11)+pja( 6)*w( 21)+pja( 7)*w( 41)+pja( 8)*w( 71)
     3+pja( 9)*w( 31)+pja(10)*w( 41)+pja(11)*w( 51)+pja(12)*w( 81)
     4+pja(13)*w( 61)+pja(14)*w( 71)+pja(15)*w( 81)+pja(16)*w( 91)
      suma( 2)=
     1+pja( 1)*w(  2)+pja( 2)*w( 12)+pja( 3)*w( 32)+pja( 4)*w( 62)
     2+pja( 5)*w( 12)+pja( 6)*w( 22)+pja( 7)*w( 42)+pja( 8)*w( 72)
     3+pja( 9)*w( 32)+pja(10)*w( 42)+pja(11)*w( 52)+pja(12)*w( 82)
     4+pja(13)*w( 62)+pja(14)*w( 72)+pja(15)*w( 82)+pja(16)*w( 92)
      suma( 3)=
     1+pja( 1)*w(  3)+pja( 2)*w( 13)+pja( 3)*w( 33)+pja( 4)*w( 63)
     2+pja( 5)*w( 13)+pja( 6)*w( 23)+pja( 7)*w( 43)+pja( 8)*w( 73)
     3+pja( 9)*w( 33)+pja(10)*w( 43)+pja(11)*w( 53)+pja(12)*w( 83)
     4+pja(13)*w( 63)+pja(14)*w( 73)+pja(15)*w( 83)+pja(16)*w( 93)
      suma( 4)=
     1+pja( 1)*w(  4)+pja( 2)*w( 14)+pja( 3)*w( 34)+pja( 4)*w( 64)
     2+pja( 5)*w( 14)+pja( 6)*w( 24)+pja( 7)*w( 44)+pja( 8)*w( 74)
     3+pja( 9)*w( 34)+pja(10)*w( 44)+pja(11)*w( 54)+pja(12)*w( 84)
     4+pja(13)*w( 64)+pja(14)*w( 74)+pja(15)*w( 84)+pja(16)*w( 94)
      suma( 5)=
     1+pja( 1)*w(  5)+pja( 2)*w( 15)+pja( 3)*w( 35)+pja( 4)*w( 65)
     2+pja( 5)*w( 15)+pja( 6)*w( 25)+pja( 7)*w( 45)+pja( 8)*w( 75)
     3+pja( 9)*w( 35)+pja(10)*w( 45)+pja(11)*w( 55)+pja(12)*w( 85)
     4+pja(13)*w( 65)+pja(14)*w( 75)+pja(15)*w( 85)+pja(16)*w( 95)
      suma( 6)=
     1+pja( 1)*w(  6)+pja( 2)*w( 16)+pja( 3)*w( 36)+pja( 4)*w( 66)
     2+pja( 5)*w( 16)+pja( 6)*w( 26)+pja( 7)*w( 46)+pja( 8)*w( 76)
     3+pja( 9)*w( 36)+pja(10)*w( 46)+pja(11)*w( 56)+pja(12)*w( 86)
     4+pja(13)*w( 66)+pja(14)*w( 76)+pja(15)*w( 86)+pja(16)*w( 96)
      suma( 7)=
     1+pja( 1)*w(  7)+pja( 2)*w( 17)+pja( 3)*w( 37)+pja( 4)*w( 67)
     2+pja( 5)*w( 17)+pja( 6)*w( 27)+pja( 7)*w( 47)+pja( 8)*w( 77)
     3+pja( 9)*w( 37)+pja(10)*w( 47)+pja(11)*w( 57)+pja(12)*w( 87)
     4+pja(13)*w( 67)+pja(14)*w( 77)+pja(15)*w( 87)+pja(16)*w( 97)
      suma( 8)=
     1+pja( 1)*w(  8)+pja( 2)*w( 18)+pja( 3)*w( 38)+pja( 4)*w( 68)
     2+pja( 5)*w( 18)+pja( 6)*w( 28)+pja( 7)*w( 48)+pja( 8)*w( 78)
     3+pja( 9)*w( 38)+pja(10)*w( 48)+pja(11)*w( 58)+pja(12)*w( 88)
     4+pja(13)*w( 68)+pja(14)*w( 78)+pja(15)*w( 88)+pja(16)*w( 98)
      suma( 9)=
     1+pja( 1)*w(  9)+pja( 2)*w( 19)+pja( 3)*w( 39)+pja( 4)*w( 69)
     2+pja( 5)*w( 19)+pja( 6)*w( 29)+pja( 7)*w( 49)+pja( 8)*w( 79)
     3+pja( 9)*w( 39)+pja(10)*w( 49)+pja(11)*w( 59)+pja(12)*w( 89)
     4+pja(13)*w( 69)+pja(14)*w( 79)+pja(15)*w( 89)+pja(16)*w( 99)
      suma(10)=
     1+pja( 1)*w( 10)+pja( 2)*w( 20)+pja( 3)*w( 40)+pja( 4)*w( 70)
     2+pja( 5)*w( 20)+pja( 6)*w( 30)+pja( 7)*w( 50)+pja( 8)*w( 80)
     3+pja( 9)*w( 40)+pja(10)*w( 50)+pja(11)*w( 60)+pja(12)*w( 90)
     4+pja(13)*w( 70)+pja(14)*w( 80)+pja(15)*w( 90)+pja(16)*w(100)
      sumb( 1)=
     1+pjb( 1)*w(  1)+pjb( 2)*w(  2)+pjb( 3)*w(  4)+pjb( 4)*w(  7)
     2+pjb( 5)*w(  2)+pjb( 6)*w(  3)+pjb( 7)*w(  5)+pjb( 8)*w(  8)
     3+pjb( 9)*w(  4)+pjb(10)*w(  5)+pjb(11)*w(  6)+pjb(12)*w(  9)
     4+pjb(13)*w(  7)+pjb(14)*w(  8)+pjb(15)*w(  9)+pjb(16)*w( 10)
      sumb( 2)=
     1+pjb( 1)*w( 11)+pjb( 2)*w( 12)+pjb( 3)*w( 14)+pjb( 4)*w( 17)
     2+pjb( 5)*w( 12)+pjb( 6)*w( 13)+pjb( 7)*w( 15)+pjb( 8)*w( 18)
     3+pjb( 9)*w( 14)+pjb(10)*w( 15)+pjb(11)*w( 16)+pjb(12)*w( 19)
     4+pjb(13)*w( 17)+pjb(14)*w( 18)+pjb(15)*w( 19)+pjb(16)*w( 20)
      sumb( 3)=
     1+pjb( 1)*w( 21)+pjb( 2)*w( 22)+pjb( 3)*w( 24)+pjb( 4)*w( 27)
     2+pjb( 5)*w( 22)+pjb( 6)*w( 23)+pjb( 7)*w( 25)+pjb( 8)*w( 28)
     3+pjb( 9)*w( 24)+pjb(10)*w( 25)+pjb(11)*w( 26)+pjb(12)*w( 29)
     4+pjb(13)*w( 27)+pjb(14)*w( 28)+pjb(15)*w( 29)+pjb(16)*w( 30)
      sumb( 4)=
     1+pjb( 1)*w( 31)+pjb( 2)*w( 32)+pjb( 3)*w( 34)+pjb( 4)*w( 37)
     2+pjb( 5)*w( 32)+pjb( 6)*w( 33)+pjb( 7)*w( 35)+pjb( 8)*w( 38)
     3+pjb( 9)*w( 34)+pjb(10)*w( 35)+pjb(11)*w( 36)+pjb(12)*w( 39)
     4+pjb(13)*w( 37)+pjb(14)*w( 38)+pjb(15)*w( 39)+pjb(16)*w( 40)
      sumb( 5)=
     1+pjb( 1)*w( 41)+pjb( 2)*w( 42)+pjb( 3)*w( 44)+pjb( 4)*w( 47)
     2+pjb( 5)*w( 42)+pjb( 6)*w( 43)+pjb( 7)*w( 45)+pjb( 8)*w( 48)
     3+pjb( 9)*w( 44)+pjb(10)*w( 45)+pjb(11)*w( 46)+pjb(12)*w( 49)
     4+pjb(13)*w( 47)+pjb(14)*w( 48)+pjb(15)*w( 49)+pjb(16)*w( 50)
      sumb( 6)=
     1+pjb( 1)*w( 51)+pjb( 2)*w( 52)+pjb( 3)*w( 54)+pjb( 4)*w( 57)
     2+pjb( 5)*w( 52)+pjb( 6)*w( 53)+pjb( 7)*w( 55)+pjb( 8)*w( 58)
     3+pjb( 9)*w( 54)+pjb(10)*w( 55)+pjb(11)*w( 56)+pjb(12)*w( 59)
     4+pjb(13)*w( 57)+pjb(14)*w( 58)+pjb(15)*w( 59)+pjb(16)*w( 60)
      sumb( 7)=
     1+pjb( 1)*w( 61)+pjb( 2)*w( 62)+pjb( 3)*w( 64)+pjb( 4)*w( 67)
     2+pjb( 5)*w( 62)+pjb( 6)*w( 63)+pjb( 7)*w( 65)+pjb( 8)*w( 68)
     3+pjb( 9)*w( 64)+pjb(10)*w( 65)+pjb(11)*w( 66)+pjb(12)*w( 69)
     4+pjb(13)*w( 67)+pjb(14)*w( 68)+pjb(15)*w( 69)+pjb(16)*w( 70)
      sumb( 8)=
     1+pjb( 1)*w( 71)+pjb( 2)*w( 72)+pjb( 3)*w( 74)+pjb( 4)*w( 77)
     2+pjb( 5)*w( 72)+pjb( 6)*w( 73)+pjb( 7)*w( 75)+pjb( 8)*w( 78)
     3+pjb( 9)*w( 74)+pjb(10)*w( 75)+pjb(11)*w( 76)+pjb(12)*w( 79)
     4+pjb(13)*w( 77)+pjb(14)*w( 78)+pjb(15)*w( 79)+pjb(16)*w( 80)
      sumb( 9)=
     1+pjb( 1)*w( 81)+pjb( 2)*w( 82)+pjb( 3)*w( 84)+pjb( 4)*w( 87)
     2+pjb( 5)*w( 82)+pjb( 6)*w( 83)+pjb( 7)*w( 85)+pjb( 8)*w( 88)
     3+pjb( 9)*w( 84)+pjb(10)*w( 85)+pjb(11)*w( 86)+pjb(12)*w( 89)
     4+pjb(13)*w( 87)+pjb(14)*w( 88)+pjb(15)*w( 89)+pjb(16)*w( 90)
      sumb(10)=
     1+pjb( 1)*w( 91)+pjb( 2)*w( 92)+pjb( 3)*w( 94)+pjb( 4)*w( 97)
     2+pjb( 5)*w( 92)+pjb( 6)*w( 93)+pjb( 7)*w( 95)+pjb( 8)*w( 98)
     3+pjb( 9)*w( 94)+pjb(10)*w( 95)+pjb(11)*w( 96)+pjb(12)*w( 99)
     4+pjb(13)*w( 97)+pjb(14)*w( 98)+pjb(15)*w( 99)+pjb(16)*w(100)
      i=0
      do 10 i5=1,4
         iia=ia+i5-1
         ija=ja+i5-1
         ioff=(iia*(iia-1))/2+ia-1
         joff=(ija*(ija-1))/2+ja-1
         do 10 i6=1,i5
            ioff=ioff+1
            joff=joff+1
            i=i+1
            f(ioff)=f(ioff)+sumb(i)
   10 f(joff)=f(joff)+suma(i)
      return
      end
      subroutine jcarin (coord,xparam,step,preci,b,ncol)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
c     jacobian dcartesian/dinternal, worked out by finite difference.
c  input
c     xparam(*) : internal coordinates
c     step      : step size for finite difference method
c     preci     : .true. if 2-points finite differences to be used,
c                 .false. otherwise.
c  output
c     b(nvar,ncol) : jacobian, step time too large.
c
      common /geosym/ ndep, locpar(maxpar), idepfn(maxpar),
     1                      locdep(maxpar)
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),
     1                nlast(numatm), norbs, nelecs,nalpha,nbeta,
     2                nclose,nopen,ndumy,fract
      common /geovar/ nvar,loc(2,maxpar), idumy, yparam(maxpar)
      common /euler / tvec(3,3),id
      common /ucell/ l1l,l2l,l3l,l1u,l2u,l3u
      common /cmpg/ geo(3,numatm)
      dimension coord(3,*),xparam(*),b(nvar,*), coold(3,numatm*27)
      logical preci
c
      ncol=3*numat
      if(id.ne.0)
     1 ncol=ncol*(l1u-l1l+1)*(l2u-l2l+1)*(l3u-l3l+1)
c
c     internal of central point
      do 10 ivar=1,nvar
   10 geo(loc(2,ivar),loc(1,ivar))=xparam(ivar)
c
      if (id.eq.0) then
c
c        molecular system
c        ----------------
         do 30 ivar=1,nvar
c        step forward
            geo(loc(2,ivar),loc(1,ivar))=xparam(ivar)+step
            if(ndep.ne.0) call mopsym()
            call gmetry (geo,coord)
            do 20 j=1,ncol
   20       b(ivar,j)=coord(j,1)
   30    geo(loc(2,ivar),loc(1,ivar))=xparam(ivar)
         if (preci) then
            do 50 ivar=1,nvar
c           step backward
               geo(loc(2,ivar),loc(1,ivar))=xparam(ivar)-step
               if(ndep.ne.0) call mopsym()
               call gmetry (geo,coord)
               do 40 j=1,ncol
   40          b(ivar,j)=b(ivar,j)-coord(j,1)
   50       geo(loc(2,ivar),loc(1,ivar))=xparam(ivar)
         else
c           central point
            if(ndep.ne.0) call mopsym()
            call gmetry (geo,coord)
            do 60 ivar=1,nvar
               do 60 j=1,ncol
   60       b(ivar,j)=b(ivar,j)-coord(j,1)
         endif
      else
c
c        solid state
c        -----------
         do 80 ivar=1,nvar
c        step forward
            geo(loc(2,ivar),loc(1,ivar))=xparam(ivar)+step
            if(ndep.ne.0) call mopsym()
            call gmetry (geo,coord)
            ij=0
            do 70 ii=1,numat
               do 70 il=l1l,l1u
                  do 70 jl=l2l,l2u
                     do 70 kl=l3l,l3u
                        do 70 ll=1,3
                           ij=ij+1
   70       b(ivar,ij)=coord(ll,ii)
     1            +tvec(ll,1)*il+tvec(ll,2)*jl+tvec(ll,3)*kl
   80    geo(loc(2,ivar),loc(1,ivar))=xparam(ivar)
         if (preci) then
            do 100 ivar=1,nvar
c           step backward
               geo(loc(2,ivar),loc(1,ivar))=xparam(ivar)-step
               if(ndep.ne.0) call mopsym()
               call gmetry (geo,coord)
               ij=0
               do 90 ii=1,numat
                  do 90 il=l1l,l1u
                     do 90 jl=l2l,l2u
                        do 90 kl=l3l,l3u
                           do 90 ll=1,3
                              ij=ij+1
   90          b(ivar,ij)=b(ivar,ij)-coord(ll,ii)
     1                -tvec(ll,1)*il-tvec(ll,2)*jl-tvec(ll,3)*kl
  100       geo(loc(2,ivar),loc(1,ivar))=xparam(ivar)
         else
c           central point
            if(ndep.ne.0) call mopsym()
            call gmetry (geo,coord)
            ij=0
            do 110 ii=1,numat
               do 110 il=l1l,l1u
                  do 110 jl=l2l,l2u
                     do 110 kl=l3l,l3u
                        ij=ij+1
                        do 110 ll=1,3
  110       coold(ll,ij)=coord(ll,ii)
     1                  +tvec(ll,1)*il+tvec(ll,2)*jl+tvec(ll,3)*kl
            do 120 ivar=1,nvar
               do 120 ij=1,ncol
  120       b(ivar,ij)=b(ivar,ij)-coold(ij,1)
         endif
      endif
      return
      end
      subroutine kab(ia,ja, pk, w, kindex, f)
      implicit REAL (a-h,o-z)
      dimension pk(*), w(*), f(*),kindex(256), sum(16)
c
c  for vector machines, remove the array sum, uncomment the lines
c  marked cvector, and comment out the second whole part of the
c  routine
c
cvector                  l=0
cvector                  m=0
cvector                  do 130 j1=ia,ia+3
cvector                  j=(j1*(j1-1))/2
cvector                  do 130 j2=ja,ja+3
cvector                  m=m+1
cvector                  if(ia.gt.ja)then
cvector                  j3=j+j2
cvector                  else
cvector                  j3=j1+(j2*(j2-1))/2
cvector                  endif
cvector                     sum=0
cvector                     do 120 i=1,16
cvector                        l=l+1
cvector  120                sum=sum+pk(i)*w(kindex(l))
cvector  130             f(j3)=f(j3)-sum
      sum( 1)=
     1+pk( 1)*w(  1)+pk( 2)*w(  2)+pk( 3)*w(  4)+pk( 4)*w(  7)
     2+pk( 5)*w( 11)+pk( 6)*w( 12)+pk( 7)*w( 14)+pk( 8)*w( 17)
     3+pk( 9)*w( 31)+pk(10)*w( 32)+pk(11)*w( 34)+pk(12)*w( 37)
     4+pk(13)*w( 61)+pk(14)*w( 62)+pk(15)*w( 64)+pk(16)*w( 67)
      sum( 2)=
     1+pk( 1)*w(  2)+pk( 2)*w(  3)+pk( 3)*w(  5)+pk( 4)*w(  8)
     2+pk( 5)*w( 12)+pk( 6)*w( 13)+pk( 7)*w( 15)+pk( 8)*w( 18)
     3+pk( 9)*w( 32)+pk(10)*w( 33)+pk(11)*w( 35)+pk(12)*w( 38)
     4+pk(13)*w( 62)+pk(14)*w( 63)+pk(15)*w( 65)+pk(16)*w( 68)
      sum( 3)=
     1+pk( 1)*w(  4)+pk( 2)*w(  5)+pk( 3)*w(  6)+pk( 4)*w(  9)
     2+pk( 5)*w( 14)+pk( 6)*w( 15)+pk( 7)*w( 16)+pk( 8)*w( 19)
     3+pk( 9)*w( 34)+pk(10)*w( 35)+pk(11)*w( 36)+pk(12)*w( 39)
     4+pk(13)*w( 64)+pk(14)*w( 65)+pk(15)*w( 66)+pk(16)*w( 69)
      sum( 4)=
     1+pk( 1)*w(  7)+pk( 2)*w(  8)+pk( 3)*w(  9)+pk( 4)*w( 10)
     2+pk( 5)*w( 17)+pk( 6)*w( 18)+pk( 7)*w( 19)+pk( 8)*w( 20)
     3+pk( 9)*w( 37)+pk(10)*w( 38)+pk(11)*w( 39)+pk(12)*w( 40)
     4+pk(13)*w( 67)+pk(14)*w( 68)+pk(15)*w( 69)+pk(16)*w( 70)
      sum( 5)=
     1+pk( 1)*w( 11)+pk( 2)*w( 12)+pk( 3)*w( 14)+pk( 4)*w( 17)
     2+pk( 5)*w( 21)+pk( 6)*w( 22)+pk( 7)*w( 24)+pk( 8)*w( 27)
     3+pk( 9)*w( 41)+pk(10)*w( 42)+pk(11)*w( 44)+pk(12)*w( 47)
     4+pk(13)*w( 71)+pk(14)*w( 72)+pk(15)*w( 74)+pk(16)*w( 77)
      sum( 6)=
     1+pk( 1)*w( 12)+pk( 2)*w( 13)+pk( 3)*w( 15)+pk( 4)*w( 18)
     2+pk( 5)*w( 22)+pk( 6)*w( 23)+pk( 7)*w( 25)+pk( 8)*w( 28)
     3+pk( 9)*w( 42)+pk(10)*w( 43)+pk(11)*w( 45)+pk(12)*w( 48)
     4+pk(13)*w( 72)+pk(14)*w( 73)+pk(15)*w( 75)+pk(16)*w( 78)
      sum( 7)=
     1+pk( 1)*w( 14)+pk( 2)*w( 15)+pk( 3)*w( 16)+pk( 4)*w( 19)
     2+pk( 5)*w( 24)+pk( 6)*w( 25)+pk( 7)*w( 26)+pk( 8)*w( 29)
     3+pk( 9)*w( 44)+pk(10)*w( 45)+pk(11)*w( 46)+pk(12)*w( 49)
     4+pk(13)*w( 74)+pk(14)*w( 75)+pk(15)*w( 76)+pk(16)*w( 79)
      sum( 8)=
     1+pk( 1)*w( 17)+pk( 2)*w( 18)+pk( 3)*w( 19)+pk( 4)*w( 20)
     2+pk( 5)*w( 27)+pk( 6)*w( 28)+pk( 7)*w( 29)+pk( 8)*w( 30)
     3+pk( 9)*w( 47)+pk(10)*w( 48)+pk(11)*w( 49)+pk(12)*w( 50)
     4+pk(13)*w( 77)+pk(14)*w( 78)+pk(15)*w( 79)+pk(16)*w( 80)
      sum( 9)=
     1+pk( 1)*w( 31)+pk( 2)*w( 32)+pk( 3)*w( 34)+pk( 4)*w( 37)
     2+pk( 5)*w( 41)+pk( 6)*w( 42)+pk( 7)*w( 44)+pk( 8)*w( 47)
     3+pk( 9)*w( 51)+pk(10)*w( 52)+pk(11)*w( 54)+pk(12)*w( 57)
     4+pk(13)*w( 81)+pk(14)*w( 82)+pk(15)*w( 84)+pk(16)*w( 87)
      sum(10)=
     1+pk( 1)*w( 32)+pk( 2)*w( 33)+pk( 3)*w( 35)+pk( 4)*w( 38)
     2+pk( 5)*w( 42)+pk( 6)*w( 43)+pk( 7)*w( 45)+pk( 8)*w( 48)
     3+pk( 9)*w( 52)+pk(10)*w( 53)+pk(11)*w( 55)+pk(12)*w( 58)
     4+pk(13)*w( 82)+pk(14)*w( 83)+pk(15)*w( 85)+pk(16)*w( 88)
      sum(11)=
     1+pk( 1)*w( 34)+pk( 2)*w( 35)+pk( 3)*w( 36)+pk( 4)*w( 39)
     2+pk( 5)*w( 44)+pk( 6)*w( 45)+pk( 7)*w( 46)+pk( 8)*w( 49)
     3+pk( 9)*w( 54)+pk(10)*w( 55)+pk(11)*w( 56)+pk(12)*w( 59)
     4+pk(13)*w( 84)+pk(14)*w( 85)+pk(15)*w( 86)+pk(16)*w( 89)
      sum(12)=
     1+pk( 1)*w( 37)+pk( 2)*w( 38)+pk( 3)*w( 39)+pk( 4)*w( 40)
     2+pk( 5)*w( 47)+pk( 6)*w( 48)+pk( 7)*w( 49)+pk( 8)*w( 50)
     3+pk( 9)*w( 57)+pk(10)*w( 58)+pk(11)*w( 59)+pk(12)*w( 60)
     4+pk(13)*w( 87)+pk(14)*w( 88)+pk(15)*w( 89)+pk(16)*w( 90)
      sum(13)=
     1+pk( 1)*w( 61)+pk( 2)*w( 62)+pk( 3)*w( 64)+pk( 4)*w( 67)
     2+pk( 5)*w( 71)+pk( 6)*w( 72)+pk( 7)*w( 74)+pk( 8)*w( 77)
     3+pk( 9)*w( 81)+pk(10)*w( 82)+pk(11)*w( 84)+pk(12)*w( 87)
     4+pk(13)*w( 91)+pk(14)*w( 92)+pk(15)*w( 94)+pk(16)*w( 97)
      sum(14)=
     1+pk( 1)*w( 62)+pk( 2)*w( 63)+pk( 3)*w( 65)+pk( 4)*w( 68)
     2+pk( 5)*w( 72)+pk( 6)*w( 73)+pk( 7)*w( 75)+pk( 8)*w( 78)
     3+pk( 9)*w( 82)+pk(10)*w( 83)+pk(11)*w( 85)+pk(12)*w( 88)
     4+pk(13)*w( 92)+pk(14)*w( 93)+pk(15)*w( 95)+pk(16)*w( 98)
      sum(15)=
     1+pk( 1)*w( 64)+pk( 2)*w( 65)+pk( 3)*w( 66)+pk( 4)*w( 69)
     2+pk( 5)*w( 74)+pk( 6)*w( 75)+pk( 7)*w( 76)+pk( 8)*w( 79)
     3+pk( 9)*w( 84)+pk(10)*w( 85)+pk(11)*w( 86)+pk(12)*w( 89)
     4+pk(13)*w( 94)+pk(14)*w( 95)+pk(15)*w( 96)+pk(16)*w( 99)
      sum(16)=
     1+pk( 1)*w( 67)+pk( 2)*w( 68)+pk( 3)*w( 69)+pk( 4)*w( 70)
     2+pk( 5)*w( 77)+pk( 6)*w( 78)+pk( 7)*w( 79)+pk( 8)*w( 80)
     3+pk( 9)*w( 87)+pk(10)*w( 88)+pk(11)*w( 89)+pk(12)*w( 90)
     4+pk(13)*w( 97)+pk(14)*w( 98)+pk(15)*w( 99)+pk(16)*w(100)
      if(ia.gt.ja)then
         m=0
         do 10 j1=ia,ia+3
            j=(j1*(j1-1))/2
            do 10 j2=ja,ja+3
               m=m+1
               j3=j+j2
   10    f(j3)=f(j3)-sum(m)
      else
c
c   ia is less than ja, therefore use other half of triangle
c
         m=0
         do 20 j1=ia,ia+3
            do 20 j2=ja,ja+3
               m=m+1
               j3=(j2*(j2-1))/2+j1
   20    f(j3)=f(j3)-sum(m)
      endif
      return
      end
      subroutine linmin(xparam,alpha,pvect,nvar,funct,okf,ic, dott)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      dimension xparam(nvar),pvect(nvar)
      common /gravec/ cosine
      common /numcal/ numcal
c*********************************************************************
c
c  linmin does a line minimisation.
c
c  on input:  xparam = starting coordinate of search.
c             alpha  = step size for initiating search.
c             pvect  = direction of search.
c             nvar   = number of variables in xparam.
c             funct  = initial value of the function to be minimized.
c             isok   = not important.
c             cosine = cosine of angle of current and previous gradient.
c
c  on output: xparam = coordinate of minimum of functi0n.
c             alpha  = new step size, used in next call of linmin.
c             funct  = final, minimum value of the function.
c             okf    = true if linmin improved funct, false otherwise.
c
c**********************************************************************
      common /keywrd/ keywrd
      common /iofile/ mfgr,mfgw
c
c  the following common is used to find out if a non-variationally
c  optimized wave-function is being used.
c
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),
     1                nlast(numatm), norbs, nelecs,nalpha,nbeta,
     2                nclose,nopen,ndumy,fract
      character keywrd*241
      dimension phi(3), vt(4)
      dimension xstor(maxpar), xparef(maxpar)
      integer left,right,center
      logical print,okf, halfe, diis
*******
      save
*******
*     save icalcn, print, halfe, xmaxm, i
*     save maxlin,  ymaxst
*******
      data icalcn /0/
      if (icalcn.ne.numcal) then
         halfe =(index(keywrd,'c.i.') .ne. 0 .or. nclose.ne.nopen)
         if(index(keywrd,'gnorm') .ne. 0)
     1drop=drop*dmin1(reada(keywrd,index(keywrd,'gnorm')),1.d0)
         xmaxm  = 0.4d0
         delta2 = 0.001d0
         if(index(keywrd,'noth') .eq. 0) then
            delta1 = 0.5d0
         else
            delta1 = 0.1d0
         endif
         alpha  = 1.d0
         maxlin = 15
         if(nvar.eq.1)then
            pvect(1)=0.01d0
            drop=0.01d0
            alpha=1.d0
            delta1 = 0.00005d0
            delta2 = 0.00001d0
            if(index(keywrd,'prec') .ne. 0) delta1=0.0000005d0
            maxlin=30
         endif
         cosine=99.99d0
c
         ymaxst  = 0.4d0
         print=(index(keywrd,'linmin') .ne. 0)
         icalcn=numcal
      endif
      do 10 i=1,nvar
         xparef(i)=xparam(i)
   10 continue         
      xmaxm=0.0d0
      do 20 i=1,nvar
         pabs=dabs(pvect(i))
   20 xmaxm=dmax1(xmaxm,pabs)
      xmaxm=ymaxst/xmaxm
      if(nvar.eq.1)
     1call compfg(xparam, .true., funct,.true.,grad,.false.)
      fin=funct
      ssqlst=funct
      diis=ic.eq.1.and.nvar.gt.1
      phi(1)=funct
      alpha=1.d0
      vt(1)=0.0d00
      vt(2)=alpha
      if (vt(2).gt.xmaxm) vt(2)=xmaxm
      fmax=funct
      fmin=funct
      alpha=vt(2)
      do 30 i=1,nvar
   30 xparam(i)=xparef(i)+alpha*pvect(i)
      call compfg(xparam, .true., phi(2),.true.,grad,.false.)
      if(phi(2).gt.fmax) fmax=phi(2)
      if(phi(2).lt.fmin) fmin=phi(2)
      call mopexc (phi(2),sqstor,energy,estor,xparam,xstor,
     1alpha,alfs,nvar)
      if(diis)goto 190
      if(nvar.gt.1)then
c
c   calculate a new alpha based on thiel's formula
c
         alpha=-alpha**2*dott/(2.d0*(phi(2)-ssqlst-alpha*dott))
         if(alpha.gt.2.d0)alpha=2.d0
      else
         if(phi(2).lt.phi(1))then
            alpha=2*alpha
         else
            alpha=-alpha
         endif
      endif
c#      if(print)write(6,'(3(a,f12.6))')' estimated drop:',dott*0.5d0,
c#     1'  actual: ',phi(2)-ssqlst, '  predicted alpha',alpha
      okf=okf.or.phi(2).lt.ssqlst
      if(delta1.gt.0.3d0)then
c
c  thiel's tests # 18 and 19
c
         if(okf.and.alpha.lt.2.d0)goto 190
      endif
      vt(3)=alpha
      if (vt(3).le.1.d0) then
         left=3
         center=1
         right=2
      else
         left=1
         center=2
         right=3
      endif
      do 40 i=1,nvar
   40 xparam(i)=xparef(i)+alpha*pvect(i)
      call compfg (xparam, .true., funct,.true.,grad,.false.)
      if(funct.gt.fmax) fmax=funct
      if(funct.lt.fmin) fmin=funct
      if (funct.lt.sqstor) call mopexc (funct,sqstor,energy,
     1estor,xparam,xstor,alpha,alfs,nvar)
      okf=(okf.or.funct.lt.fin)
      phi(3)=funct
      if (print)write (mfgw,50) vt(1),phi(1),phi(1)-fin,
     1                        vt(2),phi(2),phi(2)-fin,
     2                        vt(3),phi(3),phi(3)-fin
   50 format ( ' ---qlinmn ',/5x, 'left   ...',f17.8,2f17.11/5x,
     1 'center ...',f17.8,2f17.11,/5x, 'right  ...',f17.8,2f17.11,/)
      do 180 ictr=3,maxlin
         alpha=vt(2)-vt(3)
         beta=vt(3)-vt(1)
         gamma=vt(1)-vt(2)
         if(dabs(alpha*beta*gamma) .gt. 1.d-4)then
          alpha=-(phi(1)*alpha+phi(2)*beta+phi(3)*gamma)/
     +           (alpha*beta*gamma)
         else
c
c   finish because two points calculated are very close together
c
            goto 190
         endif
         beta=((phi(1)-phi(2))/gamma)-alpha*(vt(1)+vt(2))
         if (alpha) 60,60,90
   60    if (phi(right).gt.phi(left)) go to 70
         alpha=3.0d00*vt(right)-2.0d00*vt(center)
         go to 80
   70    alpha=3.0d00*vt(left)-2.0d00*vt(center)
   80    s=alpha-alpold
         if (dabs(s).gt.xmaxm) s=dsign(xmaxm,s)*
     +                           (1.0d0+0.01d0*(xmaxm/s))
         alpha=s+alpold
         go to 100
   90    alpha=-beta/(2.0d00*alpha)
         s=alpha-alpold
         xxm=2.0d00*xmaxm
         if (dabs(s).gt.xxm) s=dsign(xxm,s)*(1.0d0+0.01d0*(xxm/s))
         alpha=s+alpold
  100    continue
c
c   finish if calculated point is near to point already calculated
c
         do 110 i=1,3
  110    if (dabs(alpha-vt(i)).lt.delta1*(1.d0+vt(i)).and.okf) 
     +       goto 190
         do 120 i=1,nvar
  120    xparam(i)=xparef(i)+alpha*pvect(i)
         funold=funct
         call compfg (xparam, .true., funct,.true.,grad,.false.)
         if(funct.gt.fmax) fmax=funct
         if(funct.lt.fmin) fmin=funct
         if (funct.lt.sqstor) call mopexc (funct,sqstor,energy,estor,
     1   xparam,xstor,alpha,alfs,nvar)
         okf=okf .or. (funct.lt.fin)
         if (print) write(mfgw,130) vt(left),phi(left), phi(left)-fin,
     1                           vt(center),phi(center),phi(center)-fin,
     2                           vt(right),phi(right),phi(right)-fin,
     3                           alpha,funct,funct-fin
  130    format (5x,'left    ...',f17.8,2f17.11,/5x,'center  ...',
     1f17.8,2f17.11,/5x,'right   ...',f17.8,2f17.11,/5x,
     2 'new     ...',f17.8,2f17.11,/)
c
c test to exit from linmin if not dropping in value of function fast.
c
         if(dabs(funold-funct) .lt. delta2 .and. okf) 
     +      goto 190
         alpold=alpha
         if ((alpha.gt.vt(right)).or.(alpha.gt.vt(center)
     1        .and.funct.lt.phi(center)).or.(alpha.gt.vt(left)
     2        .and.alpha.lt.vt(center).and.funct.gt.phi(center)))
     3         goto 140
         vt(right)=alpha
         phi(right)=funct
         go to 150
  140    vt(left)=alpha
         phi(left)=funct
  150    if (vt(center).lt.vt(right)) go to 160
         i=center
         center=right
         right=i
  160    if (vt(left).lt.vt(center)) go to 170
         i=left
         left=center
         center=i
  170    if (vt(center).lt.vt(right)) go to 180
         i=center
         center=right
         right=i
  180 continue
  190 continue
c
c  ic=1 if the last point calculated was the best point, ic=2 otherwise
c
      ic=2
      if(dabs(estor-energy).lt.1.d-12)ic=1
      call mopexc (sqstor,funct,estor,energy,xstor,xparam,
     1             alfs,alpha,nvar)
      okf = (funct.lt.ssqlst.or.diis)
      if (funct.ge.ssqlst) return
      if (alpha) 200,220,220
  200 alpha=-alpha
      do 210 i=1,nvar
  210 pvect(i)=-pvect(i)
  220 continue
      return
c
c
      end
      subroutine locmin(m,x,n,p,ssq,alf,efs,itrap,escf)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      common /nllsqi/ ncount
      common /keywrd/ contrl
      common /numcal/ numcal
      common /iofile/ mfgr,mfgw
      dimension x(*), p(*), efs(*)
      dimension const(maxpar), xstor(maxpar), gstor(maxpar)
      dimension phi(3),vt(3)
      integer left,right,center
      character*241 keywrd, contrl
*****
      save
*****
*     save xmaxm, scale,  keywrd, eps, debug, tee, ymaxst, xcrit
*     save mxcnt2, iprint, const
*****
      logical  debug, lower
      data const/maxpar*1.d0/
      data icalcn/0/
************************************************************************
*
*    locmin is called by nllsq only. it is a line-search procedure for
*    locating a minimum in the function space of compfg.  see nllsq
*    for more details
*
************************************************************************
      if (icalcn.ne.numcal) then
         icalcn=numcal
         xmaxm=1.d9
         scale=1.d0
         keywrd=contrl
c
c the above line is to try to prevent overflow in nllsq
c
         eps=1.d-5
         debug=(index(keywrd,'linmin') .ne. 0)
         tee=1.d-2
         ymaxst=0.005d0
         xcrit=0.0002d0
         mxcnt2=30
         iprint=0
         if(debug)iprint=-1
      endif
      xmaxm=1.d-11
      do 10 i=1,n
   10 xmaxm=dmax1(xmaxm,dabs(p(i)))
      xminm=xmaxm*scale
      xmaxm=ymaxst/xmaxm/scale
      fin = ssq
      lower = .false.
      t=alf
      phi(1) = ssq
      vt(1) = 0.0d0
      vt(2) = t/4.0d0
      if(vt(2).gt.xmaxm) vt(2)=xmaxm
      t = vt(2)
      do 20 i=1,n
   20 x(i) = x(i)+t*p(i)*const(i)*scale
      call compfg(x,.true.,escf,.true.,efs,.true.)
      phi(2)=ddot(n,efs,1,efs,1)
      call mopexc(phi(2),sqstor,energy,estor,x,xstor,t,alfs,n)
      do 30 i=1,m
   30 gstor(i)=efs(i)
      if (phi(1) .le. phi(2)) then
         vt(3) = -vt(2)
         left = 3
         center = 1
         right = 2
      else
         vt(3)=2.0d0*vt(2)
         left = 1
         center = 2
         right = 3
      endif
      tlast = vt(3)
      t = tlast-t
      do 40 i=1,n
   40 x(i) = x(i)+t*p(i)*const(i)*scale
      flast=phi(2)
      call compfg(x,.true.,escf,.true.,efs,.true.)
      f=ddot(n,efs,1,efs,1)
      if(f.lt.sqstor) call mopexc(f,sqstor,energy,estor,x,
     1xstor,t,alfs,n)
      do 50 i=1,m
   50 gstor(i)=efs(i)
      if(f.lt.fin) lower = .true.
      ncount = ncount+2
      phi(3) = f
      if (iprint) 60,70,70
   60 write (mfgw,310) vt(1),phi(1),vt(2),phi(2),vt(3),phi(3)
   70 mxct=mxcnt2
      do 250 ictr=3,mxct
         xmaxm=xmaxm*3.d0
         alpha = vt(2) - vt(3)
         beta = vt(3) - vt(1)
         gamma = vt(1)-vt(2)
         if(alpha.eq.0.d0)alpha=1.d-20
         if(beta.eq.0.d0)beta=1.d-20
         if(gamma.eq.0.d0)gamma=1.d-20
         abg =-(phi(1)*alpha+phi(2)*beta+phi(3)*gamma)/alpha
         abg=abg/beta
         abg=abg/gamma
         alpha=abg
         beta = ((phi(1)-phi(2))/gamma)-alpha*(vt(1)+vt(2))
         if (alpha)  80,80,110
   80    if (phi(right) .gt. phi(left))  go to 90
         t = 3.0d0*vt(right)-2.0d0*vt(center)
         go to 100
   90    t = 3.0d0*vt(left)-2.0d0*vt(center)
  100    s=t-tlast
         t=s+tlast
         go to 150
  110    t = -beta/(2.0d0*alpha)
         s=t-tlast
         if (s) 120,260,130
  120    amdis=vt(left)-tlast-xmaxm
         go to 140
  130    amdis=vt(right)-tlast+xmaxm
  140    if(dabs(s).gt.dabs(amdis)) s=amdis
         t=s+tlast
  150    continue
         if(ictr.gt.3.and.dabs(s*xminm).lt.xcrit) then
            if( debug )
     1    write(mfgw,'('' exit due to small projected step'')')
            go to 260
         endif
         t=s+tlast
         do 160 i=1,n
  160    x(i) = x(i)+s*p(i)*const(i)*scale
         flast=f
         call compfg(x,.true.,escf,.true.,efs,.true.)
         f=ddot(n,efs,1,efs,1)
         if(f.lt.sqstor) call mopexc(f,sqstor,energy,estor,x,xstor,
     1t,alfs,n)
         do 170 i=1,m
  170    gstor(i)=efs(i)
         if(f.lt.fin) lower = .true.
         ncount = ncount+1
         if (iprint) 180,190,190
  180    write (mfgw,320) vt(left),phi(left),vt(center),phi(center),
     1  vt(right),phi(right),t,f
  190    continue
c
c    test for excited states and potholes
c
         itrap=0
         if(dabs(vt(center)).gt.1.d-10) goto 200
         if(dabs(t)/(dabs(vt(left))+1.d-15).gt.0.3333d0) goto 200
         if(2.5d0*f-phi(right)-phi(left).lt.0.5d0*phi(center)) goto 200
c
c   we are stuck on a false minimum
c
         itrap=1
         goto 260
  200    continue
*
* now for the main stopping tests.  locmin will stop if:-
*     the error function has been reduced, and
*     the rate of drop of the error function is less than 0.5% per step
*     and
*     (a) the ratio of the proposed step to the total step is less than
*         eps,   or
*     (b) the last drop in error function was less than 5%ofthetotaldrop
*         during this call to locmin.
*
         if(debug)write(mfgw,'('' f/flast'',f13.6)')f/flast
         if( lower  .and. f/flast .gt. 0.995d0) then
            if((dabs(t-tlast).le.eps*dabs(t+tlast)+tee)) then
               if( debug )
     1       write(mfgw,'('' exit as step is absolutely small '')')
               go to 260
            endif
            sum=dmin1(dabs(f-phi(1)),dabs(f-phi(2)),dabs(f-phi(3)))
            sum2=(fin-sqstor)*0.05d0
            if(sum .lt. sum2) then
               if( debug )
     1        write(mfgw,'('' exit due to having reached bottom'')')
               goto 260
            endif
         endif
         tlast = t
         if ((t .gt. vt(right)) .or. (t .gt. vt(center) .and. f .lt.
     1  phi(center)) .or. (t .gt. vt(left) .and. t .lt. vt(center) .and.
     2  f .gt. phi(center)))  go to 210
         vt(right) = t
         phi(right) = f
         go to 220
  210    vt(left) = t
         phi(left) = f
  220    if (vt(center) .lt. vt(right))  go to 230
         i = center
         center = right
         right = i
  230    if (vt(left) .lt. vt(center))  go to 240
         i = left
         left = center
         center = i
  240    if (vt(center) .lt. vt(right))  go to 250
         i = center
         center = right
         right = i
  250 continue
  260 continue
      call mopexc(sqstor,f,estor,energy,xstor,x,alfs,t,n)
      do 270 i=1,m
  270 efs(i)=gstor(i)
      ssq=f
      alf=t
      if (t) 280,300,300
  280 t = -t
      do 290 i=1,n
  290 p(i) = -p(i)
  300 continue
      alf=t
      return
  310 format(' ---locmin'/5x,'left   ...',2f19.6/5x,'center ...',
     1  2f19.6/5x,'right  ...',2f19.6/' ')
  320 format(5x,'left   ...',2f19.6/5x,'center ...',2f19.6/5x,
     1  'right  ...',2f19.6/5x,'new    ...',2f19.6/' ')
      end
      subroutine mamult(a,b,c,n,one)
      implicit REAL (a-h,o-z)
      dimension a(*),b(*),c(*)
************************************************************************
*
*   mamult multiplies a by b and puts the result in c
*
************************************************************************
      l=0
      do 40 i=1,n
         ii=((i-1)*i)/2
         do 40 j=1,i
            jj=((j-1)*j)/2
            l=l+1
            sum=0.0d0
            do 10 k=1,j
   10       sum=sum+a(ii+k)*b(jj+k)
            do 20 k=j+1,i
   20       sum=sum+a(ii+k)*b(((k-1)*k)/2+j)
            do 30 k=i+1,n
               kk=(k*(k-1))/2
   30       sum=sum+a(kk+i)*b(kk+j)
   40 c(l)=sum+one*c(l)
      return
      end
      subroutine me08a(a,alpha,beta,n,ia,q)
      COMPLEX  a(ia,*),alpha(*),beta(*),q(*),cw,qj
      COMPLEX  fm06as,fm06bs
      REAL pp,zero,p5,h
      REAL s1,pp1
      data zero/0.0d0/, p5 /0.5d0/
c**************************************************************
c the reduction of full hermitian matrix into tri-diagonal hermitian
c form is done in n-2 steps.at the i th step zeros are introduced in
c the i th row and columns without destroying previously produced zeros
c
c                                                    h
c at the i th step we have  a =p a   p  with p =i-u u  /k
c                            i  i i-1 i       i    i i   i
c
c where u =(0,0,...,a     (1+s /t ),a     ,...,a   )
c        i           i,i+1    i  i   i,i+2      i,n
c        2   n          2        2                2
c       s = sum  ] a   ]     k =s +t   and  t = sqrt(]a     ] s )
c        i   j=i+1  i,j       i  i  i        i         i,i+1   i
c
c computational details at the i th stage are (1) form s  ,k   then
c                                                       i   i
c
c                                     h                      h     h
c (2) q =a   u  /k    (3) q =q -.5u (u q /k ) (4) a =a   -u q  -q u
c      i  i-1 i   i        i  i    i  i i  i       i  i-1  i i   i i
c
c  the vectors u being appropiately in a.
      if(n.le.0)go to 90
      do 10 j=1,n
         alpha(j)=a(j,j)
         do 10 i=1,j
   10 a(i,j)=conjg(a(j,i))
      if(n-2)90,80,20
   20 n2=n-2
      do 60 i=1,n2
         i1=i+1
c                       (1)
         cw=fm06bs(n-i,a(i,i+1),ia,a(i,i+1),ia)
         pp=cw
         pp1=dsqrt(pp)
         beta(i+1)=cmplx(-pp1,zero)
         s1=cdabs(a(i,i+1))
         if(s1.gt.zero)beta(i+1)=beta(i+1)*a(i,i+1)/s1
         if(pp.le.1.d-15)go to 60
         h=pp+pp1*s1
         a(i,i+1)=a(i,i+1)-beta(i+1)
c                       (2)
         do 30 k=i1,n
            qj=fm06as(-(i-k),a(i+1,k),1,a(i,i+1),ia)
            qj=fm06bs(n-k,a(k,k+1),ia,a(i,k+1),ia)+conjg(qj)
   30    q(k)=qj/h
c                       (3)
         cw=fm06as(n-i,a(i,i+1),ia,q(i+1),1)
         pp=cw*p5/h
         do 40 k=i1,n
   40    q(k)=q(k)-pp*conjg(a(i,k))
c                       (4)
         do 50 k=i1,n
   50    call me08b (a(k,k),q(k),a(i,k),n-k+1,ia*2)
   60 continue
      do 70 i=2,n
         qj=alpha(i)
         alpha(i)=a(i,i)
   70 a(i,i)=qj
   80 beta(n)=a(n-1,n)
   90 return
      end
      subroutine me08b (a,q,b,n,ia)
      COMPLEX a(ia,*),q(2,*),b(ia,*)
      do 10 i=1,n
         a(1,i)=a(1,i) -q(1,1)*b(1,i)+q(2,1)*b(2,i)
     1 -q(1,i)*b(1,1)+q(2,i)*b(2,1)
   10 a(2,i)=a(2,i)-q(2,1)*b(1,i)-q(1,1)*b(2,i)
     1 +q(2,i)*b(1,1)+q(1,i)*b(2,1)
      return
      end
      function meci(eigs,coeff)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      dimension eigs(norbs), coeff(norbs,norbs)
***********************************************************************
*
*                 program meci
*
*   a multi-electron configuration interaction calculation
*
*   written by james j. p. stewart, at the
*              frank j. seiler research laboratory
*              usafa, colorado springs, co 80840
*
*              1985
*
***********************************************************************
c
      REAL meci
c
c   matrices for permutation work
c
      dimension nfa(2*nmeci), nperma(nmeci,6*nmeci),
     1npermb(nmeci,6*nmeci), eiga(nmeci)
c
      common / readme / ird
c
c   matrices for one and two electron integrals
c
      common /rjks/ rjkab(nmeci,nmeci), rjkaa(nmeci,nmeci)
c
c   spin matrices
c
      dimension spin(nmeci**2)
      logical debug,  large, prnt, lspin, lspin1,
     1 first1, bigprt, sing, doub, trip, quar, quin, sext,
     2 prnt2, geook
      character keywrd*241, tspin(7)*8, line*80
      character citxt*6
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),
     1                nlast(numatm), norbs, nelecs,
     2                ndummy(2), nclose, nopen, ndumy, fract
      common /last  / last
      common /spqr/ ispqr(nmeci**2,nmeci),is,i,k
      common /keywrd/ keywrd
c
c   matrices for sec.det., vectors, and eigenvalues.
c
      common /work2 / cimat(nmeci**4), eig(nmeci**2), diag(2*nmeci**3)
      common /baseoc/ occa(nmeci)
      common /work3 / dijkl(mpack*4)
      common /civect/ vectci(nmeci**2),conf(nmeci**4+1)
      common /nalmat/ nalpha(nmeci**2)
      common /micros/ microa(nmeci,4*nmeci**2), microb(nmeci,4*nmeci**2)
      common /cibits/ nmos,lab,nelec, nbo(3)
      common /xyijkl/ xy(nmeci,nmeci,nmeci,nmeci)
      common /numcal/ numcal
      common/iofile/mfgr,mfgw
c
      save
c
*     save first1, tspin
*     save j,l, debug, prnt2,mdim, lspin1
*     save large, lroot, sing, doub, quar, quin, sext, smult, ne
*     save geook
c
      data icalcn/0/
      data tspin/'singlet ','doublet ','triplet ','quartet ','quintet ',
     1'sextet  ','septet  '/
      citxt = 'c.i.=('
      if (icalcn.ne.numcal) then
         icalcn=numcal
         first1=.true.
         mdim=nmeci**2
         geook=(index(keywrd,'geo-ok').ne.0)
         lspin1=(index(keywrd,'esr').ne.0)
         debug=(index(keywrd,'debug').ne.0)
         prnt2=(index(keywrd,'meci').ne.0)
         debug=(debug.and.prnt2)
         large=(index(keywrd,'large').ne.0)
         ndoubl=99
         if(index(keywrd,'c.i.=(').ne.0)then
            ndoubl=reada(keywrd,index(keywrd,citxt)+7)
            nmos=reada(keywrd,index(keywrd,citxt)+5)
         elseif (index(keywrd,'c.i.=').ne.0)then
            nmos=reada(keywrd,index(keywrd,'c.i.=')+5)
         else
            nmos=nopen-nclose
         endif
         lroot=1
         if(index(keywrd,'exci').ne.0)lroot=2
         i=index(keywrd,'root')
         if(i.ne.0)lroot=reada(keywrd,i)
         if(ndoubl.eq.99)then
            j=max(
     +        min((nclose+nopen+1)/2-(nmos-1)/2,norbs-nmos+1),1)
         else
            j=nclose-ndoubl+1
            if(fract.gt.1.99d0)j=j+1
         endif
         l=0
         do 10 i=j,nclose
            l=l+1
   10    occa(l)=1
         do 20 i=nclose+1,nopen
            l=l+1
   20    occa(l)=fract*0.5d0
         do 30 i=nopen+1,j+nmos-1
            l=l+1
   30    occa(l)=0.0d0
c#         write(6,'('' initial orbital occupancies'')')
c#         write(6,'(6f12.6)')(occa(l),l=1,nmos)
         sing=(index(keywrd,'sing')+
     1         index(keywrd,'exci')+
     2         index(keywrd,'birad').ne.0)
         doub=(index(keywrd,'doub').ne.0)
         trip=(index(keywrd,'trip').ne.0)
         quar=(index(keywrd,'quar').ne.0)
         quin=(index(keywrd,'quin').ne.0)
         sext=(index(keywrd,'sext').ne.0)
c
c  define magnetic component of spin
c
         msdel=index(keywrd,' ms')
         if(msdel.ne.0)then
            msdel=1.0001d0*reada(keywrd,index(keywrd,' ms'))
         else
            if(trip.or.quar)msdel=1
            if(quin.or.sext)msdel=2
         endif
         smult=-.5d0
         if(sing) smult=0.00d0
         if(doub) smult=0.75d0
         if(trip) smult=2.00d0
         if(quar) smult=3.75d0
         if(quin) smult=6.00d0
         if(sext) smult=8.75d0
         x=0.0d0
         do 40 j=1,nmos
   40    x=x+occa(j)
         xx=x+x
         ne=xx+0.5d0
         nelec=(nelecs-ne+1)/2
      endif
      prnt=(debug.or.last.eq.3.and.prnt2)
      bigprt=(prnt.and.large)
c
c    test to see if the set of energy levels used in meci is complete,
c    i.e., all components of degenerate irreducible representations
c    are used.  if not, then results will be nonsense.  give users a
c    chance to really foul things up by allowing job to continue if
c    'geo-ok' is specified.
c
      do 50 i=1,nmos
         in=i+nelec
   50 eiga(i)=eigs(in)
      lspin=(lspin1.and. last.eq.3)
      if(bigprt)then
         write(mfgw,'(''  initial eigenvalues'')')
         write(mfgw,'(5f12.6)')(eiga(i),i=1,nmos)
         write(mfgw,
     +   '(//10x,''number of electrons in c.i. ='',f5.1)')xx
      endif
      if(.not.geook.and.nelec.gt.0)then
         if(dabs(eigs(nelec+1)-eigs(nelec)).lt.1.d-1.or.
     1      dabs(eigs(nelec+1+nmos)-eigs(nelec+nmos)).lt.1.d-1)then
            write(mfgw,
     +      '(///10x,a)')'degenerate energy levels detected in meci'
            write(mfgw,
     +      '(10x,a)')'some of these levels would be treated by'//
     +      ' meci,'
            write(mfgw,
     +      '(10x,a)')'while others would not.  this would result in'
            write(mfgw,'(10x,a)')'non-reproducible electronic energies.'
            write(mfgw,
     +      '(10x,a)')'  job stopped.  to continue, specify "geo-ok"'
_IF(ipsc,tools)
            call pend
_ELSE
            stop
_ENDIF
         endif
      endif
      if( bigprt ) then
         write(mfgw,'(//10x,''eigenvectors'',/)')
         do 60 i=1,norbs
   60    write(mfgw,'(6f12.6)')(coeff(i,j+nelec),j=1,nmos)
      endif
      nfa(2)=1
      nfa(1)=1
      do 70 i=3,nmeci+1
   70 nfa(i)=nfa(i-1)*(i-1)
      call mopi(coeff(1,nelec+1),coeff,nelec,nmos,dijkl)
      do 80 i=1,nmos
         do 80 j=1,nmos
            rjkaa(i,j)=xy(i,i,j,j)-xy(i,j,i,j)
   80 rjkab(i,j)=xy(i,i,j,j)
      do 100 i=1,nmos
         x=0.0d0
         do 90 j=1,nmos
            x=x+(rjkaa(i,j)+rjkab(i,j))*occa(j)
   90    continue
         eiga(i)=eiga(i)-x
c#      if(abs(occa(i)-0.5).lt.1.d-4)eiga(i)=eiga(i)+xy(i,i,i,i)*0.25d0
  100 continue
      if(bigprt) then
         write(mfgw,110)
  110    format(/,5x,
     +   'eigenvalues after removal of inter-electronic interactions',/)
         write(mfgw,'(6f12.6)')(eiga(i),i=1,nmos)
         write(mfgw,'(///10x,''two-electron j-integrals'',/)')
         do 120 i1=1,nmos
  120    write(mfgw,'(10f10.4)')(rjkab(i1,j1),j1=1,nmos)
         write(mfgw,'(///10x,''two-electron k-integrals'',/)')
         do 130 i1=1,nmos
  130    write(mfgw,'(10f10.4)')(rjkab(i1,j1)-rjkaa(i1,j1),j1=1,nmos)
      endif
      natoms=numat
      do 140 i=1,nmos
         do 140 j=1,nmos
            rjkaa(i,j)=rjkaa(i,j)*0.5d0
  140 continue
      if(first1) then
         i=index(keywrd,'micros')
         if(i.ne.0)then
            k=reada(keywrd,i)
            lab=k
            if(prnt)write(mfgw,'(''    microstates read in'')')
            ntot=xx+0.5d0
            rewind ird
            do 150 i=1,1000
               read(ird,'(a)')line
  150       if(index(line,'micro').ne.0)goto 160
  160       do 170 i=1,1000
               read(ird,'(a)')line
  170       if(index(line,'micro').ne.0)goto 180
  180       do 210 i=1,lab
               read(ird,'(a)')line
               izero=max(0,min(index(line,'0'),index(line,'1'))-1)
               do 190 j=1,nmos
                  if(line(j+izero:j+izero).ne.'1')
     1            line(j+izero:j+izero)='0'
                  if(line(j+nmos+izero:j+nmos+izero).ne.'1')
     1            line(j+nmos+izero:j+nmos+izero)='0'
                  microa(j,i)=ichar(line(j+izero:j+izero))-
     1          ichar('0')
                  microb(j,i)=ichar(line(j+nmos+izero:j+nmos+izero))-
     1          ichar('0')
  190          continue
               if(prnt)write(mfgw,'(20i6)')(microa(j,i),j=1,nmos),
     1        (microb(j,i),j=1,nmos)
               k=0
               do 200 j=1,nmos
  200          k=k+microa(j,i)+microb(j,i)
               if(k.ne.ntot)then
                  ntot=k
                  xx=k
                  write(mfgw,
     +  '(/,''number of electrons in c.i. redefined to:'',i4,/)')k
               endif
  210       continue
            first1=.false.
            goto 260
         endif
         nupp=(ne+1)/2 +msdel
         ndown=ne-nupp
         ams=(nupp-ndown)*0.5d0
         if(prnt)write(mfgw,220) ams
  220    format(10x,'component of spin  = ',f4.1)
         if(nupp*ndown.lt.0) then
_IF(ipsc,tools)
         call pend
_ELSE
         stop
_ENDIF
         endif
         lima=nfa(nmos+1)/(nfa(nupp+1)*nfa(nmos-nupp+1))
         limb=nfa(nmos+1)/(nfa(ndown+1)*nfa(nmos-ndown+1))
         lab=lima*limb
         if(prnt)write(mfgw,230) lab
  230    format(//10x,35h no of configurations considered = ,i4)
c#      if(lab.lt.101) goto 240
c#      write(mfgw,230)
c#  230 format(10x,24h too many configurations/)
c#      goto 160
c#  240 continue
         call perm(nperma, nupp, nmos, nmeci, lima)
         call perm(npermb, ndown, nmos, nmeci, limb)
         k=0
         do 240 i=1,lima
            do 240 j=1,limb
               k=k+1
               do 240 l=1,nmos
                  microa(l,k)=nperma(l,i)
  240    microb(l,k)=npermb(l,j)
  250    format(10i1)
  260    continue
         lima=lab
         limb=lab
      endif
      gse=0.0d0
      do 270 i=1,nmos
         gse=gse+eiga(i)*occa(i)*2.d0
         gse=gse+xy(i,i,i,i)*occa(i)*occa(i)
         do 270 j=i+1,nmos
  270 gse=gse+2.d0*(2.d0*xy(i,i,j,j) - xy(i,j,i,j))*occa(i)*occa(j)
      j=0
      do 280 i=1,lab
         diag(i)=emsiab(microa(1,i),microb(1,i),eiga,xy,nmos)-gse
  280 continue
  290 continue
      if(lab.le.mdim) goto 330
      x=-100.d0
      do 300 i=1,lab
         if(diag(i).gt.x)then
            x=diag(i)
            j=i
         endif
  300 continue
      if(j.ne.lab) then
         do 320 i=j,lab
            i1=i+1
            do 310 k=1,nmos
               microa(k,i)=microa(k,i1)
  310       microb(k,i)=microb(k,i1)
  320    diag(i)=diag(i1)
      endif
      lab=lab-1
      goto 290
  330 continue
c
c     build spin and number of alpha spin tables.
c     -------------------------------------------
      do 350 i=1,lab
         k=0
         x=0.0d0
         do 340 j=1,nmos
            x=x+microa(j,i)*microb(j,i)
  340    k=k+microa(j,i)
         nalpha(i)=k
  350 spin(i)=4.d0*x-(xx-2*nalpha(i))**2
c
c   before starting, check that the root wanted can exist
c
      if(lab.lt.lroot)then
         write(mfgw,'(//10x,
     +   ''c.i. is of size less than root specified'')')
         write(mfgw,'(10x,''modify size of c.i. or root number'')')
         write(mfgw,'(a,i4,a,i4)')
     +   ' size of c.i.:',lab,' root required:',lroot
_IF(ipsc,tools)
         call pend
_ELSE
         stop
_ENDIF
      endif
      if(prnt)then
         write(mfgw,
     +   '(/,'' configurations considered in c.i.      '',/
     +          '' m.o. number :      '',10i4)')(i,i=nelec+1,nelec+nmos)
         write(mfgw,'(''          energy'')')
         do 360 i=1,lab
            write(mfgw,'(/10x,i4,6x,10i4)') i,(microa(k,i),k=1,nmos)
  360    write(mfgw,
     +   '(6x,f10.4,4x,10i4)')diag(i),(microb(k,i),k=1,nmos)
      endif
      call mecih(diag,cimat,nmos,lab)
      if(bigprt)then
         write(mfgw,'(//,'' c.i. matrix'')')
         i=min(lab,maxorb)
         if(i.ne.lab)write(mfgw,'(''   (output has been truncated)'')')
         call vecprt(cimat,-i)
      else
         if(prnt)write(mfgw,'(//,'' diagonal of c.i. matrix'')')
         if(prnt)write(mfgw,'(5f13.6)')(cimat((i*(i+1))/2),i=1,lab)
      endif
c#       call timop('sec. det. constructed')
      labsiz=min(lab,lroot+10)
      call hqrii(cimat,lab,labsiz,eig,conf)
c#       call timop('diag. done')
c
c   decide which root to extract
c
      kroot=0
      if(smult.lt.-0.1d0)then
         meci=eig(lroot)
         do 370 j=1,lab
  370    vectci(j)=conf(j+lab*(lroot-1))
         kroot=lroot
      endif
      if(bigprt)  then
         write(mfgw,'(//20x,''state vectors'',//)')
         i=min(lab,norbs)
         j=min(labsiz,norbs)
         call mopmat(conf,eig,j,-i,lab)
      endif
      if(prnt)then
         write(mfgw,380)
  380    format(///,' state energies '
     1,' expectation value of s**2  s from s**2=s(s+1)',//)
      endif
      iroot=0
      do 390 i=1,9
  390 cimat(i)=0.1d0
      do 440 i=1,labsiz
         x=0.5d0*xx
         ii=(i-1)*lab
         do 420 j=1,lab
            ji=j+ii
            x=x-conf(ji)*conf(ji)*spin(j)*0.25d0
            k=ispqr(j,1)
            if(k.eq.1)  goto  410
            do 400 l=2,k
               li=ispqr(j,l)+ii
  400       x=x+conf(ji)*conf(li)*2.d0
  410       continue
  420    continue
         y=(-1.d0+dsqrt(1.d0+4.d0*x))*0.5d0
         if(dabs(smult-x).lt.0.01d0)then
            iroot=iroot+1
            if(iroot.eq.lroot) then
               kroot=i
               meci=eig(i)
               do 430 j=1,lab
  430          vectci(j)=conf(j+lab*(i-1))
            endif
         endif
         j=y*2.d0+1.5d0
         cimat(j)=cimat(j)+1.0d0
  440 if(prnt)write(mfgw,460) i,eig(i),tspin(j),x,y
      if(kroot.eq.0)then
         write(mfgw,
     +   '(//10x,''the state required is not present in the'')')
         write(mfgw,'(10x,  ''    set of configurations available'')')
         write(mfgw,'(/ 4x,
     +   ''number of states accessible using current key-words'',/)')
         do 450 i=1,7
  450    if(cimat(i).gt.0.5d0)
     1write(mfgw,'((24x,a8,i4))')tspin(i),nint(cimat(i))
_IF(ipsc,tools)
         call pend
_ELSE
         stop
_ENDIF
      endif
  460 format(i5,f12.6,3x,a8,f15.5,f10.5)
  470 continue
      maxvec=0
      if(lspin)maxvec=min(4,lab)
      if(lspin.and.(ne/2)*2.eq.ne) then
         write(mfgw,
     +   '(''   esr specified for an even-electron system'')')
      endif
c#      do 570 i=1,nmos
c#         do 570 j=1,norbs
c#  570 coeff(j,i+nelec)=coeff(j,i+nelec)**2
      do 540 iuj=1,maxvec
         iofset=(iuj-1)*lab
         write(mfgw,'(//,''      microstate contributions to '',
     1''state eigenfunction'',i3)')iuj
         write(mfgw,'(5f13.6)')(conf(i+iofset),i=1,lab)
         do 480 i=1,lab
  480    conf(i)=vectci(i+iofset)**2
c                                             second vector!
         do 500 i=1,nmos
            sum=0.0d0
            do 490 j=1,lab
  490       sum=sum+(microa(i,j)-microb(i,j))*conf(j)
  500    eiga(i)=sum
         write(mfgw,
     +   '(/,''    spin densities from each m.o., energy:''
     1,f7.3)')eig(iuj)
         write(mfgw,'(5f12.6)') (eiga(i),i=1,nmos)
         write(mfgw,*)
         write(mfgw,*)'     spin densities from each atomic orbital'
         write(mfgw,*)
     +   '                              s        px        '//
     1'py        pz        total'
         do 530 i=1,natoms
            il=nfirst(i)
            iu=nlast(i)
            l=0
            summ=0.0d0
            do 520 k=il,iu
               l=l+1
               sum=0.0d0
               do 510 j=1,nmos
  510          sum=sum+coeff(k,j+nelec)**2*eiga(j)
               summ=summ+sum
  520       eigs(l)=sum
            if(l.eq.4)then
               write(mfgw,
     +         '(''  atom'',i4,''    spin density  '',5f10.7)')
     1i,(eigs(k),k=1,l),summ
            else
               write(mfgw,
     +         '(''  atom'',i4,''    spin density  '',f10.7,30x,
     1f10.7)')i,eigs(1),summ
            endif
  530    continue
  540 continue
      return
      end
      subroutine mecid(eigs,gse,eiga,diag)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      dimension eigs(*), eiga(*), diag(*)
************************************************************************
*
*   mecid calculates the effect of removing the electrons involved in
*   the c.i. from the ground-state configuration, and calculates the
*   microstate energies of the microstates involved in the c.i.
*
*  the quantities nmos, nelec, and lab, and the arrays eigs, occa,
*  microa, and microb are used, but unchanged on exit
*
*   on exit, gse is the electronic energy of stabilization due to
*            removal of the electrons involved in the c.i.
*
*            eiga holds the one-electron energy levels resulting from
*            removal of the electrons involved in the c.i.
*
*            diag holds the microstate energies of all states involved
*            in the c.i.  this can be used as the diagonal of a c.i.
*            matrix
*
************************************************************************
      common /baseoc/ occa(nmeci)
      common /micros/ microa(nmeci,4*nmeci**2),microb(nmeci,4*nmeci**2)
      common /cibits/ nmos,lab,nelec, nbo(3)
      common /xyijkl/ xy(nmeci,nmeci,nmeci,nmeci)
      gse=0.0d0
      do 20 i=1,nmos
         x=0.0d0
         do 10 j=1,nmos
   10    x=x+(2.d0*xy(i,i,j,j)-xy(i,j,i,j))*occa(j)
         eiga(i)=eigs(i+nelec)-x
         gse=gse+eiga(i)*occa(i)*2.d0
         gse=gse+xy(i,i,i,i)*occa(i)*occa(i)
         do 20 j=i+1,nmos
   20 gse=gse+2.d0*(2.d0*xy(i,i,j,j) - xy(i,j,i,j))*occa(i)*occa(j)
      do 30 i=1,lab
   30 diag(i)=emsiab(microa(1,i),microb(1,i),eiga,xy,nmos)-gse
      return
      end
      subroutine mecih(diag,cimat,nmos,lab)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      dimension diag(*),cimat(*)
c
c     build the c.i. matrix 'cimat' in packed canonical form.
c
      common /spqr/ ispqr(nmeci**2,nmeci),is,i,k
      common /nalmat/ nalpha(nmeci**2)
      common /micros/ microa(nmeci,4*nmeci**2), 
     +                microb(nmeci,4*nmeci**2)
c
      ik=0
c
c     outer loop to fill c.i. matrix.
      do 30 i=1,lab
         is=2
c
c     inner loop.
         do 20 k=1,i
            ik=ik+1
            cimat(ik)=0.0d0
            ix=0
            iy=0
            do 10 j=1,nmos
               ix=ix+iabs(microa(j,i)-microa(j,k))
   10       iy=iy+iabs(microb(j,i)-microb(j,k))
c
c                              check if matrix element has to be zero
c
            if(ix+iy.gt.4 .or. nalpha(i).ne.nalpha(k)) go to 20
            if(ix+iy.eq.4) then
               if(ix.eq.0)then
                  cimat(ik)=babbcd(microa(1,i),microb(1,i)
     1                            ,microa(1,k),microb(1,k),nmos)
               else if(ix.eq.2) then
                  cimat(ik)=aabbcd(microa(1,i),microb(1,i)
     1                            ,microa(1,k),microb(1,k),nmos)
               else
                  cimat(ik)=aabacd(microa(1,i),microb(1,i)
     1                            ,microa(1,k),microb(1,k),nmos)
               endif
            else if(ix.eq.2) then
               cimat(ik)=aababc(microa(1,i),microb(1,i)
     1                         ,microa(1,k),nmos)
            else if(iy.eq.2) then
               cimat(ik)=babbbc(microa(1,i),microb(1,i)
     1                         ,microb(1,k),nmos)
            else
               cimat(ik)=diag(i)
            endif
   20    continue
   30 ispqr(i,1)=is-1
      return
      end
      subroutine mecip(coeffs,norbs,deltap, delta)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      dimension coeffs(norbs,norbs), deltap(nmos,nmos),
     1 delta(norbs,nmos)
************************************************************************
*
*   mecip will correct the total density matrix for the effect of the
*   c.i.
*              on input
*
*  coeffs       : all m.o.'s (norbs m.o.s)
*  norbs        : number of molecular orbitals = number of a.o.'s
*  p            : total density matrix
*  nmos         : number of m.o.'s in active space
*  vectci       : state vector of length lab
*  microa(i,j)  : alpha occupancy of m.o. 'i' in microstate 'j'
*  microb(i,j)  : beta  occupancy of m.o. 'i' in microstate 'j'
*
*  note: this is a modification of code originally written by
*        prof. daniel liotard
************************************************************************
      common /cibits/ nmos,lab,nelec, nbo(3)
      common /densty/ p(mpack), pa(mpack), pb(mpack)
      common /nalmat/ nalpha(nmeci**2)
      common /baseoc/ occa(nmeci)
      common /civect/ vectci(nmeci**2),conf(nmeci**4+1)
      common /micros/ microa(nmeci,4*nmeci**2), microb(nmeci,4*nmeci**2)
c     initialize with the opposite of the 'scf' density.
      do 10 i=1,nmos
         deltap(i,i)=-occa(i)*2.d0
         do 10 j=1,i-1
   10 deltap(i,j)=0.0d0
c
c     add the c.i. correction
      do 120 id=1,lab
         do 120 jd=1,id
c     check spin agreement
            if(nalpha(id).ne.nalpha(jd)) go to 120
            ix=0
            iy=0
            do 20 j=1,nmos
               ix=ix+iabs(microa(j,id)-microa(j,jd))
   20       iy=iy+iabs(microb(j,id)-microb(j,jd))
c     check number of differing m.o.
            if(ix+iy.gt.2) go to 120
            if(ix.eq.2) then
c        determinants id and jd differ by m.o i in id and m.o j in jd:
               do 30 i=1,nmos
   30          if(microa(i,id).ne.microa(i,jd)) go to 40
   40          ij=microb(i,id)
               do 50 j=i+1,nmos
                  if(microa(j,id).ne.microa(j,jd)) go to 60
   50          ij=ij+microa(j,id)+microb(j,id)
c        ij gives the sign of the permutation
   60          deltap(j,i)=deltap(j,i)+vectci(id)*vectci(jd)*
     +                     dfloat(1-2*mod(ij,2))
            else if(iy.eq.2) then
c        determinants id and jd differ by m.o j in id and m.o i in jd:
               do 70 i=1,nmos
   70          if(microb(i,id).ne.microb(i,jd)) go to 80
   80          ij=0
               do 90 j=i+1,nmos
                  if(microb(j,id).ne.microb(j,jd)) go to 100
   90          ij=ij+microa(j,id)+microb(j,id)
  100          ij=ij+microa(j,id)
               deltap(j,i)=deltap(j,i)+vectci(id)*vectci(jd)*
     +                     dfloat(1-2*mod(ij,2))
            else
c        determinants id and jd are identical:
               do 110 i=1,nmos
  110          deltap(i,i)=deltap(i,i)+(microa(i,id)+microb(i,id))*
     +         vectci(id)**2
            endif
  120 continue
c
c     back transform into a.o. basis.
c     -------------------------------
c     p(c.i.) = p(scf) + c * deltap * c'
      do 130 i=1,nmos
cdir$ ivdep
         do 130 j=1,i-1
  130 deltap(j,i)=deltap(i,j)
c     step 1: deltap = c * deltap
      call mxm (coeffs(1,nelec+1),norbs,deltap,nmos,delta,nmos)
c     step 2: p = p + deltap * c'
      ij=0
      do 150 i=1,norbs
         do 150 j=1,i
            ij=ij+1
            sum=0.0d0
            do 140 k=1,nmos
  140       sum=sum+delta(i,k)*coeffs(j,nelec+k)
  150 p(ij)=p(ij)+sum
c     note from d.l.: at this point the 'natural orbitals' of this state
c     can be obtained straightway as eigenvectors of the density matrix.
      return
      end
c
      subroutine minv(a,n,d)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      dimension a(*)
**********************************************************************
*
*     invert a matrix using gauss-jordan method.  part of diis
*     a - input matrix (must be a general matrix), destroyed in
*        computation and replaced by resultant inverse.
*     n - order of matrix a
*     d - resultant determinant
*
**********************************************************************
      dimension m(maxpar), l(maxpar)
c
c     search for largest element
c
      d=1.0d0
      nk=-n
      do 180 k=1,n
         nk=nk+n
         l(k)=k
         m(k)=k
         kk=nk+k
         biga=a(kk)
         do 20 j=k,n
            iz=n*(j-1)
            do 20 i=k,n
               ij=iz+i
   10          if (dabs(biga).lt.dabs(a(ij)))then
                  biga=a(ij)
                  l(k)=i
                  m(k)=j
               endif
   20    continue
c
c     interchange rows
c
         j=l(k)
         if (j-k) 50,50,30
   30    ki=k-n
         do 40 i=1,n
            ki=ki+n
            hold=-a(ki)
            ji=ki-k+j
            a(ki)=a(ji)
   40    a(ji)=hold
c
c     interchange columns
c
   50    i=m(k)
         if (i-k) 80,80,60
   60    jp=n*(i-1)
         do 70 j=1,n
            jk=nk+j
            ji=jp+j
            hold=-a(jk)
            a(jk)=a(ji)
   70    a(ji)=hold
c
c     divide column by minus pivot (value of pivot element is
c     contained in biga)
c
   80    if (biga) 100,90,100
   90    d=0.0d0
         return
  100    do 120 i=1,n
            if (i-k) 110,120,110
  110       ik=nk+i
            a(ik)=a(ik)/(-biga)
  120    continue
c  reduce matrix
         do 150 i=1,n
            ik=nk+i
            hold=a(ik)
            ij=i-n
            do 150 j=1,n
               ij=ij+n
               if (i-k) 130,150,130
  130          if (j-k) 140,150,140
  140          kj=ij-i+k
               a(ij)=hold*a(kj)+a(ij)
  150    continue
c
c     divide row by pivot
c
         kj=k-n
         do 170 j=1,n
            kj=kj+n
            if (j-k) 160,170,160
  160       a(kj)=a(kj)/biga
  170    continue
c
c     product of pivots
c
         d=dmax1(-1.0d25,dmin1(1.0d25,d))
         d=d*biga
c
c     replace pivot by reciprocal
c
         a(kk)=1.0d0/biga
  180 continue
c
c     final row and column interchange
c
      k=n
  190 k=(k-1)
      if (k) 260,260,200
  200 i=l(k)
      if (i-k) 230,230,210
  210 jq=n*(k-1)
      jr=n*(i-1)
      do 220 j=1,n
         jk=jq+j
         hold=a(jk)
         ji=jr+j
         a(jk)=-a(ji)
  220 a(ji)=hold
  230 j=m(k)
      if (j-k) 190,190,240
  240 ki=k-n
      do 250 i=1,n
         ki=ki+n
         hold=a(ki)
         ji=ki-k+j
         a(ki)=-a(ji)
  250 a(ji) =hold
      go to 190
  260 return
      end
      subroutine moldat(mode)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      common /iofile/ mfgr,mfgw
      common /geokst/ natoms,labels(numatm),
     1                na(numatm),nb(numatm),nc(numatm)
      common /molmec/ htype(4),nhco(4,20),nnhco,itype
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),
     1                nlast(numatm), norbs, nelecs,nalpha,nbeta,
     2                nclose,nopen,ndumy,fract
      common /keywrd/ keywrd
      common /cmporb/ natorb(107)
      common /corec/ core(107)
      common /betas/ betas(107),betap(107),betad(107)
      common /molorb/ uspd(maxorb),pspd(maxorb)
      common /vsips/ vs(107),vp(107),vd(107)
      common /cmpone/ uss(107),upp(107),udd(107)
      common /atheat/ atheat
      common /polvol/ polvol(107)
      common /multip/ dd(107),qq(107),am(107),ad(107),aq(107)
      common /twoele/ gss(107),gsp(107),gpp(107),gp2(107),hsp(107)
     4                ,gsd(107),gpd(107),gdd(107)
      common /ideaa/ guesa1(107,10),guesa2(107,10),guesa3(107,10)
      common /ideas/ guess1(107,10),guess2(107,10),guess3(107,10)
      common /ideap/ guesp1(107,10),guesp2(107,10),guesp3(107,10)
      common /alpha/ alp(107)
      common /refs/ allref(107,4)
      common /mndo/  ussm(107), uppm(107), uddm(107), zsm(107),
     1zpm(107), zdm(107), betasm(107), betapm(107), betadm(107),
     2alpm(107), eisolm(107), ddm(107), qqm(107), amm(107),
     3adm(107), aqm(107), gssm(107), gspm(107), gppm(107),
     4gp2m(107), hspm(107), polvom(107)
      common /pm3/  usspm3(107), upppm3(107), uddpm3(107), zspm3(107),
     1zppm3(107), zdpm3(107), betasp(107), betapp(107), betadp(107),
     2alppm3(107), eisolp(107), ddpm3(107), qqpm3(107), ampm3(107),
     3adpm3(107), aqpm3(107) ,gsspm3(107), gsppm3(107), gpppm3(107),
     4gp2pm3(107), hsppm3(107),polvop(107)
      common /am1blo/ussam1(107), uppam1(107), uddam1(107), zsam1(107),
     1zpam1(107), zdam1(107), betasa(107), betapa(107), betada(107),
     2alpam1(107), eisola(107), ddam1(107), qqam1(107), amam1(107),
     3adam1(107), aqam1(107) ,gssam1(107), gspam1(107), gppam1(107),
     4gp2am1(107), hspam1(107),polvoa(107)
      common /cmpg/ geo(3,numatm)
      parameter (mdumy=maxpar**2-mpack)
      common /scrach/ rxyz(mpack), xdumy(mdumy)
*
*  common blocks for mindo/3
*
      common /onele3/  uss3(18),upp3(18)
      common /atomi3/  eisol3(18),eheat3(18)
      common /expon3/  zs3(18),zp3(18)
*
*  end of mindo/3 common blocks
*
      common /expont/ zs(107),zp(107),zd(107)
      common /atomic/ eisol(107),eheat(107)
      dimension coord(3,numatm), iswap(2,20), estore(107)
      character*241 keywrd, olde(20)*6, allref*80, citxt*6
      logical debug, uhf,exci, trip, mindo3, birad, am1, lpm3,
     1lmndo, halfe, slow
      data estore(1)/0.d0/
      citxt = 'c.i.=('
      if(estore(1).eq.0.d0)then
      do 9 i=1,107
   9  estore(i)=eheat(i)
      endif
      do 8 i=1,107
  8   eheat(i)=estore(i)
      debug = (index(keywrd,'moldat').ne.0)
      lpm3  = (index(keywrd,'pm3').ne.0)
      mindo3= (index(keywrd,'mindo').ne.0)
      uhf=(index(keywrd,'uhf') .ne. 0)
      am1= (index(keywrd,'am1').ne.0)
      lmndo=(.not.am1.and..not.lpm3)
      kharge=0
      i=index(keywrd,'charge')
      if(i.ne.0) kharge=reada(keywrd,i)
      elecs=-kharge
      ndorbs=0
      atheat=0.0d0
      eat=0.0d0
      numat=0
      if(mode.eq.1) goto 80
      if ( lmndo ) then
*
*    switch in mndo parameters
*
c
c       zero out gaussian 1 for carbon.  this will be used in
c       rotate to decide whether or not to use am1-type gaussians
c
         guess1(6,1)=0.0d0
         do 10 i=1,107
            if(.not.mindo3) polvol(i)=polvom(i)
            zs(i)=zsm(i)
            zp(i)=zpm(i)
            zd(i)=zdm(i)
            uss(i)=ussm(i)
            upp(i)=uppm(i)
            udd(i)=uddm(i)
            betas(i)=betasm(i)
            betap(i)=betapm(i)
            betad(i)=betadm(i)
            alp(i)=alpm(i)
            eisol(i)=eisolm(i)
            dd(i)=ddm(i)
            qq(i)=qqm(i)
            am(i)=amm(i)
            ad(i)=adm(i)
            aq(i)=aqm(i)
            gss(i)=gssm(i)
            gpp(i)=gppm(i)
            gsp(i)=gspm(i)
            gp2(i)=gp2m(i)
            hsp(i)=hspm(i)
   10    continue
      elseif( lpm3 ) then
*
*    switch in mndo-pm3 parameters
*
         do 30 i=1,107
            do 20 j=1,10
               guess1(i,j)=guesp1(i,j)
               guess2(i,j)=guesp2(i,j)
   20       guess3(i,j)=guesp3(i,j)
            polvol(i)=polvop(i)
            zs(i)=zspm3(i)
            zp(i)=zppm3(i)
            zd(i)=zdpm3(i)
            uss(i)=usspm3(i)
            upp(i)=upppm3(i)
            udd(i)=uddpm3(i)
            betas(i)=betasp(i)
            betap(i)=betapp(i)
            betad(i)=betadp(i)
            alp(i)=alppm3(i)
            eisol(i)=eisolp(i)
            dd(i)=ddpm3(i)
            qq(i)=qqpm3(i)
            am(i)=ampm3(i)
            ad(i)=adpm3(i)
            aq(i)=aqpm3(i)
            gss(i)=gsspm3(i)
            gpp(i)=gpppm3(i)
            gsp(i)=gsppm3(i)
            gp2(i)=gp2pm3(i)
            hsp(i)=hsppm3(i)
   30    continue
      else
*
*    switch in am1 parameters
*
         do 50 i=1,107
            do 40 j=1,10
               guess1(i,j)=guesa1(i,j)
               guess2(i,j)=guesa2(i,j)
   40       guess3(i,j)=guesa3(i,j)
            polvol(i)=polvoa(i)
            zs(i)=zsam1(i)
            zp(i)=zpam1(i)
            zd(i)=zdam1(i)
            uss(i)=ussam1(i)
            upp(i)=uppam1(i)
            udd(i)=uddam1(i)
            betas(i)=betasa(i)
            betap(i)=betapa(i)
            betad(i)=betada(i)
            alp(i)=alpam1(i)
            eisol(i)=eisola(i)
            dd(i)=ddam1(i)
            qq(i)=qqam1(i)
            am(i)=amam1(i)
            ad(i)=adam1(i)
            aq(i)=aqam1(i)
            gss(i)=gssam1(i)
            gpp(i)=gppam1(i)
            gsp(i)=gspam1(i)
            gp2(i)=gp2am1(i)
            hsp(i)=hspam1(i)
   50    continue
      endif
c
c        swap in old parameters for elements.  olde contains the
c        character name of the element, and iswap(1,1:newele) contains
c        the atomic number of the element. iswap(2,1:newele) contains
c        the storage address of the old set of parameters.
c
      newele=3
      olde(1)=' s1978'
      iswap(1,1)=16
      iswap(2,1)=91
      olde(2)='si1978'
      iswap(1,2)=14
      iswap(2,2)=90
      olde(3)='p1994'
      iswap(1,3)=15
      iswap(2,3)=89
c$doit asis
      do 60 k=1,newele
         if(index(keywrd,olde(k)).ne.0)then
            i=iswap(1,k)
            j=iswap(2,k)
            allref(i,3)=allref(j,1)
            allref(i,1)=allref(j,1)
            do 43 kk=1,10
               guess1(i,kk)=guess1(j,kk)
               guess2(i,kk)=guess2(j,kk)
   43       guess3(i,kk)=guess3(j,kk)
            zs(i)=zs(j)
            zp(i)=zp(j)
            zd(i)=zd(j)
            uss(i)=uss(j)
            upp(i)=upp(j)
            udd(i)=udd(j)
            betas(i)=betas(j)
            betap(i)=betap(j)
            betad(i)=betad(j)
            alp(i)=alp(j)
            eisol(i)=eisol(j)
            dd(i)=dd(j)
            qq(i)=qq(j)
            am(i)=am(j)
            ad(i)=ad(j)
            aq(i)=aq(j)
            if(gss(j).ne.0)gss(i)=gss(j)
            if(gpp(j).ne.0)gpp(i)=gpp(j)
            if(gsp(j).ne.0)gsp(i)=gsp(j)
            if(gp2(j).ne.0)gp2(i)=gp2(j)
            if(hsp(j).ne.0)hsp(i)=hsp(j)
         endif
   60 continue
      if( mindo3 ) then
         do 70 i=1,17
            if(i.ne.2.and.i.ne.10)then
               uss(i)=uss3(i)
               upp(i)=upp3(i)
               eisol(i)=eisol3(i)
               eheat(i)=eheat3(i)
               zs(i)=zs3(i)
               zp(i)=zp3(i)
               gss(i)=gssm(i)
               gpp(i)=gppm(i)
               gsp(i)=gspm(i)
               gp2(i)=gp2m(i)
               hsp(i)=hspm(i)
            endif
   70    continue
      endif
   80 continue
      if(uss(1) .gt. -1.d0) then
         write(mfgw,
     +   '(''  the hamiltonian requested is not available in''
     1,'' this program'')')
_IF(ipsc,tools)
         call pend
_ELSE
         stop
_ENDIF
      endif
      ia=1
      ib=0
      nheavy=0
      do 130 ii=1,natoms
         if(labels(ii).eq.99.or.labels(ii).eq.107) goto 130
         numat=numat+1
         nat(numat)=labels(ii)
         nfirst(numat)=ia
         ni=nat(numat)
         atheat=atheat+eheat(ni)
         eat   =eat   +eisol(ni)
         elecs=elecs+core(ni)
         ib=ia+natorb(ni)-1
         nmidle(numat)=ib
         if(natorb(ni).eq.9)ndorbs=ndorbs+5
         if(natorb(ni).eq.9)nmidle(numat)=ia+3
         nlast(numat)=ib
         if(ia.gt.maxorb) goto 270
         uspd(ia)=uss(ni)
         if(ia.eq.ib) goto 120
         k=ia+1
         k1=ia+3
c$doit asis
         do 90 j=k,k1
            if(j.gt.maxorb) goto 270
            uspd(j)=upp(ni)
   90    continue
         nheavy=nheavy+1
  100    if(k1.eq.ib)goto 120
         k=k1+1
c$doit asis
         do 110 j=k,ib
  110    uspd(j)=udd(ni)
  120    continue
  130 ia=ib+1
      if(numat.eq.1)then
         if(index(keywrd,'force').ne.0)then
            write(mfgw,
     +      '(///,a)')'      a single atom has no vibrational modes'
_IF(ipsc,tools)
            call pend
_ELSE
            stop
_ENDIF
         endif
      endif
      if(mode.ne.1)call refer
      atheat=atheat-eat*23.061d0
      norbs=nlast(numat)
      if(norbs.gt.maxorb)then
         write(mfgw,'(//10x,''**** max. number of orbitals:'',i4,/
     1            10x,''number of orbitals in system:'',i4)')
     2maxorb,norbs
_IF(ipsc,tools)
         call pend
_ELSE
         stop
_ENDIF
      endif
      nlight=numat-nheavy
      n2el=50*nheavy*(nheavy-1)+10*nheavy*nlight+(nlight*(nlight-1))/2
      if(n2el.gt.n2elec)then
         write(mfgw,
     +   '(//10x,''**** max. number of two-electron integrals:'',i8,/
     2       10x,''number of two electron integrals in system:'',3i8)')
     4n2elec,n2el
_IF(ipsc,tools)
         call pend
_ELSE
         stop
_ENDIF
      endif
c
c   now to calculate the number of levels occupied
      trip=(index(keywrd,'trip').ne.0)
      exci=(index(keywrd,'exci').ne.0)
      birad=(exci.or.index(keywrd,'birad').ne.0)
      if(index(keywrd,citxt) .ne. 0 .and. uhf ) then
         write(mfgw,'(//10x,''c.i. not allowed with uhf '')')
_IF(ipsc,tools)
         call pend
_ELSE
         stop
_ENDIF
      endif
c
c now to work out how many electrons are in each type of shell
c
      nalpha=0
      nbeta=0
c
c      protect dumb users from dumb errors!
c
      nelecs=dmax1(elecs+0.5d0,0.d0)
      nelecs=min(2*norbs,nelecs)
      nclose=0
      nopen=0
      if( uhf ) then
         fract=1.d0
         nbeta=nelecs/2
         if( trip ) then
            if(nbeta*2 .ne. nelecs) then
               write(mfgw,
     +         '(//10x,''triplet specified with odd number'',
     1            '' of electrons, correct fault '')')
_IF(ipsc,tools)
               call pend
_ELSE
               stop
_ENDIF
            else
               if(mode.ne.1)
     1write(mfgw,'(//'' triplet state calculation'')')
               nbeta=nbeta-1
            endif
         endif
         if(index(keywrd,'quar').ne.0) then
            if(nbeta*2 .eq. nelecs) then
               write(mfgw,'(//10x,
     +         ''quartet specified with even number'',
     1            '' of electrons, correct fault '')')
_IF(ipsc,tools)
               call pend
_ELSE
               stop
_ENDIF
            else
               if(mode.ne.1)
     1write(mfgw,'(//'' quartet state calculation'')')
               nbeta=nbeta-1
            endif
         endif
         if(index(keywrd,'quin').ne.0) then
            if(nbeta*2 .ne. nelecs) then
               write(mfgw,'(//10x,''quintet specified with odd number'',
     1            '' of electrons, correct fault '')')
_IF(ipsc,tools)
               call pend
_ELSE
               stop
_ENDIF
            else
               if(mode.ne.1)
     1write(mfgw,'(//'' quintet state calculation'')')
               nbeta=nbeta-2
            endif
         endif
         if(index(keywrd,'sext').ne.0) then
            if(nbeta*2 .eq. nelecs) then
               write(mfgw,'(//10x,''sextet specified with even number'',
     1            '' of electrons, correct fault '')')
_IF(ipsc,tools)
               call pend
_ELSE
               stop
_ENDIF
            else
               if(mode.ne.1)
     +         write(mfgw,'(//'' sextet state calculation'')')
               nbeta=nbeta-2
            endif
         endif
         nalpha=nelecs-nbeta
         if(mode.ne.1)
     1write(mfgw,
     +   '(//10x,''uhf calculation, no. of alpha electrons ='',i3,
     +      /27x,''no. of beta  electrons ='',i3)')nalpha,nbeta
      else
c
c   now to determine open and closed shells
c
         ielec=0
         ilevel=0
         if( trip .or. exci .or. birad ) then
            if( (nelecs/2)*2 .ne. nelecs) then
               write(mfgw,'(//10x,''system specified with odd number'',
     1            '' of electrons, correct fault '')')
_IF(ipsc,tools)
               call pend
_ELSE
               stop
_ENDIF
            endif
            if(mode.ne.1) then
               if(birad)write(mfgw,'(//'' system is a biradical'')')
               if(trip )write(mfgw,'(//'' triplet state calculation'')')
               if(exci )write(mfgw,'(//'' excited state calculation'')')
            endif
            ielec=2
            ilevel=2
         elseif((nelecs/2)*2.ne.nelecs) then
            ielec=1
            ilevel=1
         endif
         if(index(keywrd,'quar').ne.0) then
            if(mode.ne.1)write(mfgw,
     +      '(//'' quartet state calculation'')')
            ielec=3
            ilevel=3
         endif
         if(index(keywrd,'quin').ne.0) then
            if(mode.ne.1)write(mfgw,
     +      '(//'' quintet state calculation'')')
            ielec=4
            ilevel=4
         endif
         if(index(keywrd,'sext').ne.0) then
            if(mode.ne.1)write(mfgw,
     +      '(//'' sextet state calculation'')')
            ielec=5
            ilevel=5
         endif
         i=index(keywrd,'open(')
         if(i.ne.0)then
            ielec=reada(keywrd,i)
            ilevel=reada(keywrd,i+7)
         endif
         nclose=nelecs/2
         nopen = nelecs-nclose*2
         if( ielec.ne.0 )then
            if((nelecs/2)*2.eq.nelecs .neqv.
     1                  (ielec/2)*2.eq.ielec) then
               write(mfgw,
     +    '('' impossible number of open shell electrons'')')
_IF(ipsc,tools)
               call pend
_ELSE
               stop
_ENDIF
            endif
            nclose=nclose-ielec/2
            nopen=ilevel
            if(nclose+nopen.gt.norbs)then
               write(mfgw,'(a)')
     +   ' number of doubly filled plus partly filled levels'
               write(mfgw,'(a)')
     +   ' greater than total number of orbitals.'
_IF(ipsc,tools)
               call pend
_ELSE
               stop
_ENDIF
            endif
            fract=ielec*1.d0/ilevel
            if(mode.ne.1)
     1write(mfgw,
     +     '('' there are'',i3,'' doubly filled levels'')')nclose
         endif
         if(mode.ne.1)write(mfgw,
     +   '(//10x,''rhf calculation, no. of '',
     1''doubly occupied levels ='',i3)')nclose
         if(mode.ne.1 .and. nopen.ne.0.and.dabs(fract-1.d0).lt.1.d-4)
     1write(mfgw,'(/27x,
     +  ''no. of singly occupied levels ='',i3)')nopen
         if(mode.ne.1 .and. nopen.ne.0.and.dabs(fract-1.d0).gt.1.d-4)
     1write(mfgw,'(/27x,''no. of levels with occupancy'',f6.3,
     +''  ='',i3)')  fract,nopen
         if(index(keywrd,'c.i.=(').ne.0) then
            i=reada(keywrd,index(keywrd,'c.i.=(')+5)-
     1      reada(keywrd,index(keywrd,'c.i.=(')+7)
            if(nopen.gt.i)then
               write(mfgw,
     +'(//,'' number of open-shells allowed in c.i. is less '' /
     +     ''    than that specified by other keywords'')
     2')
_IF(ipsc,tools)
               call pend
_ELSE
               stop
_ENDIF
            endif
         endif
         if(index(keywrd,'c.i.').ne.0.and.nopen.eq.0)then
            nopen=1
            nclose=nclose-1
            fract=2.d0
         endif
         nopen=nopen+nclose
      endif
c
c  work out if defined spin-state allowed
c
      msdel=index(keywrd,' ms')
      if(msdel.ne.0)then
         msdel=1.0001d0*reada(keywrd,index(keywrd,' ms'))
      else
         if(index(keywrd,'trip')+index(keywrd,'quar').gt.0)msdel=1
         if(index(keywrd,'quin')+index(keywrd,'sext').gt.0)msdel=2
      endif
      if(msdel.ne.0.and..not.uhf)then
c
c   msdel = number of alpha electrons - number of beta electrons
c
         ndoubl=99
         if(index(keywrd,'c.i.=(').ne.0)then
            ndoubl=reada(keywrd,index(keywrd,'c.i.=(')+7)
            nmos=reada(keywrd,index(keywrd,'c.i.=(')+5)
         elseif (index(keywrd,'c.i.=').ne.0)then
            nmos=reada(keywrd,index(keywrd,'c.i.=')+5)
         else
            nmos=nopen-nclose
         endif
         if(ndoubl.eq.99)then
            j=max(
     +        min((nclose+nopen+1)/2-(nmos-1)/2,norbs-nmos+1),1)
         else
            j=nclose-ndoubl+1
         endif
         ne=dmax1(0.d0,(nclose-j+1.d0))*2.d0+
     1     dmax1(0.d0,(nopen-nclose)*fract) + 0.5d0
         nupp=(ne+1)/2+msdel
         ndown=ne-nupp
c
c  nupp  = number of alpha electrons in active space
c  ndown = number of beta  electrons in active space
c
         if(nupp*ndown.lt.0.or.nupp.gt.nmos.or.ndown.gt.nmos)then
            write(mfgw,'(a)')
     1' specified spin component not spanned by active space'
_IF(ipsc,tools)
            call pend
_ELSE
             stop
_ENDIF
         endif
      endif
c#      write(mfgw,'(''  nopen,nclose,nalpha,nbeta,fract'',4i4,f12.5)')
c#     1 nopen, nclose, nlapha, nbeta, fract
c
c   make sure analyt is not used with analytical c.i. derivatives
c
      halfe = (nopen.gt.nclose.and.fract.ne.2.d0.and.fract.ne.0.d0
     1 .or. index(keywrd,'c.i.').ne.0)
      slow=(index(keywrd,'exci').ne.0.or.
     1index(keywrd,'root').ne.0.and.index(keywrd,'root=1').eq.0)
      if(halfe)halfe=(.not.slow)
      if(index(keywrd,'noanci').eq.0.and.
     1index(keywrd,'analyt').ne.0.and.halfe)then
         write(mfgw,*)
         write(mfgw,'(a)')' keyword ''analyt'' cannot be used here: ',
     1' analyical c.i. derivatives must use finite differences',
     2' to correct, remove keyword ''analyt'' or add ''noanci'''
_IF(ipsc,tools)
         call pend
_ELSE
         stop
_ENDIF
      endif
      yy=dfloat(kharge)/(norbs+1.d-10)
      l=0
      do 160 i=1,numat
         ni=nat(i)
         xx=1.d0/(nlast(i)-nfirst(i)+1+1.d-10)
         w=core(ni)*xx-yy
         ia=nfirst(i)
         ic=nmidle(i)
         ib=nlast(i)
c$doit asis
         do 140 j=ia,ic
            l=l+1
  140    pspd(l)=w
c$doit asis
         do 150 j=ic+1,ib
            l=l+1
  150    pspd(l)=0.0d0
  160 continue
c
c   write out the interatomic distances
c
      call gmetry(geo,coord)
      rmin=100.d0
      l=0
      do 170 i=1,numat
         do 170 j=1,i
            l=l+1
            rxyz(l)=dsqrt((coord(1,i)-coord(1,j))**2+
     1                    (coord(2,i)-coord(2,j))**2+
     2                    (coord(3,i)-coord(3,j))**2)
            if(rmin.gt.rxyz(l) .and. i .ne. j .and.
     1 (nat(i).lt.103 .or. nat(j).lt.103)) then
               iminr=i
               jminr=j
               rmin=rxyz(l)
            endif
  170 continue
      nnhco=0
c
c   set up molecular-mechanics correction to -(c=o)-(nh)- linkage
c   this will be used if mmok has been specified.
c
      itype=1
      if(index(keywrd,'am1').ne.0)itype=2
      if(index(keywrd,'pm3').ne.0)itype=3
      if(index(keywrd,'mindo').ne.0)itype=4
c
c   identify o=c-n-h systems via the interatomic distances matrix
      do 220 i=1,numat
         if(nat(i).ne.8) goto 220
         do 210 j=1,numat
            if(nat(j).ne.6) goto 210
            ij=max(i,j)
            ji=i+j-ij
            if(rxyz((ij*(ij-1))/2+ji).gt.1.3)goto 210
            do 200 k=1,numat
               if(nat(k).ne.7) goto 200
               jk=max(j,k)
               kj=j+k-jk
               if(rxyz((jk*(jk-1))/2+kj).gt.1.6)goto 200
               do 190 l=1,numat
                  if(nat(l).ne.1) goto 190
                  kl=max(k,l)
                  lk=k+l-kl
                  if(rxyz((kl*(kl-1))/2+lk).gt.1.3)goto 190
c
c   we have a h-n-c=o system.  the atom numbers are l-k-j-i
c   now search out atom attached to nitrogen, this specifies
c   the system x-n-c=o
c
                  do 180 m=1,numat
                     if(m.eq.k.or.m.eq.l.or.m.eq.j) goto 180
                     mk=max(m,k)
                     km=m+k-mk
                     if(rxyz((mk*(mk-1))/2+km).gt.1.7)goto 180
                     nnhco=nnhco+1
                     nhco(1,nnhco)=i
                     nhco(2,nnhco)=j
                     nhco(3,nnhco)=k
                     nhco(4,nnhco)=m
                     nnhco=nnhco+1
                     nhco(1,nnhco)=i
                     nhco(2,nnhco)=j
                     nhco(3,nnhco)=k
                     nhco(4,nnhco)=l
                     goto 190
  180             continue
  190          continue
  200       continue
  210    continue
  220 continue
      if(mode.ne.1.and.nnhco.ne.0)then
         if(index(keywrd,'mmok').ne.0) then
            write(mfgw,'(a)')' molecular mechanics correction ',
     +      'applied to peptidelinkage'
         elseif(index(keywrd,'nomm').ne.0)then
            write(mfgw,'(a,i2,2a)')' there are ',nnhco/2,
     +      ' peptide linkages',' identified in this system'
            write(mfgw,'(a)')
     +      ' if you want mm correction to the conh barrier, ',
     +      'add the key-word "mmok"'
            nnhco=0
         else
            write(mfgw,'(a)')' this system contains -hnco- groups.'
            write(mfgw,'(a)')' you must specify "nomm" or "mmok" ',
     +      ' regarding molecular mechanics correction'
_IF(ipsc,tools)
            call pend
_ELSE
            stop
_ENDIF
         endif
      endif
      if(mode.ne.1.and.index(keywrd,'nointer') .eq. 0) then
         write(mfgw,'(//10x,''  interatomic distances'')')
         call vecprt(rxyz,numat)
      endif
      if(rmin.lt.0.8d0.and.index(keywrd,'geo-ok') .eq.0) then
         write(mfgw,230)iminr,jminr,rmin
  230    format(//,'   atoms',i3,' and',i3,' are separated by',f8.4,
     1' angstroms.',/'   to continue calculation specify "geo-ok"')
_IF(ipsc,tools)
         call pend
_ELSE
         stop
_ENDIF
      endif
      if(.not. debug) return
      write(mfgw,240)numat,norbs,ndorbs,natoms
  240 format('   number of real atoms:',i4,/
     1      ,'   number of orbitals:  ',i4,/
     2      ,'   number of d orbitals:',i4,/
     3      ,'   total no. of atoms:  ',i4)
      write(mfgw,250)(uspd(i),i=1,norbs)
  250 format('   one-electron diagonal terms',/,10(/,10f8.3))
      write(mfgw,260)(pspd(i),i=1,norbs)
  260 format('   initial p for all atomic orbitals',/,10(/,10f8.3))
      return
  270 write(mfgw,
     +  '(//10x,'' maximum number of atomic orbitals exceeded'')')
      write(mfgw,'(  10x,'' maximum allowed ='',i4)')maxorb
_IF(ipsc,tools)
      call pend
_ELSE
      stop
_ENDIF
      end
      subroutine molval(c,p,nocc,rhfuhf)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      common /iofile/ mfgr,mfgw
      dimension c(norbs,norbs), p(*)
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),
     1                nlast(numatm), norbs, nelecs,nalpha,nbeta,
     2                nclose,nopen,ndumy,fract
      dimension val(maxorb)
      do 40 i=1,nocc
         sum=0.0d0
         do 30 jj=1,numat
            jl=nfirst(jj)
            ju=nlast(jj)
            do 30 j=jl,ju
               do 30 kk=1,numat
                  if(kk.eq.jj) goto 20
                  kl=nfirst(kk)
                  ku=nlast(kk)
                  do 10 k=kl,ku
                     l1=max(j,k)
                     l2=j+k-l1
                     l=(l1*(l1-1))/2+l2
                     sum=sum+c(j,i)*c(k,i)*p(l)
   10             continue
   20             continue
   30    continue
         val(i)=sum*rhfuhf
   40 continue
      write(mfgw,'(10f8.4)')(val(i),i=1,nocc)
      end
*gamess
_IF(ipsc,tools)
      program mopac
_ELSE
      subroutine mopac(core,quit)
_ENDIF
c
c         notice of public domain nature of mopac
c
c      'this computer program is a work of the united states
c       government and as such is not subject to protection by
c       copyright (17 u.s.c. # 105.)  any person who fraudulently
c       places a copyright notice or does any other act contrary
c       to the provisions of 17 u.s. code 506(c) shall be subject
c       to the penalties provided therein.  this notice shall not
c       be altered or removed from this software and is to be on
c       all reproductions.'
c
c
c     this is a modified version of mopac-6.0, which incorporates:
c     a) computation of the m.e.p. from semiempirical wavefunction
c        (orthogonal and deorthogonal).
c        m.e.p is evaluated in points placed in cubic grids or  on
c        connolly surfaces.
c     b) computation of solvent effects following miertus-scrocco-
c        tomasi self-consistent reaction field model.
c
c     modified by f.j.luque and m.orozco.
c
c     october-1993
c
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
*gamess
      logical quit,gamess,ostop
      common /scftyp/ emin, limscf
      common /keywrd/ keywrd
      common /okmany/ isok
      common /geovar/ nvar,loc(2,maxpar), idumy, xparam(maxpar)
      common /mesage/ iflepo,iscf
      common /geosym/ ndep,locpar(maxpar),idepfn(maxpar),locdep(maxpar)
      common /geokst/ natoms,labels(numatm),
     1na(numatm),nb(numatm),nc(numatm)
      common /cmpg/ geo(3,numatm)
      common /gradnt/ grad(maxpar),gnorm
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),
     1                nlast(numatm), norbs, nelecs,nalpha,nbeta,
     2                nclose,nopen,ndumy,fract
      common /atheat/ atheat
      common /last  / last
      common /atomic/ eisol(107),eheat(107)
      common /numcal/ numcal
      common /timem/ time0
      common /path/ latom,lparam,react(200)
      common /readme/ ird
      common /iofile/ iread,iwrite
c cosmo change
      logical iseps, useps , upda
      common /iseps/  iseps, useps, upda
c end of cosmo change
c     patas
      common /mstq/ qs(1500),mflag,iterq
c     patas
      character*241 keywrd
c     character*241 getnam*80
      logical isok, limscf
_IF(ipsc,tools)
_IF(tools)
      call pbeginf
_ENDIF
      begtim=dclock()
      call initia
_ELSE
*gamess
      dimension core(*)
*gamess
_ENDIF
      quit = .true.
      ostop = .false.
      gamess = .false.
*gamess
      call getdat(gamess)
c     patas
      mflag=0
      iterq=0
c
c   close unit 6 in case it was already pre-assigned
c
*gamess          close (6)
*gamess          open(unit=6,file=getnam('for006'),status='new')
*gamess          rewind 6
c#      call timop('first line')
      numcal=0
      isok=.true.
   10 numcal=numcal+1
c
      time0=secmop()
c
c read and check input file, exit if necessary.
c     write input file to unit 6 as feedback to user
c
c is mopac run to be followed by ab initio calculation
      if(numcal.gt.1)then
       if(gamess.or.index(keywrd,'abinitio').ne.0) then
       quit = .false.
_IF(ipsc,tools)
       call pend
_ELSE
       return
_ENDIF
       endif
      endif
      call moprdm(ostop)
      if (ostop.or.natoms.eq.0) then
c      close(iread,status='delete')
c      stop
       go to 50
      emin=0.0d0
      endif
c#      call timop('after read')
      if(natoms.eq.0) goto 50
      if(index(keywrd,'author') .ne. 0) then
         write(iwrite,
     +        '(10x,'' mopac - a general molecular orbital package'',
     1/        ,10x,''   original version written in 1983'')')
         write(iwrite,'(10x,''     by james j. p. stewart at the'',/
     1         ,10x,''     university of texas at austin'',/
     2         ,10x,''          austin, texas, 78712'')')
         write(iwrite,'(10x,''  modified to do esp calculations by''
     1         ,10x,''    brent h. besler and k. m. merz jr. 1989'')')
      endif
c
c initialize calculation and write calculation independent info
c
      if(index(keywrd,'0scf') .ne. 0) then
         write(iwrite,'(a)')' geometry in mopac z-matrix format'
         call geout(6)
         if(index(keywrd,' aigout').ne.0)then
            write(iwrite,'(//,a)')
     +   '  geometry in gaussian z-matrix format'
            call wrttxt(iwrite)
            call geoutg(iwrite,.false.)
         endif
         if(index(keywrd,' out=gamess').ne.0)then
            write(iwrite,'(//,a)')'  geometry in gamess z-matrix format'
            call wrttxt(iwrite)
            call geoutg(6,.true.)
         endif
         goto 50
      endif
      call moldat(0)
c cosmo change
c  initialize solvation
      iseps = .false.
      useps = .false.
      upda = .false.
      indeps=index(keywrd,'eps=')
      if (indeps .ne. 0) then
        iseps = .true.
        upda =.true.
        call initsv (indeps)
      end if
c a.klamt 18.7.91
c end of cosmo change
      if(index(keywrd,'external') .ne. 0) then
         call datin
c
c  recalculate the atomic energy
c
         atheat=0.0d0
         eat=0.0d0
         do 30 ii=1,numat
            ni=nat(ii)
            atheat=atheat+eheat(ni)
   30    eat   =eat   +eisol(ni)
         atheat=atheat-eat*23.061d0
      endif
      if (index(keywrd,'restart').eq.0)then
         if (index(keywrd,'1scf').ne.0) then
            if(latom.ne.0)then
               write(iwrite,'(//,10x,a)')
     +         '1scf specified with path.  this pair of'
               write(iwrite,'(   10x,a)')
     +         'options is not allowed'
               goto 50
            endif
            iflepo=1
            iscf=1
            last=1
            i=index(keywrd,'grad')
            do 39 j=1,nvar
  39        grad(j)=0.0d0
            call compfg(xparam,.true.,escf,.true.,grad,i.ne.0)
            goto 40
         endif
      endif
c
c calculate dynamic reaction coordinate.
c
c
      if(index(keywrd,'saddle') .ne. 0) then
         call react1(escf)
         goto 50
      endif
      if(index(keywrd,'step1') .ne. 0) then
         call mopg()
         goto 50
      endif
      if (latom .ne. 0) then
c
c       do path
c
         if (index(keywrd,'step').eq.0.or.
     1index(keywrd,'point').eq.0) then
            call mopth()
            goto 50
         endif
         call pathk()
         goto 50
      endif
      if (   index(keywrd,'force') .ne. 0
     1  .or. index(keywrd,'irc=' ) .ne. 0
     2  .or. index(keywrd,'therm') .ne. 0 ) then
c
c force calculation if desired
c
         call force
         goto 50
      endif
      if(index(keywrd,' drc') + index(keywrd,' irc') .ne. 0) then
c
c   in this context, "react" holds initial velocity vector components.
c
         call drc(react,react)
         goto 50
      endif
c
      if(index(keywrd,'nllsq') .ne. 0) then
         call nllsq(xparam, nvar )
         call compfg(xparam,.true.,escf,.true.,grad,.true.)
         goto 40
      endif
c
      if(index(keywrd,'sigma') .ne. 0) then
         call powsq(xparam, nvar, escf)
         goto 40
      endif
c
c  ef optimisation
c
      if(index(keywrd,' ef').ne.0 .or. index(keywrd,' ts').ne.0) then
         if(index(keywrd,'geo-ok').eq.0.and.nvar.gt.3*natoms-6)then
            write(iwrite,'(a)')
     +      ' eigenvector following is not recommended when'
            write(iwrite,'(a)')
     +      ' more than 3n-6 coordinates are to be optimized'
            write(iwrite,'(a)')' to continue, specify ''geo-ok'''
_IF(ipsc,tools)
            call pend
_ELSE
            stop
_ENDIF
         endif
         call ef (xparam,nvar,escf)
         goto 40
      endif
c
c ordinary geometry optimisation
c
c
c ordinary geometry optimisation
c
c#      call timop('before flepo')
c cosmo change 1/9/92 sjc
      upda = .false.
c end of cosmo change
      call flepo(xparam, nvar, escf)
   40 last=1
      if(iflepo.ge.0)call writmo(time0, escf)
      if(index(keywrd,'polar') .ne. 0) then
         call polar
      endif
         if(index(keywrd,'pmep') .ne. 0) call pmep
c pmep by bingze wang
      if(index(keywrd,' esp') .ne. 0)then
c  if you want to use the esp program, uncomment the line
c  "c#      call esp", add "esp, " to mopac.opt, then compile esp and
c  mndo, and relink.
        call esp
      endif
c     patas
c
c     m.e.p. calculation
c
  50  if (index(keywrd,'mep=').ne.0) then
      open(15,file='mol.mep',status='new',form='formatted')
      call ldima
      close(15)
      endif
c
c     miertus-scrocco_tomasi solvation model
c
      if (index(keywrd,'tom').ne.0) then
      open(18,file='mol.pot',status='new',form='formatted')
      open(15,file='mol.mep',status='new',form='formatted')
      open(17,file='mol.sol',status='new',form='formatted')
  200 call ldima
      call rfield
      iterq=iterq+1
      call flepo(xparam, nvar, escf)
      call writmo(time0, escf)
      if (mflag.lt.3) go to 200
c
c     option 'jiali'
c
      if (index(keywrd,'jiali').eq.0) go to 52
c
c     h in solution --  psi in vacuo
c
      mflag=mflag+1
c
c     mflag=4
c
      write(iwrite,*)
      write(iwrite,*) '*** h in solution - psi in vacuo ***'
      call ldima
      call rfield
      iterq=iterq+1
      call flepo(xparam, nvar, escf)
      call writmo(time0, escf)
c
c     h in vacuo - psi in solution
c
      mflag=mflag+2
c
c     mflag=6
c
      write(iwrite,*)
      write(iwrite,*) '*** h in vacuo - psi in solution ***'
      call flepo(xparam, nvar, escf)
      call writmo(time0, escf)
  52  close(14)
      close(15)
      close(17)
c 52  continue
      endif
c     patas
   51 tim=secmop()-time0
      limscf=.false.
      write(iwrite,
     +  '(///,'' total cpu time: '',f16.2,'' seconds'')') tim
      write(iwrite,'(/,'' == mopac done =='')')
_IFN(ipsc,tools)
      if(isok) goto 10
      close(iread,status='delete')
      return
_ELSE
c     if(isok) goto 10
      endtim=dclock()
      runtim=endtim-begtim
      write(iwrite,60)runtim
   60 format(/' mopac runtime = ',f10.2,' elapsed seconds'/)
_IF(tools)
c
      if (nodeid().eq.0) call stats
      close(ird,status='delete')
_ENDIF
      call pend
_ENDIF
      end
      subroutine mopd(fao,vector,nocc,eig,mdim,n)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      dimension fao(*),vector(mdim,*),eig(*),ws(maxorb)
c***********************************************************************
c
c   "fast" diagonalisation procedure.
c
c    on input fao contains the lower half triangle of the matrix to be
c                         diagonalised, packed.
c             vector  contains the old eigenvectors on input, the new
c             vectors on exiting.
c             nocc = number of occupied molecular orbitals.
c             eig  = eigenvalues from an exact diagonalisation
c             mdim = declared size of matrix "c".
c             n = number of atomic orbitals in basis set
c
c  diag is a pseudo-diagonalisation procedure, in that the vectors that
c       are generated by it are more nearly able to block-diagonalise
c       the fock matrix over molecular orbitals than the starting
c       vectors. it must be considered pseudo for several reasons:
c       (a) it does not generate eigenvectors - the secular determinant
c           is not diagonalised, only the occupied-virtual intersection.
c       (b) many small elements in the sec.det. are ignored as being too
c           small compared with the largest element.
c       (c) when elements are eliminated by rotation, the rest of the
c           sec. det. is assumed not to change, i.e. elements created
c           are ignored.
c       (d) the rotation required to eliminate those elements considered
c           significant is approximated to using the eigenvalues of the
c           exact diagonalisation throughout the rest of the iterative
c           procedure.
c
c  (note:- in an iterative procedure all the approximations present in
c          diag become valid at self-consistency, self-consistency is
c          not slowed down by use of these approximations)
c
c    reference:
c             "fast semiempirical calculations",
c             stewart. j.j.p., csaszar, p., pulay, p., j. comp. chem.,
c             3, 227, (1982)
c
c***********************************************************************
      common /scrach/ fmo(morb2), xdumy(maxpar**2-morb2)
c             fmo  is a work-space of size (n-nocc)*nocc, it will hold
c                  the fock molecular orbital interaction matrix.
c
c  first, construct that part of a secular determinant over molecular
c  orbitals which connects the occupied and virtual sets.
c
c***********************************************************************
c
      logical first
      data first /.true./
      if(first)then
         first=.false.
c
c   eps is the smallest number which, when added to 1.d0, is not
c   equal to 1.d0
         call epseta(eps,eta)
c
c   increase eps to allow for a lot of round-off
c
         bigeps=10.d0*dsqrt(eps)
      endif
      tiny=0.0d0
      lumo=nocc+1
      ij=0
c#      call timop('squaring')
      do 60 i=lumo,n
         kk=0
         do 30 j=1,n
_IFN(blas)
            sum=0.d0
            do 10 k=1,j
               kk=kk+1
   10       sum=sum+fao(kk)*vector(k,i)
_ELSE
            sum=ddot(j,fao(kk+1),1,vector(1,i),1)
            kk=kk+j
_ENDIF
            if(j.eq.n) goto 30
            j1=j+1
            k2=kk
            do 20 k=j1,n
               k2=k2+k-1
   20       sum=sum+fao(k2)*vector(k,i)
   30    ws(j)=sum
         do 50 j=1,nocc
            ij=ij+1
_IFN(blas)
            sum=0.d0
            do 40 k=1,n
   40       sum=sum+ws(k)*vector(k,j)
_ELSE
            sum=ddot(n,ws(1),1,vector(1,j),1)
_ENDIF
            if(tiny.lt.dabs(sum)) tiny=dabs(sum)
   50    fmo(ij)=sum
   60 continue
      tiny=0.05d0*tiny
c***********************************************************************
c
c   now do a crude 2 by 2 rotation to "eliminate" significant elements
c
c***********************************************************************
c#      call timop('rotating')
      ij=0
      do 90 i=lumo,n
         do 80 j=1,nocc
            ij=ij+1
            if(dabs(fmo(ij)).lt.tiny) goto 80
c
c      begin 2 x 2 rotations
c
            a=eig(j)
            b=eig(i)
            c=fmo(ij)
            d=a-b
c
c    use bigeps to determine whether to do a 2 by 2 rotation
c
            if(dabs(c/d).lt.bigeps) goto 80
c
c  at this point we know that
            e=dsign(dsqrt(4.d0*c*c+d*d),d)
            alpha=dsqrt(0.5d0*(1.d0+d/e))
            beta=-dsign(dsqrt(1.d0-alpha*alpha),c)
c
c      rotation of pseudo-eigenvectors
c
_IFN(blas)
            do 70 m=1,n
               a=vector(m,j)
               b=vector(m,i)
               vector(m,j)=alpha*a+beta*b
               vector(m,i)=alpha*b-beta*a
   70       continue
_ELSE
      call drot(n,vector(1,j),1,vector(1,i),1,alpha,beta)
_ENDIF
   80    continue
   90 continue
c#      call timop('returning')
      return
      end
      subroutine mopdv(geo,grad)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      common /iofile/ mfgr,mfgw
      dimension grad(*), geo(3,*)
************************************************************************
*
*    deriv calculates the derivatives of the energy with respect to the
*          internal coordinates. this is done by finite differences.
*
*    the main arrays in deriv are:
*        loc    integer array, loc(1,i) contains the address of the atom
*               internal coordinate loc(2,i) is to be used in the
*               derivative calculation.
*        geo    array \geo\ holds the internal coordinates.
*        grad   on exit, contains the derivatives
*
************************************************************************
      common /euler/ tvec(3,3), id
      common / readme / ird
      common /okmany/ isok
      common /geovar/ nvar,loc(2,maxpar), idumy, dummy(maxpar)
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),
     1                nlast(numatm), norbs, nelecs,nalpha,nbeta,
     2                nclose,nopen,ndumy,fract
      common /geokst/ natoms,labels(numatm),
     1na(numatm),nb(numatm),nc(numatm)
      common /gravec/ cosine
      common /geosym/ ndep, locpar(maxpar), idepfn(maxpar),
     1locdep(maxpar)
      common /path/ latom,lparam,react(200)
      common /ucell/ l1l,l2l,l3l,l1u,l2u,l3u
      common /xyzgra/ dxyz(9*numatm)
      common /enuclr/ enuclr
      common /numcal/ numcal
      common /hmatrx/ h(mpack)
      common /atheat/ atheat
      common /keywrd/ keywrd
      common /errfn/ errfn(maxpar), aicorr(maxpar)
      common /work3/ work2(4*mpack)
      common /cmopgl/ coord(3,numatm), cold(3,numatm*3), gold(maxpar),
     1 xparam(maxpar)
      character*241 keywrd, line*80, getmop*80
      dimension change(3), xjuc(3), aidref(maxpar)
      save scf1, halfe, idelta, slow
      logical debug, halfe, scf1, ci, precis, slow, aic, noanci,
     1aifrst, isok, geook, int
      save icalcn,debug,aifrst,precis,int,geook,ci,aic,change
      save aidref,xjuc,grlim
      data icalcn /0/
      if(icalcn.ne.numcal) then
         aifrst= (index(keywrd,'restart').eq.0)
         debug = (index(keywrd,'deriv') .ne. 0)
         precis= (index(keywrd,'prec') .ne. 0)
         int   = (index(keywrd,' xyz') .eq. 0)
         geook = (index(keywrd,'geo-ok') .ne. 0)
         ci    = (index(keywrd,'c.i.') .ne. 0)
         scf1  = (index(keywrd,'1scf') .ne. 0)
         aic=(index(keywrd,'aider').ne.0)
         icapa=ichar('a')
         ilowa=ichar('a')
         ilowz=ichar('z')
         if(aic.and.aifrst)then
            open(unit=ird,file=getmop(1),status='old',blank='zero')
            rewind ird
c
c  isok is set false: only one system allowed
c
            isok=.false.
            do 10 i=1,3
   10       read(ird,'(a)')line
            do 30 j=1,1000
               read(ird,'(a)',end=40,err=40)line
************************************************************************
               do 20 i=1,80
                  iline=ichar(line(i:i))
                  if(iline.ge.ilowa.and.iline.le.ilowz) then
                     line(i:i)=char(iline+icapa-ilowa)
                  endif
   20          continue
************************************************************************
   30       if(index(line,'aider').ne.0)goto 60
   40       write(mfgw,'(//,a)')' keyword "aider" specified, but not'
            write(mfgw,'(a)')' present after z-matrix.  job stopped'
_IF(ipsc,tools)
            call pend
_ELSE
            stop
_ENDIF
   50       write(mfgw,'(//,a)')
     +   '  fault in read of ab initio derivatives'
            write(mfgw,'(a)')'  derivatives read in are as follows'
            write(mfgw,'(6f12.6)')(aidref(j),j=1,i)
_IF(ipsc,tools)
            call pend
_ELSE
            stop
_ENDIF
   60       continue
            if(natoms.gt.2)then
               j=3*natoms-6
            else
               j=1
            endif
            read(ird,*,end=50,err=50)(aidref(i),i=1,j)
            write(mfgw,'(/,a,/)')
     1' ab-initio derivatives in kcal/mol/(angstrom or radian)'
            write(mfgw,'(5f12.6)')(aidref(i),i=1,j)
            do 70 i=1,nvar
               if(loc(1,i).gt.3)then
                  j=3*loc(1,i)+loc(2,i)-9
               elseif(loc(1,i).eq.3)then
                  j=loc(2,i)+1
               else
                  j=1
               endif
   70       aidref(i)=aidref(j)
            write(mfgw,'(/,a,/)')
     1' ab-initio derivatives for variables'
            write(mfgw,'(5f12.6)')(aidref(i),i=1,nvar)
            if(ndep.ne.0)then
               do 90 i=1,nvar
                  sum=aidref(i)
                  do 80 j=1,ndep
                     if(loc(1,i).eq.locpar(j).and.(loc(2,i).eq.idepfn(j)
     1.or.loc(2,i).eq.3.and.idepfn(j).eq.14)) aidref(i)=aidref(i)+sum
   80             continue
   90          continue
               write(mfgw,'(/,a,/)')
     1' ab-initio derivatives after symmetry weighting'
               write(mfgw,'(5f12.6)')(aidref(j),j=1,nvar)
            endif
         endif
         icalcn=numcal
         if(index(keywrd,'restart') .eq. 0) then
            do 100 i=1,nvar
  100       errfn(i)=0.0d0
         endif
         grlim=0.01d0
         if(precis)grlim=0.0001d0
         halfe = (nopen.gt.nclose.and.fract.ne.2.d0.and.fract.ne.0.d0
     1 .or. ci)
         idelta=-7
*
*   idelta is a machine-precision dependant integer
*
         change(1)= 10.d0**idelta
         change(2)= 10.d0**idelta
         change(3)= 10.d0**idelta
c
c    change(i) is the step size used in calculating the derivatives.
c    for "cartesian" derivatives, calculated using dcart,an
c    infinitesimal step, here 0.000001, is acceptable. in the
c    half-electron method a quite large step is needed as full scf
c    calculations are needed, and the difference between the total
c    energies is used. the step cannot be very large, as the second
c    derivitive in flepo is calculated from the differences of two
c    first derivatives. change(1) is for change in bond length,
c    (2) for angle, and (3) for dihedral.
c
      endif
      if(nvar.eq.0) return
      if(debug)then
         write(mfgw,'('' geo at start of deriv'')')
         write(mfgw,'(f19.5,2f12.5)')((geo(j,i),j=1,3),i=1,natoms)
      endif
      gnorm=0.0d0
      do 110 i=1,nvar
         gold(i)=grad(i)
         xparam(i)=geo(loc(2,i),loc(1,i))
  110 gnorm=gnorm+grad(i)**2
      gnorm=dsqrt(gnorm)
      slow=.false.
      noanci=.false.
      if(halfe) then
         noanci=(index(keywrd,'noanci').ne.0 .or. nopen.eq.norbs)
         slow=(noanci.and.(gnorm .lt. grlim .or. scf1))
      endif
      if(ndep.ne.0) call mopsym()
      call gmetry(geo,coord)
c
c  coord now holds the cartesian coordinates
c
      if(halfe.and..not.noanci) then
         if(debug)write(mfgw,*) 'doing analytical c.i. derivatives'
         call dernvo(coord,dxyz)
      else
         if(debug)
     +   write(mfgw,*) 'doing variationally opimized derivatives'
         call dcart(coord,dxyz)
      endif
      ij=0
      do 150 ii=1,numat
         do 140 il=l1l,l1u
            do 140 jl=l2l,l2u
               do 140 kl=l3l,l3u
c$doit asis
                  do 120 ll=1,3
  120             xjuc(ll)=coord(ll,ii)+tvec(ll,1)*il+tvec(ll,2)*jl+tvec
     1(ll,3)*kl
                  ij=ij+1
c$doit asis
                  do 130 kk=1,3
                     cold(kk,ij)=xjuc(kk)
  130             continue
  140    continue
  150 continue
      step=change(1)
      call jcarin (coord,xparam,step,precis,work2,ncol)
      call mxm (work2,nvar,dxyz,ncol,grad,1)
      if (precis) then
         step=0.5d0/step
      else
         step=1.0d0/step
      endif
      do 160 i=1,nvar
  160 grad(i)=grad(i)*step
c
c  now to ensure that internal derivatives accurately reflect cartesian
c  derivatives
c
      if(int.and. .not. geook .and. nvar.ge.numat*3-6.and.id.eq.0)then
c
c  number of variables looks o.k.
c
         sum=ddot(nvar,grad,1,grad,1)
         if(sum.lt.2.d0.and.ddot(3*numat,dxyz,1,dxyz,1).gt.
     +            dmax1(4.d0,sum*4.d0))then
c
c oops, looks like an error.
c
            do 170 i=1,nvar
               j=xparam(i)/3.141d0
               if(loc(2,i).eq.2.and.loc(1,i).gt.3.and.
     1 dabs(xparam(i)-j*3.1415926d0).lt.0.005d0 )then
c
c  error located, but cannot correct in this run
c
                  write(mfgw,'(//,3(a,/),i3,a)')
     1' internal coordinate derivatives do not reflect',
     2' cartesian coordinate derivatives',
     3' to correct error, increase dihedral of atom',loc(1,i),
     4' by 90 degrees'
                  write(mfgw,'(//,a)')'     current geometry'
                  call geout(mfgw)
_IF(ipsc,tools)
                  call pend
_ELSE
                  stop
_ENDIF
               endif
  170       continue
         endif
      endif
c
c  this code is only used if the keyword noanci is specified
      if(slow)then
         if(debug)write(mfgw,*) 'doing full scf derivatives'
         call deritr(errfn,geo)
c
c the array errfn holds the exact derivatives minus the approximate
c derivatives
         do 180 i=1,nvar
  180    errfn(i)=errfn(i)-grad(i)
      endif
      cosine=ddot(nvar,grad,1,gold,1)/
     1 dsqrt(ddot(nvar,grad,1,grad,1)*
     +       ddot(nvar,gold,1,gold,1)+1.d-20)
      do 190 i=1,nvar
  190 grad(i)=grad(i)+errfn(i)
      if(aic)then
         if(aifrst)then
            aifrst=.false.
            do 200 i=1,nvar
  200       aicorr(i)=-aidref(i)-grad(i)
         endif
c#         write(mfgw,'('' gradients before ai correction'')')
c#         write(mfgw,'(10f8.3)')(grad(i),i=1,nvar)
         do 210 i=1,nvar
  210    grad(i)=grad(i)+aicorr(i)
      endif
  220 if(debug) then
         write(mfgw,'('' gradients'')')
         write(mfgw,'(10f8.3)')(grad(i),i=1,nvar)
         if(slow)then
            write(mfgw,'('' error function'')')
            write(mfgw,'(10f8.3)')(errfn(i),i=1,nvar)
         endif
      endif
      if(debug)
     1write(mfgw,
     +    '('' cosine of search direction ='',f30.6)')cosine
      return
      end
      subroutine mopexc (a,b,c,d,x,y,t,q,n)
      implicit REAL (a-h,o-z)
      dimension x(*), y(*)
c********************************************************************
c
c the contents of a, c, t, and x are stored in b, d, q, and y!
c
c   this is a dedicated routine, it is called by linmin and locmin only.
c
c********************************************************************
      b=a
      d=c
      q=t
      do 10 i=1,n
         y(i)=x(i)
   10 continue
      return
c
      end
      subroutine mopfd(eigval,fx,nvar,dmax,
     1osmin,ts,lrjk,lorjk,rrscal,donr)
c     this version forms geometry step by either pure nr, p-rfo or qa
c     algorithm, under the condition that the steplength is less than dmax
      implicit REAL (a-h,o-z)
      REAL lamda,lamda0
INCLUDE(common/sizes)                                                           
      common /iofile/ mfgr,mfgw
      logical ts,rscal,frodo1,frodo2,lrjk,lorjk,rrscal,donr
      dimension eigval(maxpar),fx(maxpar)                                       
      common/fmatrx/oldf(maxpar),d(maxpar),vmode(maxpar),
     $u(maxpar,maxpar),dd,rmin,rmax,omin,xlamd,xlamd0,skal,
     $mode,nstep,negreq,iprnt
      data zero/0.0d0/, half/0.5d0/, two/2.0d+00/, toll/1.0d-8/         
      data step/5.0d-02/, ten/1.0d+1/, one/1.0d+0/, big/1.0d+3/         
      data four/4.0d+00/
      data tmtwo/1.0d-2/, tmsix/1.0d-06/, sfix/1.0d+01/, eps/1.0d-12/ 
c                                                                       
      maxit=999                                                         
      numit=0                                                           
      skal=one
      rscal=rrscal
      it=0
      jt=1
      if (ts) then
      if(mode.ne.0) then 
      call overlp(dmax,osmin,newmod,nvar,lorjk) 
      if (lorjk) return
c                                                                               
c  on return from overlp, newmod is the ts mode
c                                                                               
      if(newmod.ne.mode .and. iprnt.ge.1) 
     +   write(mfgw,1000) mode,newmod
1000  format(5x,'warning! mode switching. was following mode ',i3,             
     $       ' now following mode ',i3)                                         
      mode=newmod                                                               
      it=mode                                                                   
      else
      it=1
      endif
      eigit=eigval(it)
      if (iprnt.ge.1) then                                                      
         write(mfgw,900)it,eigit
         write(mfgw,910)(u(i,it),i=1,nvar)                                         
900      format(/,5x,'ts mode is number',i3,' with eigenvalue',f9.1,/,          
     *5x,'and components',/)                                                    
910      format(5x,8f9.4)                                                       
      endif                                                                     
      endif
      if (it.eq.1) jt=2
      eone=eigval(jt)                                                    
      ssmin=dmax1(dabs(eone)*eps,(ten*eps))
      ssmax=dmax1(big,dabs(eone))
      ssmax=ssmax*big
      sstoll=toll
      d2max=dmax*dmax                                                   
c     write(mfgw,*)'from mopfd, eone, ssmin, ssmax, sstoll',
c    $eone,ssmin,ssmax,sstoll
      
c  solve iteratively for lamda                                          
c  initial guess for lamda is zero except note that                     
c  lamda should be less than eigval(1)                                  
c  start by bracketing root, then hunt it down with brute force bisect. 
c                                                                       
         frodo1=.false.
         frodo2=.false.
         lamda=zero                                                     
         lamda0=zero
      if (ts .and. eigit.lt.zero .and. eone.ge.zero .and. donr) then
         if (iprnt.ge.1) then
         write(mfgw,*)
     +   ' ts search, correct hessian, trying pure nr step'
         endif
         goto 776
      endif
      if (.not.ts .and. eone.ge.zero .and. donr) then
         if (iprnt.ge.1) then
         write(mfgw,*)
     +   ' min search, correct hessian, trying pure nr step'
         endif
         goto 776
      endif
5     if (ts) then
         lamda0=eigval(it)+dsqrt(eigval(it)**2+four*fx(it)**2)
         lamda0=lamda0*half
         if (iprnt.ge.1)write(mfgw,1030) lamda0 
      endif
         sstep = step                                                          
         if(eone.le.zero) lamda=eone-sstep                              
         if(eone.gt.zero) sstep=eone                                           
         bl = lamda - sstep                                             
         bu = lamda + sstep*half                                        
20       fl = zero                                                      
         fu = zero                                                      
         do 30 i = 1,nvar                                               
            if (i.eq.it) goto 30
            fl   = fl + (fx(i)*fx(i))/(bl-eigval(i))                    
            fu   = fu + (fx(i)*fx(i))/(bu-eigval(i))                    
30       continue                                                       
         fl = fl - bl                                                   
         fu = fu - bu                                                   
c        write(mfgw,*)'bl,bu,fl,fu from brack'                             
c        write(mfgw,668)bl,bu,fl,fu                                        
c668     format(6f20.15)
         if (fl*fu .lt. zero) goto 40                                   
         bl = bl - (eone-bl)                                            
         bu = bu + half*(eone-bu)                                       
         if (bl.le.-ssmax) then
            bl = -ssmax
            frodo1=.true.
         endif
         if (dabs(eone-bu).le.ssmin) then
            bu = eone-ssmin           
            frodo2=.true.
         endif
         if (frodo1.and.frodo2) then              
            write(mfgw,*)'numerical problems in bracketing lamda',
     $                    eone,bl,bu,fl,fu
            write(mfgw,*)' going for fixed step size....'                       
            goto 450                                                           
         endif                                                          
         goto 20                                                        
                                                                        
40       continue                                                       
         ncnt = 0                                                       
         xlamda = zero                                                  
50       continue                                                       
         fl = zero                                                      
         fu = zero                                                      
         fm = zero                                                      
         lamda = half*(bl+bu)                                                  
         do 60 i = 1,nvar                                               
            if (i.eq.it) goto 60
            fl   = fl + (fx(i)*fx(i))/(bl-eigval(i))                    
            fu   = fu + (fx(i)*fx(i))/(bu-eigval(i))                    
            fm   = fm + (fx(i)*fx(i))/(lamda-eigval(i))                 
60       continue                                                       
         fl = fl - bl                                                   
         fu = fu - bu                                                   
         fm = fm - lamda                                                
c        write(mfgw,*)'bl,bu,lamda,fl,fu,fm from search'                   
c        write(mfgw,668)bl,bu,lamda,fl,fu,fm                               
         if (dabs(xlamda-lamda).lt.sstoll) goto 776
         ncnt = ncnt + 1                                                
         if (ncnt.gt.1000) then                                         
            write(mfgw,*)'too many iterations in lamda bisect',
     $                    bl,bu,lamda,fl,fu
_IF(ipsc,tools)
            call pend
_ELSE
            stop
_ENDIF
         endif                                                          
         xlamda = lamda                                                 
         if (fm*fu.lt.zero) bl = lamda                                  
         if (fm*fl.lt.zero) bu = lamda                                  
         goto 50                                                        
c                                                                       
776   if (iprnt.ge.1) write(mfgw,1031) lamda 
c                                                                       
c  calculate the step                                                   
c                                                                       
      do 310 i=1,nvar                                                   
      d(i)=zero                                                         
310   continue                                                          
      do 330 i=1,nvar                                                   
      if (lamda.eq.zero .and. dabs(eigval(i)).lt.tmtwo) then
      temp=zero
      else
      temp=fx(i)/(lamda-eigval(i))                                      
      endif
      if (i.eq.it) then
      temp=fx(it)/(lamda0-eigval(it)) 
      endif
      if (iprnt.ge.5) write(mfgw,*)'mopfd, delta step',i,temp
      do 320 j=1,nvar                                                   
      d(j)=d(j)+temp*u(j,i)                                             
320   continue                                                          
330   continue                                                          
      dd=dsqrt(ddot(nvar,d,1,d,1))
      if(lamda.eq.zero .and. lamda0.eq.zero .and.iprnt.ge.1)
     1 write(mfgw,777)dd
777   format(1x,'pure nr-step has length',f10.5)
      if(lamda.ne.zero .and. lamda0.ne.-lamda .and.iprnt.ge.1) 
     1write(mfgw,778)dd
778   format(1x,'p-rfo-step   has length',f10.5)
      if (dd.lt.(dmax+tmsix)) then
         xlamd=lamda
         xlamd0=lamda0
         return
      endif
      if (lamda.eq.zero .and. lamda0.eq.zero) goto 5
      if (rscal) then
         skal=dmax/dd
         do 160 i=1,nvar
            d(i)=d(i)*skal
160      continue
         dd=dsqrt(ddot(nvar,d,1,d,1))
         if(iprnt.ge.1)write(mfgw,170)skal
170      format(5x,'calculated step size too large, scaled with',f9.5)
         xlamd=lamda
         xlamd0=lamda0
         return
      endif

450      lamda=zero                                                     
         frodo1=.false.
         frodo2=.false.
         sstep = step                                                          
         if(eone.le.zero) lamda=eone-sstep                              
         if (ts .and. -eigit.lt.eone) lamda=-eigit-sstep
         if(eone.gt.zero) sstep=eone                                           
         bl = lamda - sstep                                             
         bu = lamda + sstep*half                                        
520      fl = zero                                                      
         fu = zero                                                      
         do 530 i = 1,nvar                                              
            if (i.eq.it) goto 530
            fl   = fl + (fx(i)/(bl-eigval(i)))**2                       
            fu   = fu + (fx(i)/(bu-eigval(i)))**2                       
530      continue                                                       
         if (ts) then
            fl   = fl + (fx(it)/(bl+eigval(it)))**2                       
            fu   = fu + (fx(it)/(bu+eigval(it)))**2                       
         endif
         fl = fl - d2max                                                
         fu = fu - d2max                                                
c        write(mfgw,*)'bl,bu,fl,fu from brack2'                            
c        write(mfgw,668)bl,bu,fl,fu                                        
         if (fl*fu .lt. zero) goto 540                                  
         bl = bl - (eone-bl)                                            
         bu = bu + half*(eone-bu)                                       
         if (bl.le.-ssmax) then
            bl = -ssmax
            frodo1=.true.
         endif
         if (dabs(eone-bu).le.ssmin) then
            bu = eone-ssmin           
            frodo2=.true.
         endif
         if (frodo1.and.frodo2) then              
            write(mfgw,*)'numerical problems in bracketing lamda',
     $                    eone,bl,bu,fl,fu
            write(mfgw,*)' going for fixed level shifted nr step...'
c           both lamda searches failed, go for fixed level shifted nr    
c           this is unlikely to produce anything useful, but maybe we're lucky
            lamda=eone-sfix                                                    
            lamda0=eigit+sfix
            rscal=.true.                                                
            goto 776                                                    
         endif                                                          
         goto 520                                                       
                                                                        
540      continue                                                       
         ncnt = 0                                                       
         xlamda = zero                                                  
550      continue                                                       
         fl = zero                                                      
         fu = zero                                                      
         fm = zero                                                      
         lamda = half*(bl+bu)                                                  
         do 560 i = 1,nvar                                              
            if (i.eq.it) goto 560
            fl   = fl + (fx(i)/(bl-eigval(i)))**2                       
            fu   = fu + (fx(i)/(bu-eigval(i)))**2                       
            fm   = fm + (fx(i)/(lamda-eigval(i)))**2                    
560      continue                                                       
         if (ts) then
            fl   = fl + (fx(it)/(bl+eigval(it)))**2                       
            fu   = fu + (fx(it)/(bu+eigval(it)))**2                       
            fm   = fm + (fx(it)/(lamda+eigval(it)))**2                    
         endif
         fl = fl - d2max                                                
         fu = fu - d2max                                                
         fm = fm - d2max                                                
c        write(mfgw,*)'bl,bu,lamda,fl,fu,fm from search2'                  
c        write(mfgw,668)bl,bu,lamda,fl,fu,fm                               
         if (dabs(xlamda-lamda).lt.sstoll) goto 570                        
         ncnt = ncnt + 1                                                
         if (ncnt.gt.1000) then                                         
            write(mfgw,*)'too many iterations in lamda bisect',
     $                    bl,bu,lamda,fl,fu
_IF(ipsc,tools)
            call pend
_ELSE
            stop
_ENDIF
         endif                                                          
         xlamda = lamda                                                 
         if (fm*fu.lt.zero) bl = lamda                                  
         if (fm*fl.lt.zero) bu = lamda                                  
         goto 550                                                       
c                                                                       
570      continue                                                       
         lamda0=-lamda
         rscal=.true.                                                   
         goto 776                                                       
c                                                                       
1030  format(1x,'lamda that maximizes along ts modes =   ',f15.5)       
1031  format(1x,'lamda that minimizes along all modes =  ',f15.5)       
      end                                                               
      subroutine mopfr(fmat,numat,mode,shift)
      implicit REAL (a-h,o-z)
      dimension fmat(*), shift(6)
INCLUDE(common/sizes)
      common /coord/coord(3,numatm)
      common /atmass/ atmass(numatm)
      dimension vib(6,maxpar), rot(3,3), coord1(3,numatm)
***********************************************************************
*
*   frame applies an rigid orientation to the molecule in a force
*         calculation. the translations are given a 'force constant'
*         of t(x)=500 millidynes/angstrom
*            t(y)=600 millidynes/angstrom
*            t(z)=700 millidynes/angstrom
*         and the rotations are given a 'force constant' of
*            r(x)=800 millidynes/angstrom
*            r(y)=900 millidynes/angstrom
*            r(z)=1000 millidynes/angstrom,
*    the rotations are made about axes determined by the moments
*    of inertia, which in turn depend on the isotopic masses. for
*    the normal frequency calculation these are the real masses,
*    for the force calculation they are all unity.
***********************************************************************
      common /euler/ tvec(3,3), id
      call axis(coord,numat,a,b,c,sumw, mode,rot )
      do 20 i=1,numat
         do 20 j=1,3
            sum=0.0d0
            do 10 k=1,3
   10       sum=sum+coord(k,i)*rot(k,j)
   20 coord1(j,i)=sum
      n3=numat*3
      j=0
      wtmass=1.d0
      do 30 i=1,numat
         if(mode.eq.1)  wtmass=dsqrt(atmass(i))
         j=j+1
         vib(1,j)=wtmass
         vib(2,j)=0.0d0
         vib(3,j)=0.0d0
         vib(4,j)=0.0d0
         vib(5,j)=coord1(3,i)*wtmass
         vib(6,j)=coord1(2,i)*wtmass
         j=j+1
         vib(1,j)=0.0d0
         vib(2,j)=wtmass
         vib(3,j)=0.0d0
         vib(4,j)=coord1(3,i)*wtmass
         vib(5,j)=0.0d0
         vib(6,j)=-coord1(1,i)*wtmass
         j=j+1
         vib(1,j)=0.0d0
         vib(2,j)=0.0d0
         vib(3,j)=wtmass
         vib(4,j)=-coord1(2,i)*wtmass
         vib(5,j)=-coord1(1,i)*wtmass
         vib(6,j)=0.0d0
   30 continue
      j=1
      do 50 i=1,numat
         do 40 k=4,6
            x=vib(k,j)
            y=vib(k,j+1)
            z=vib(k,j+2)
            vib(k,j  )=x*rot(1,1)+y*rot(1,2)+z*rot(1,3)
            vib(k,j+1)=x*rot(2,1)+y*rot(2,2)+z*rot(2,3)
            vib(k,j+2)=x*rot(3,1)+y*rot(3,2)+z*rot(3,3)
   40    continue
         j=j+3
   50 continue
      sum1=0.0d0
      sum2=0.0d0
      sum3=0.0d0
      sum4=0.0d0
      sum5=0.0d0
      sum6=0.0d0
      do 60 i=1,n3
         sum1=sum1+vib(1,i)**2
         sum2=sum2+vib(2,i)**2
         sum3=sum3+vib(3,i)**2
         sum4=sum4+vib(4,i)**2
         sum5=sum5+vib(5,i)**2
   60 sum6=sum6+vib(6,i)**2
      if(sum1.gt.1.d-5)sum1=dsqrt(1.d0/sum1)
      if(sum2.gt.1.d-5)sum2=dsqrt(1.d0/sum2)
      if(sum3.gt.1.d-5)sum3=dsqrt(1.d0/sum3)
      if(sum4.gt.1.d-5)sum4=dsqrt(1.d0/sum4)
      if(sum5.gt.1.d-5)sum5=dsqrt(1.d0/sum5)
      if(sum6.gt.1.d-5)sum6=dsqrt(1.d0/sum6)
      if(id.ne.0)then
         sum4=0.0d0
         sum5=0.0d0
         sum6=0.0d0
      endif
      do 70 i=1,n3
         vib(1,i)=vib(1,i)*sum1
         vib(2,i)=vib(2,i)*sum2
         vib(3,i)=vib(3,i)*sum3
         vib(4,i)=vib(4,i)*sum4
         vib(5,i)=vib(5,i)*sum5
   70 vib(6,i)=vib(6,i)*sum6
      do 80 i=1,6
   80 shift(i)=400.d0+i*100.d0
      l=0
      do 100 i=1,n3
         do 100 j=1,i
            l=l+1
            sum1=0.0d0
            do 90 k=1,6
   90       sum1=sum1+vib(k,i)*shift(k)*vib(k,j)
  100 fmat(l)=fmat(l)+sum1
      end
      subroutine mopg
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
************************************************************************
*
*  grid calculates the energy-surface resulting from variation of
*       two coordinates. the step-size is step1 and step2, and a 11
*       by 11 grid of points is generated
*
*         this routine is extensively modified by manyin yi, aug 1989.
*
*         new features:
*      1. the input geometry definition should always be the upper-left
*           corner(smallest coordinates) instead of the middle point;
*        2. the starting point for calculation can be one of the four
*           corners by setting "+/-" step1/2;
*        3. the grid size(max 23*23) is controlled by point1/2,
*           if point1/2 is omitted, then a size of 11*11 is assumed;
*           kwd max sets the max size;
*        4. the upper-left corner of the plotting grid always corresponds
*           to the smallest coordinates, the lower-right corner to the
*           largest, no matter where the calculation starts;
*        5. restartable.
*       6. write out unimap irregular data ump.dat
*
************************************************************************
      common /cmpg/ geo(3,numatm)
      common /geovar/ nvar,loc(2,maxpar), idumy, xparam(maxpar)
      common /gradnt/ grad(maxpar),gnorm
      common /gravec/ cosine
      common /mesh  / latom1, lpara1, latom2, lpara2
      common /gparam/ currt1,currt2
      common /ijlp  / ijlp, ilp, jlp, jlp1, ione
      common /surf  / surf
      common /keywrd/ keywrd
      common /titles/ koment, title
      character keywrd*241, koment*81, title*81, getmop*80
      logical restrt
      dimension gd(maxpar),xlast(maxpar),mdfp(20),xdfp(20)
      dimension surfac(23,23)
      dimension surf(23*23)
      dimension umpx(23),umpy(23),umpz(23*23)
c
      step1=reada(keywrd,index(keywrd,'step1')+6)
      step2=reada(keywrd,index(keywrd,'step2')+6)
      npts1=11
      npts2=11
      if (index(keywrd,' max').ne.0) then
         npts1=23
         npts2=23
         goto 10
      endif
      if (index(keywrd,'point1').ne.0)
     1 npts1=dabs(reada(keywrd,index(keywrd,'point1')+7))
      if (index(keywrd,'point2').ne.0)
     1 npts2=dabs(reada(keywrd,index(keywrd,'point2')+7))
   10 restrt=(index(keywrd,'restart').ne.0)
c
c  the top-left value of the first and second dimensions are
c      geo(lpara1,latom1) and geo(lpara2,latom2)
c
      umpy(1)=geo(lpara1,latom1)
      umpx(1)=geo(lpara2,latom2)
      degree=180.d0/3.14159265359d0
      if(lpara1.ne.1)step1=step1/degree
      if(lpara2.ne.1)step2=step2/degree
c
c  now set the starting point to the desired corner
c
      if(step1.gt.0.0d0.and.step2.gt.0.0d0) then
         start1=geo(lpara1,latom1)
         start2=geo(lpara2,latom2)
      endif
c bottom-left
      if(step1.lt.0.0d0.and.step2.gt.0.0d0)then
         start1=geo(lpara1,latom1)+(npts1-1)*(dabs(step1))
         start2=geo(lpara2,latom2)
      endif
c top-right
      if(step1.gt.0.0d0.and.step2.lt.0.0d0)then
         start1=geo(lpara1,latom1)
         start2=geo(lpara2,latom2)+dabs((npts2-1)*step2)
      endif
c bottom-right
      if(step1.lt.0.0d0.and.step2.lt.0.0d0)then
         start1=geo(lpara1,latom1)+dabs((npts1-1)*step1)
         start2=geo(lpara2,latom2)+dabs((npts2-1)*step2)
      endif
c
c  now to sweep through the grid of points left to right then right
c  to left or visa versa. this should avoid the geometry or scf getting
c  messed up.
c
      if(lpara1.ne.1) then
         c1=degree
      else
         c1=1.d0
      endif
      if(lpara2.ne.1) then
         c2=degree
      else
         c2=1.d0
      endif
c   these parameters need to be dumped in '.res'
      currt1=start1
      currt2=start2
      ione=-1.d0
      cputot=0.0d0
      ijlp=0
      ilp=1
      jlp=1
      jlp1=1
      surf(1)=0.0d0
c
      if (restrt) then
         mdfp(9)=0
         call dfpsav(cputot,xparam,gd,xlast,escf,mdfp,xdfp)
      endif
c
      geo(lpara1,latom1)=currt1
      geo(lpara2,latom2)=currt2
      do 30 iloop=ilp,npts1
         ione=-ione
         do 20 jloop=jlp,npts2
            jloop1=0
            if(ione.lt.0)jloop1=npts2+1
            if(restrt) then
               jloop1=jlp1
               ione=-ione
               restrt=.false.
            else
               jloop1=jloop1+ione
               jlp1=jloop1
            endif
            cpu1=secmop()
            currt1=geo(lpara1,latom1)
            currt2=geo(lpara2,latom2)
            call flepo(xparam, nvar, escf)
            cpu2=secmop()
            cpu3=cpu2-cpu1
            cputot=cputot+cpu3
            jlp=jlp+1
            ijlp=ijlp+1
            surf(ijlp)=escf
            write(mfgw,
     +      '(/''       first variable   second variable function'')')
            write(mfgw,
     +      '('' :'',f16.5,f16.5,f16.6)')geo(lpara1,latom1)*c1,
     1        geo(lpara2,latom2)*c2,escf
            call geout(mfgw)
            geo(lpara2,latom2)=geo(lpara2,latom2)+step2*ione
   20    continue
         geo(lpara1,latom1)=geo(lpara1,latom1)+step1
         geo(lpara2,latom2)=geo(lpara2,latom2)-step2*ione
         ilp=ilp+1
         jlp=1
   30 continue
      write(mfgw,'(/10x,''horizontal: varying second parameter,'',
     1          /10x,''vertical:   varying first parameter'')')
      write(mfgw,
     +    '(/10x,''whole of grid, suitable for plotting'',//)')
c
c  archive
      open(unit=12,file=getmop(6),status='unknown')
      open(unit=20,file=getmop(9),status='new',err=31)
      goto 32
  31  open(unit=20,file=getmop(9),status='old')
  32  continue
      write(12,40)
      call wrttxt(12)
   40 format(' archive file for grid calculation'/'grid of heats'/)
      write(12,'(/'' total cpu time in flepo : '',f10.3/)') cputot
c
c  write out the grids
      ione=1.d0
      iloop=1
      jloop1=1
      do 50 ij=1,npts1*npts2
         surfac(jloop1,iloop)=surf(ij)
         n=ij-(ij/npts2)*npts2
         if (n.eq.0) then
            iloop=iloop+1
            jloop1=jloop1+ione
            ione=-ione
         endif
         jloop1=jloop1+ione
   50 continue
c
      do 60 i=2,npts1
   60 umpy(i)=umpy(1)+(i-1)*dabs(step1)
      do 70 i=2,npts2
   70 umpx(i)=umpx(1)+(i-1)*dabs(step2)
      n=0
      if(step1.gt.0.0d0.and.step2.gt.0.0d0) then
         do 90 i=1,npts1
            do 80 j=1,npts2
               n=n+1
   80       umpz(n)=surfac(j,i)
            write(mfgw,'(11f7.2)')(surfac(j,i),j=1,npts2)
   90    write(12,'(11f7.2)')(surfac(j,i),j=1,npts2)
      endif
      if(step1.lt.0.0d0.and.step2.gt.0.0d0) then
         do 110 i=npts1,1,-1
            do 100 j=1,npts2
               n=n+1
  100       umpz(n)=surfac(j,i)
            write(mfgw,'(11f7.2)')(surfac(j,i),j=1,npts2)
  110    write(12,'(11f7.2)')(surfac(j,i),j=1,npts2)
      endif
      if(step1.gt.0.0d0.and.step2.lt.0.0d0) then
         do 130 i=1,npts1
            do 120 j=npts2,1,-1
               n=n+1
  120       umpz(n)=surfac(j,i)
            write(mfgw,'(11f7.2)')(surfac(j,i),j=npts2,1,-1)
  130    write(12,'(11f7.2)')(surfac(j,i),j=npts2,1,-1)
      endif
      if(step1.lt.0.0d0.and.step2.lt.0.0d0) then
         do 150 i=npts1,1,-1
            do 140 j=npts2,1,-1
               n=n+1
  140       umpz(n)=surfac(j,i)
            write(mfgw,'(11f7.2)')(surfac(j,i),j=npts2,1,-1)
  150    write(12,'(11f7.2)')(surfac(j,i),j=npts2,1,-1)
      endif
      do 160 i=0,npts1-1
         do 160 j=1,npts2
            n=i*npts2+j
  160 write(20,'(3(1x,f8.3))')umpx(j),umpy(i+1),umpz(n)
      close(20)
      end
c
      subroutine mophc (coord,h,w, wj,wk,enuclr)
      implicit REAL (a-h,o-z)
      logical fldon
INCLUDE(common/sizes)
      common /iofile/ mfgr,mfgw
      dimension coord(3,*),h(*), wj(n2elec), wk(n2elec), w(n2elec)
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),
     1                nlast(numatm), norbs, nelecs,nalpha,nbeta,
     2                nclose,nopen,ndumy,fract
      common /molorb/ uspd(maxorb),dumy(maxorb)
      common /keywrd/ keywrd
      common /euler/ tvec(3,3), id
      common /multip/ dd(107),qq(107),am(107),ad(107),aq(107)
      common /corec/ core(107)
      common /cmpfd/ efield(3)
      common /numcal/ numcal
c     patas
      common /mstpo/ hq(mpack),ezq,eeq
      common /mstq/ qs(1500),mflag
      common /mstxyz/ xq(3575),yq(3575),zq(3575),nqs
      common /jiali/ mmflag
c     patas
c cosmo change
      logical iseps, useps, upda
      common /iseps/  iseps, useps, upda
c end of cosmo change
************************************************************************
c
c   mophc generates the one-electron matrix and two electron integrals
c         for a given molecule whose geometry is defined in cartesian
c         coordinates.
c
c  on input  coord   = coordinates of the molecule.
c
c  on output  h      = one-electron matrix.
c             w      = two-electron integrals.
c             enuclr = nuclear energy
c
c  mophc also computes the perturbation operator in miertus-scrocco-
c  tomasi solvation model, which is added to h to form the final one
c  electron matrix
c
************************************************************************
      character*241 keywrd, tmpkey
      logical first,debug
      save first, ione, cutoff, debug
      dimension e1b(10),e2a(10),di(9,9), wjd(100), wkd(100)
c     patas
      dimension cc(3,1500)
c     patas
      save icalcn
      data icalcn/0/
      first=(icalcn.ne.numcal)
      icalcn=numcal
      if (first) then
         ione=1
         cutoff=1.d10
         if(id.ne.0)cutoff=60.d0
         if(id.ne.0)ione=0
         debug=(index(keywrd,'hcore') .ne. 0)
*******************************************************************
         xf=0.0d0
         yf=0.0d0
         zf=0.0d0
         tmpkey=keywrd
         i=index(tmpkey,' field(')
         if(i.eq.0) goto 6 
c
c   erase all text from tmpkey except field data
c
         tmpkey(:i)=' '
         tmpkey(index(tmpkey,')'):)=' '
c
c   read in the effective field in x,y,z coordinates
c
         xf=reada(tmpkey,i)
         i=index(tmpkey,',')
         if(i.eq.0) goto 5 
         tmpkey(i:i)=' '
         yf=reada(tmpkey,i)
         i=index(tmpkey,',')
         if(i.eq.0) goto 5 
         tmpkey(i:i)=' '
         zf=reada(tmpkey,i)
    5    continue
         write(mfgw,
     +   '(/10x,''the electric field is'',3f10.5)')xf,yf,zf
         write(mfgw,
     +   '(10x,''in 8*a.u. (8*27.21/0.529 volts/angstrom)'',/)')
    6    continue
         efield(1)=xf
         efield(2)=yf
         efield(3)=zf
c**********************************************************************
      endif
      fldon = .false.
      if ((efield(1).ne.0.0d00).or.(efield(2).ne.0.0d00).or.
     1    (efield(3).ne.0.0d00)) then
         fldcon = 51.4257d00
         fldon = .true.
      endif
      do 10 i=1,(norbs*(norbs+1))/2
c     patas
      hq(i)=0.0d0
c     patas
   10 h(i)=0.0d0
      enuclr=0.0d0
c     patas
      ezq=0.0d0
      eeq=0.0d0
c     patas
      kr=1
      do 110 i=1,numat
         ia=nfirst(i)
         ib=nlast(i)
         ic=nmidle(i)
         ni=nat(i)
c
c first we fill the diagonals, and off-diagonals on the same atom
c
         do 30 i1=ia,ib
            i2=i1*(i1-1)/2+ia-1
            do 20 j1=ia,i1
               i2=i2+1
               h(i2)=0.0d0
c     patas
               hq(i2)=0.0d0
c     patas
               if (fldon) then
                  io1 = i1 - ia
                  jo1 = j1 - ia
                  if ((jo1.eq.0).and.(io1.eq.1)) then
                     hterme = -0.529177d00*dd(ni)*efield(1)*fldcon
                     h(i2) = hterme
                  endif
                  if ((jo1.eq.0).and.(io1.eq.2)) then
                     hterme = -0.529177d00*dd(ni)*efield(2)*fldcon
                     h(i2) = hterme
                  endif
                  if ((jo1.eq.0).and.(io1.eq.3)) then
                     hterme = -0.529177d00*dd(ni)*efield(3)*fldcon
                     h(i2) = hterme
                  endif
               endif
   20       continue
            h(i2) = uspd(i1)
            if (fldon) then
               fnuc = -(efield(1)*coord(1,i) + efield(2)*coord(2,i) +
     1              efield(3)*coord(3,i))*fldcon
               h(i2) = h(i2) + fnuc
            endif
   30    continue
c
c   fill the atom-other atom one-electron matrix<psi(lambda)|psi(sigma)>
c
         im1=i-ione
         do 100 j=1,im1
            half=1.d0
            if(i.eq.j)half=0.5d0
            ja=nfirst(j)
            jb=nlast(j)
            jc=nmidle(j)
            nj=nat(j)
            call h1elec(ni,nj,coord(1,i),coord(1,j),di)
            i2=0
            do 40 i1=ia,ib
               ii=i1*(i1-1)/2+ja-1
               i2=i2+1
               j2=0
               jj=min(i1,jb)
               do 40 j1=ja,jj
                  ii=ii+1
                  j2=j2+1
   40       h(ii)=h(ii)+di(i2,j2)
c
c   calculate the two-electron integrals, w; the electron nuclear terms
c   e1b and e2a; and the nuclear-nuclear term enuc.
c
            if(id.eq.0) then
               call moprat(ni,nj,coord(1,i),coord(1,j),
     1 w(kr), kr,e1b,e2a,enuc,cutoff)
            else
               kro=kr
               call solrot(ni,nj,coord(1,i),coord(1,j),
     1                wjd, wkd,kr,e1b,e2a,enuc,cutoff)
               jj=0
               do 50 ii=kro,kr-1
                  jj=jj+1
                  wj(ii)=wjd(jj)
   50          wk(ii)=wkd(jj)
            endif
            enuclr = enuclr + enuc
c
c   add on the electron-nuclear attraction term for atom i.
c
            i2=0
            do 60 i1=ia,ic
               ii=i1*(i1-1)/2+ia-1
               do 60 j1=ia,i1
                  ii=ii+1
                  i2=i2+1
   60       h(ii)=h(ii)+e1b(i2)*half
            do  70 i1=ic+1,ib
               ii=(i1*(i1+1))/2
   70       h(ii)=h(ii)+e1b(1)*half
c
c   add on the electron-nuclear attraction term for atom j.
c
            i2=0
            do 80 i1=ja,jc
               ii=i1*(i1-1)/2+ja-1
               do 80 j1=ja,i1
                  ii=ii+1
                  i2=i2+1
   80       h(ii)=h(ii)+e2a(i2)*half
            do 90 i1=jc+1,jb
               ii=(i1*(i1+1))/2
   90       h(ii)=h(ii)+e2a(1)*half
  100    continue
  110 continue
c cosmo change
c a. klamt 16.7.91
      if (useps) then
c the following routine adds the dielectric correction for the electron-core
c interaction to the diagonal elements of h
         call addhcr (h)
c in the following routine the dielectric correction to the core-core-
c interaction is added to enuclr
         call addnuc (enuclr)
      endif
c end of cosmo change
      if( .not. debug) go to 300
      write(mfgw,'(//10x,''one-electron matrix from mophc'')')
      call vecprt(h,norbs)
      j=min(400,kr)
      if(id.eq.0) then
         write(mfgw,'(//10x,''two-electron matrix in mophc''/)')
         write(mfgw,120)(w(i),i=1,j)
      else
         write(mfgw,'(//10x,''two-electron j matrix in mophc''/)')
         write(mfgw,120)(wj(i),i=1,j)
         write(mfgw,'(//10x,''two-electron k matrix in mophc''/)')
         write(mfgw,120)(wk(i),i=1,j)
      endif
  120 format(10f8.4)
c     return
c     end
c     patas
c
c     add perturbation operator in mst solvation model
c
300   continue
      if (mflag.ge.6) return
      if (index(keywrd,'tom').ne.0.and.(mflag.eq.1.or.mflag.eq.4)) then
      mflag=mflag+1
c
c     mflag=2 or 5
c
      limit=(norbs*(norbs+1))/2
      do 320 i=1,numat
      ia=nfirst(i)
      ib=nlast(i)
      ic=nmidle(i)
      ni=nat(i)
      do 330 j=1,nqs
        cc(1,j)=xq(j)/1.8897626d0
        cc(2,j)=yq(j)/1.8897626d0
        cc(3,j)=zq(j)/1.8897626d0
        nj=j
        call moprat(ni,nj,coord(1,i),cc(1,j),
     +              w(kr),kr,e1b,e2a,enuc,cutoff)
        ezq=ezq+enuc
        i2=0
        do 340 i1=ia,ic
          ii=i1*(i1-1)/2+ia-1
          do 340 j1=ia,i1
            ii=ii+1
            i2=i2+1
            hq(ii)=hq(ii)+e1b(i2)
            h(ii)=h(ii)+e1b(i2)
  340 continue
        do 350 i1=ic+1,ib
        ii=(i1*(i1+1))/2
        hq(ii)=hq(ii)+e1b(1)
        h(ii)=h(ii)+e1b(1)
  350 continue
  330 continue
  320 continue
      mflag=mflag-1
c
c     mflag=1 or 4
c
      enuclr=enuclr+ezq
      if( .not. debug) return
      write(mfgw,'(//10x,''final one-electron matrix from mophc'')')
      call vecprt(h,norbs)
      write(mfgw,'(//10x,''one-electron perturbation matrix'')')
      call vecprt(hq,norbs)
      end if
c     patas
      return
      end
      subroutine mophes(svec,tvec,nvar,iupd)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      common /iofile/ mfgr,mfgw
      dimension tvec(*),svec(*)
      logical first
      common /fmatrx/ oldf(maxpar),d(maxpar),vmode(maxpar),
     $u(maxpar,maxpar),dd,rmin,rmax,omin,xlamd,xlamd0,skal,
     $mode,nstep,negreq,iprnt
convex      common /nllcom/ hess(maxpar,maxpar*3)
      common /nllcom/ hess(maxpar,maxpar)
      common /gradnt/ grad(maxpar),gnfina
c
      save first
      data first/.false./
c
      data zero/0.0d0/
c
c  updating of the hessian
c  depends on current gradients, old gradients and the
c  correction vector used on the last cycle
c  svec & tvec are for temporary storage
c
c  2 updating procedures are possible
c  (i)   the powell update
c        this preserves the symmetric character of the hessian
c        whilst allowing its eigenvalue structure to change.
c        it is the default update for a transition state search
c  (ii)  the bfgs update
c        this update has the important characteristic of retaining
c        positive definiteness (note: this is not rigorously
c        guaranteed, but can be checked for by the program).
c        it is the default update for a minimum search
c
c     switch : iupd
c       iupd = 0  :  skip update
c       iupd = 1  :  powell
c       iupd = 2  :  bfgs
c
      if (.not. first) then
         first=.true.
         if(iprnt.ge.2) then
            if (iupd.eq.0)write(mfgw,90)
            if (iupd.eq.1)write(mfgw,80)
            if (iupd.eq.2)write(mfgw,120)
         endif
      endif
      if(iupd.eq.0) return
convex      do 10 i=1,nvar
convex         tvec(i)=zero
convex         do 10 j=1,nvar
convex            tvec(i)=tvec(i) + hess(i,j)*d(j)
convex   10 continue
      do 5 i=1,nvar
         tvec(i)=zero
 5    continue
      do 10 j=1,nvar
         do 10 i=1,nvar
            tvec(i)=tvec(i) + hess(i,j)*d(j)
   10 continue
c
      if(iupd.eq.1) then
c
c   (i) powell update
c
         do 20 i=1,nvar
            tvec(i)=grad(i)-oldf(i)-tvec(i)
            svec(i)=grad(i)-oldf(i)
   20    continue
         dds=dd*dd
         ddtd=ddot(nvar,tvec,1,d,1)
         ddtd=ddtd/dds
c
convex         do 40 i=1,nvar
convex            do 30 j=1,i
convex               temp=tvec(i)*d(j) + d(i)*tvec(j) - d(i)*ddtd*d(j)
convex               hess(i,j)=hess(i,j)+temp/dds
convex               hess(j,i)=hess(i,j)
convex   30       continue
convex   40    continue
         do 40 i=2,nvar
c$dir no_recurrence
            do 30 j=1,i-1
               temp=tvec(i)*d(j) + d(i)*tvec(j) - d(i)*ddtd*d(j)
               hess(i,j)=hess(i,j)+temp/dds
               hess(j,i)=hess(i,j)
   30       continue
   40    continue
         do 45 i=1,nvar
            temp=d(i)*(2.0d0*tvec(i) - d(i)*ddtd)
            hess(i,i)=hess(i,i)+temp/dds
 45      continue
c
      endif
      if (iupd.eq.2) then
c
c  (ii) bfgs update
c
         do 50 i=1,nvar
            svec(i)=grad(i)-oldf(i)
   50    continue
         dds=ddot(nvar,svec,1,d,1)
c
c  if dds is negative, retention of positive definiteness is not
c  guaranteed. print a warning and skip update this cycle.
c
cfrj with the current level shift technique i think the hessian should
cfrj be allowed to aquire negative eigenvalues. without updating the
cfrj optimization has the potential of stalling
cfrj     if(dds.lt.zero) then
cfrj        write(mfgw,100)
cfrj        write(mfgw,110)
cfrj        return
cfrj     endif
c
         ddtd=ddot(nvar,d,1,tvec,1)
c
convex         do 70 i=1,nvar
convex            do 60 j=1,i
convex               temp= (svec(i)*svec(j))/dds - (tvec(i)*tvec(j))/ddtd
convex               hess(i,j)=hess(i,j)+temp
convex               hess(j,i)=hess(i,j)
convex   60       continue
convex   70    continue
         do 70 i=2,nvar
c$dir no_recurrence
            do 60 j=1,i-1
               temp= (svec(i)*svec(j))/dds - (tvec(i)*tvec(j))/ddtd
               hess(i,j)=hess(i,j)+temp
               hess(j,i)=hess(i,j)
   60       continue
   70    continue
         do 75 i=1,nvar
            temp= (svec(i)*svec(i))/dds - (tvec(i)*tvec(i))/ddtd
            hess(i,i)=hess(i,i)+temp
 75      continue
      endif
c
      return
c
   80 format(/,5x,'hessian is being updated using the powell update',/)
   90 format(/,5x,'hessian is not being updated',/)
c 100 format(5x,'warning! hereditary positive definiteness endangered')
c 110 format(5x,'update skipped this cycle')
  120 format(/,5x,'hessian is being updated using the bfgs update',/)
      end
      subroutine mopi(cp, cf, nelec, nmos, dijkl)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      dimension cp(norbs,nmos), cf(norbs,norbs),
     1dijkl(norbs,nmos,(nmos*(nmos+1))/2)
************************************************************************
*
*   mopi fills the xy array.  xy holds the two-electron integrals over
*        molecular orbitals in the active space.
*        xy(i,j,k,l) = <ij|1/r(1,2)|kl>
*
*           on input
*
* cp     = m.o.'s over c.i. active space (normally 1 to 5 m.o.s)
* cf     = all m.o.'s, including those in cp
* norbs  = number of atomic orbitals
* nelec  = number of occupied m.o.s not involved in the c.i.
* nmos   = number of m.o.s involved in the c.i. (normally 1 to 5 m.o.s)
*          also called the active space of the c.i.
*
*  note: this routine is unusual in that one function is to
*        fill the array xy which is not passed as an argument,
*        instead it is passed via common block xyijkl.
*
************************************************************************
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),
     1                nlast(numatm), norbs, nelecs,nalpha,nbeta,
     2                nclose,nopen,ndumy,fract
      common /vector/ dumy1(morb2+maxorb), cij(10*maxorb),
     1wcij(10*maxorb), dumy(morb2-19*maxorb)
      common /xyijkl/ xy(nmeci,nmeci,nmeci,nmeci)
      dimension ckl(10*maxorb)
      dimension nb(0:8)
      equivalence (ckl, cij)
      data nb /1,0,0,10,0,0,0,0,45/
c
c  calculate two-electron integrals for the set dijkl(k,l,ij)
c  the index k runs over all m.o.'s, l over active-space m.o.'s,
c  and ij over lower-half triangle of active-space m.o.'s, j faster than
c  i.
c  all active-space interactions are copied into the array xy
c
      ij=0
      do 70 i=1,nmos
         do 70 j=1,i
            ij=ij+1
            ipq=0
            do 10 ii=1,numat
               do 10 ip=nfirst(ii),nlast(ii)
                  do 10 iq=nfirst(ii),ip
                     ipq=ipq+1
   10       cij(ipq)=cp(ip,i)*cp(iq,j)+cp(ip,j)*cp(iq,i)
c
c  cij holds the density distribution psi(i)*psi(j) over atomic bases
c  i and j are m.o. indices within the active space.  cij(m,n) is for
c  the atomic bases m and n for m.o.'s i and j.
c
            call partxy (cij,wcij)
c
c wcij holds the ket part of the integral <k,l|1/r(1,2)|i,j>
c that is, |1/r(1,2)|i,j>.  wcij(m,n) is for the atomic bases m and n
c for m.o.'s k and l.
c
   20       continue
            do 60 k=1,norbs
               do 50 l=1,nmos
c
c  about to calculate <i,j|1/r(1,2)|k,l>
c
                  ipq=0
                  do 30 ii=1,numat
                     do 30 ip=nfirst(ii),nlast(ii)
                        do 30 iq=nfirst(ii),ip
                           ipq=ipq+1
   30             ckl(ipq)=cf(ip,k)*cp(iq,l)+cp(ip,l)*cf(iq,k)
c
c ckl holds the density distribution psi(k)*psi(l) over atomic bases.
c k is the index of a m.o.; l is an index of a m.o. in the active space.
c
                  sum=0.0d0
                  do 40 ii=1,ipq
   40             sum=sum+ckl(ii)*wcij(ii)
c
c  sum is the integral <i,j|1/r(1,2)|k,l>
c
                  dijkl(k,l,ij)=sum
   50          continue
   60       continue
   70 continue
c
c  now spread the integrals over the xy array.  xy is entirely
c  in active space
c
      do 80 k=1,nmos
         kk=nelec+k
c
c  k is a m.o. index in active space
c kk is a m.o. index
c
         do 80 l=1,nmos
            ij=0
            do 80 i=1,nmos
               do 80 j=1,i
                  ij=ij+1
                  sum=dijkl(kk,l,ij)
                  xy(i,j,k,l)=sum
                  xy(i,j,l,k)=sum
                  xy(j,i,k,l)=sum
                  xy(j,i,l,k)=sum
                  xy(k,l,i,j)=sum
                  xy(k,l,j,i)=sum
                  xy(l,k,i,j)=sum
   80 continue
      return
      end
      subroutine moplo(c,mdim,nocc,eig)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      common /iofile/ mfgr,mfgw
      dimension c(mdim,mdim), eig(maxorb)
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),
     1                nlast(numatm), norbs, nelecs,nalpha,nbeta,
     2                nclose,nopen,ndumy,fract
c**********************************************************************
c
c   localisation subroutine
c on input
c        c = eigenvectors in an mdim*mdim matrix
c        nocc = number of filled levels
c        norbs = number of orbitals
c        numat = number of atoms
c        nlast   = integer array of atom orbital counters
c        nfirst   = integer array of atom orbital counters
c
c       routine maximizes (psi)**4
c       reference_
c       a new rapid method for orbital localisation, p.g. perkins and
c       j.j.p. stewart, j.c.s. faraday (ii) 77, 000, (1981).
c
c       modified and corrected to avoid sigma-pi orbital mixing by
c       juan carlos paniagua, university of barcelona, may 1983.
c
c**********************************************************************
      common /scrach/ 
     +        cold(maxorb,maxorb),xdumy(maxpar**2-maxorb*maxorb)
      dimension eig1(maxorb),psi1(maxorb),psi2(maxorb),
     1          cii(maxorb), refeig(maxorb),iel(20)
      save elemnt
      character*2 elemnt(99)
      data elemnt/'h','he',
     1 'li','be','b','c','n','o','f','ne',
     2 'na','mg','al','si','p','s','cl','ar',
     3 'k','ca','sc','ti','v','cr','mn','fe','co','ni','cu',
     4 'zn','ga','ge','as','se','br','kr',
     5 'rb','sr','y','zr','nb','mo','tc','ru','rh','pd','ag',
     6 'cd','in','sn','sb','te','i','xe',
     7 'cs','ba','la','ce','pr','nd','pm','sm','eu','gd','tb','dy',
     8 'ho','er','tm','yb','lu','hf','ta','w','re','os','ir','pt',
     9 'au','hg','tl','pb','bi','po','at','rn',
     1 'fr','ra','ac','th','pa','u','np','pu','am','cm','bk','cf','xx'/
      niter=100
      eps=1.0d-7
      do 10 i=1,norbs
         refeig(i)=eig(i)
         do 10 j=1,norbs
   10 cold(i,j)=c(i,j)
      iter=0
   20 continue
      sum=0.0d0
      iter=iter+1
      do 80 i=1,nocc
         do 70 j=1,nocc
            if(j.eq.i) goto 70
            xijjj=0.0d0
            xjiii=0.0d0
            xiiii=0.0d0
            xjjjj=0.0d0
            xijij=0.0d0
            xiijj=0.0d0
            do 30 k=1,norbs
               psi1(k)=c(k,i)
   30       psi2(k)=c(k,j)
c now follows the rate-determining step for the calculation
            do 50 k1=1,numat
               kl=nfirst(k1)
               ku=nlast(k1)
               dij=0.0d0
               dii=0.0d0
               djj=0.0d0
c$doit asis
               do 40 k=kl,ku
                  dij=dij+psi1(k)*psi2(k)
                  dii=dii+psi1(k)*psi1(k)
                  djj=djj+psi2(k)*psi2(k)
   40          continue
               xijjj=xijjj+dij*djj
               xjiii=xjiii+dij*dii
               xiiii=xiiii+dii*dii
               xjjjj=xjjjj+djj*djj
               xijij=xijij+dij*dij
               xiijj=xiijj+dii*djj
   50       continue
            aij=xijij-(xiiii+xjjjj-2.0d0*xiijj)/4.0d0
            bij=xjiii-xijjj
            ca=dsqrt(aij*aij+bij*bij)
            sa=aij+ca
            if(sa.lt.1.0d-14) go to 70
            sum=sum+sa
            ca=-aij/ca
            ca=(1.0d0+dsqrt((1.0d0+ca)/2.0d0))/2.0d0
            if((2.0d0*ca-1.0d0)*bij.lt.0.0d0)ca=1.0d0-ca
            sa=dsqrt(1.0d0-ca)
            ca=dsqrt(ca)
            do 60 k=1,norbs
               c(k,i)=ca*psi1(k)+sa*psi2(k)
   60       c(k,j)=-sa*psi1(k)+ca*psi2(k)
   70    continue
   80 continue
      sum1=0.0d0
      do 100 i=1,nocc
         do 100 j=1,numat
            il=nfirst(j)
            iu=nlast(j)
            x=0.0d0
c$doit asis
            do 90 k=il,iu
   90       x=x+c(k,i)**2
  100 sum1=sum1+x*x
      if(sum.gt.eps.and.iter.lt.niter) go to 20
      write(mfgw,110)iter,sum1
  110 format(/10x,'number of iterations =',i4/
     110x,'localisation value =',f14.9,/)
      write(mfgw,120)
  120 format(3x,'number of centers',14x,'(composition of orbitals)'//)
      do 150 i=1,nocc
         sum=0.0d0
         do 140 j=1,nocc
            co=0.0d0
            do 130 k=1,norbs
  130       co=co+cold(k,j)*c(k,i)
  140    sum=sum+co*co*eig(j)
  150 eig1(i)=sum
      do 180 i=1,nocc
         x=100.d0
         do 160 j=i,nocc
            if (x.lt.eig1(j))  goto  160
            x=eig1(j)
            i1=j
  160    continue
         eig(i)=eig1(i1)
         x=eig1(i1)
         eig1(i1)=eig1(i)
         eig1(i)=x
         do 170 j=1,norbs
            x=c(j,i1)
            c(j,i1)=c(j,i)
  170    c(j,i)=x
  180 continue
      do 250 i=1,nocc
         x=0.0d0
         do 200 k1=1,numat
            kl=nfirst(k1)
            ku=nlast(k1)
            dii=0.0d0
            do 190 k=kl,ku
  190       dii=dii+c(k,i)**2
            x=x+dii*dii
  200    psi1(k1)=dii*100.d0
         x=1/x
         do 220 ii=1,numat
            sum=0.0d0
            do 210 j=1,numat
               if(psi1(j).lt.sum) goto 210
               sum=psi1(j)
               k=j
  210       continue
            psi1(k)=0.0d0
            cii(ii)=sum
            iel(ii)=k
            if(sum.lt.1.d0) goto 230
  220    continue
  230    continue
         ii=ii-1
         write(mfgw,240)x,(elemnt(nat(iel(k))),iel(k),cii(k),k=1,ii)
  240    format(f10.4,4(5(3x,a2,i3,f6.2),/10x))
  250 continue
  260 format(//20x,20h localized orbitals   ,//)
      write(mfgw,260)
      call mopmat(c,eig,nocc,norbs,mdim)
  270 format(10f12.6)
      do 280 i=1,nocc
         eig(i)=refeig(i)
         do 280 j=1,norbs
  280 c(j,i)=cold(j,i)
      return
      end
      subroutine moprat(ni,nj,xi,xj,w,kr,e1b,e2a,enuc,cutoff)
      implicit REAL (a-h,o-z)
c     patas
INCLUDE(common/sizes)
c     patas
c***********************************************************************
c
c..improved scalar version
c..written by ernest r. davidson, indiana university.
c
c
c   rotate calculates the two-particle interactions.
c
c   on input  ni     = atomic number of first atom.
c             nj     = atomic number of second atom.
c             xi     = coordinate of first atom.
c             xj     = coordinate of second atom.
c
c on output w      = array of two-electron repulsion integrals.
c           e1b,e2a= array of electron-nuclear attraction integrals,
c                    e1b = electron on atom ni attracting nucleus of nj.
c           enuc   = nuclear-nuclear repulsion term.
c
c
c *** this routine computes the repulsion and nuclear attraction
c     integrals over molecular-frame coordinates.  the integrals over
c     local frame coordinates are evaluated by subroutine repp and
c     stored as follows (where p-sigma = o,   and p-pi = p and p* )
c     in ri
c     (ss/ss)=1,   (so/ss)=2,   (oo/ss)=3,   (pp/ss)=4,   (ss/os)=5,
c     (so/so)=6,   (sp/sp)=7,   (oo/so)=8,   (pp/so)=9,   (po/sp)=10,
c     (ss/oo)=11,  (ss/pp)=12,  (so/oo)=13,  (so/pp)=14,  (sp/op)=15,
c     (oo/oo)=16,  (pp/oo)=17,  (oo/pp)=18,  (pp/pp)=19,  (po/po)=20,
c     (pp/p*p*)=21,   (p*p/p*p)=22.
c
c***********************************************************************
      common /numcal/ numcal
      save analyt, icalcn
      common /molmec/ htype(4),nhco(4,20),nnhco,itype
      character*241 keywrd
      logical si,sj, analyt
      common /cmporb/ natorb(107)
      common /twoel3/ f03(107)
      common /alpha3/ alp3(153)
      common /alpha/ alp(107)
      common /corec/ tore(107)
      common /ideas/ fn1(107,10),fn2(107,10),fn3(107,10)
      common /alptm/ alptm(30), emudtm(30)
      common /rotdum/ css1,csp1,cpps1,cppp1,css2,csp2,cpps2,cppp2
      common /rotdu2/ x(3),y(3),z(3)
      common /keywrd/ keywrd
c     patas
      common /mstq/ qs(1500),mflag
c     patas
      dimension xi(3),xj(3),w(100),e1b(10),e2a(10)
      dimension ri(22),ccore(4,2), boron1(3,4), boron2(3,4), boron3(3,4)
      equivalence (ccore(1,1),css1)
      data icalcn/0/
      data boron1/  0.182613d0,  0.118587d0, -0.073280d0,
     1              0.412253d0, -0.149917d0,  0.000000d0,
     2              0.261751d0,  0.050275d0,  0.000000d0,
     3              0.359244d0,  0.074729d0,  0.000000d0/
      data boron2/  6.d0,  6.d0,  5.d0,
     1             10.d0,  6.d0,  0.d0,
     2              8.d0,  5.d0,  0.d0,
     3              9.d0,  9.d0,  0.d0/
      data boron3/  0.727592d0,  1.466639d0,  1.570975d0,
     1              0.832586d0,  1.186220d0,  0.000000d0,
     2              1.063995d0,  1.936492d0,  0.000000d0,
     3              0.819351d0,  1.574414d0,  0.000000d0/
c
      if(icalcn.ne.numcal)then
         icalcn=numcal
         analyt=(index(keywrd,'analyt') .ne. 0)
         if(analyt)then
            open(unit=2,status='scratch',form='unformatted')
            rewind 2
         endif
      endif
c
      x(1)=xi(1)-xj(1)
      x(2)=xi(2)-xj(2)
      x(3)=xi(3)-xj(3)
      rij=x(1)*x(1)+x(2)*x(2)+x(3)*x(3)
      if (rij.lt.0.00002d0) then
c
c     small rij case
c
         do 10 i=1,10
            e1b(i)=0.0d0
            e2a(i)=0.0d0
   10    continue
         w(kr)=0.0d0
         enuc=0.0d0
c
      else if (itype.eq.4) then
c
c     mindo case
c
         sum=14.399d0/dsqrt(rij+(7.1995d0/f03(ni)+7.1995d0/f03(nj))**2)
         w(1)=sum
         kr=kr+1
         do 20 l=1,10
            e1b(l)=0.0d0
            e2a(l)=0.0d0
   20    continue
         e1b(1) = -sum*tore(nj)
         e1b(3) = e1b(1)
         e1b(6) = e1b(1)
         e1b(10)= e1b(1)
         e2a(1) = -sum*tore(ni)
         e2a(3) = e2a(1)
         e2a(6) = e2a(1)
         e2a(10)= e2a(1)
         ii = max(ni,nj)
         nbond = (ii*(ii-1))/2+ni+nj-ii
         rij = dsqrt(rij)
         if(nbond.lt.154) then
            if(nbond.eq.22 .or. nbond .eq. 29) then
c              nbond = 22 is c-h case
c              nbond = 29 is n-h case
               scale=alp3(nbond)*dexp(-rij)
            else
c              nbond < 154  is ni < 18 and nj < 18 case
               scale=dexp(-alp3(nbond)*rij)
            endif
         else
c              nbond > 154 involves ni or nj > 18
            scale = 0
            if(natorb(ni).eq.0) scale=      dexp(-alp(ni)*rij)
            if(natorb(nj).eq.0) scale=scale+dexp(-alp(ni)*rij)
         endif
         if (dabs(tore(ni)).gt.20.d0 .and.dabs(tore(nj)).gt.20.d0) 
     +                 then
            enuc=0.0d0
         else if (rij.lt.1.d0 .and. natorb(ni)*natorb(nj).eq.0) then
            enuc=0.0d0
         else
            enuc = tore(ni)*tore(nj)*sum
     1       +dabs(tore(ni)*tore(nj)*(14.399d0/rij-sum)*scale)
         endif
c
c     mndo and am1 cases
c
c *** the repulsion integrals over molecular frame (w) are stored in the
c     order in which they will later be used.  ie.  (i,j/k,l) where
c     j.le.i  and  l.le.k     and l varies most rapidly and i least
c     rapidly.  (anti-normal computer storage)
c
      else
c
         rijx = dsqrt(rij)
         rij = dmin1(rijx,cutoff)
c
c *** compute integrals in diatomic frame
c
         call reppp(ni,nj,rij,ri,ccore)
         if(analyt)write(2)(ri(i),i=1,22)
c
         gam = ri(1)
         a=1.d0/rijx
         x(1) = x(1)*a
         x(2) = x(2)*a
         x(3) = x(3)*a
         if (dabs(x(3)).gt.0.99999999d0) then
            x(3) = dsign(1.d0,x(3))
            y(1) = 0.d0
            y(2) = 1.d0
            y(3) = 0.d0
            z(1) = 1.d0
            z(2) = 0.d0
            z(3) = 0.d0
         else
            z(3)=dsqrt(1.d0-x(3)*x(3))
            a=1.d0/z(3)
            y(1)=-a*x(2)*dsign(1.d0,x(1))
            y(2)=dabs(a*x(1))
            y(3)=0.0d0
            z(1)=-a*x(1)*x(3)
            z(2)=-a*x(2)*x(3)
         endif
c     patas
      if (index(keywrd,'tom').ne.0.and.(mflag.eq.2.or.
     1mflag.eq.5)) then
         e1b(1)=-css1
         if(natorb(ni).eq.4) then
            e1b(2) = -csp1 *x(1)
            e1b(3) = -cpps1*x(1)*x(1)-cppp1*(y(1)*y(1)+z(1)*z(1))
            e1b(4) = -csp1 *x(2)
            e1b(5) = -cpps1*x(2)*x(1)-cppp1*(y(2)*y(1)+z(2)*z(1))
            e1b(6) = -cpps1*x(2)*x(2)-cppp1*(y(2)*y(2)+z(2)*z(2))
            e1b(7) = -csp1 *x(3)
            e1b(8) = -cpps1*x(3)*x(1)-cppp1*z(3)*z(1)
            e1b(9) = -cpps1*x(3)*x(2)-cppp1*z(3)*z(2)
            e1b(10)= -cpps1*x(3)*x(3)-cppp1*z(3)*z(3)
         endif
c
c     compute nuclei-charge repulsion energy for mst model
c
      enuc=14.399d0*tore(ni)*qs(nj)/rij
      return
      end if
c     patas
         si = (natorb(ni).gt.1)
         sj = (natorb(nj).gt.1)
         if ( si .or. sj) then
            xx11 = x(1)*x(1)
            xx21 = x(2)*x(1)
            xx22 = x(2)*x(2)
            xx31 = x(3)*x(1)
            xx32 = x(3)*x(2)
            xx33 = x(3)*x(3)
            yy11 = y(1)*y(1)
            yy21 = y(2)*y(1)
            yy22 = y(2)*y(2)
            zz11 = z(1)*z(1)
            zz21 = z(2)*z(1)
            zz22 = z(2)*z(2)
            zz31 = z(3)*z(1)
            zz32 = z(3)*z(2)
            zz33 = z(3)*z(3)
            yyzz11 = yy11+zz11
            yyzz21 = yy21+zz21
            yyzz22 = yy22+zz22
            xy11 = 2.d0*x(1)*y(1)
            xy21 =      x(1)*y(2)+x(2)*y(1)
            xy22 = 2.d0*x(2)*y(2)
            xy31 =      x(3)*y(1)
            xy32 =      x(3)*y(2)
            xz11 = 2.d0*x(1)*z(1)
            xz21 =      x(1)*z(2)+x(2)*z(1)
            xz22 = 2.d0*x(2)*z(2)
            xz31 =      x(1)*z(3)+x(3)*z(1)
            xz32 =      x(2)*z(3)+x(3)*z(2)
            xz33 = 2.d0*x(3)*z(3)
            yz11 = 2.d0*y(1)*z(1)
            yz21 =      y(1)*z(2)+y(2)*z(1)
            yz22 = 2.d0*y(2)*z(2)
            yz31 =      y(1)*z(3)
            yz32 =      y(2)*z(3)
         endif
c
c     (s s/s s)
         w(1)=ri(1)
         ki = 1
         if (sj) then
c     (s s/px s)
            w(2)=ri(5)*x(1)
c     (s s/px px)
            w(3)=ri(11)*xx11+ri(12)*yyzz11
c     (s s/py s)
            w(4)=ri(5)*x(2)
c     (s s/py px)
            w(5)=ri(11)*xx21+ri(12)*yyzz21
c     (s s/py py)
            w(6)=ri(11)*xx22+ri(12)*yyzz22
c     (s s/pz s)
            w(7)=ri(5)*x(3)
c     (s s/pz px)
            w(8)=ri(11)*xx31+ri(12)*zz31
c     (s s/pz py)
            w(9)=ri(11)*xx32+ri(12)*zz32
c     (s s/pz pz)
            w(10)=ri(11)*xx33+ri(12)*zz33
            ki = 10
         endif
c
         if (si) then
c     (px s/s s)
            w(11)=ri(2)*x(1)
            if (sj) then
c     (px s/px s)
               w(12)=ri(6)*xx11+ri(7)*yyzz11
c     (px s/px px)
               w(13)=x(1)*(ri(13)*xx11+ri(14)*yyzz11)
     1           +ri(15)*(y(1)*xy11+z(1)*xz11)
c     (px s/py s)
               w(14)=ri(6)*xx21+ri(7)*yyzz21
c     (px s/py px)
               w(15)=x(1)*(ri(13)*xx21+ri(14)*yyzz21)
     1           +ri(15)*(y(1)*xy21+z(1)*xz21)
c     (px s/py py)
               w(16)=x(1)*(ri(13)*xx22+ri(14)*yyzz22)
     1           +ri(15)*(y(1)*xy22+z(1)*xz22)
c     (px s/pz s)
               w(17)=ri(6)*xx31+ri(7)*zz31
c     (px s/pz px)
               w(18)=x(1)*(ri(13)*xx31+ri(14)*zz31)
     1           +ri(15)*(y(1)*xy31+z(1)*xz31)
c     (px s/pz py)
               w(19)=x(1)*(ri(13)*xx32+ri(14)*zz32)
     1           +ri(15)*(y(1)*xy32+z(1)*xz32)
c     (px s/pz pz)
               w(20)=x(1)*(ri(13)*xx33+ri(14)*zz33)
     1           +ri(15)*(          z(1)*xz33)
c     (px px/s s)
               w(21)=ri(3)*xx11+ri(4)*yyzz11
c     (px px/px s)
               w(22)=x(1)*(ri(8)*xx11+ri(9)*yyzz11)
     1           +ri(10)*(y(1)*xy11+z(1)*xz11)
c     (px px/px px)
               w(23) =
     1     (ri(16)*xx11+ri(17)*yyzz11)*xx11+ri(18)*xx11*yyzz11
     2     +ri(19)*(yy11*yy11+zz11*zz11)
     3     +ri(20)*(xy11*xy11+xz11*xz11)
     4     +ri(21)*(yy11*zz11+zz11*yy11)
     5     +ri(22)*yz11*yz11
c     (px px/py s)
               w(24)=x(2)*(ri(8)*xx11+ri(9)*yyzz11)
     1           +ri(10)*(y(2)*xy11+z(2)*xz11)
c     (px px/py px)
               w(25) =
     1     (ri(16)*xx11+ri(17)*yyzz11)*xx21+ri(18)*xx11*yyzz21
     2     +ri(19)*(yy11*yy21+zz11*zz21)
     3     +ri(20)*(xy11*xy21+xz11*xz21)
     4     +ri(21)*(yy11*zz21+zz11*yy21)
     5     +ri(22)*yz11*yz21
c     (px px/py py)
               w(26) =
     1     (ri(16)*xx11+ri(17)*yyzz11)*xx22+ri(18)*xx11*yyzz22
     2     +ri(19)*(yy11*yy22+zz11*zz22)
     3     +ri(20)*(xy11*xy22+xz11*xz22)
     4     +ri(21)*(yy11*zz22+zz11*yy22)
     5     +ri(22)*yz11*yz22
c     (px px/pz s)
               w(27)=x(3)*(ri(8)*xx11+ri(9)*yyzz11)
     1           +ri(10)*(         +z(3)*xz11)
c     (px px/pz px)
               w(28) =
     1      (ri(16)*xx11+ri(17)*yyzz11)*xx31
     2     +(ri(18)*xx11+ri(19)*zz11+ri(21)*yy11)*zz31
     3     +ri(20)*(xy11*xy31+xz11*xz31)
     4     +ri(22)*yz11*yz31
c     (px px/pz py)
               w(29) =
     1      (ri(16)*xx11+ri(17)*yyzz11)*xx32
     2     +(ri(18)*xx11+ri(19)*zz11+ri(21)*yy11)*zz32
     3     +ri(20)*(xy11*xy32+xz11*xz32)
     4     +ri(22)*yz11*yz32
c     (px px/pz pz)
               w(30) =
     1      (ri(16)*xx11+ri(17)*yyzz11)*xx33
     2     +(ri(18)*xx11+ri(19)*zz11+ri(21)*yy11)*zz33
     3     +ri(20)*xz11*xz33
c     (py s/s s)
               w(31)=ri(2)*x(2)
c     (py s/px s)
               w(32)=ri(6)*xx21+ri(7)*yyzz21
c     (py s/px px)
               w(33)=x(2)*(ri(13)*xx11+ri(14)*yyzz11)
     1           +ri(15)*(y(2)*xy11+z(2)*xz11)
c     (py s/py s)
               w(34)=ri(6)*xx22+ri(7)*yyzz22
c     (py s/py px)
               w(35)=x(2)*(ri(13)*xx21+ri(14)*yyzz21)
     1           +ri(15)*(y(2)*xy21+z(2)*xz21)
c     (py s/py py)
               w(36)=x(2)*(ri(13)*xx22+ri(14)*yyzz22)
     1           +ri(15)*(y(2)*xy22+z(2)*xz22)
c     (py s/pz s)
               w(37)=ri(6)*xx32+ri(7)*zz32
c     (py s/pz px)
               w(38)=x(2)*(ri(13)*xx31+ri(14)*zz31)
     1           +ri(15)*(y(2)*xy31+z(2)*xz31)
c     (py s/pz py)
               w(39)=x(2)*(ri(13)*xx32+ri(14)*zz32)
     1           +ri(15)*(y(2)*xy32+z(2)*xz32)
c     (py s/pz pz)
               w(40)=x(2)*(ri(13)*xx33+ri(14)*zz33)
     1           +ri(15)*(         +z(2)*xz33)
c     (py px/s s)
               w(41)=ri(3)*xx21+ri(4)*yyzz21
c     (py px/px s)
               w(42)=x(1)*(ri(8)*xx21+ri(9)*yyzz21)
     1           +ri(10)*(y(1)*xy21+z(1)*xz21)
c     (py px/px px)
               w(43) =
     1     (ri(16)*xx21+ri(17)*yyzz21)*xx11+ri(18)*xx21*yyzz11
     2     +ri(19)*(yy21*yy11+zz21*zz11)
     3     +ri(20)*(xy21*xy11+xz21*xz11)
     4     +ri(21)*(yy21*zz11+zz21*yy11)
     5     +ri(22)*yz21*yz11
c     (py px/py s)
               w(44)=x(2)*(ri(8)*xx21+ri(9)*yyzz21)
     1           +ri(10)*(y(2)*xy21+z(2)*xz21)
c     (py px/py px)
               w(45) =
     1     (ri(16)*xx21+ri(17)*yyzz21)*xx21+ri(18)*xx21*yyzz21
     2     +ri(19)*(yy21*yy21+zz21*zz21)
     3     +ri(20)*(xy21*xy21+xz21*xz21)
     4     +ri(21)*(yy21*zz21+zz21*yy21)
     5     +ri(22)*yz21*yz21
c     (py px/py py)
               w(46) =
     1     (ri(16)*xx21+ri(17)*yyzz21)*xx22+ri(18)*xx21*yyzz22
     2     +ri(19)*(yy21*yy22+zz21*zz22)
     3     +ri(20)*(xy21*xy22+xz21*xz22)
     4     +ri(21)*(yy21*zz22+zz21*yy22)
     5     +ri(22)*yz21*yz22
c     (py px/pz s)
               w(47)=x(3)*(ri(8)*xx21+ri(9)*yyzz21)
     1           +ri(10)*(         +z(3)*xz21)
c      (py px/pz px)
               w(48) =
     1     (ri(16)*xx21+ri(17)*yyzz21)*xx31
     2     +(ri(18)*xx21+ri(19)*zz21+ri(21)*yy21)*zz31
     3     +ri(20)*(xy21*xy31+xz21*xz31)
     4     +ri(22)*yz21*yz31
c      (py px/pz py)
               w(49) =
     1     (ri(16)*xx21+ri(17)*yyzz21)*xx32
     2     +(ri(18)*xx21+ri(19)*zz21+ri(21)*yy21)*zz32
     3     +ri(20)*(xy21*xy32+xz21*xz32)
     4     +ri(22)*yz21*yz32
c      (py px/pz pz)
               w(50) =
     1     (ri(16)*xx21+ri(17)*yyzz21)*xx33
     2     +(ri(18)*xx21+ri(19)*zz21+ri(21)*yy21)*zz33
     3     +ri(20)*xz21*xz33
c     (py py/s s)
               w(51)=ri(3)*xx22+ri(4)*yyzz22
c     (py py/px s)
               w(52)=x(1)*(ri(8)*xx22+ri(9)*yyzz22)
     1           +ri(10)*(y(1)*xy22+z(1)*xz22)
c      (py py/px px)
               w(53) =
     1     (ri(16)*xx22+ri(17)*yyzz22)*xx11+ri(18)*xx22*yyzz11
     2     +ri(19)*(yy22*yy11+zz22*zz11)
     3     +ri(20)*(xy22*xy11+xz22*xz11)
     4     +ri(21)*(yy22*zz11+zz22*yy11)
     5     +ri(22)*yz22*yz11
c     (py py/py s)
               w(54)=x(2)*(ri(8)*xx22+ri(9)*yyzz22)
     1           +ri(10)*(y(2)*xy22+z(2)*xz22)
c      (py py/py px)
               w(55) =
     1     (ri(16)*xx22+ri(17)*yyzz22)*xx21+ri(18)*xx22*yyzz21
     2     +ri(19)*(yy22*yy21+zz22*zz21)
     3     +ri(20)*(xy22*xy21+xz22*xz21)
     4     +ri(21)*(yy22*zz21+zz22*yy21)
     5     +ri(22)*yz22*yz21
c      (py py/py py)
               w(56) =
     1     (ri(16)*xx22+ri(17)*yyzz22)*xx22+ri(18)*xx22*yyzz22
     2     +ri(19)*(yy22*yy22+zz22*zz22)
     3     +ri(20)*(xy22*xy22+xz22*xz22)
     4     +ri(21)*(yy22*zz22+zz22*yy22)
     5     +ri(22)*yz22*yz22
c     (py py/pz s)
               w(57)=x(3)*(ri(8)*xx22+ri(9)*yyzz22)
     1           +ri(10)*(         +z(3)*xz22)
c      (py py/pz px)
               w(58) =
     1     (ri(16)*xx22+ri(17)*yyzz22)*xx31
     2     +(ri(18)*xx22+ri(19)*zz22+ri(21)*yy22)*zz31
     3     +ri(20)*(xy22*xy31+xz22*xz31)
     4     +ri(22)*yz22*yz31
c      (py py/pz py)
               w(59) =
     1     (ri(16)*xx22+ri(17)*yyzz22)*xx32
     2     +(ri(18)*xx22+ri(19)*zz22+ri(21)*yy22)*zz32
     3     +ri(20)*(xy22*xy32+xz22*xz32)
     4     +ri(22)*yz22*yz32
c      (py py/pz pz)
               w(60) =
     1     (ri(16)*xx22+ri(17)*yyzz22)*xx33
     2     +(ri(18)*xx22+ri(19)*zz22+ri(21)*yy22)*zz33
     3     +ri(20)*xz22*xz33
c     (pz s/ss)
               w(61)=ri(2)*x(3)
c     (pz s/px s)
               w(62)=ri(6)*xx31+ri(7)*zz31
c     (pz s/px px)
               w(63)=x(3)*(ri(13)*xx11+ri(14)*yyzz11)
     1           +ri(15)*(         +z(3)*xz11)
c     (pz s/py s)
               w(64)=ri(6)*xx32+ri(7)*zz32
c     (pz s/py px)
               w(65)=x(3)*(ri(13)*xx21+ri(14)*yyzz21)
     1           +ri(15)*(         +z(3)*xz21)
c     (pz s/py py)
               w(66)=x(3)*(ri(13)*xx22+ri(14)*yyzz22)
     1           +ri(15)*(         +z(3)*xz22)
c     (pz s/pz s)
               w(67)=ri(6)*xx33+ri(7)*zz33
c     (pz s/pz px)
               w(68)=x(3)*(ri(13)*xx31+ri(14)*zz31)
     1           +ri(15)*(         +z(3)*xz31)
c     (pz s/pz py)
               w(69)=x(3)*(ri(13)*xx32+ri(14)*zz32)
     1           +ri(15)*(         +z(3)*xz32)
c     (pz s/pz pz)
               w(70)=x(3)*(ri(13)*xx33+ri(14)*zz33)
     1           +ri(15)*(         +z(3)*xz33)
c     (pz px/s s)
               w(71)=ri(3)*xx31+ri(4)*zz31
c     (pz px/px s)
               w(72)=x(1)*(ri(8)*xx31+ri(9)*zz31)
     1           +ri(10)*(y(1)*xy31+z(1)*xz31)
c      (pz px/px px)
               w(73) =
     1     (ri(16)*xx31+ri(17)*zz31)*xx11+ri(18)*xx31*yyzz11
     2     +ri(19)*zz31*zz11
     3     +ri(20)*(xy31*xy11+xz31*xz11)
     4     +ri(21)*zz31*yy11
     5     +ri(22)*yz31*yz11
c     (pz px/py s)
               w(74)=x(2)*(ri(8)*xx31+ri(9)*zz31)
     1           +ri(10)*(y(2)*xy31+z(2)*xz31)
c      (pz px/py px)
               w(75) =
     1     (ri(16)*xx31+ri(17)*zz31)*xx21+ri(18)*xx31*yyzz21
     2     +ri(19)*zz31*zz21
     3     +ri(20)*(xy31*xy21+xz31*xz21)
     4     +ri(21)*zz31*yy21
     5     +ri(22)*yz31*yz21
c      (pz px/py py)
               w(76) =
     1     (ri(16)*xx31+ri(17)*zz31)*xx22+ri(18)*xx31*yyzz22
     2     +ri(19)*zz31*zz22
     3     +ri(20)*(xy31*xy22+xz31*xz22)
     4     +ri(21)*zz31*yy22
     5     +ri(22)*yz31*yz22
c     (pz px/pz s)
               w(77)=x(3)*(ri(8)*xx31+ri(9)*zz31)
     1           +ri(10)*(         +z(3)*xz31)
c     (pz px/pz px)
               w(78) =
     1      (ri(16)*xx31+ri(17)*zz31)*xx31
     2     +(ri(18)*xx31+ri(19)*zz31)*zz31
     3     +ri(20)*(xy31*xy31+xz31*xz31)
     4     +ri(22)*yz31*yz31
c      (pz px/pz py)
               w(79) =
     1      (ri(16)*xx31+ri(17)*zz31)*xx32
     2     +(ri(18)*xx31+ri(19)*zz31)*zz32
     3     +ri(20)*(xy31*xy32+xz31*xz32)
     4     +ri(22)*yz31*yz32
c      (pz px/pz pz)
               w(80) =
     1      (ri(16)*xx31+ri(17)*zz31)*xx33
     2     +(ri(18)*xx31+ri(19)*zz31)*zz33
     3     +ri(20)*xz31*xz33
c     (pz py/s s)
               w(81)=ri(3)*xx32+ri(4)*zz32
c     (pz py/px s)
               w(82)=x(1)*(ri(8)*xx32+ri(9)*zz32)
     1           +ri(10)*(y(1)*xy32+z(1)*xz32)
c      (pz py/px px)
               w(83) =
     1     (ri(16)*xx32+ri(17)*zz32)*xx11+ri(18)*xx32*yyzz11
     2     +ri(19)*zz32*zz11
     3     +ri(20)*(xy32*xy11+xz32*xz11)
     4     +ri(21)*zz32*yy11
     5     +ri(22)*yz32*yz11
c     (pz py/py s)
               w(84)=x(2)*(ri(8)*xx32+ri(9)*zz32)
     1           +ri(10)*(y(2)*xy32+z(2)*xz32)
c      (pz py/py px)
               w(85) =
     1     (ri(16)*xx32+ri(17)*zz32)*xx21+ri(18)*xx32*yyzz21
     2     +ri(19)*zz32*zz21
     3     +ri(20)*(xy32*xy21+xz32*xz21)
     4     +ri(21)*zz32*yy21
     5     +ri(22)*yz32*yz21
c      (pz py/py py)
               w(86) =
     1     (ri(16)*xx32+ri(17)*zz32)*xx22+ri(18)*xx32*yyzz22
     2     +ri(19)*zz32*zz22
     3     +ri(20)*(xy32*xy22+xz32*xz22)
     4     +ri(21)*zz32*yy22
     5     +ri(22)*yz32*yz22
c     (pz py/pz s)
               w(87)=x(3)*(ri(8)*xx32+ri(9)*zz32)
     1           +ri(10)*(         +z(3)*xz32)
c      (pz py/pz px)
               w(88) =
     1      (ri(16)*xx32+ri(17)*zz32)*xx31
     2     +(ri(18)*xx32+ri(19)*zz32)*zz31
     3     +ri(20)*(xy32*xy31+xz32*xz31)
     4     +ri(22)*yz32*yz31
c      (pz py/pz py)
               w(89) =
     1      (ri(16)*xx32+ri(17)*zz32)*xx32
     2     +(ri(18)*xx32+ri(19)*zz32)*zz32
     3     +ri(20)*(xy32*xy32+xz32*xz32)
     4     +ri(22)*yz32*yz32
c       (pz py/pz pz)
               w(90) =
     1      (ri(16)*xx32+ri(17)*zz32)*xx33
     2     +(ri(18)*xx32+ri(19)*zz32)*zz33
     3     +ri(20)*xz32*xz33
c     (pz pz/s s)
               w(91)=ri(3)*xx33+ri(4)*zz33
c     (pz pz/px s)
               w(92)=x(1)*(ri(8)*xx33+ri(9)*zz33)
     1           +ri(10)*(          z(1)*xz33)
c       (pz pz/px px)
               w(93) =
     1     (ri(16)*xx33+ri(17)*zz33)*xx11+ri(18)*xx33*yyzz11
     2     +ri(19)*zz33*zz11
     3     +ri(20)*xz33*xz11
     4     +ri(21)*zz33*yy11
c     (pz pz/py s)
               w(94)=x(2)*(ri(8)*xx33+ri(9)*zz33)
     1           +ri(10)*(         +z(2)*xz33)
c       (pz pz/py px)
               w(95) =
     1     (ri(16)*xx33+ri(17)*zz33)*xx21+ri(18)*xx33*yyzz21
     2     +ri(19)*zz33*zz21
     3     +ri(20)*xz33*xz21
     4     +ri(21)*zz33*yy21
c       (pz pz/py py)
               w(96) =
     1     (ri(16)*xx33+ri(17)*zz33)*xx22+ri(18)*xx33*yyzz22
     2     +ri(19)*zz33*zz22
     3     +ri(20)*xz33*xz22
     4     +ri(21)*zz33*yy22
c     (pz pz/pz s)
               w(97)=x(3)*(ri(8)*xx33+ri(9)*zz33)
     1           +ri(10)*(         +z(3)*xz33)
c       (pz pz/pz px)
               w(98) =
     1      (ri(16)*xx33+ri(17)*zz33)*xx31
     2     +(ri(18)*xx33+ri(19)*zz33)*zz31
     3     +ri(20)*xz33*xz31
c       (pz pz/pz py)
               w(99) =
     1      (ri(16)*xx33+ri(17)*zz33)*xx32
     2     +(ri(18)*xx33+ri(19)*zz33)*zz32
     3     +ri(20)*xz33*xz32
c       (pz pz/pz pz)
               w(100) =
     1      (ri(16)*xx33+ri(17)*zz33)*xx33
     2     +(ri(18)*xx33+ri(19)*zz33)*zz33
     3     +ri(20)*xz33*xz33
               ki = 100
            else
c     (px s/s s)
               w(2)=ri(2)*x(1)
c     (px px/s s)
               w(3)=ri(3)*xx11+ri(4)*yyzz11
c     (py s/s s)
               w(4)=ri(2)*x(2)
c     (py px/s s)
               w(5)=ri(3)*xx21+ri(4)*yyzz21
c     (py py/s s)
               w(6)=ri(3)*xx22+ri(4)*yyzz22
c     (pz s/ss)
               w(7)=ri(2)*x(3)
c     (pz px/s s)
               w(8)=ri(3)*xx31+ri(4)*zz31
c     (pz py/s s)
               w(9)=ri(3)*xx32+ri(4)*zz32
c     (pz pz/s s)
               w(10)=ri(3)*xx33+ri(4)*zz33
               ki = 10
            end if
         end if
c
c *** now rotate the nuclear attraction integrals.
c *** the storage of the nuclear attraction integrals  core(kl/ij) is
c     (ss/)=1,   (so/)=2,   (oo/)=3,   (pp/)=4
c
         e1b(1)=-css1
         if(natorb(ni).eq.4) then
            e1b(2) = -csp1 *x(1)
            e1b(3) = -cpps1*xx11-cppp1*yyzz11
            e1b(4) = -csp1 *x(2)
            e1b(5) = -cpps1*xx21-cppp1*yyzz21
            e1b(6) = -cpps1*xx22-cppp1*yyzz22
            e1b(7) = -csp1 *x(3)
            e1b(8) = -cpps1*xx31-cppp1*zz31
            e1b(9) = -cpps1*xx32-cppp1*zz32
            e1b(10)= -cpps1*xx33-cppp1*zz33
         end if
         e2a(1)=-css2
         if(natorb(nj).eq.4) then
            e2a(2) = -csp2 *x(1)
            e2a(3) = -cpps2*xx11-cppp2*yyzz11
            e2a(4) = -csp2 *x(2)
            e2a(5) = -cpps2*xx21-cppp2*yyzz21
            e2a(6) = -cpps2*xx22-cppp2*yyzz22
            e2a(7) = -csp2 *x(3)
            e2a(8) = -cpps2*xx31-cppp2*zz31
            e2a(9) = -cpps2*xx32-cppp2*zz32
            e2a(10)= -cpps2*xx33-cppp2*zz33
         end if
         if(dabs(tore(ni)).gt.20.d0.and.dabs(tore(nj)).gt.20.d0) then
c sparkle-sparkle interaction
            enuc=0.0d0
            return
         elseif (rij.lt.1.d0.and.natorb(ni)*natorb(nj).eq.0) then
            enuc=0.0d0
            return
         endif
         scale = dexp(-alp(ni)*rij)+dexp(-alp(nj)*rij)
c
         if (ni.eq.24.and.nj.eq.24) then
            scale = dexp(-alptm(ni)*rij)+dexp(-alptm(nj)*rij)
         endif
c
         nt=ni+nj
         if(nt.eq.8.or.nt.eq.9) then
            if(ni.eq.7.or.ni.eq.8) scale=scale+(rij-1.d0)*
     +         dexp(-alp(ni)*rij)
            if(nj.eq.7.or.nj.eq.8) scale=scale+(rij-1.d0)*
     +         dexp(-alp(nj)*rij)
         endif
         enuc = tore(ni)*tore(nj)*gam
         scale=dabs(scale*enuc)
         if(itype.eq.2.and.(ni.eq.5.or.nj.eq.5))then
c
c   load in am1 boron gaussians
c
            nk=ni+nj-5
c   nk is the atomic number of the non-boron atom
            nl=1
            if(nk.eq.1)nl=2
            if(nk.eq.6)nl=3
            if(nk.eq.9.or.nk.eq.17.or.nk.eq.35.or.nk.eq.53)nl=4
            do 30 i=1,3
               fn1(5,i)=boron1(i,nl)
               fn2(5,i)=boron2(i,nl)
   30       fn3(5,i)=boron3(i,nl)
         endif
         if(itype.eq.2.or.itype.eq.3) then
            do 40 ig=1,10
               if(dabs(fn1(ni,ig)).gt.0.d0) then
                  ax = fn2(ni,ig)*(rij-fn3(ni,ig))**2
                  if(ax .le. 25.d0) then
                     scale=scale +tore(ni)*tore(nj)/rij*fn1(ni,ig)*
     +               dexp(-ax)
                  endif
               endif
               if(dabs(fn1(nj,ig)).gt.0.d0) then
                  ax = fn2(nj,ig)*(rij-fn3(nj,ig))**2
                  if(ax .le. 25.d0) then
                     scale=scale +tore(ni)*tore(nj)/rij*fn1(nj,ig)*
     +               dexp(-ax)
                  endif
               endif
   40       continue
         endif
         enuc=enuc+scale
c
         if(natorb(ni)*natorb(nj).eq.0)ki=0
         kr=kr+ki
c
c
      endif
      return
      end
      subroutine moprdm(ostop)
      implicit REAL (a-h, o-z)
INCLUDE(common/sizes)
INCLUDE(../m4/common/jinfo)
      common /iofile/ mfgr,mfgw
_IF(ipsc,tools)
      logical ostop,oroot
_ELSE
      logical ostop
_ENDIF
c
c module to read in geometry file, output it to the user,
c and check the data to see if it is reasonable.
c exit if necessary.
c
c
c
c  on exit natoms    = number of atoms plus dummy atoms (if any).
c          keywrd    = keywords to control calculation
c          koment    = comment card
c          title     = title card
c          labels    = array of atomic labels including dummy atoms.
c          geo       = array of internal coordinates.
c          lopt      = flags for optimization of molecule
c          na        = array of labels of atoms, bond lengths.
c          nb        = array of labels of atoms, bond angles.
c          nc        = array of labels of atoms, dihedral angles.
c          latom     = label of atom of reaction coordinate.
c          lparam    = rc: 1 for length, 2 for angle, and 3 for dihedral
c          react(200)= reaction coordinate parameters
c          loc(1,i)  = label of atom to be optimized.
c          loc(2,i)  = 1 for length, 2 for angle, and 3 for dihedral.
c          nvar      = number of parameters to be optimized.
c          xparam    = starting value of parameters to be optimized.
c
************************************************************************
c *** input the trial geometry  \ie.  kgeom=0\
c   label(i) = the atomic number of atom\i\.
c            = 99, then the i-th atom is a dummy atom used only to
c              simplify the definition of the molecular geometry.
c   geo(1,i) = the internuclear separation \in angstroms\ between atoms
c              na(i) and (i).
c   geo(2,i) = the angle nb(i):na(i):(i) input in degrees; stored in
c              radians.
c   geo(3,i) = the angle between the vectors nc(i):nb(i) and na(i):(i)
c              input in degrees - stored in radians.
c  lopt(j,i) = -1 if geo(j,i) is the reaction coordinate.
c            = +1 if geo(j,i) is a parameter to be optimized
c            =  0 otherwise.
c *** note:    much of this data is not included for the first 3 atoms.
c     atom1  input labels(1) only.
c     atom2  input labels(2) and geo(1,2) separation between atoms 1+2
c     atom3  input labels(3), geo(1,3)    separation between atoms 2+3
c              and geo(2,3)              angle atom1 : atom2 : atom3
c
************************************************************************
c
      dimension lopt(3,numatm)
      character keywrd*241, koment*81, title*81, line*80, banner*80
      character keys(80)*1, space*1, space2*2, ch*1, ch2*2
      character elemnt*2,  getmop*80, name*4, idate*8
      common /readme/ ird
      common /keywrd/ keywrd
      common /titles/ koment,title
      common /geovar/ nvar, loc(2,maxpar), idumy, xparam(maxpar)
      common /path/ latom,lparam,react(200)
      common /mesh/ latom1, lpara1, latom2, lpara2
      common /elemts/ elemnt(107)
      common /molkst/ numat,nat(numatm),nfirst(numatm),
     * nmidle(numatm),nlast(numatm),norbs,nelecs,nalpha,nbeta,
     * nclose,nopen,ndumy,fract
      common /okmany/ isok
      parameter (mxdim=maxorb+numatm)
      common /symres/ trans,rtr,sig,name,namo(mxdim),indx(mxdim),
     * ista(2)
      common /istope/ ams(107)
      common /cmpg/ geo(3,numatm)
      common /numcal/ numcal
      common /geokst/ natoms,labels(numatm),
     1na(numatm),nb(numatm),nc(numatm)
      common /geosym/ ndep, locpar(maxpar), idepfn(maxpar),
     1                      locdep(maxpar)
c     patas
      common /mopgrd/ xp(3),yp(3),zp(3),ds
      common /connol/ scale,scincr,den,nsurf
      common /mstsol/ eps,dmp,mc,icomp,ifield,icav
      common /mstsur/ omega,rd,ret,fro,dr,ndiv,nesf,icent
      common /mstcav/ tabs,vmol,dmol,tce,sten,dsten,cmf
      common /poly/ xe(500),ye(500),ze(500),re(500),
     1ssfe(500),
     1iploch(1500),as(1500),stot,vol,nsf,nc1(numatm)
      common /mopfac/ factor
      common /clases/ iclass(numatm)
c     patas
      logical int, aigeo, isok
      save space, space2, ireact, int
      dimension coord(3,numatm),value(40)
      equivalence (keys(1),keywrd)
      data space, space2/' ','  '/
c     patas
      data antoau,one/1.8897626d0,1.0d0/
c     patas
      convtr=2.d0*dasin(1.d0)/180.d0
      aigeo=.false.
   10 continue
c
      call gettxt
      if(index(keywrd,'echo').ne.0)then
_IF(ipsc,tools)
        if(oroot()) then
_ENDIF
         rewind ird
         isok=.false.
         do 50 i=1,1000
            read(ird,'(a)',end=60)keywrd
            do 20 j=80,2,-1
   20       if(keywrd(j:j).ne.' ')goto 30
            j=1
   30       do 40 k=1,j
   40       if(ichar(keywrd(k:k)).lt.32)keywrd(k:k)='*'
            write(mfgw,'(1x,a)')keywrd(1:j)
   50    continue
   60    continue
         rewind ird
         call gettxt
_IF(ipsc,tools)
        endif
_ENDIF
      endif
      if(index(keywrd,'echo').ne.0)write(mfgw,'(''1'')')
      if(keywrd(1:1) .ne. space) then
         ch=keywrd(1:1)
         keywrd(1:1)=space
         do 70 i=2,239
            ch2=keywrd(i:i)
            keywrd(i:i)=ch
            ch=ch2
            if(keywrd(i+1:i+2) .eq. space2) then
               keywrd(i+1:i+1)=ch
               goto 80
            endif
   70    continue
         ch2=keywrd(240:240)
         keywrd(240:240)=ch
         keywrd(241:241)=ch2
   80    continue
      endif
      if(koment(1:1) .ne. space) then
         ch=koment(1:1)
         koment(1:1)=space
         do 90 i=2,79
            ch2=koment(i:i)
            koment(i:i)=ch
            ch=ch2
            if(koment(i+1:i+2) .eq. space2) then
               koment(i+1:i+1)=ch
               goto 100
            endif
   90    continue
         ch2=koment(80:80)
         koment(80:80)=ch
         koment(81:81)=ch2
  100    continue
      endif
      if(title(1:1) .ne. space) then
         ch=title(1:1)
         title(1:1)=space
         do 110 i=2,79
            ch2=title(i:i)
            title(i:i)=ch
            ch=ch2
            if(title(i+1:i+2) .eq. space2) then
               title(i+1:i+1)=ch
               goto 120
            endif
  110    continue
         ch2=title(80:80)
         title(80:80)=ch
         title(81:81)=ch2
  120    continue
      endif
      do 121 i=1,200
  121 react(i)=0.0d0
      latom=0
      lparam=0
      if(index(keywrd,'oldgeo').eq.0) then
         nvar=0
         ndep=0
         if(aigeo.or.index(keywrd,'aigin').ne.0)then
            call getgeg(ird,labels,geo,     na,nb,nc,ams,natoms,int)
         if(nvar.eq.0)then
         do 122 j=1,3
         do 122 i=1,natoms
  122    lopt(j,i)=0
         endif
         else
            call getgeo(ird,labels,geo,lopt,na,nb,nc,ams,natoms,int)
            if(natoms.lt.0)then
               rewind ird
               if(numcal.ne.1)then
                  write(mfgw,'(//,a)')
     +        '   gaussian input requires stand-alone job'
                  write(mfgw,'(/,a)')'   or keyword "aigin"'
                  go to 1000
               endif
               aigeo=.true.
               goto 10
            endif
         endif
         if(natoms.eq.0)go to 1000
      else
      degree=90.d0/dasin(1.d0)
      if(na(1).eq.99)then
      do 128 i=1,natoms
      do 128 j=1,3
      lopt(j,i)=1
  128 coord(j,i)=geo(j,i)
      lopt(1,1)=0
      lopt(2,1)=0
      lopt(3,1)=0
      lopt(2,2)=0
      lopt(3,2)=0
      lopt(3,3)=0
      call mopxyz(coord,natoms,na,nb,nc,degree,geo)
      else 
      do 130 i=1,natoms
      do 130 j=2,3
 130  geo(j,i)=geo(j,i)*degree
      endif
      endif
      if(index(keywrd,'force').ne.0 .and. labels(natoms).eq.107) then
      do 131 i=1,na(natoms)
      if(labels(i).eq.99)then
      write(mfgw,'(a)')' no dummy atoms allowed before translation'
      write(mfgw,'(a)')' atom in a force calculation'
      go to 1000
      endif
  131 continue
      endif
c
c
c output file to unit 6
c
c    write header
      idate=zdate
c     call gtnv('mopacdate',idate)
      write(mfgw,'(1x,15(''*****''),''****'')')
c
c     change the following line to suit local environment, if desired
c
      banner=' '
      write(mfgw,'(a)')banner
c
c    the banner does not appear anywhere else.
c
      write(mfgw,'(1x,79(''*''))')
      line='   mndo'
      if(index(keywrd,'mindo') .ne. 0) line='mindo/3'
      if(index(keywrd,'am1')   .ne. 0) line='    am1'
      if(index(keywrd,'pm3')   .ne. 0) line='    pm3'
      write(mfgw,
     +'(/29x,a,'' calculation results'',28x,///1x,15(''*****'')
     1,''****'' )')line(:7)
      write(mfgw,'('' *'',10x,''MOPAC:  version '',f5.2,
     115x,a)') verson, idate
c
c convert angles to radians
      do 140 j=2,3
c$doit vbest
         do 140 i=1,natoms
            geo(j,i) = geo(j,i) * convtr
  140 continue
c
c check data
c
      na(1)=0
      nb(1)=0
      nc(1)=0
      do 150 i=1,natoms
         if (labels(i) .le. 0 ) then
            write(mfgw,
     +      '('' atomic number of '',i3,'' ?'')') labels(i)
            if(i.eq.1) then
               write(mfgw,'(a)')' this was the first atom'
            else
               write(mfgw,'(a)')
     +         '    geometry up to, but not including, the'//
     +         ' faulty atom'
               natoms=i-1
               call geout(mfgw)
            endif
            go to 1000
         endif
         if (  na(i).ge.i.or. nb(i).ge.i.or. nc(i).ge.i
     1  .or. (na(i).eq.nb(i))   .and. i.gt.1
     2  .or. (na(i).eq.nc(i).or.nb(i).eq.nc(i))  .and. i.gt.2
     3  .or.  na(i)*nb(i)*nc(i).eq.0  .and. i.gt.3) then
            write(mfgw,'('' atom number '',i3,'' is ill-defined'')') i
            if(i.eq.1)go to 1000
            write(mfgw,'(/,''  geometry read in'',/)')
            call geout(mfgw)
            go to 1000
         endif
  150 continue
c
c write keywords back to user as feedback
      call wrtkey(keywrd)
      write(mfgw,
     + '(1x,14(''*****''),''*'',i3.3,''by'',i3.3)')maxhev,maxlit
c
c fill in geo matrix if needed
      if(index(keywrd,'oldgeo').eq.0.and.index(keywrd,'sym') .ne. 0
     1.and. ndep.eq.0) call gtsymm
      if(ndep.ne.0) call mopsym()
c
c initialize flags for optimize and path
      iflag = 0
      latom = 0
      numat=0
      if(nvar.ne.0)then
         numat=natoms
      else
         do 180 i=1,natoms
            if(labels(i).ne.99.and.labels(i).ne.107)numat=numat+1
            do 180 j=1,3
               if (lopt(j,i) ) 160, 180, 170
c    flag for path
  160          convrt=1.d0
               if ( iflag .ne. 0 ) then
                  if(index(keywrd,'step1').ne.0)then
                     lpara1=lparam
                     latom1=latom
                     lpara2=j
                     latom2=i
                     latom=0
                     iflag=0
                     goto 180
                  else
                     write(mfgw,
     +               '('' only one reaction coordinate permitted'')')
                     go to 1000
                  endif
               endif
               latom  = i
               lparam = j
               if(j.gt.1) convrt=0.01745329252d00
               react(1)  = geo(j,i)
               ireact=1
               iflag = 1
               go to 180
c    flag for optimize
  170          nvar = nvar + 1
               loc(1,nvar) = i
               loc(2,nvar) = j
               xparam(nvar)   = geo(j,i)
  180    continue
      endif
c read in path values
      if(iflag.eq.0) go to 221
      if(index(keywrd,'nllsq').ne.0)then
         write(mfgw,'(a)')' nllsq used with reaction path; '//
     1'this option is not allowed'
         go to 1000
      endif
      if(index(keywrd,'sigma').ne.0)then
         write(mfgw,'(a)')' sigma used with reaction path; '//
     1'this option is not allowed'
         go to 1000
      endif
      if(index(keywrd,'step')+index(keywrd,'points').ne.0)then
         step=reada(keywrd,index(keywrd,'step=')+5)
         npts=reada(keywrd,index(keywrd,'point=')+6)
         if(npts.gt.200)then
            write(mfgw,
     +      '(///,''    only two hundred points allowed in react
     1'',''ion coordinate'')')
            go to 1000
         endif
         if(lparam.eq.1.and.step.le.0)then
            write(mfgw,
     +      '(///,''    step for bond length should be set posit
     1ive '',''to prevent two atoms collapse'')')
            go to 1000
         endif
         go to 221
      endif
  190 read(ird,'(a)',end=210) line
      call nuchar(line,value,nreact)
      if(nreact.eq.0)goto 210
      do 200 i=1,nreact
         ij=ireact+i
         if(ij.gt.200)then
            write(mfgw,
     +  '(///,''    only two hundred points allowed in reaction'',
     +   '' coordinate'')')
            go to 1000
         endif
         react(ij)=value(i)*convrt
         if(dabs(react(ij)-react(ij-1)).lt.1.d-5)then
            dum1 = react(ij)/convrt
            dum2 = react(ij-1)/convrt
            write(mfgw,'(///,'' two adjacent points are identical:  '',
     1 f7.3,2x,f7.3,/,'' this is not allowed in a path calculation'')')
     2 dum1,dum2
            go to 1000
         endif
  200 continue
      ireact=ireact+nreact
      go to 190
  210 continue
      degree=1.d0
      if(lparam.gt.1)degree=90.d0/dasin(1.d0)
      if(ireact.le.1) then
         write(mfgw,'(//10x,'' no points supplied for reaction path'')')
         write(mfgw,
     +   '(//10x,'' geometry as read in is as follows'')')
         call geout(1)
         go to 1000
      else
         write(mfgw,'(//10x,'' points on reaction coordinate'')')
         write(mfgw,'(10x,8f8.2)')(react(i)*degree,i=1,ireact)
      endif
      iend=ireact+1
      react(iend)=-1.d12
c     patas
c
c     read in cubic grid or connolly surface for m.e.p. computation
c
  221 if (index(keywrd,'mep=').ne.0) then
      i=(reada(keywrd,index(keywrd,'mep=')))
        if (i.eq.1) then
c     fill common /mopgrd/
        do 222 j=1,3
           read(ird,'(a)') line
           call nuchar (line,value,nvalue)
           xp(j)=value(1)*antoau
           yp(j)=value(2)*antoau
           zp(j)=value(3)*antoau
  222   continue
        read(ird,'(a)') line
        call nuchar (line,value,nvalue)
        ds=value(1)*antoau
        else
c     fill common /connol/
        read(ird,'(a)') line
        call nuchar (line,value,nvalue)
        scale=value(1)*one
        scincr=value(2)*one
        den=value(3)*one
        nsurf=value(4)
        endif
      endif
c
c     read in data for mst solvation model
c
      if (index(keywrd,'tom').ne.0) then
c
c     fill common /mstsol/
c
      read(ird,'(a)') line
      call nuchar (line,value,nvalue)
      eps=value(1)*one
      dmp=value(2)
      mc=value(3)
      icomp=value(4)
      ifield=value(5)
      icav=value(6)
c
c     fill common /mstcav/
c
      read(ird,'(a)') line
      call nuchar (line,value,nvalue)
      if (icav.eq.0) go to 303
      if (icav.eq.1.or.icav.eq.3) then
      tabs=value(1)*one
      vmol=value(2)*one
      dmol=value(3)*one
      tce=value(4)*one
      endif
      if (icav.eq.3) then
      sten=value(5)*one
      dsten=value(6)*one
      cmf=value(7)*one
      endif
      if (icav.eq.2) then
      sten=value(1)*one
      dsten=value(2)*one
      cmf=value(3)*one
      endif
c     fill common /mstsur/
  303 read(ird,'(a)') line
      call nuchar (line,value,nvalue)
      omega=value(1)*one
      rd=value(2)*one
      ret=value(3)*one
      fro=value(4)*one
      dr=value(5)*one
      ndiv=value(6)
      nesf=value(7)
      icent=value(8)
c
c     fill common /poly/
c
      do 300 i=1,nesf
      read(ird,'(a)') line
      call nuchar (line,value,nvalue)
      if (icent.eq.0) then
      xe(i)=value(1)*one
      ye(i)=value(2)*one
      ze(i)=value(3)*one
      re(i)=value(4)*one
      iclass(i)=value(5)
      else
      nc1(i)=value(1)
      re(i)=value(2)*one
      iclass(i)=value(3)
      endif
  300 continue
c
c     fill common /mopfac/
c
      read(ird,'(a)') line
      call nuchar (line,value,nvalue)
      factor=value(1)*one
      endif
c     patas
c
c output geometry as feedback
c
  220 call wrttxt(mfgw)
      if(index(keywrd,'nolog').eq.0)then
_IF(ipsc,tools)
       if(oroot()) then
_ENDIF
         open(unit=11, form='formatted', status='unknown',
     +file=getmop(5))
         call wrttxt(11)
_IF(ipsc,tools)
       endif
_ENDIF
      endif
      call geout(1)
      call gmetry(geo,coord)
c
c  if a polymer, expand to mers
c
      if(index(keywrd,' mers').ne.0)call makpol(coord)
      if (index(keywrd,'noxyz') .eq. 0) then
         if(index(keywrd,'0scf').ne.0)then
c
c  write out cartesian coordinates for use as a data-set
c
            write(mfgw,'(a)')
     +  '   geometry in cartesian coordinate format'
            call wrttxt(mfgw)
            j=0
            do 230 i=1,natoms
               if(labels(i).ne.99)then
                  j=j+1
                  write(mfgw,'(2x,a,3(f19.13,i3))')
     1    elemnt(labels(i)),(coord(k,j),1,k=1,3)
               endif
  230       continue
         else
            write(mfgw,'(//10x,''cartesian coordinates '',/)')
            write(mfgw,'(4x,''no.'',7x,''atom'',9x,''x'',
     1  9x,''y'',9x,''z'',/)')
            l=0
            do 240 i=1,natoms
               if(labels(i) .eq. 99.or.labels(i).eq.107) goto 240
               l=l+1
               write(mfgw,'(i6,8x,a2,4x,3f10.4)')
     1  l,elemnt(labels(i)),(coord(j,l),j=1,3)
  240       continue
         endif
      endif
      call symtrz(coord,c,norbs,norbs,.false.,.false.)
      write(mfgw,
     +      '(//''     molecular point group   :   '',a4)') name
      if(   index(keywrd,' xyz') .ne. 0 )then
         if( nvar .ne. 0 .and.
     1 int.and.(ndep .ne. 0 .or.  nvar.lt.3*numat-6)) then
            if(ndep.ne.0)
     1write(mfgw,
     +      '(//10x,'' internal coordinates read in, and symmetry''
     2,/10x,'' specified, but calculation to be run in cartesian ''
     3,''coordinates'')')
            if(nvar.lt.3*numat-6)
     1write(mfgw,
     +      '(//10x,'' internal coordinates read in, and'',
     2'' calculation '',/10x,''to be run in cartesian coordinates, '',
     3/10x,''but not all coordinates marked for optimisation'')')
            write(mfgw,
     +      '(//10x,'' this involves a logicallly absurd choice''
     1 ,/10x,'' so the calculation is terminated at this point'')')
            go to 1000
         endif
         sumx=0.0d0
         sumy=0.0d0
         sumz=0.0d0
         do 250 j=1,numat
            sumx=sumx+coord(1,j)
            sumy=sumy+coord(2,j)
  250    sumz=sumz+coord(3,j)
         sumx=sumx/numat
         sumy=sumy/numat
         sumz=sumz/numat
         do 260 j=1,numat
            geo(1,j)=coord(1,j)-sumx
            geo(2,j)=coord(2,j)-sumy
  260    geo(3,j)=coord(3,j)-sumz
         na(1)=99
         j=0
         nvar=0
         do 280 i=1,natoms
            if(labels(i).ne.99)then
               j=j+1
               if(j.eq.1)then
                  k=0
               elseif(j.lt.4)then
                  k=min(3,i-1)
               else
                  k=3
               endif
               do 270 l=1,k
                  nvar=nvar+1
                  loc(1,nvar)=j
                  loc(2,nvar)=l
  270          xparam(nvar)=geo(l,j)
               labels(j)=labels(i)
            endif
  280    continue
         natoms=numat
      else
         if(nvar.eq.0) return
         if( .not. int.and.(ndep .ne. 0 .or.  nvar.lt.3*numat-6)) then
            if(ndep.ne.0)
     1write(mfgw,
     +'(//10x,'' cartesian coordinates read in, and symmetry''
     2,/10x,'' specified, but calculation to be run in internal ''
     3,''coordinates'')')
            if(nvar.lt.3*numat-6)
     1write(mfgw,
     +'(//10x,'' cartesian coordinates read in, and'',
     2'' calculation '',/10x,''to be run in internal coordinates, '',
     3/10x,''but not all coordinates marked for optimisation'')')
            write(mfgw,
     +'(//10x,''mopac, by default, uses internal coordinates'',
     +/10x,''to specify cartesian coordinates use key-word :xyz:'')
     2')
            write(mfgw,
     +'(10x,''your current choice of key-words involves''
     1,'' a logicallly'',/10x,''absurd choice so the calculation is'',
     2'' terminated at this point'')')
            go to 1000
         endif
      endif
      return
1000  ostop = .true.
      return
      end
      subroutine mops(val,vec,n)
      implicit REAL (a-h,o-z)
      COMPLEX vec(n,*), sum
      REAL    val(*)
      do 30 i=1,n
         x=1.d9
         do 10 j=i,n
            if(val(j).lt.x) then
               k=j
               x=val(j)
            endif
   10    continue
         do 20 j=1,n
            sum=vec(j,k)
            vec(j,k)=vec(j,i)
   20    vec(j,i)=sum
         val(k)=val(i)
         val(i)=x
   30 continue
      return
      end
      subroutine mopm(a,nar,b,nbr,c,ncc)
      implicit REAL (a-h,o-z)
c     matrix product c(nar,ncc) = a(nar,nbr) * (b(ncc,nbr))'
c     all matrices rectangular , packed.
      dimension a(nar,nbr),b(ncc,nbr),c(nar,ncc)
      do 20 j=1,ncc
         do 10 i=1,nar
   10    c(i,j)=0.0d0
         do 20 k=1,nbr
            do 20 i=1,nar
   20 c(i,j)=c(i,j)+a(i,k)*b(j,k)
      return
      end
      subroutine moppun (a,b,nc,nr,ndim,iwrite)
      implicit REAL (a-h,o-z)
      character elemnt*2
INCLUDE(common/sizes)
      dimension a(ndim,ndim), b(ndim)
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),
     1                nlast(numatm), norbs, nelecs,nalpha,nbeta,
     2                nclose,nopen,ndumy,fract
      common /elemts/ elemnt(107)
c**********************************************************************
c
c      moppun punches a square matrix of eigenvectors and eigenvalues
c
c    on input a contains the matrix to be printed.
c             b contains the eigenvalues.
c             nc number of molecular orbitals to be printed.
c             nr is the size of the square array to be printed.
c             ndim is the actual size of the square array "a".
c             nfirst and nlast contain atom orbital counters.
c             nat = array of atomic numbers of atoms.
c
c***********************************************************************
      if(numat.eq.0) return
c
      write (iwrite,*) 'vectors mopac'
      do 50 j = 1 , nc
         imax = 0
         ic = 0
 40      imin = imax + 1
         imax = imax + 5
         ic = ic + 1
         if (imax.gt.nr) imax = nr
         write (iwrite,6040) j , ic , (a(i,j),i=imin,imax)
 6040    format (i2,i3,5e15.8)
         if (imax.lt.nr) go to 40
 50   continue
      return
      end
      subroutine mopro(coord,i,j,ix,rij,del1,idx)
      implicit REAL (a-h,o-z)
      common /derivs/ ds(16),dg(22),dr(100),tdx(3),tdy(3),tdz(3)
      common /cmpex/ g(22),tx(3),ty(3),tz(3)
      dimension coord(3,25)
      xd=coord(1,i)-coord(1,j)
      yd=coord(2,i)-coord(2,j)
      zd=coord(3,i)-coord(3,j)
      rxy=dsqrt(xd*xd+yd*yd)
      ryz=dsqrt(yd*yd+zd*zd)
      rzx=dsqrt(zd*zd+xd*xd)
      do 10 ijk=1,3
         tx(ijk)=0.0d0
         ty(ijk)=0.0d0
         tz(ijk)=0.0d0
         tdx(ijk)=0.0d0
         tdy(ijk)=0.0d0
         tdz(ijk)=0.0d0
   10 continue
      if(rxy.lt.1.0d-4) then
c   molecular z axis is parallel to diatomic z axis
         tx(3)=1.0d0
         if(zd.lt.0.0d0) tx(3)=-1.0d0
         ty(2)=1.0d0
         tz(1)=tx(3)
         if(idx.eq.1) return
         if(ix.eq.1) tdx(1)=1.0d0/rij
         if(ix.eq.2) tdx(2)=1.0d0/rij
         if(ix.eq.1) tdz(3)=-1.0d0/rij
         if(ix.eq.2) tdy(3)=-tx(3)/rij
      elseif(ryz.lt.1.0d-4) then
c   molecular x axis is parallel to diatomic z axis
         tx(1)=1.0d0
         if(xd.lt.0.0d0) tx(1)=-1.0d0
         ty(2)=tx(1)
         tz(3)=1.0d0
         if(idx.eq.1) return
         if(ix.eq.2) tdx(2)=1.0d0/rij
         if(ix.eq.3) tdx(3)=1.0d0/rij
         if(ix.eq.2) tdy(1)=-1.0d0/rij
         if(ix.eq.3) tdz(1)=-tx(1)/rij
      elseif(rzx.lt.1.0d-4) then
c   molecular y axis is parallel to diatomic z axis
         tx(2)=1.0d0
         if(yd.lt.0.0d0) tx(2)=-1.0d0
         ty(1)=-tx(2)
         tz(3)=1.0d0
         if(idx.eq.1) return
         if(ix.eq.1) tdx(1)=1.0d0/rij
         if(ix.eq.3) tdx(3)=1.0d0/rij
         if(ix.eq.1) tdy(2)=1.0d0/rij
         if(ix.eq.3) tdz(2)=-tx(2)/rij
      else
         tx(1)=xd/rij
         tx(2)=yd/rij
         tx(3)=zd/rij
         tz(3)=rxy/rij
         ty(1)=-tx(2)*dsign(+1.0d0,tx(1))/tz(3)
         ty(2)=dabs(tx(1)/tz(3))
         ty(3)=0.0d0
         tz(1)=-tx(1)*tx(3)/tz(3)
         tz(2)=-tx(2)*tx(3)/tz(3)
         if(idx.eq.1) return
         term=del1/(rij*rij)
         if(ix.eq.1)then
            tdx(1)=1.0d0/rij-tx(1)*term
            tdx(2)=-tx(2)*term
            tdx(3)=-tx(3)*term
            tdz(3)=tx(1)/rxy-tz(3)*term
         elseif(ix.eq.2) then
            tdx(1)=-tx(1)*term
            tdx(2)=1.0d0/rij-tx(2)*term
            tdx(3)=-tx(3)*term
            tdz(3)=tx(2)/rxy-tz(3)*term
         elseif(ix.eq.3)then
            tdx(1)=-tx(1)*term
            tdx(2)=-tx(2)*term
            tdx(3)=1.0d0/rij-tx(3)*term
            tdz(3)=-tz(3)*term
         endif
         tdy(1)=-tdx(2)/tz(3)+tx(2)*tdz(3)/tz(3)**2
         if(tx(1).lt.0.0d0) tdy(1)=-tdy(1)
         tdy(2)=tdx(1)/tz(3)-tx(1)*tdz(3)/tz(3)**2
         if(tx(1).lt.0.0d0) tdy(2)=-tdy(2)
         tdy(3)=0.0d0
         tdz(1)=-tx(3)*tdx(1)/tz(3)-tx(1)*tdx(3)/tz(3)
     1 +tx(1)*tx(3)*tdz(3)/tz(3)**2
         tdz(2)=-tx(3)*tdx(2)/tz(3)-tx(2)*tdx(3)/tz(3)
     1 +tx(2)*tx(3)*tdz(3)/tz(3)**2
      endif
      return
      end
      subroutine mopsrc(xparam,alpha,sig,nvar,gmin,okf, funct)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      common /iofile/ mfgr,mfgw
      dimension xparam(*), sig(*)
************************************************************************
*
* mopsrc performs a line search for powsq. it minimizes the norm of
*        the gradient vector in the direction sig.
*
* on input  xparam = current point in nvar dimensional space.
*           alpha  = step size (in fact alpha is calculated in search).
*           sig    = search direction vector.
*           nvar   = number of parameters in sig (& xparam)
*
* on output xparam = parameters of minimum.
*           alpha  = distance to minimum.
*           gmin   = gradient norm at minimum.
*           okf    = function was improved.
************************************************************************
      common /sigma1/ gnext, amin, anext
      common /sigma2/  gnext1(maxpar), gmin1(maxpar)
      common /keywrd/ keywrd
      common /numcal/ numcal
      dimension grad(maxpar),xref(maxpar), gref(maxpar), xmin1(maxpar)
      save debug, g,  tiny, looks, tolerg
      character*241 keywrd
      logical debug, okf, nopr
      save icalcn
      data icalcn/0/
      if (icalcn.ne.numcal) then
         icalcn=numcal
c
c    tolg   = criterion for exit by relative change in gradient.
c
         debug=(index(keywrd,'linmin') .ne. 0)
         nopr=( .not. debug)
         looks=0
         okf=.true.
         tiny=0.1d0
         tolerg=0.02d0
         g=100.d0
         alpha=0.1d0
      endif
      do 10 i=1,nvar
         gref(i)  =gmin1(i)
         gnext1(i)=gmin1(i)
         xmin1(i) =xparam(i)
   10 xref(i)  =xparam(i)
      if(dabs(alpha) .gt. 0.2)alpha=dsign(0.2d0,alpha)
      if(debug) then
         write(mfgw,'('' search direction vector'')')
         write(mfgw,'(6f12.6)')(sig(i),i=1,nvar)
         write(mfgw,'('' initial gradient vector'')')
         write(mfgw,'(6f12.6)')(gmin1(i),i=1,nvar)
      endif
      gb=ddot(nvar,gmin1,1,gref,1)
      if(debug) write(mfgw,'('' gradient at start of search:'',f16.6)')
     1          dsqrt(gb)
      gstore=gb
      amin=0.0d0
      gminn=1.d9
c
c
      ta=0.0d0
      ga=gb
      gb=1.d9
      itrys=0
      goto 30
   20 sum=ga/(ga-gb)
      itrys=itrys+1
      if(dabs(sum) .gt. 3.d0) sum=dsign(3.d0,sum)
      alpha=(tb-ta)*sum+ta
c
c         xparam is the geometry of the predicted minimum along the line
c
   30 continue
      do 40 i=1,nvar
   40 xparam(i)=xref(i)+alpha*sig(i)
c
c         calculate gradient norm and gradients at the predicted minimum
c
      if(itrys.eq.1)then
         do 50 i=1,nvar
   50    grad(i)=0.0d0
      endif
      call compfg (xparam, .true., funct, .true., grad, .true.)
      looks=looks+1
c
c          g is the projection of the gradient along sig.
c
      g=ddot(nvar,gref,1,grad,1)
      gtot=dsqrt(ddot(nvar,grad,1,grad,1))
      if( .not. nopr)write(mfgw,
     +'('' looks'',i3,'' alpha ='',f12.6,'' gradient'',f12.3,
     2'' g  ='',f16.6)')
     3looks,alpha,dsqrt(ddot(nvar,grad,1,grad,1)),g
      if(gtot .lt. gminn) then
         gminn=gtot
         if(dabs(amin-alpha) .gt.1.d-2) then
*
* we can move anext to a point near, but not too near, amin, so that the
* second derivativeswillberealistic(d2e/dx2=(gnext1-gmin1)/(anext-amin))
*
            anext=amin
            do 60 i=1,nvar
   60       gnext1(i)=gmin1(i)
         endif
         amin=alpha
         do 70 i=1,nvar
            if(gminn.lt.gmin) xmin1(i)=xparam(i)
   70    gmin1(i)=grad(i)
         if(gmin.gt.gminn)gmin=gminn
      endif
      if(itrys .gt. 8) goto 80
      if (dabs(g/gstore).lt.tiny .or. dabs(g) .lt. tolerg) go to 80
      if(dabs(g) .lt. dmax1(dabs(ga),dabs(gb)) .or.
     1     ga*gb .gt. 0.d0 .and. g*ga .lt. 0.d0) then
c
c   g is an improvement on ga or gb.
c
         if(dabs(gb) .lt. dabs(ga))then
            ta=alpha
            ga=g
            go to 20
         else
            tb=alpha
            gb=g
            go to 20
         endif
      else
c#         write(mfgw,'(//10x,'' failed in search, search continuing'')')
         goto 80
      endif
   80 continue  
      gminn=dsqrt(ddot(nvar,gmin1,1,gmin1,1))
      do 90 i=1,nvar
   90 xparam(i)=xmin1(i)
      if(debug) then
         write(mfgw,'('' at exit from search'')')
         write(mfgw,'('' xparam'',6f12.6)')(xparam(i),i=1,nvar)
         write(mfgw,'('' gnext1'',6f12.6)')(gnext1(i),i=1,nvar)
         write(mfgw,'('' gmin1 '',6f12.6)')(gmin1(i),i=1,nvar)
         write(mfgw,'('' amin, anext,gmin'',4f12.6)')
     1    amin,anext,gmin
      endif
      if(gminn.gt.gmin)then
         do 100 i=1,nvar
  100    xparam(i)=xref(i)
      endif
      return
c
      end
      subroutine mopsym
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      common /cmpg/ geo(3,numatm)
      common /geosym/ ndep, locpar(maxpar), idepfn(maxpar),
     1         locdep(maxpar)
c**********************************************************************
c
c  mopsym computes the bond lengths and angles that are functions of
c         other bond lengths and angles.
c
c on input geo     = known internal coordinates
c          ndep    = number of dependency functions.
c          idepfn  = array of dependency functions.
c          locdep  = array of labels of dependent atoms.
c          locpar  = array of labels of reference atoms.
c
c  on output the array "geo" is filled
c***********************************************************************
c
c     now compute the dependent parameters.
c
      do 10 i=1,ndep
         call haddon (value,locn,idepfn(i),locpar(i),geo)
         j=locdep(i)
   10 geo(locn,j)=value
      return
      end
      subroutine mopth
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      common /iofile/ mfgr,mfgw
      common /path/ latom,lparam,react(200)
      common /geovar/ nvar, loc(2,maxpar), idumy, xparam(maxpar)
      common /keywrd/ keywrd
      common /timem/ time0
      common /cmpg/ geo(3,numatm)
      common /alparm/ alparm(3,maxpar),x0, x1, x2, iloop
************************************************************************
*
*   mopth follows a reaction coordinate.   the reaction coordinate is on
*        atom latom, and is a distance if lparam=1,
*                           an angle   if lparam=2,
*                           an dihedralif lparam=3.
*
************************************************************************
      dimension gd(maxpar),xlast(maxpar),mdfp(20),xdfp(20)
      character*241 keywrd
      character*10 type(3)
      save type, gd, xlast, mdfp, xdfp
      data type / 'angstroms ','degrees   ','degrees   '/
      iloop=1
      if(index(keywrd,'restar') .ne. 0) then
         mdfp(9)=0
         call dfpsav(totime,xparam,gd,xlast,funct1,mdfp,xdfp)
         write(mfgw,'(//10x,'' restarting at point'',i3)')iloop
      endif
      if(iloop.gt.1) goto 10
      write(mfgw,'(''  about to enter flepo from path'')')
      time0=secmop()
      call flepo(xparam,nvar,funct)
      write(mfgw,
     +    '(''  optimized values of parameters, initial point'')')
      call writmo(time0,funct)
      time0=secmop()
   10 continue
      if(iloop.gt.2) goto 40
      geo(lparam,latom)=react(2)
      if(iloop.eq.1) then
         x0=react(1)
         x1=x0
         x2=react(2)
_IF(ipsc,tools)
         if(x2.lt. -100.d0) call pend
_ELSE
         if(x2.lt. -100.d0) stop
_ENDIF
         do 20 i=1,nvar
            alparm(2,i)=xparam(i)
   20    alparm(1,i)=xparam(i)
         iloop=2
      endif
      call flepo(xparam,nvar,funct)
      rnord=react(2)
      if(lparam.gt.1) rnord=rnord*57.29577951d0
      write(mfgw,
     +     '(1x,16(''*****'')//17x,''reaction coordinate = ''
     1,f12.4,2x,a10,19x//1x,16(''*****''))')rnord,type(lparam)
      call writmo(time0,funct)
      time0=secmop()
      do 30 i=1,nvar
   30 alparm(3,i)=xparam(i)
c
c   now for the main interpolation route
c
      if(iloop.eq.2)iloop=3
   40 continue
      lpr=iloop
      do 110 iloop = lpr,100
c
         if(react(iloop).lt. -100.d0) return
c
         rnord=react(iloop)
         if(lparam.gt.1) rnord=rnord*57.29577951d0
         write(mfgw,
     +       '(1x,16(''*****'')//19x,''reaction coordinate = ''
     1,f12.4,2x,a10,19x//1x,16(''*****''))')rnord,type(lparam)
c
         x3=react(iloop)
         c3=(x0**2-x1**2)*(x1-x2)-(x1**2-x2**2)*(x0-x1)
c      write(mfgw,'(''   c3:'',f13.7)')c3
         if (dabs(c3) .lt. 1.d-8) then
c
c    we use a linear interpolation
c
            cc1=0.0d0
            cc2=0.0d0
         else
c    we do a quadratic interpolation
c
            cc1=(x1-x2)/c3
            cc2=(x0-x1)/c3
         endif
         cb1=1.d0/(x1-x2)
         cb2=(x1**2-x2**2)*cb1
c
c    now to calculate the interpolated coordinates
c
         do 50 i=1,nvar
            delf0=alparm(1,i)-alparm(2,i)
            delf1=alparm(2,i)-alparm(3,i)
            aconst = cc1*delf0-cc2*delf1
            bconst = cb1*delf1-aconst*cb2
            cconst = alparm(3,i) - bconst*x2 - aconst*x2**2
            xparam(i)=cconst+bconst*x3+aconst*x3**2
            alparm(1,i)=alparm(2,i)
   50    alparm(2,i)=alparm(3,i)
c
c   now to check that the guessed geometry is not too absurd
c
         do 60 i=1,nvar
   60    if(dabs(xparam(i)-alparm(3,i)) .gt. 0.2) goto 70
         goto 90
   70    write(mfgw,
     +  '('' geometry too unstable for extrapolation to be used
     1''/ ,'' - the last geometry is being used to start the next''
     2,'' calculation'')')
         do 80 i=1,nvar
   80    xparam(i)=alparm(3,i)
   90    continue
         x0=x1
         x1=x2
         x2=x3
         geo(lparam,latom)=react(iloop)
         call flepo(xparam,nvar,funct)
         call writmo(time0,funct)
         time0=secmop()
         do 100 i=1,nvar
  100    alparm(3,i)=xparam(i)
  110 continue
      end
      subroutine moptho(a,b,c,linear,sym,wt,vibs,nvibs,escf)
      implicit REAL (a-h,o-z)
      dimension vibs(*)
      logical linear
      character keywrd*241, koment*81, title*81, tmpkey*241
      common /keywrd/ keywrd
      common /titles/ koment,title
      common /iofile/ mfgr,mfgw
c
c
c   moptho calculates the various thermodynamic quantities for a
c   specified temperature given the vibrational frequencies, moments of
c   inertia, molecular weight and symmetry number.
c
c   reference: g.herzberg molecular spectra and molecular structure
c              vol 2, chap. 5
c
c   ----    table of symmetry numbers    ----
c
c        c1 ci cs     1      d2 d2d d2h  4       c(inf)v   1
c        c2 c2v c2h   2      d3 d3d d3h  6       d(inf)h   2
c        c3 c3v c3h   3      d4 d4d d4h  8       t td     12
c        c4 c4v c4h   4      d6 d6d d6h  12      oh       24
c        c6 c6v c6h   6      s6          3
c
c
c   program limitations:  the equations used are appropriate to the
c   high temperature limit and will begin to be inadequate at tempera-
c   tures below about 100 k.  secondly this program is only appropriate
c   in the case of molecules in which there is no free rotation
c
c
c
c
*******************************************************************
*
*  the following constants are now defined:
*          pi  = circumference to diameter of a circle
*          r   = gas constant in calories/mole
*          h   = planck's constant in erg-seconds
*          ak  = boltzmann constant in erg/degree
*          ac  = speed of light in cm/sec
*******************************************************************
      save pi, r, h, ak, ac
      dimension trange(300)
      data pi /3.14159d0 /
      data r/1.98726d0/
      data h/6.626d-27/
      data ak/1.3807d-16/
      data ac/2.99776d+10/
*******************************************************************
      it1=200
      it2=400
      istep=10
      tmpkey=keywrd
      i=index(tmpkey,'thermo(')
      if(i.ne.0) then
c
c   erase all text from tmpkey except thermo data
c
         tmpkey(:i)=' '
         tmpkey(index(tmpkey,')'):)=' '
         it1=reada(tmpkey,i)
         if(it1.lt.100) then
            write(mfgw,
     +      '(//10x,''temperature range starts too low,'',
     1'' lower bound is reset to 30k'')')
            it1=100
         endif
         i=index(tmpkey,',')
         if(i.ne.0) then
            tmpkey(i:i)=' '
            it2=reada(tmpkey,i)
            if(it2.lt.it1) then
               it2=it1+200
               istep=10
               goto 10
            endif
            i=index(tmpkey,',')
            if(i.ne.0) then
               tmpkey(i:i)=' '
               istep=reada(tmpkey,i)
               if(istep.lt.1)istep=1
            else
               istep=(it2-it1)/20
               if(istep.eq.0)istep=1
               if(istep.ge.2.and. istep.lt.5)istep=2
               if(istep.ge.5.and. istep.lt.10)istep=5
               if(istep.ge.10.and. istep.lt.20)istep=10
               if(istep.gt.20.and. istep.lt.50)istep=20
               if(istep.gt.50.and. istep.lt.100)istep=50
               if(istep.gt.100)istep=100
            endif
         else
            it2=it1+200
         endif
      endif
   10 continue
      write(mfgw,'(//,a)')title
      write(mfgw,'(a)')koment
      if(linear) then
         write(mfgw,'(//10x,''molecule is linear'')')
      else
         write(mfgw,'(//10x,''molecule is not linear'')')
      endif
      write(mfgw,
     +'(/10x,''there are'',i3,'' genuine vibrations in this '',
     1''system'')')nvibs
      write(mfgw,20)
   20 format(10x,'this thermodynamics calculation is limited to',/
     110x,'molecules which have no internal rotations'//)
      write(mfgw,'(//20x,''calculated thermodynamic properties'')')
      write(mfgw,'(42x,''*'')')
      write(mfgw,'(''   temp. (k)   partition function   h.o.f.'',
     1''    enthalpy   heat capacity  entropy'')')
      write(mfgw,'(  ''                                    kcal/mol'',
     1''   cal/mole    cal/k/mol   cal/k/mol'',/)')
      do 30 i=1,nvibs
   30 vibs(i)=dabs(vibs(i))
      ilim=1
      do 40 itemp=it1,it2,istep
         ilim=ilim+1
   40 trange(ilim)=itemp
      trange(1)=298.d0
      do 80 ir=1,ilim
         itemp=trange(ir)
         t=itemp
c   ***   initialise some variables   ***
         c1=h*ac/ak/t
         qv=1.0d0
         hv=0.0d0
         e0=0.0d0
         cpv=0.0d0
         sv1=0.0d0
         sv2=0.0d0
c   ***   construct the frequency dependent parts of partition function
         do 50 i=1,nvibs
            wi=vibs(i)
            ewj=dexp(-wi*c1)
            qv=qv/(1-ewj)
            hv=hv+wi*ewj/(1-ewj)
            e0=e0+wi
            cpv=cpv+wi*wi*ewj/(1-ewj)/(1-ewj)
            sv1=sv1+log(1.0d0-ewj)
   50    sv2=sv2+wi*ewj/(1-ewj)
c   ***   finish calculation of vibrational parts   ***
         hv=hv*r*h*ac/ak
         e0=e0*1.4295d0
         cpv=cpv*r*c1*c1
         sv=sv2*r*c1-r*sv1
c   ***   now calculate the rotational parts  (first linear molecules
         if(.not.linear) goto 60
         qr=1/(c1*a*sym)
         hr=r*t
         cpr=r
         sr=r*(log(t*ak/(h*ac*a*sym)))+r
         goto 70
   60    qr=dsqrt(pi/(a*b*c*c1*c1*c1))/sym
         hr=3.0d0*r*t/2.0d0
         cpr=3.0d0*r/2.0d0
         sr=0.5d0*r*(3.d0*log(t*ak/(h*ac))
     1-2.d0*log(sym)+log(pi/(a*b*c))+3.d0)
   70    continue
c   ***   calculate internal contributions   ***
         qint=qv*qr
         hint=hv+hr
         cpint=cpv+cpr
         sint=sv+sr
c   ***   construct translation contributions   ***
         qtr=(dsqrt(2.d0*pi*wt*t*ak*1.6606d-24)/h)**3
         htr=5.0d0*r*t/2.0d0
         cptr=5.0d0*r/2.0d0
         str=2.2868d0*(5.0d0*log10(t)+3.0d0*log10(wt))-2.3135d0
c   ***   construct totals   ***
         cptot=cptr+cpint
         stot=str+sint
         htot=htr+hint
c   ***   output section   ***
         if(ir.eq.1)then
            h298=htot
         else
            write(mfgw,'(/,i7,''  vib.'',g18.4
     1           ,13x,3f11.5        )')itemp,qv,  hv,  cpv,  sv
            write(mfgw,'(7x,''  rot.'',g13.3
     1           ,16x,3f11.3        )')      qr,  hr,  cpr,  sr
            write(mfgw,'(7x,''  int.'',g13.3
     1           ,16x,3f11.3        )')      qint,hint,cpint,sint
            write(mfgw,'(7x,''  tra.'',g13.3
     1           ,16x,3f11.3)')
     2                                      qtr, htr, cptr, str
            write(mfgw,'(7x,''  tot.'',13x,f17.3,f11.4,2f11.4)')
     1                     escf+(htot-h298)/1000.d0,htot,cptot,stot
         endif
   80 continue
      write(mfgw,
     +'(/3x,'' * note: heats of formation are relative to the'',
     1/12x,'' elements in their standard state at 298k'')')
      end
      subroutine moptim(nout,tim)
c
c     convert the time from seconds to days, hours, minutes, and seconds
c
      implicit REAL (a-h,o-z)
c
      REAL mins, minphr
c
c
      data hrspd /24.0d0/,    minphr /60.0d0/
      data secpd /86400.0d0/, secpmi /60.0d0/
c
      days = tim / secpd
      idays = idint(days)
      hours = (days - dfloat(idays)) * hrspd
      ihours = idint(hours)
      mins = (hours - dfloat(ihours)) * minphr
      imins = idint(mins)
      secs = (mins - dfloat(imins)) * secpmi
c
      if (idays .gt. 1) then
         write (nout,10) idays,ihours,imins,secs
      else if (idays .eq. 1) then
         write (nout,20) idays,ihours,imins,secs
      else if (ihours .gt. 0) then
         write (nout,30) ihours,imins,secs
      else if (imins .gt. 0) then
         write (nout,40) imins,secs
      else
         write (nout,50) secs
      end if
c
   10 format (10x,'computation time = ',i2,1x,'days',2x,i2,1x,'hours',
     1        1x,i2,1x,'minutes and',1x,f7.3,1x,'seconds')
   20 format (10x,'computation time = ',i2,1x,'day',2x,i2,1x,'hours',
     1        1x,i2,1x,'minutes and',1x,f7.3,1x,'seconds')
   30 format (10x,'computation time = ',i2,1x,'hours',
     1        1x,i2,1x,'minutes and',1x,f7.3,1x,'seconds')
   40 format (10x,'computation time = ',i2,1x,'minutes and',
     1        1x,f7.3,1x,'seconds')
   50 format (10x,'computation time = ',f7.3,1x,'seconds')
      end
      subroutine mopmat1(a,b,ncx,nr,ndim,iflag)
      implicit REAL (a-h,o-z)
      common /iofile/ mfgr,mfgw
INCLUDE(common/sizes)
      parameter (mxdim=maxpar+numatm)
      parameter (maxdim=max(maxorb,3*numatm))
      dimension a(nr,nr),b(ndim)
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),
     1                nlast(numatm), norbs, nelecs,nalpha,nbeta,
     2                nclose,nopen,ndumy,fract
      common /elemts/ elemnt(107)
      common /symres/ trans,rtr,sig,name,namo(mxdim),
     +                jndex(mxdim),ista(2)
      common /keywrd/ keywrd
      character*241 keywrd
      logical allprt
c**********************************************************************
c
c     mopmat1 prints a square matrix of eigenvectors and eigenvalues
c
c    on input a contains the matrix to be printed.
c             b contains the eigenvalues.
c             nc number of molecular orbitals to be printed.
c             nr is the size of the square array to be printed.
c             ndim is the actual size of the square array "a".
c             nfirst and nlast contain atom orbital counters.
c             nat = array of atomic numbers of atoms.
c
c
c     output type (row labeling)
c       iflag=1 : orbitals
c       iflag=2 : orbitals + symmetry-designators
c       iflag=3 : atoms
c       iflag=4 : numbers only
c       iflag=5 : vibrations + symmetry-designations
c
c
c***********************************************************************
      character*2 elemnt, atorbs(9), itext(maxdim), jtext(maxdim),xyz(3)
      dimension natom(maxdim)
      data xyz/' x',' y',' z'/
      data atorbs/'s ','px','py','pz','x2','xz','z2','yz','xz'/
c      -------------------------------------------------
      allprt=(index(keywrd,'allvec').ne.0)
      if(iflag.gt.2.and.iflag.ne.5) go to 30
      nc=ncx
      if(allprt) go to 1988
      nsave=ncx
      nfix=max(nalpha,nclose)
      if(iflag.eq.2.and.nc.gt.16) nc=nfix+7
      if(nc.gt.nsave) nc=nsave
 1988 continue
      if(numat.eq.0)  goto 30
      if(nlast(numat).ne.nr) goto 30
      do 20 i=1,numat
         jlo=nfirst(i)
         jhi=nlast(i)
         l=nat(i)
         k=0
         if(iflag.le.2) then
         do 10 j=jlo,jhi
            k=k+1
            itext(j)=atorbs(k)
            jtext(j)=elemnt(l)
            natom(j)=i
   10    continue
         else
        jhi=3*(i-1)
        do  15  j=1,3
        k=k+1
        itext(j+jhi)=xyz(j)
        jtext(j+jhi)=elemnt(l)
  15    natom(j+jhi)=i
      endif
   20 continue
      goto 50
   30 continue
      nr=iabs(nr)
      do  40 i=1,nr
      itext(i)='  '
      jtext(i)='  '
      if(iflag.eq.3) jtext(i)=elemnt(nat(i))
  40  natom(i)=i
   50 continue
      ka=1
      kc=8
      if(allprt) go to 1989
      if(iflag.eq.2.and.norbs.gt.16) ka=nfix-8
      if(ka.lt.1) ka=1
      if(iflag.eq.2.and.norbs.gt.16) kc=ka+7
 1989 continue
   60 kb=min(kc,nc)
      write(mfgw,100) (i,i=ka,kb)
      if  (iflag.eq.2.or.iflag.eq.5)
     *   write(mfgw,150) (jndex(i),namo(i),i=ka,kb)
      if(b(1).ne.0.d0) then
      if(iflag.eq.5) then
      write(mfgw,111) (b(i),i=ka,kb)
      else
      write(mfgw,110) (b(i),i=ka,kb)
      endif
      endif
      write(mfgw,120)
      la=1
      lc=40
   70 lb=min(lc,nr)
      do 80 i=la,lb
         if(itext(i).eq.' s')write(mfgw,120)
         write(mfgw,130) itext(i),jtext(i),natom(i),(a(i,j),j=ka,kb)
   80 continue
      if (lb.eq.nr) go to 90
      la=lc+1
      lc=lc+40
      go to 70
  90  if (kb.eq.nc) return
      ka=kc+1
      kc=kc+8
      go to 60
  100 format (//,2x,9h root no.,i5,9i8)
  110 format (/10x,10f8.3)
  111 format (/10x,10f8.1)
  120 format (2h  )
  130 format (1h ,2(1x,a2),i3,f8.4,10f8.4)
 150  format(/12x,10(i3,1x,a4))
      end
      subroutine mopmat (a,b,nc,nr,ndim)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      common /iofile/ mfgr,mfgw
      dimension a(ndim,ndim), b(ndim)
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),
     1                nlast(numatm), norbs, nelecs,nalpha,nbeta,
     2                nclose,nopen,ndumy,fract
      common /elemts/ elemnt(107)
c**********************************************************************
c
c      mopmat prints a square matrix of eigenvectors and eigenvalues
c
c    on input a contains the matrix to be printed.
c             b contains the eigenvalues.
c             nc number of molecular orbitals to be printed.
c             nr is the size of the square array to be printed.
c             ndim is the actual size of the square array "a".
c             nfirst and nlast contain atom orbital counters.
c             nat = array of atomic numbers of atoms.
c
c
c***********************************************************************
      character*2 elemnt, atorbs(9), itext(4*maxhev+3*maxlit),
     + jtext(4*maxhev+3*maxlit)
      dimension natom(4*maxhev+3*maxlit )
      save atorbs
      data atorbs/' s','px','py','pz','x2','xz','z2','yz','xy'/
      if(numat.eq.0)goto 30
      if(nlast(numat).ne.nr) goto 30
      do 20 i=1,numat
         jlo=nfirst(i)
         jhi=nlast(i)
         l=nat(i)
         k=0
         do 10 j=jlo,jhi
            k=k+1
            itext(j)=atorbs(k)
            jtext(j)=elemnt(l)
            natom(j)=i
   10    continue
   20 continue
      goto 50
   30 continue
      nr=iabs(nr)
      do 40 i=1,nr
         itext(i)='  '
         jtext(i)='  '
   40 natom(i)=i
   50 continue
      ka=1
      kc=6
   60 kb=min(kc,nc)
      write(mfgw,100) (i,i=ka,kb)
      if(b(1).ne.0.d0)write(mfgw,110) (b(i),i=ka,kb)
      write(mfgw,120)
      la=1
      lc=40
   70 lb=min(lc,nr)
      do 80 i=la,lb
         if(itext(i).eq.' s')write(mfgw,120)
         write(mfgw,130) itext(i),jtext(i),natom(i),(a(i,j),j=ka,kb)
   80 continue
      if (lb.eq.nr) go to 90
      la=lc+1
      lc=lc+40
      write(mfgw,140)
      go to 70
   90 if (kb.eq.nc) return
      ka=kc+1
      kc=kc+6
      if (nr.gt.25) write(mfgw,140)
      go to 60
c
  100 format (////,3x,9h root no.,i5,9i12)
  110 format (/8x,10f12.5)
  120 format (2h  )
  130 format (2(1x,a2),i4,f10.5,10f12.5)
  140 format (1h1)
c
      end
      subroutine mopupd(iparam, ielmnt, param, kfn)
      implicit REAL (a-h,o-z)
      common /iofile/ mfgr,mfgw
************************************************************************
*
*  mopupd updates the common blocks which hold all the parameters for
*         running mndo.
*         iparam refers to the type of parameter,
*         ielmnt refers to the element,
*         param is the value of the parameter, and
*
************************************************************************
      common /mndo/ 
     +    ussm(107), uppm(107), uddm(107), zsm(107),zpm(107),
     1zdm(107), betasm(107), betapm(107), betadm(107), alpm(107),
     2eisolm(107), ddm(107), qqm(107), amm(107), adm(107), aqm(107)
     3,gssm(107),gspm(107),gppm(107),gp2m(107),hspm(107), polvom(107)
      common /expont/ zs(107),zp(107),zd(107)
      common /cmporb/ natorb(107)
      common /betas/ betas(107),betap(107),betad(107)
      common /vsips/ vs(107),vp(107),vd(107)
      common /cmpone/ uss(107),upp(107),udd(107)
      common /multip/ dd(107),qq(107),am(107),ad(107),aq(107)
      common /twoele/ gss(107),gsp(107),gpp(107),gp2(107),hsp(107)
     7                ,gsd(107),gpd(107),gdd(107)
      common /alpha/ alp(107)
      common /ideas/ guess1(107,10), guess2(107,10), guess3(107,10)
      common /cmpga/ fn1(107),fn2(107)
      goto
     1(10,20,30,40,50,60,70,80,90,100,110,120,130,140,150,160,170,180,
     2190,200,210,220,230,240,250),iparam
   10 uss (ielmnt)=param
      ussm(ielmnt)=param
      return
   20 upp (ielmnt)=param
      uppm(ielmnt)=param
      return
   30 udd (ielmnt)=param
      uddm(ielmnt)=param
      return
   40 zs (ielmnt)=param
      zsm(ielmnt)=param
      return
   50 zp (ielmnt)=param
      zpm(ielmnt)=param
      return
   60 zd (ielmnt)=param
      zdm(ielmnt)=param
      return
   70 betas (ielmnt)=param
      betasm(ielmnt)=param
      return
   80 betap (ielmnt)=param
      betapm(ielmnt)=param
      return
   90 betad (ielmnt)=param
      betadm(ielmnt)=param
      return
  100 gss (ielmnt)=param
      gssm(ielmnt)=param
      return
  110 gsp (ielmnt)=param
      gspm(ielmnt)=param
      return
  120 gpp (ielmnt)=param
      gppm(ielmnt)=param
      return
  130 gp2 (ielmnt)=param
      gp2m(ielmnt)=param
      return
  140 hsp (ielmnt)=param
      hspm(ielmnt)=param
      return
  150 return
  160 return
  170 return
  180 alp (ielmnt)=param
      alpm(ielmnt)=param
      return
  190 return
  200 return
  210 return
  220 guess1(ielmnt,kfn)=param
      return
  230 guess2(ielmnt,kfn)=param
      return
  240 guess3(ielmnt,kfn)=param
      return
  250 natorb(ielmnt)=param
      i=idint(param+0.5d0)
      if(i.ne.9.and.i.ne.4.and.i.ne.1)then
         write(mfgw,
     +   '(///10x,'' unacceptable value for no. of orbitals'',
     1'' on atom'')')
_IF(ipsc,tools)
         call pend
_ELSE
         stop
_ENDIF
      endif
      end
      subroutine mopx(c,n,mdim,nocc,ifill)
      implicit  REAL (a-h,o-z)
INCLUDE(common/sizes)
      common /iofile/ mfgr,mfgw
      dimension c(mdim,mdim)
c******************************************************************
c
c        mopx ensures that a named molecular orbital ifill is filled
c on input
c          c = eigenvectors in a mdim*mdim matrix
c          n = number of orbitals
c          nocc = number of occupied orbitals
c          ifill = filled orbital
c******************************************************************
      common /swap0/ psi(maxorb), stdpsi(maxorb)
      if(ifill.gt.0) goto 20
c
c     we now define the filled orbital
c
      ifill=-ifill
      do 10 i=1,n
         stdpsi(i)=c(i,ifill)
   10 psi(i)=c(i,ifill)
      return
   20 continue
c
c     first find the location of ifill
c
      sum=0.0d0
      do 30 i=1,n
   30 sum=sum+psi(i)*c(i,ifill)
      if(dabs(sum).gt.0.7071d0) goto 90
c
c     ifill has moved!
c
      summax=0.0d0
      do 50 ifill=1,n
         sum=0.0d0
         do 40 i=1,n
   40    sum=sum+stdpsi(i)*c(i,ifill)
         sum=dabs(sum)
         if(sum.gt.summax)jfill=ifill
         if(sum.gt.summax)summax=sum
         if(sum.gt.0.7071d0) goto 90
   50 continue
      do 70 ifill=1,n
         sum=0.0d0
         do 60 i=1,n
   60    sum=sum+psi(i)*c(i,ifill)
         sum=dabs(sum)
         if(sum.gt.summax)jfill=ifill
         if(sum.gt.summax)summax=sum
         if(sum.gt.0.7071d0) goto 90
   70 continue
      write(mfgw,80)summax,jfill
   80 format(/,' caution !!! sum in swap very small, summax =',f10.5,
     1' jfill=',i3)
      ifill=jfill
   90 continue
      if(ifill.le.nocc) return
c
c    its empty, so swap it with the highest filled
c
      do 100 i=1,n
         x=c(i,nocc)
         c(i,nocc)=c(i,ifill)
         c(i,ifill)=x
  100 continue
      return
      end
      subroutine mopxyz(xyz,numat,na,nb,nc,degree,geo)
      implicit REAL (a-h,o-z)
      dimension xyz(3,*), na(*), nb(*), nc(*), geo(3,*)
***********************************************************************
*
* mopxyz works out the internal coordinates of a molecule.
*        the "rules" for the connectivity are as follows:
*        atom i is defined as being at a distance from the nearest
*        atom j, atom j already having been defined.
*        atom i makes an angle with atom j and the atom k, which has
*        already been defined, and is the nearest atom to j
*        atom i makes a dihedral angle with atoms j, k, and l. l having
*        been defined and is the nearest atom to k, and j, k and l
*        have a contained angle in the range 15 to 165 degrees,
*        if possible.
*
*        if(na(2).eq.-1 or -2 then the original connectivity is used.
*
*        note that geo and xyz must not be the same in the call.
*
*   on input xyz    = cartesian array of numat atoms
*            degree = 1 if angles are to be in radians
*            degree = 57.29578 if angles are to be in degrees
*
***********************************************************************
      common /geook/ igeook
      common /numcal/ numcal
      save icalcn
      data icalcn/0/
      igeook=99
      if(.not.(icalcn.ne.numcal).and.na(2).eq.-1 .or. na(2).eq.-2)then
         na(2)=1
         do 10 i=2,numat
            j=na(i)
            if(i.gt.3)call dihed(xyz,i,j,nb(i),nc(i),geo(3,i))
            if(i.gt.2)call bangle(xyz,i,j,nb(i),geo(2,i))
            geo(1,i)=dsqrt((xyz(1,i)-xyz(1,j))**2+
     +                     (xyz(2,i)-xyz(2,j))**2+
     +                     (xyz(3,i)-xyz(3,j))**2)
   10    continue
      else
         if(na(2).eq.-1)icalcn=numcal
         do 30 i=1,numat
            na(i)=2
            nb(i)=3
            nc(i)=4
            im1=i-1
            if(im1.eq.0)goto 30
            sum=1.d30
            do 20 j=1,im1
               r=(xyz(1,i)-xyz(1,j))**2+
     1          (xyz(2,i)-xyz(2,j))**2+
     2          (xyz(3,i)-xyz(3,j))**2
               if(r.lt.sum.and.na(j).ne.j.and.nb(j).ne.j) then
                  sum=r
                  k=j
               endif
   20       continue
c
c   atom i is nearest to atom k
c
            na(i)=k
            if(i.gt.2)nb(i)=na(k)
            if(i.gt.3)nc(i)=nb(k)
c
c   find any atom to relate to na(i)
c
   30    continue
      endif
      na(1)=0
      nb(1)=0
      nc(1)=0
      nb(2)=0
      nc(2)=0
      nc(3)=0
      call xyzgeo(xyz,numat,na,nb,nc,degree,geo)
      return
      end
      subroutine mpcpop(c,icok)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      common /iofile/ mfgr,mfgw
c
c   this routine calculates the total mulliken populations on the
c   atoms by summing the diagonal elements from the  mulliken
c   population analysis.
c
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),
     1                nlast(numatm), norbs, nelecs,nalpha,nbeta,
     2                nclose,nopen,ndumy,fract
      common /corec/ core(107)
      dimension c(morb2),pop(numatm),chrg(numatm)
      write(16,'(i4,5x,'' mulliken population and charge'')',err=40)icok
c
c icok = 1 ==> print populations
c icok = 0 ==> keyword mulliken = .f.
c         no population analysis performed
c
      if (icok.ne.0) then
         do 20 i = 1,numat
            if = nfirst(i)
            il = nlast(i)
            sum = 0.0d0
            pop(i) = 0.0d0
            chrg(i) = 0.0d0
            do 10 j = if,il
c
c    diagonal element of mulliken matrix
c
               sum = sum + c((j*(j+1))/2)
   10       continue
            k = nat(i)
c
c    mulliken population for i'th atom
c
            pop(i) = sum
            chrg(i) = core(k) - pop(i)
   20    continue
         write(mfgw,'(///10x,''mulliken populations and charges'')')
         do 30 j = 1,numat
            write(mfgw,60) j, pop(j), chrg(j)
            write(16,70,err=40) pop(j), chrg(j)
   30    continue
      endif
      return
   40 write(mfgw,'(a)') 'error writing sybyl mulliken population output'
      return
   50 format(//,5x,'atom',8x,'population',6x,'charge')
   60 format(5x,i4,4x,f11.6,6x,f11.6)
   70 format(2f12.6)
      end
c
c this routine writes out the optimized geometry and atomic charges
c   for a mopac run.
c
      subroutine mpcsyb(numat,coord,chr,icok,eigs,nclose,funct
     1                       ,eionis,kchrge,dip)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      common /iofile/ mfgr,mfgw
      dimension coord(3, numat), chr(numat),eigs(maxorb)
c  write out the charge flag and number of atoms
      write(16,'(2i4)', err=30) icok,numat
c  write out the coordinates and charges
      do 10 i=1, numat
         write(16,'(4f12.6)', err=30) (coord(j, i), j=1, 3), chr(i)
   10 continue
      i1 = max(1,nclose - 1)
      i2 = min(maxorb,nclose + 2)
c
c  write out the 2 highest and 2 lowest orbital energies
c
      write(16,20,err=30)(eigs(j),j=i1,i2),nclose
   20 format(4f12.6,2x,i4,2x,'homos,lumos,# of occupied mos')
c
c  write out the heat of formation and ionisation potential
c
      write(16,'(2f12.6,4x,''hf and ip'')',err=30) funct,eionis
c
c  write out the dipole moment
c
      if(kchrge.ne.0) dip = 0.0d0
      write(16, '(i4,f10.3,''  charge,dipole moment'')', err=30)
     1kchrge, dip
      return
   30 write(mfgw,'(a)') 'error writing sybyl mopac output'
      return
      end
      subroutine mtxm (a,nar,b,nbr,c,ncc)
      implicit REAL (a-h,o-z)
c     matrix product c(nar,ncc) = (a(nbr,nar))' * b(nbr,ncc)
c     all matrices rectangular , packed.
      dimension a(nbr,nar),b(nbr,ncc),c(nar,ncc)
      do 20 j=1,ncc
         do 10 i=1,nar
   10    c(i,j)=0.0d0
         do 20 k=1,nbr
            do 20 i=1,nar
   20 c(i,j)=c(i,j)+a(k,i)*b(k,j)
      return
      end
      subroutine mtxmc (a,nar,b,nbr,c)
      implicit REAL (a-h,o-z)
c     matrix product c(nar,nar) = (a(nbr,nar))' * b(nbr,nar)
c     a and b rectangular , packed,
c     c lower left triangle only, packed in canonical order.
      dimension a(nbr,nar),b(nbr,nar),c(*)
c  note ... this is the best version on cray 1.
      l=1
      do 10 i=1,nar
         call mxm (a(1,i),1,b,nbr,c(l),i)
   10 l=l+i
      return
      end
      subroutine mullik(c,h,f,norbs,vecs,store)
      implicit REAL (a-h,o-z)
_IF(ipsc,tools)
      logical oroot
_ENDIF
INCLUDE(common/sizes)
INCLUDE(../m4/common/utilc)
      dimension c(*), h(*), vecs(*), store(*), f(*)
**********************************************************************
*
*  mullik does a mulliken population analysis
* on input     c      =  square array of eigenvectors.
*              h      =  packed array of one-electron matrix
*              f      =  workstore of size at least norbs*norbs
*              vecs   =  workstore of size at least norbs*norbs
*              store  =  workstore of size at least (norbs*(norbs+1))/2
*
**********************************************************************
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),
     2                nlast(numatm), norbx, nelecs,nalpha,nbeta,
     3                nclose,nopen,ndumy,fract
      common /keywrd/ keywrd
      common /betas/ betas(107),betap(107),betad(107)
      common /cmpg/ geo(3,numatm)
      common /expont/ zs(107),zp(107),zd(107)
c     patas
      common /mstq/ qs(1500),mflag
c     patas
      character keywrd*241, getmop*80
      logical graph
c     patas
      logical mep
      logical tom
c     patas
**********************************************************************
*
*  first, re-calculate the overlap matrix
*
**********************************************************************
      dimension eigs(maxorb), ifact(maxorb), xyz(3,numatm)
      graph=(index(keywrd,'graph').ne.0)
c     patas
      mep=(index(keywrd,'mep=').ne.0)
      tom=(index(keywrd,'tom').ne.0)
c     patas
      do 10 i=1,norbs
   10 ifact(i)=(i*(i-1))/2
      ifact(norbs+1)=(norbs*(norbs+1))/2
      do 50 i=1,numat
         if=nfirst(i)
         il=nlast(i)
         im1=i-1
         bi=betas(nat(i))
         do 50 k=if,il
            ii=(k*(k-1))/2
            do 30 j=1,im1
               jf=nfirst(j)
               jl=nlast(j)
               bj=betas(nat(j))
               do 20 jj=jf,jl
                  ij=ii+jj
                  h(ij)=2.d0*h(ij)/(bi+bj)     +1.d-14
c  the  +1.d-14 is to prevent possible errors in the diagonalization.
                  store(ij)=h(ij)
   20          bj=betap(nat(j))
   30       continue
            do 40 jj=if,k
               ij=ii+jj
               store(ij)=0.0d0
   40       h(ij)=0.0d0
   50 bi=betap(nat(i))
      do 60 i=1,norbs
         store(ifact(i+1))=1.d0
   60 h(ifact(i+1))=1.d0
      call rsp(h,norbs,norbs,eigs,vecs)
      do 70 i=1,norbs
   70 eigs(i)=1.d0/dsqrt(dabs(eigs(i)))
      ij=0
      do 90 i=1,norbs
         do 90 j=1,i
            ij=ij+1
            sum=0.0d0
            do 80 k=1,norbs
   80       sum=sum+vecs(i+(k-1)*norbs)*eigs(k)
     1                *vecs(j+(k-1)*norbs)
            f(i+(j-1)*norbs)=sum
   90 f(j+(i-1)*norbs)=sum
c     patas
      if (tom.and.mflag.ne.3) go to 333
c     patas
      if (graph) then
         call gmetry(geo,xyz)
*
* write to disk the following data for graphics calculation, in order:
*
*      number of atoms, orbital, electrons
*      all atomic coordinates
*      orbital counters
*      orbital exponents, s, p, and d, and atomic numbers
*      eigenvectors (m.o.s not re-normalized)
*      inverse-square root of the overlap matrix.
*
_IF(ipsc,tools)
       if(oroot().and.odumpm) then
_ELSE
       if(odumpm) then
_ENDIF
      open(unit=13,file=getmop(7),form='unformatted',
     +status='new',err=31)
      goto 32
  31  open(unit=13,file=getmop(7),status='old',
     +form='unformatted')
  32  continue
         write(13)numat,norbs,nelecs,((xyz(i,j),j=1,numat),i=1,3)
         write(13)(nlast(i),nfirst(i),i=1,numat)
         write(13)(zs(nat(i)),i=1,numat),(zp(nat(i)),i=1,numat),
     1         (zd(nat(i)),i=1,numat),(nat(i),i=1,numat)
         linear=norbs*norbs
         write(13)(c(i),i=1,linear)
         write(13)(f(i),i=1,linear)
       endif
         if(index(keywrd,'mullik').eq.0)return
      endif
c     patas
  333 continue
c     patas
*
* otherwise perform mulliken analysis
*
      call mult(c,f,vecs,norbs)
c     patas
      if (mep) return
      if (tom) return
c     patas
      i=-1
      call densit(vecs,norbs,norbs,nclose,nopen,fract,c,2)
      linear=(norbs*(norbs+1))/2
      do 100 i=1,linear
  100 c(i)=c(i)*store(i)
      summ=0.0d0
      do 130 i=1,norbs
         sum=0
         do 110 j=1,i
  110    sum=sum+c(ifact(i)+j)
         do 120 j=i+1,norbs
  120    sum=sum+c(ifact(j)+i)
         summ=summ+sum
  130 c(ifact(i+1))=sum
      call vecprt(c,norbs)
      return
      end
      subroutine mult(c,s,vecs,n)
      implicit REAL (a-h,o-z)
      dimension c(n,*), s(n,*), vecs(n,*)
***********************************************************************
*
*   mult is used in the mulliken analysis only. it performs the
*        operation:-
*                                   vecs=back-transformed eigenvectors
*        vecs  =  c*s               c   =un-back-transformed vectors
*                                   s   =1/sqrt(overlap matrix)
*
***********************************************************************
      do 20 i=1,n
         do 20 j=1,n
            sum=0.0d0
            do 10 k=1,n
   10       sum=sum+c(k,i)*s(j,k)
   20 vecs(j,i)=sum
      return
      end
_IF()
      subroutine mxm(a,nar,b,nbr,c,ncc)
      implicit REAL (a-h,o-z)
c     rectangular matrix product c=a*b.
c     each matrix is entirely fullfilled and packed.
c     simulate routine on cray (same name and calling sequence).
      dimension a(nar,nbr),b(nbr,ncc),c(nar,ncc)
      do 20 j=1,ncc
         do 10 i=1,nar
   10    c(i,j)=0.0d0
         do 20 k=1,nbr
            do 20 i=1,nar
   20 c(i,j)=c(i,j)+a(i,k)*b(k,j)
      return
      end
_ENDIF
      function myword(keywrd,testwd)
      logical myword
      character keywrd*(*), testwd*(*)
      myword=.false.
   10 j=index(keywrd,testwd)
      if(j.ne.0)then
   20    if(keywrd(j:j).ne.' ')goto 30
         j=j+1
         goto 20
   30    myword=.true.
         do 60 k=j,241
            if(keywrd(k:k).eq.'='.or.keywrd(k:k).eq.' ') then
c
c     check for attached '=' sign
c
               j=k
               if(keywrd(j:j).eq.'=')goto 50
c
c     check for separated '=' sign
c
               do 40 j=k+1,241
                  if(keywrd(j:j).eq.'=') goto 50
   40          if(keywrd(j:j).ne.' ')goto 10
c
c    there is no '=' sign associated with this keyword
c
               goto 10
   50          keywrd(j:j)=' '
c
c   there must be a number after the '=' sign, somewhere
c
               goto 20
            endif
   60    keywrd(k:k)=' '
      endif
      return
      end
      subroutine naicap(isc,is,ip,npr,nc,ipe,ipx,icd)
      implicit REAL (a-h,o-z)
_IF(ipsc,tools)
      logical oroot
_ENDIF
c***********************************************************************
c     this routine evaluates (p|p) nuclear attraction integrals over
c
c     a sto-ng basis set.
c     written by b.h. besler at ford scientific research labs in
c     sept. 1989
c
c     on input:  ic = loop index of the gaussian
c                icd = contraction depth of basis set
c                iesp = loop index of the esp point
c                is = number os s primitives
c                ipe = index of last px primitive
c                ipx = number of px primitives
c                is = number os s primitives
c                isc = number of contracted
c                npr = number of primitives
c                nc = number of contracted functions
c
c
c     for more info see: obara&saika j.chem.phys. 1986,84,3963.
c***********************************************************************
INCLUDE(../m4/common/utilc)
INCLUDE(common/sizes)
      common /iofile/ mfgr,mfgw
      REAL nai,nai1,nai2
      character*80 getmop
      character*241 keywrd
      common /keywrd/ keywrd
      common/espf/ al((numatm+4)**2),a(numatm,numatm),b(numatm),
     1q(numatm+4),cespm(maxorb,maxorb)
      common /indx/ indc(maxorb)
      common /densty/ p(mpack),pa(mpack),pb(mpack)
      common /potesp/ xc,yc,zc,espnuc,espele,nesp
      common /abc/    co(3,numatm),ian(numatm),natom
      common /work1/  potpt(3,mesp), es(mesp), esp(mesp), work1d(2*mesp)
      common /expont/ zs(107),zp(107),zd(107)
      common /sto6g/  allc(6,5,2),allz(6,5,2)
      common /espc/ cc(maxpr),cen(maxpr,3),iam(maxpr,2),ind(maxpr),
     1ex(maxpr),espi(maxorb,maxorb),fv(0:8,821),
     2fac(0:7),dex(-1:96),tf(0:2),
     3temp(maxpr),itemp(maxpr),ovl(maxorb,maxorb),exsr(maxpr,6)
      common/x/ dx(maxpr),dy(maxpr),dz(maxpr),f1(maxpr,6),f2(maxpr,6),
     1td(maxpr),ce(maxpr,6),u(maxpr,6),exs(maxpr,6),expn(maxpr,6),
     2nai(maxpr,6),ewcx(maxpr,6),ewcy(maxpr,6),ewcz(maxpr,6),f0(maxpr,6)
     3,nai1(maxpr,6),nai2(maxpr,6)
      common/fp/ pf0(maxhes),pf1(maxhes),pf2(maxhes),id(maxpar),
     1pexs(maxhes),pce(maxhes),pexpn(maxhes),ptd(maxhes),
     2pewcx(maxhes),pewcy(maxhes),pewcz(maxhes),ird(maxhes)
      data bohr/0.529167d0/
c     set number of equally spaced dumps
      idn=10
c
      idc=0
      write(mfgw,*)
      ipx2=2*ipx
      pi=4.d0*datan(1.d0)
      np=is+1
c     setup index array
      do 10 i=np,ipe
         ird(i)=i-is
         ird(i+ipx)=i-is
         ird(i+ipx2)=i-is
   10 continue
c
c     calculate quantities invariant with esp point for
c     (p|p) esp integrals
c
      il=l
      l=0
      do 30 i=np,ipe
         do 20 j=i,ipe
            l=l+1
            ptd(l)=(cen(i,1)-cen(j,1))**2+(cen(i,2)-cen(j,2))**2+
     1(cen(i,3)-cen(j,3))**2
            pexs(l)=1.d0/(ex(i)+ex(j))
            pce(l)=ex(i)*ex(j)*pexs(l)
            pexpn(l)=dexp(-pce(l)*ptd(l))
            pewcx(l)=(ex(i)*cen(i,1)+ex(j)*cen(j,1))*pexs(l)
            pewcy(l)=(ex(i)*cen(i,2)+ex(j)*cen(j,2))*pexs(l)
            pewcz(l)=(ex(i)*cen(i,3)+ex(j)*cen(j,3))*pexs(l)
   20    continue
c
c     set up other index array for packed symmetric array
c     storage
c
         id(i-is)=l-ipx
   30 continue
c
c     read in restart information if this is a restart
c
      if(index(keywrd,'esprst') .ne. 0) then
_IF(ipsc,tools)
       if(oroot()) then
_ENDIF
         open(unit=15,file=getmop(13),status='unknown'
     1,form='unformatted')
c        open(unit=15,file='esp.dump',status='unknown',form='unformatted
c    1')
         read(15) jstart,iesps
         if(jstart .ne. isc*2) then
            iesps=0
            close(15)
            goto 50
         endif
         do 40 i=1,nesp
            read(15) es(i)
   40    continue
         close(15)
         idc=dfloat(iesps)/dfloat(nesp)*10
_IF(ipsc,tools)
        else
         write(mfgw,*)' restarts not available in esprst'
         call pend
        endif
_ENDIF
      else
         iesps=0
      endif
   50 continue
c
c     loop over esp probe points
c
      do 250 iesp=iesps+1,nesp
         potp1=potpt(1,iesp)/bohr
         potp2=potpt(2,iesp)/bohr
         potp3=potpt(3,iesp)/bohr
c     calculate quantity u
c
         l=0
         do 60 i=np,ipe
            do 60 j=i,ipe
               l=l+1
               ptd(l)=((pewcx(l)-potp1)**2+(pewcy(l)-potp2)**2+
     1      (pewcz(l)-potp3)**2)/pexs(l)
               pce(l)=dsqrt(pi/ptd(l))
   60    continue
c
c     calculate f0, f1, and f2(u) using taylor series
c     or asymptotic expansion
c
         il=l
         l=0
         do 100 i=1,il
            if(ptd(i) .le. tf(0)) then
               iref=dnint(ptd(i)*20.d0)
               ref=0.05d0*iref
               res=ptd(i)-ref
               term=1.d0
               pf0(i)=0.0d0
               do 70 k=0,6
                  f=fv(k,iref+1)
                  ts=f*term*fac(k)
                  term=-term*res
                  pf0(i)=pf0(i)+ts
   70          continue
            else
               pf0(i)=pce(i)*0.5d0
            endif
            if(ptd(i) .le. tf(1)) then
               iref=dnint(ptd(i)*20.d0)
               ref=0.05d0*iref
               res=ptd(i)-ref
               term1=1.d0
               pf1(i)=0.0d0
               do 80 k=0,6
                  fi=fv(k+1,iref+1)
                  ts1=fi*term1*fac(k)
                  term1=-term1*res
                  pf1(i)=pf1(i)+ts1
   80          continue
            else
               pf1(i)=pce(i)*0.25d0/ptd(i)
            endif
            if(ptd(i) .le. tf(2)) then
               iref=dnint(ptd(i)*20.d0)
               ref=0.05d0*iref
               res=ptd(i)-ref
               term2=1.d0
               pf2(i)=0.0d0
               do 90 k=0,6
                  fii=fv(k+2,iref+1)
                  ts2=fii*term2*fac(k)
                  term2=-term2*res
                  pf2(i)=pf2(i)+ts2
   90          continue
            else
               pf2(i)=pce(i)*0.375d0/(ptd(i)*ptd(i))
            endif
  100    continue
c
c     calculate (s||s) type integrals
c
         do 110 i=1,il
            pf0(i)=2.d0*pi*pexs(i)*pexpn(i)*pf0(i)
            ptd(i)=pf0(i)
            pf1(i)=2.d0*pi*pexs(i)*pexpn(i)*pf1(i)
            pf2(i)=2.d0*pi*pexs(i)*pexpn(i)*pf2(i)
  110    continue
c
         do 230 ic=isc+1,nc
            ipr=ic*icd-icd+1
            istart=ipr
            do 200 j=1,icd
c
c     calculate (p||s) esp integrals
c
               if((iam(ipr,1) .eq. 1) .and. (is .ne. ip)) then
                  do 150 i=istart,npr
                     in=ipr+j-1
                     ir=ird(i)+id(ird(in))
                     ir2=id(ird(i))+ird(in)
                     if(ir2 .le. ir ) ir=ir2
                     go to (120,130,140),iam(in,2)
  120                nai2(i,j)=(pewcx(ir)-cen(in,1))*pf1(ir)-pf2(ir)*
     1      (pewcx(ir)-potp1)
                     nai(i,j)=(pewcx(ir)-cen(in,1))*pf0(ir)-pf1(ir)*
     1      (pewcx(ir)-potp1)
                     go to 150
  130                nai2(i,j)=(pewcy(ir)-cen(in,2))*pf1(ir)-pf2(ir)*
     1      (pewcy(ir)-potp2)
                     nai(i,j)=(pewcy(ir)-cen(in,2))*pf0(ir)-pf1(ir)*
     1      (pewcy(ir)-potp2)
                     go to 150
  140                nai2(i,j)=(pewcz(ir)-cen(in,3))*pf1(ir)-pf2(ir)*
     1      (pewcz(ir)-potp3)
                     nai(i,j)=(pewcz(ir)-cen(in,3))*pf0(ir)-pf1(ir)*
     1      (pewcz(ir)-potp3)
  150             continue
               endif
c
c     calculate (p||p) esp integrals
c
               if((iam(ipr,1) .eq. 1) .and. (is .ne. ip)) then
                  do 190 i=istart,npr
                     in=ipr+j-1
                     ir=ird(i)+id(ird(in))
                     ir2=id(ird(i))+ird(in)
                     if(ir2 .le. ir ) ir=ir2
                     go to (160,170,180),iam(i,2)
  160                nai(i,j)=(pewcx(ir)-cen(i,1))*nai(i,j)-(pewcx(ir)-
     +               potp1)*      nai2(i,j)
                     if(iam(in,2) .eq. iam(i,2)) nai(i,j)=nai(i,j)+pexs(
     1ir)*      0.5d0*(ptd(ir)-pf1(ir))
                     go to 190
  170                nai(i,j)=(pewcy(ir)-cen(i,2))*nai(i,j)-(pewcy(ir)-
     +               potp2)*      nai2(i,j)
                     if(iam(in,2) .eq. iam(i,2)) nai(i,j)=nai(i,j)+pexs(
     1ir)*      0.5d0*(ptd(ir)-pf1(ir))
                     go to 190
  180                nai(i,j)=(pewcz(ir)-cen(i,3))*nai(i,j)-(pewcz(ir)-
     +               potp3)*      nai2(i,j)
                     if(iam(in,2) .eq. iam(i,2)) nai(i,j)=nai(i,j)+pexs(
     1ir)*      0.5d0*(ptd(ir)-pf1(ir))
  190             continue
               endif
  200       continue
c
c     form integrals over contracted functions
c
            ips=ic*icd-icd+1
            do 220 i=ic,nc
               jps=i*icd-icd+1
               espi(i,ic)=0.0d0
               do 210 j=jps,jps+icd-1
                  do 210 k=ips,ips+icd-1
                     espi(i,ic)=espi(i,ic)+cc(j)*cc(k)*nai(j,k-ips+1)
  210          continue
               es(iesp)=es(iesp)+2.d0*cespm(indc(i),indc(ic))*espi(i,ic)
  220       continue
            es(iesp)=es(iesp)-cespm(indc(ic),indc(ic))*espi(ic,ic)
  230    continue
c
c     write out restart information every nesp/10 points
c
_IF(ipsc,tools)
         if(mod(iesp,nesp/idn) .eq. 0 .and. oroot() .and. odumpm) then
_ELSE
         if(mod(iesp,nesp/idn) .eq. 0 .and. odumpm) then
_ENDIF
            open(unit=15,file=getmop(13),status='unknown',
     1form='unformatted')
            jstart=isc*2
            write(15) jstart,iesp
            do 240 i=1,nesp
               write(15) es(i)
  240       continue
            close(15)
            idc=idc+1
            write(mfgw,'(a,f6.2,a)')
     1'naicap dumped: ',100.d0/idn*idc,' percent complete'
         endif
  250 continue
      return
      end
      subroutine naicas(isc,is,ip,npr,nc,ipe,ipx,icd)
      implicit REAL (a-h,o-z)
_IF(ipsc,tools)
      logical oroot
_ENDIF
c***********************************************************************
c
c     this routine evaluates (s|s) , (s|p) type nuclear attraction
c     integrals for a sto-ng basis set
c     written by b.h. besler at ford scientific research labs in
c     december 1989.
c
c     on input:  ic = loop index of the gaussian
c                iesp = loop index of the esp point
c                ipe = index of last px primitive
c                ipx = number of px primitives
c                is = number os s orbitals
c                isc = number of contracted s orbitals
c                ip = number of p orbitals
c                npr = number of primitives
c                nc = number of contracted functions
c
c
c     for more info see: obara&saika j.chem.phys. 1986,84,3963.
c***********************************************************************
INCLUDE(common/sizes)
INCLUDE(../m4/common/utilc)
      common /iofile/ mfgr,mfgw
      REAL nai,nai1,nai2
      character*80 getmop
      character*241 keywrd
      common/keywrd/ keywrd
      common/espf/ al((numatm+4)**2),a(numatm,numatm),b(numatm),
     1q(numatm+4),cespm(maxorb,maxorb)
      common /indx/ indc(maxorb)
      common /densty/ p(mpack),pa(mpack),pb(mpack)
      common /potesp/ xc,yc,zc,espnuc,espele,nesp
      common /abc/    co(3,numatm),ian(numatm),natom
      common /work1/  potpt(3,mesp), es(mesp), esp(mesp), work1d(2*mesp)
      common /expont/ zs(107),zp(107),zd(107)
      common /sto6g/  allc(6,5,2),allz(6,5,2)
      common /espc/ cc(maxpr),cen(maxpr,3),iam(maxpr,2),ind(maxpr),
     1ex(maxpr),espi(maxorb,maxorb),fv(0:8,821),
     2fac(0:7),dex(-1:96),tf(0:2),
     3temp(maxpr),itemp(maxpr),ovl(maxorb,maxorb),exsr(maxpr,6)
      common/x/ dx(maxpr),dy(maxpr),dz(maxpr),f1(maxpr,6),f2(maxpr,6),
     1td(maxpr),ce(maxpr,6),u(maxpr,6),exs(maxpr,6),expn(maxpr,6),
     2nai(maxpr,6),ewcx(maxpr,6),ewcy(maxpr,6),ewcz(maxpr,6),f0(maxpr,6)
     3,nai1(maxpr,6),nai2(maxpr,6)
      data bohr/0.529167d0/
c
c     calculate distance arrays
c
      write(mfgw,*)
      pi=4.d0*datan(1.d0)
      ipx2=2*ipx
c     if this is a restart run, read in restart info
      if(index(keywrd,'esprst') .ne. 0) then
_IF(ipsc,tools)
       if(oroot()) then
_ENDIF
         if(odumpm) then
         open(unit=15,file=getmop(13),status='unknown'
     1,form='unformatted')
         endif
         read(15) jstart,iesps
         if(jstart .eq. isc*2) then
            close(15)
            return
         endif
         do 10 i=1,nesp
            read(15) es(i)
   10    continue
         close(15)
c
         jstart=jstart+1
_IF(ipsc,tools)
       else
        write(mfgw,*)' restarts not available in naicas'
        call pend
       endif
_ENDIF
      else
         jstart=1
      endif
      np=is+1
      do 200 ic=jstart,isc
         ipr=ic*icd-icd+1
         istart=ipr
         do 20 i=istart,ipe
            dx(i)=cen(ipr,1)-cen(i,1)
            dy(i)=cen(ipr,2)-cen(i,2)
            dz(i)=cen(ipr,3)-cen(i,3)
            td(i)=dx(i)**2+dy(i)**2+dz(i)**2
   20    continue
c
c     calculate exponent sum
c
         do 30 i=istart,ipe
            do 30 j=1,icd
               exsr(i,j)=ex(ipr+j-1)+ex(i)
               exs(i,j)=1.d0/exsr(i,j)
               ce(i,j)=ex(ipr+j-1)*ex(i)*exs(i,j)
               expn(i,j)=dexp(-ce(i,j)*td(i))
   30    continue
c
c     calculate exponent weighted centers
c
         do 40 i=istart,ipe
            do 40 j=1,icd
               ewcx(i,j)=(ex(i)*cen(i,1)+ex(ipr+j-1)
     1*cen(ipr+j-1,1))*exs(i,j)
               ewcy(i,j)=(ex(i)*cen(i,2)+ex(ipr+j-1)
     1*cen(ipr+j-1,2))*exs(i,j)
               ewcz(i,j)=(ex(i)*cen(i,3)+ex(ipr+j-1)
     1*cen(ipr+j-1,3))*exs(i,j)
   40    continue
c
c     begin loop over esp points
c
         do 180 iesp=1,nesp
            potp1=potpt(1,iesp)/bohr
            potp2=potpt(2,iesp)/bohr
            potp3=potpt(3,iesp)/bohr
c
c     begin loop over components of contracted function ic
c
            do 150 j=1,icd
c
c     calculate distance between exponent weighted and probe point
c
               do 50 i=istart,ipe
                  u(i,j)=((ewcx(i,j)-potp1)**2+(ewcy(i,j)-potp2)**2+
     1      (ewcz(i,j)-potp3)**2)*exsr(i,j)
                  nai(i,j)=dsqrt(pi/u(i,j))
   50          continue
c
c     calculate esp integrals
c
               do 70 i=istart,ipe
                  if(u(i,j) .le. tf(0)) then
                     iref=dnint(u(i,j)*20.d0)
                     ref=0.05d0*iref
                     res=u(i,j)-ref
                     term=1.d0
                     f0(i,j)=0.0d0
                     do 60 k=0,6
                        f=fv(k,iref+1)
                        ts=f*term*fac(k)
                        term=-term*res
                        f0(i,j)=f0(i,j)+ts
   60                continue
                  else
                     f0(i,j)=nai(i,j)*0.5d0
                  endif
   70          continue
               do 90 i=np,ipe
                  if(u(i,j) .le. tf(1)) then
                     iref=dnint(u(i,j)*20.d0)
                     ref=0.05d0*iref
                     res=u(i,j)-ref
                     term1=1.d0
                     f1(i,j)=0.0d0
                     do 80 k=0,6
                        fi=fv(k+1,iref+1)
                        ts1=fi*term1*fac(k)
                        term1=-term1*res
                        f1(i,j)=f1(i,j)+ts1
   80                continue
                  else
                     f1(i,j)=nai(i,j)*0.25d0/u(i,j)
                  endif
   90          continue
               do 100 i=istart,is
  100          u(i,j)=2.d0*pi*exs(i,j)*expn(i,j)*f0(i,j)
               np=is+1
               do 110 i=np,ipe
                  nai(i,j)=2.d0*pi*exs(i,j)*expn(i,j)*f0(i,j)
                  nai1(i,j)=2.d0*pi*exs(i,j)*expn(i,j)*f1(i,j)
  110          continue
c
c     calculate (s||p) esp integrals
c
               if((iam(ipr,1) .eq. 0) .and. (is .ne. ip)) then
                  do 120 i=np,ipe
  120             u(i,j)=(ewcx(i,j)-cen(i,1))*nai(i,j)
     1-(ewcx(i,j)-potp1)*nai1(i,j)
                  do 130 i=ipe+1,ipe+1+ipx
  130             u(i,j)=(ewcy(i-ipx,j)-cen(i-ipx,2))*nai(i-ipx,j)
     1-(ewcy(i-ipx,j)-potp2)*nai1(i-ipx,j)
                  do 140 i=ipe+1+ipx,npr
  140             u(i,j)=(ewcz(i-ipx2,j)-cen(i-ipx2,3))*nai(i-ipx2,j)
     1-(ewcz(i-ipx2,j)-potp3)*nai1(i-ipx2,j)
               endif
  150       continue
            ips=ic*icd-icd+1
            do 170 i=ic,nc
               jps=i*icd-icd+1
               espi(i,ic)=0.0d0
               do 160 j=jps,jps+icd-1
                  do 160 k=ips,ips+icd-1
                     espi(i,ic)=espi(i,ic)+cc(j)*cc(k)*u(j,k-ips+1)
  160          continue
               es(iesp)=es(iesp)+2.d0*cespm(indc(i),indc(ic))*espi(i,ic)
  170       continue
            es(iesp)=es(iesp)-cespm(indc(ic),indc(ic))*espi(ic,ic)
  180    continue
c     write out restart information
         if(odumpm) then
         open(unit=15,file=getmop(13),status='unknown'
     1,form='unformatted')
         endif
         iesps=0
         write(15) ic,iesps
         do 190 i=1,nesp
            write(15) es(i)
  190    continue
         close(15)
c
         write(mfgw,'(a,f6.2,a)')
     1'naicas dumped: ',100.d0/isc*ic,' percent complete'
  200 continue
      return
      end
      subroutine nllsq(x,n)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      common /iofile/ mfgr,mfgw
      common /keywrd/ keywrd
      character*241 keywrd
      dimension x(*)
      common /mesage/ iflepo,iiter
************************************************************************
*
*  nllsq is a non-derivative, nonlinear least-squares minimizer. it uses
*        bartel's procedure to minimize a function which is a sum of
*        squares.
*
*    on input n    = number of unknowns
*             x    = parameters of function to be minimized.
*
*    on exit  x    = optimized parameters.
*
*    the function to be minimized is "compfg". compfg must have the
*    calling sequence
*                  call compfg(xparam,.true.,escf,.true.,efs,.true.)
*                  ssq=dot(efs,efs,n)
*    where   efs  is a vector which  compfg  fills with the n individual
*                 components of the error function at the point x
*            ssq is the value of the sum of the  efs  squared.
*    in this formulation of nllsq m and n are the same.
*    the precise definitions of these two quantities is:
*
*     n = number of parameters to be optimized.
*     m = number of reference functions. m must be greater then, or
*         equal to, n
************************************************************************
c     q = orthogonal matrix   (m by m)
c     r = right-triangular matrix   (m by n)
c     mxcnt(1) = max allow overall fun evals
c     mxcnt(2) = max allow no of fnc evals per lin search
c     tols1 = relative tolerance on x overall
c     tols2 = absolute tolerance on x overall
c     tols5 = relative tolerance on x for linear searches
c     tols6 = absolute tolerance on x for linear searches
c     nrst = number of cycles between sidesteps
c     **********
      common /timem/ time0
      common /nllsqi/ ncount
      common /numscf/ nscf
      dimension y(maxpar), efs(maxpar), p(maxpar)
      common /last/ last
      common /timdmp/ tleft, tdump
      common /nllcom/ q(maxpar,maxpar),r(maxpar,maxpar*2)
      common /nllco2/ dddum(6),efslst(maxpar),xlast(maxpar),iiium(7)
      logical middle, resfil, minprt, log
      equivalence ( iiium(2), icyc),(iiium(3), irst),
     1(iiium(4),jrst),
     2(dddum(2),alf), (dddum(3),ssq),(dddum(4), pn)
      middle=(index(keywrd,'restart') .ne. 0)
      log=(index(keywrd,'nolog') .eq. 0)
      iflepo=10
c*
      m=n
c*
      tol2=4.d-1
      if(index(keywrd,'gnorm') .ne. 0) then
         tol2=reada(keywrd,index(keywrd,'gnorm'))
         if(tol2.lt.0.01d0.and.index(keywrd,' let').eq.0)then
            write(mfgw,
     +      '(/,a)')'  gnorm has been set too low, reset to 0.01'
            tol2=0.01d0
         endif
      endif
      last=0
      tols1=1.d-12
      tols2=1.d-10
      tols5=1.d-6
      tols6=1.d-3
      nrst=4
      tlast=tleft
      minprt=.true.
      resfil=.false.
      tleft=tleft-secmop()+time0
c     **********
c     set up counters and switches
c     **********
      nto=n/6
      ifrtl=0
      nsst=0
      if(ixso.eq.0) ixso=n
      np1 = n+1
      np2 = n+2
      icyc = 0
      irst = 0
      jrst = 1
      eps =tols5
      t = tols6
c     **********
c     get starting-point function value
c     set up estimate of initial line step
c     **********
      if(middle) then
         call parsav(0,n,m)
         nscf=iiium(1)
         close(13)
         ncount=iiium(5)
         do 10 i=1,n
   10    x(i)=xlast(i)
         time1=secmop()
         if(index(keywrd,'1scf') .ne. 0) then
            iflepo=13
            last=1
            return
         endif
         goto 60
      endif
      call compfg(x,.true.,escf,.true.,efslst,.true.)
      ssq=ddot(n,efslst,1,efslst,1)
      ncount = 1
   20 continue
      do 40 i=1,m
         do 30 j=1,n
            r(i,j) = 0.0d0
            if (i .eq. j)  r(i,j)=1.0d0
   30    continue
         do 40 j=i,m
            q(i,j) = 0.0d0
            q(j,i) = 0.0d0
            if (i .eq. j)  q(i,i)=1.0d0
   40 continue
      temp = 0.0d0
      do 50 i=1,n
   50 temp = temp+x(i)**2
      alf = 100.0d0*(eps*dsqrt(temp)+t)
c     **********
c     main loop
c     **********
      time1=secmop()
   60 continue
c     **********
c     update counters and test for printing this cycle
c     **********
      ifrtl=ifrtl+1
      icyc = icyc+1
      irst = irst+1
c     **********
c     set  prt,  the levenberg-marquardt parameter.
c     **********
      prt = dsqrt(ssq)
c     **********
c     if a sidestep is to be taken, go to 31
c     **********
      if (irst .ge. nrst)  go to 210
c     **********
c     solve the system    q*r*p = -efslst    in the least-squares sense
c     **********
      nsst=0
      do 80 i=1,m
         temp = 0.0d0
         do 70 j=1,m
   70    temp = temp-q(j,i)*efslst(j)
   80 efs(i) = temp
      do 90 j=1,n
         jj = np1-j
         do 90 i=1,j
            ii = np2-i
   90 r(ii,jj) = r(i,j)
      do 160 i=1,n
         i1 = i+1
         y(i) = prt
         efsss=0.0d0
         if (i .ge. n)  go to 110
         do 100 j=i1,n
  100    y(j) = 0.0d0
  110    continue
         do 150 j=i,n
            ii = np2-j
            jj = np1-j
            if (dabs(y(j)).lt.dabs(r(ii,jj)))  go to 120
            temp = y(j)*dsqrt(1.0d0+(r(ii,jj)/y(j))**2)
            go to 130
  120       temp = r(ii,jj)*dsqrt(1.0d0+(y(j)/r(ii,jj))**2)
  130       continue
            sin = r(ii,jj)/temp
            cos = y(j)/temp
            r(ii,jj) = temp
            temp = efs(j)
            efs(j)=sin*temp+cos*efsss
            efsss=sin*efsss-cos*temp
            if (j .ge. n)  go to 160
            j1 = j+1
            do 140 k=j1,n
               jj = np1-k
               temp = r(ii,jj)
               r(ii,jj) = sin*temp+cos*y(k)
  140       y(k) = sin*y(k)-cos*temp
  150    continue
  160 continue
      p(n) = efs(n)/r(2,1)
      i = n
  170 i = i-1
      if (i)  200,200,180
  180 temp = efs(i)
      k = i+1
      ii = np2-i
      do 190 j=k,n
         jj = np1-j
  190 temp = temp-r(ii,jj)*p(j)
      jj = np1-i
      p(i) = temp/r(ii,jj)
      go to 170
  200 continue
      go to 230
c     **********
c     sidestep section
c     **********
  210 jrst = jrst+1
      nsst=nsst+1
      if(nsst.ge.ixso) go to 670
      if (jrst .gt. n)  jrst=2
      irst = 0
c     **********
c     production of a vector orthogonal to the last p-vector
c     **********
      work = pn*(dabs(p(1))+pn)
      temp = p(jrst)
      p(1) = temp*(p(1)+dsign(pn,p(1)))
      do 220 i=2,n
  220 p(i) = temp*p(i)
      p(jrst) = p(jrst)-work
c     **********
c     compute norm and norm-square of the p-vector
c     **********
  230 pnlast = pn
      pn=0.0d0
      pn2 = 0.0d0
      do 240 i=1,n
         pn=pn+dabs(p(i))
  240 pn2 = pn2+p(i)**2
      if(pn.lt.1.d-20) then
         write(mfgw,
     +'('' system does not appear to be optimizable.'',/
     1,'' this can happen if (a) it was optimized to begin with'',/
     2,'' or                 (b) it is neither a ground nor a'',
     3'' transition state'')')
         call geout(1)
_IF(ipsc,tools)
         call pend
_ELSE
         stop
_ENDIF
      endif
      if(pn2.lt.1.d-20)pn2=1.d-20
      pn = dsqrt(pn2)
      if(alf.gt.1.d20)alf=1.d20
      if(icyc .gt. 1) then
         alf=alf*1.d-20*pnlast/pn
         if(alf.gt.1.d10)        alf=1.d10
         alf=alf*1.d20
      endif
      ttmp=alf*pn
      if(ttmp.lt.0.0001d0) alf=0.001d0/pn
c     **********
c     printing section
c     **********
c#      write(mfgw,501)tleft,icyc,ssq
      do 250 i=1,n
         efs(i)=x(i)
  250 continue
c     **********
c     perform line-minimization from point x in direction p or -p
c     **********
      ssqlst = ssq
      do 260 i=1,n
         efs(i)=0.0d0
  260 xlast(i)=x(i)
      call locmin(m,x,n,p,ssq,alf,efs,ierr,escf)
      if(ssqlst .lt. ssq ) then
         if(ierr .eq. 0)      ssq=ssqlst
         do 270 i=1,n
  270    x(i)=xlast(i)
         irst=nrst
         pn=pnlast
         time2=time1
         time1=secmop()
         tcycle=time1-time2
         tleft=tleft-tcycle
         if(tleft .gt. tcycle*2) go to 60
         goto 630
      endif
c     **********
c     produce the vector   r*p
c     **********
      do 290 i=1,n
         temp = 0.0d0
         do 280 j=i,n
  280    temp = temp+r(i,j)*p(j)
  290 y(i) = temp
c     **********
c     produce the vector ...
c                  y  =    (efs-efslst-alf*q*r*p)/(alf*(normsquare(p))
c     compute norm of this vector as well
c     **********
      work = alf*pn2
      yn = 0.0d0
      do 310 i=1,m
         temp = 0.0d0
         do 300 j=1,n
  300    temp = temp+q(i,j)*y(j)
         temp = (efs(i)-efslst(i)-alf*temp)
         efslst(i) = efs(i)
         yn = yn+temp**2
  310 efs(i) = temp/work
      yn = dsqrt(yn)/work
c     **********
c     the broyden update   new matrix = old matrix + y*(p-trans)
c     has been formed.  it is now necessary to update the  qr decomp.
c     first let    y = (q-trans)*y.
c     **********
      do 330 i=1,m
         temp = 0.0d0
         do 320 j=1,m
  320    temp = temp+q(j,i)*efs(j)
  330 y(i) = temp
c     **********
c     reduce the vector y to a multiple of the first unit vector using
c     a householder transformation for components n+1 through m and
c     elementary rotations for the first n+1 components.  apply all
c     transformations transposed on the right to the matrix q, and
c     apply the rotations on the left to the matrix r.
c     this gives    (q*(v-trans))*((v*r) + (v*y)*(p-trans)),    where
c     v is the composite of the transformations.  the matrix
c     ((v*r) + (v*y)*(p-trans))    is upper hessenberg.
c     **********
      if (m .le. np1)  go to 390
c
c the next three lines were inserted to try to get round overflow bugs.
c
      const=1.d-12
      do 340 i=np1,m
  340 const=dmax1(dabs(y(np1)),const)
      ytail = 0.0d0
      do 350 i=np1,m
  350 ytail = ytail+(y(i)/const)**2
      ytail = dsqrt(ytail)*const
      bet = (1.0d25/ytail)/(ytail+dabs(y(np1)))
      y(np1) = dsign(ytail+dabs(y(np1)),y(np1))
      do 380 i=1,m
         tmp = 0.0d0
         do 360 j=np1,m
  360    tmp = tmp+q(i,j)*y(j)*1.d-25
         tmp = bet*tmp
         do 370 j=np1,m
  370    q(i,j) = q(i,j)-tmp*y(j)
  380 continue
      y(np1) = ytail
      i = np1
      go to 400
  390 continue
      i = m
  400 continue
  410 j = i
      i = i-1
      if (i)  480,480,420
  420 if (y(j))  430,410,430
  430 if (dabs(y(i)) .lt.dabs(y(j)))  go to 440
      temp = dabs(y(i))*dsqrt(1.0d0+(y(j)/y(i))**2)
      go to 450
  440 temp = dabs(y(j))*dsqrt(1.0d0+(y(i)/y(j))**2)
  450 cos = y(i)/temp
      sin = y(j)/temp
      y(i) = temp
      do 460 k=1,m
         temp = cos*q(k,i)+sin*q(k,j)
         work = -sin*q(k,i)+cos*q(k,j)
         q(k,i) = temp
  460 q(k,j) = work
      if (i .gt. n)  go to 410
      r(j,i) = -sin*r(i,i)
      r(i,i) = cos*r(i,i)
      if (j .gt. n)  go to 410
      do 470 k=j,n
         temp = cos*r(i,k)+sin*r(j,k)
         work = -sin*r(i,k)+cos*r(j,k)
         r(i,k) = temp
  470 r(j,k) = work
      go to 410
  480 continue
c     **********
c     reduce the upper-hessenberg matrix to upper-triangular form
c     using elementary rotations.  apply the same rotations, transposed,
c     on the right to the matrix  q.
c     **********
      do 490 k=1,n
  490 r(1,k) = r(1,k)+yn*p(k)
      jend = np1
      if (m .eq. n)  jend=n
      do 560 j=2,jend
         i = j-1
         if (r(j,i))  500,560,500
  500    if (dabs(r(i,i)) .lt. dabs(r(j,i)))  go to 510
         temp = dabs(r(i,i))*dsqrt(1.0d0+(r(j,i)/r(i,i))**2)
         go to 520
  510    temp = dabs(r(j,i))*dsqrt(1.0d0+(r(i,i)/r(j,i))**2)
  520    cos = r(i,i)/temp
         sin = r(j,i)/temp
         r(i,i) = temp
         if (j .gt. n)  go to 540
         do 530 k=j,n
            temp = cos*r(i,k)+sin*r(j,k)
            work = -sin*r(i,k)+cos*r(j,k)
            r(i,k) = temp
  530    r(j,k) = work
  540    do 550 k=1,m
            temp = cos*q(k,i)+sin*q(k,j)
            work = -sin*q(k,i)+cos*q(k,j)
            q(k,i) = temp
  550    q(k,j) = work
  560 continue
c     **********
c     check the stopping criteria
c     **********
      temp = 0.0d0
      do 570 i=1,n
  570 temp = temp+x(i)**2
      tolx = tols1*dsqrt(temp)+tols2
      if (dsqrt(alf*pn2) .le. tolx)  go to 650
      if(ssq.ge.2.d0*n) go to 590
      do 580 i=1,n
c*****
c     the stopping criterion is that no individual gradient be
c         greater than tol2
c*****
         if(dabs(efslst(i)).ge.tol2) go to 590
  580 continue
c#      write(mfgw,730) ssq
      go to 660
  590 continue
      time2=time1
      time1=secmop()
      tcycle=time1-time2
      tleft=tleft-tcycle
      if(resfil)then
         write(mfgw,600)tleft,sqrt(ssq),escf
  600    format('  restart file written,  time left:',f9.1,
     1' grad.:',f10.3,' heat:',g14.7)
         resfil=.false.
      else
         if(minprt) write(mfgw,610)icyc,dmin1(tcycle,9999.99d0),
     1dmin1(tleft,9999999.9d0),dmin1(dsqrt(ssq),999999.999d0),escf
         if(log) write(11,610)icyc,dmin1(tcycle,9999.99d0),
     1dmin1(tleft,9999999.9d0),dmin1(dsqrt(ssq),999999.999d0),escf
  610    format(' cycle:',i5,' time:',f6.1,' time left:',f9.1,
     1' grad.:',f10.3,' heat:',g14.7)
      endif
      if(tlast-tleft.gt.tdump)then
         tlast=tleft
         resfil=.true.
         do 620 i=1,n
  620    xlast(i)=x(i)
         iiium(1)=nscf
         call parsav(2,n,m)
      endif
      if(tleft .gt. tcycle*2) go to 60
  630 iiium(5)=ncount
      do 640 i=1,n
  640 xlast(i)=x(i)
      iiium(1)=nscf
      call parsav(1,n,m)
      iflepo=-1
      return
  650 write (mfgw,760)  ncount
      goto 870
  660 write (mfgw,770)  ncount
      goto 870
  670 continue
      write(mfgw,680) ixso
  680 format(1h ,5x,'attempt to go downhill is unsuccessful after',i5,5x
     1,'orthogonal searches')
      goto 870
c#  730 format(1h ,'final gradient =',f15.7)
  690 format(1h ,3x,'alf =',e12.4)
  700 format(1h ,3x,'ncount =',i5)
  710 format(3x,'time left:',f7.1,' cycle',i5,3x,'gnorm squared is'
     1,f13.5)
  720 format(4(5x,'x(',i2,') = ',e15.8))
  730 format(4(5x,'p(',i2,') = ',e15.8))
  740 format(5x,'r-matrix diagonal entries ...')
  750 format(6e13.3)
  760 format('0test on x satisfied, number of function calls = ',i5)
  770 format('0test on ssq satisfied, number of function calls = ',i5)
  780 format(' ///// next cycle is a side-step along the ',i2,
     1  '-th normal to p')
  790 format('0allowed number of function calls exceeded.'/
     1  ' number of function calls was ',i5)
  800 format('  l.-m. parameter = ',e15.7,
     1  '   sumsquares change = ',e15.7)
  810 format(1h )
  820 format(1h )
  830 format(1h ,3x,'i',7x,i2,9(10x,i2))
  840 format(1h ,1x,'x(i)',1x,f10.5,2x,9(f10.5,2x))
  850 format(1h ,1x,'g(i)',1x,f10.5,2x,9(f10.5,2x))
  860 format(1h ,1x,'p(i)',1x,f10.5,2x,9(f10.5,2x))
  870 last=1
      return
      end
      subroutine nuchar(line,value,nvalue)
      implicit REAL (a-h,o-z)
************************************************************************
*
*   nuchar  determins and returns the real values of all numbers
*           found in 'line'. all connected substrings are assumed
*           to contain numbers
*   on entry line    = character string
*   on exit  value   = array of nvalue real values
*
************************************************************************
      dimension value(40),istart(40)
      character*80 line
      character*1 tab,comma,space
      logical leadsp
      save comma, space
      data comma,space/',',' '/
      tab=char(9)
*
* clean out tabs and commas
*
      do 10 i=1,80
   10 if(line(i:i).eq.tab.or.line(i:i).eq.comma)line(i:i)=space
*
* find initial digit of all numbers, check for leading spaces followed
*     by a character
*
      leadsp=.true.
      nvalue=0
      do 20 i=1,80
         if (leadsp.and.line(i:i).ne.space) then
            nvalue=nvalue+1
            istart(nvalue)=i
         endif
         leadsp=(line(i:i).eq.space)
   20 continue
*
* fill number array
*
      do 30 i=1,nvalue
         value(i)=reada(line,istart(i))
   30 continue
      return
      end
      character*5 function oper(r)
c
      implicit REAL (a-h,o-z)
      character opr*5, num*10
      dimension r(9)
c
c
      opr = ' '
      num = '0123456789'
      trace = r(1) + r(5) + r(9)
      det = r(1)*r(5)*r(9) + r(2)*r(6)*r(7) + r(3)*r(4)*r(8)
     +    - r(1)*r(6)*r(8) - r(2)*r(4)*r(9) - r(3)*r(5)*r(7)
      trace = (trace - det)/2.d0
      if (det .gt. 0.d0) then
        opr(1:1) = 'c'
        if (trace .gt. 0.97d0) then
          opr(1:1) = 'e'
          goto 20
        endif
      else
        opr(1:1) = 's'
        if (trace .gt. 0.97d0) then
          opr(1:5) = 'sigma'
          goto 20
        endif
        if (trace .lt. -0.97d0) then
          opr(1:5) = ' inv '
          goto 20
        endif
      endif
      if (trace .lt. -0.97d0) then
        opr(2:2) = num(3:3) 
        goto 20
      endif
      ang = dacos(trace)
      afull = dacos(-1.0d0)*2.d0
      do 10 i = 3, 18
        ans = i*ang/afull
        if (dabs(ans - nint(ans)) .le. 2.5d-3) then
          if(i .ge.10) then
            opr(2:2) = num(2:2)
            opr(3:3) = num(i-9:i-9)
          else
            opr(2:2) = num(i+1:i+1)
          endif
          if (nint(ans) .ne. 1) then
            opr(4:5) = '* '
            opr(5:5) = num(nint(ans)+1:nint(ans)+1)
          endif
          goto 20
        endif
  10  continue
      opr(2:5) = 'unkn'
c
  20  oper = opr
      return
      end
      subroutine osinv (a,n,d)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      dimension a(*)
************************************************************************
*
*    osinv inverts a general square matrix of order up to maxorb. see
*          dimension statements below.
*
*   on input       a = general square matrix stored linearly.
*                  n = dimension of matrix a.
*                  d = variable, not defined on input.
*
*   on output      a = inverse of original a.
*                  d = determinant of original a, unless a was singular,
*                      in which case d = 0.0
*
************************************************************************
      dimension l(maxorb), m(maxorb)
************************************************************************
*
*    if the value of tol given here is unsuitable, it can be changed.
      tol=1.d-8
*
*
************************************************************************
      d=1.0d0
      nk=-n
      do 180 k=1,n
         nk=nk+n
         l(k)=k
         m(k)=k
         kk=nk+k
         biga=a(kk)
         do 20 j=k,n
            iz=n*(j-1)
            do 20 i=k,n
               ij=iz+i
c
c     10 follows
c
               if (dabs(biga)-dabs(a(ij))) 10,20,20
   10          biga=a(ij)
               l(k)=i
               m(k)=j
   20    continue
         j=l(k)
         if (j-k) 50,50,30
   30    ki=k-n
         do 40 i=1,n
            ki=ki+n
            holo=-a(ki)
            ji=ki-k+j
            a(ki)=a(ji)
   40    a(ji)=holo
   50    i=m(k)
         if (i-k) 80,80,60
   60    jp=n*(i-1)
         do 70 j=1,n
            jk=nk+j
            ji=jp+j
            holo=-a(jk)
            a(jk)=a(ji)
   70    a(ji)=holo
   80    if (dabs(biga)-tol) 90,100,100
   90    d=0.0d0
         return
  100    do 120 i=1,n
            if (i-k) 110,120,110
  110       ik=nk+i
            a(ik)=a(ik)/(-biga)
  120    continue
         do 150 i=1,n
            ik=nk+i
            ij=i-n
            do 150 j=1,n
               ij=ij+n
               if (i-k) 130,150,130
  130          if (j-k) 140,150,140
  140          kj=ij-i+k
               a(ij)=a(ik)*a(kj)+a(ij)
  150    continue
         kj=k-n
         do 170 j=1,n
            kj=kj+n
            if (j-k) 160,170,160
  160       a(kj)=a(kj)/biga
  170    continue
         d=dmin1(d*biga,1.d10)
         a(kk)=1.0d0/biga
  180 continue
      k=n
  190 k=k-1
      if (k) 260,260,200
  200 i=l(k)
      if (i-k) 230,230,210
  210 jq=n*(k-1)
      jr=n*(i-1)
      do 220 j=1,n
         jk=jq+j
         holo=a(jk)
         ji=jr+j
         a(jk)=-a(ji)
  220 a(ji)=holo
  230 j=m(k)
      if (j-k) 190,190,240
  240 ki=k-n
      do 250 i=1,n
         ki=ki+n
         holo=a(ki)
         ji=ki+j-k
         a(ki)=-a(ji)
  250 a(ji)=holo
      go to 190
  260 return
c
      end
      subroutine overlp(dmax,osmin,newmod,nvar,lorjk)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      common /iofile/ mfgr,mfgw
      common/fmatrx/oldf(maxpar),d(maxpar),vmode(maxpar),
     $u(maxpar,maxpar),dd,rmin,rmax,omin,xlamd,xlamd0,skal,
     $mode,nstep,negreq,iprnt
      dimension xo(maxpar)
      logical lorjk,first
      data first/.true./
c
c  on the first step simply determine which mode to follow
c
c     if(nstep.eq.1) then
      if(first) then
         first=.false.
         if(mode.gt.nvar)then
            write(mfgw,*)
     +      'error!! mode is larger than nvar',mode
_IF(ipsc,tools)
            call pend
_ELSE
            stop
_ENDIF
         endif
         it=mode
         if (iprnt.ge.1) write(mfgw,40) mode
   40 format(5x,'hessian mode following switched on'/
     1     '     following mode ',i3)
c
      else
c
c  on subsequent steps determine which hessian eigenvector has
c  the greatest overlap with the mode we are following
c
         it=1
         lorjk=.false.
         tovlp=ddot(nvar,u(1,1),1,vmode,1)
         tovlp=dabs(tovlp)
c        xo(1)=tovlp
         do 10 i=2,nvar
            ovlp=ddot(nvar,u(1,i),1,vmode,1)
            ovlp=dabs(ovlp)
c           xo(i)=ovlp
            if(ovlp.gt.tovlp) then
               tovlp=ovlp
               it=i
            endif
   10    continue
c
         if (iprnt.ge.5) then
         do j=1,5
         xxx=0.0d0
         do i=1,nvar
         if (xo(i).gt.xxx)ix=i
         if (xo(i).gt.xxx)xxx=xo(i)
         enddo
         xo(ix)=0.0d0
         write(mfgw,*)'overlaps',ix,xxx
         enddo
         endif

         if(iprnt.ge.1)write(mfgw,30) it,tovlp
         if (tovlp.lt.omin) then
            if (dmax.gt.osmin) then
            lorjk=.true.
            if (iprnt.ge.1)write(mfgw,31)omin
            return
            else
            if (iprnt.ge.1)write(mfgw,32)omin,dmax,osmin
            endif
         endif
      endif
   30 format(5x,'overlap of current mode',i3,' with previous mode is ',
     $       f6.3)
   31 format(5x,'overlap less than omin',
     1f6.3,' rejecting previous step')
   32 format(5x,'overlap less than omin',f6.3,' but trust radius',f6.3,
     $          ' is less than',f6.3,/,5x,' accepting step')
c
c  save the eigenvector in vmode
c
      do 20 i=1,nvar
         vmode(i)=u(i,it)
   20 continue
c
      newmod=it
      return
c
      end
      subroutine ovlp(ic,iesp,is,ip,npr,nc,icd)
      implicit REAL (a-h,o-z)
c***********************************************************************
c
c     ovlp calculates the overlap integrals for a sto-6g basis set.
c     the resulting integrals are used in the deorthogonalization
c     process.
c     the code was written by b.h.besler and k.m.merz in feb. 1989
c     at ucsf.
c
c     on input:  ic = loop index
c                iesp = loop index
c                is = number of s orbitals
c                ip = number of p orbitals
c                npr = number of primitives
c                nc = number of contracted functions
c
c     on output: ovl is filled with the overlap integral value
c
c     for further info see: obara & saika j.chem.phys. 1986,84,3963
c***********************************************************************
      logical called
      REAL nai,nai1,nai2
INCLUDE(common/sizes)
      common /densty/ p(mpack),pa(mpack),pb(mpack)
      common /potesp/ xc,yc,zc,espnuc,espele,nesp
      common /abc/    co(3,numatm),ian(numatm),natom
      common /work1/  potpt(3,mesp), es(mesp), esp(mesp), work1d(2*mesp)
      common /expont/ zs(107),zp(107),zd(107)
      common /sto6g/  allc(6,5,2),allz(6,5,2)
      common /espc/ cc(maxpr),cen(maxpr,3),iam(maxpr,2),ind(maxpr),
     1ex(maxpr),espi(maxorb,maxorb),fv(0:8,821),
     2fac(0:7),dex(-1:96),tf(0:2),
     3temp(maxpr),itemp(maxpr),ovl(maxorb,maxorb),xdmy(maxpr*6)
      common/x/ dx(maxpr),dy(maxpr),dz(maxpr),f1(maxpr,6),f2(maxpr,6),
     1td(maxpr),ce(maxpr,6),u(maxpr,6),exs(maxpr,6),expn(maxpr,6),
     2nai(maxpr,6),ewcx(maxpr,6),ewcy(maxpr,6),ewcz(maxpr,6),f0(maxpr,6)
     3,nai1(maxpr,6),nai2(maxpr,6)
      data bohr/0.529167d0/
c
c     calculate distance arrays
c
      pi=4.d0*datan(1.d0)
      ipr=ic*icd-icd+1
      istart=ipr
      do 10 i=istart,npr
         dx(i)=cen(ipr,1)-cen(i,1)
         dy(i)=cen(ipr,2)-cen(i,2)
         dz(i)=cen(ipr,3)-cen(i,3)
         td(i)=dx(i)**2+dy(i)**2+dz(i)**2
   10 continue
c
c     calculate exponent sum
c
      do 20 i=istart,npr
         do 20 j=1,icd
            exs(i,j)=1.d0/(ex(ipr+j-1)+ex(i))
            ce(i,j)=ex(ipr+j-1)*ex(i)*exs(i,j)
   20 continue
c
c     calculate exponent weighted centers
c
      do 30 i=istart,npr
         do 30 j=1,icd
            ewcx(i,j)=(ex(i)*cen(i,1)+ex(ipr+j-1)
     1*cen(ipr+j-1,1))*exs(i,j)
            ewcy(i,j)=(ex(i)*cen(i,2)+ex(ipr+j-1)
     1*cen(ipr+j-1,2))*exs(i,j)
            ewcz(i,j)=(ex(i)*cen(i,3)+ex(ipr+j-1)
     1*cen(ipr+j-1,3))*exs(i,j)
   30 continue
      do 40 i=1,npr
         do 40 j=1,icd
            expn(i,j)=dexp(-ce(i,j)*td(i))
            nai(i,j)=(pi*exs(i,j))**1.5d0*expn(i,j)
            expn(i,j)=nai(i,j)
   40 continue
c
c     calculate (s||p) esp integrals
c
      if((iam(ipr,1) .eq. 0) .and. (is .ne. ip)) then
         np=is+1
         do 80 i=np,npr
            do 80 j=1,icd
               go to (50,60,70),iam(i,2)
   50          nai(i,j)=(ewcx(i,j)-cen(i,1))*expn(i,j)
               go to 80
   60          nai(i,j)=(ewcy(i,j)-cen(i,2))*expn(i,j)
               go to 80
   70          nai(i,j)=(ewcz(i,j)-cen(i,3))*expn(i,j)
   80    continue
      endif
c
c     calculate (p||s) esp integrals
c
      if((iam(ipr,1) .eq. 1) .and. (is .ne. ip)) then
         np=is+1
         do 120 i=        istart,npr
            do 120 j=1,icd
               go to (90,100,110),iam(ipr+j-1,2)
   90          nai(i,j)=(ewcx(i,j)-cen(ipr+j-1,1))*expn(i,j)
               go to 120
  100          nai(i,j)=(ewcy(i,j)-cen(ipr+j-1,2))*expn(i,j)
               go to 120
  110          nai(i,j)=(ewcz(i,j)-cen(ipr+j-1,3))*expn(i,j)
  120    continue
      endif
c
c     calculate (p||p) esp integrals
c
      if((iam(ipr,1) .eq. 1) .and. (is .ne. ip)) then
         do 160 i=istart,npr
            do 160 j=1,icd
               go to (130,140,150),iam(i,2)
  130          nai(i,j)=(ewcx(i,j)-cen(i,1))*nai(i,j)
               if(iam(ipr+j-1,2) .eq. iam(i,2))
     1nai(i,j)=nai(i,j)+exs(i,j)*0.5d0
     2      *expn(i,j)
               go to 160
  140          nai(i,j)=(ewcy(i,j)-cen(i,2))*nai(i,j)
               if(iam(ipr+j-1,2) .eq. iam(i,2))
     1nai(i,j)=nai(i,j)+exs(i,j)*0.5d0
     2      *expn(i,j)
               go to 160
  150          nai(i,j)=(ewcz(i,j)-cen(i,3))*nai(i,j)
               if(iam(ipr+j-1,2) .eq. iam(i,2))
     1nai(i,j)=nai(i,j)+exs(i,j)*0.5d0
     2      *expn(i,j)
  160    continue
      endif
      ips=ic*icd-icd+1
      do 180 i=ic,nc
         jps=i*icd-icd+1
         ovl(ic,i)=0.0d0
         do 170 j=jps,jps+icd-1
            do 170 k=ips,ips+icd-1
               ovl(ic,i)=ovl(ic,i)+cc(j)*cc(k)*nai(j,k-ips+1)
  170    continue
         ovl(i,ic)=ovl(ic,i)
  180 continue
      return
      end
      subroutine parsav(mode,n,m)
      implicit REAL (a-h,o-z)
_IF(ipsc,tools)
      logical oroot
_ENDIF
INCLUDE(common/sizes)
INCLUDE(../m4/common/utilc)
      common /iofile/ mfgr,mfgw
**********************************************************************
*
*   parsav saves and restores data used in nllsq gradient minimization.
*
*    if mode is 0 data are restored, if 1 then saved.
*
**********************************************************************
      common /densty/ p(mpack), pa(mpack), pb(mpack)
      common /alparm/ alparm(3,maxpar),x0, x1, x2, iloop
      common /keywrd/ keywrd
      common /elemts/ elemnt(107)
      common /errfn / errfn(maxpar), aicorr(maxpar)
      common /geosym/ ndep,locpar(maxpar),idepfn(maxpar),
     1                     locdep(maxpar)
      common /geokst/ natoms,labels(numatm),
     1                na(numatm),nb(numatm),nc(numatm)
      common /cmpg/ geo(3,numatm)
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),
     1                nlast(numatm), norbs, nelecs,nalpha,nbeta,
     2                nclose,nopen,ndumy,fract
      common /nllcom/ q(maxpar,maxpar),r(maxpar,maxpar*2)
      common /nllco2/ dddum(6),efslst(maxpar),xlast(maxpar),iiium(7)
      common /geovar/ nvar,loc(2,maxpar), jdumy, dumy(maxpar)
      common /locvar/ locvar(2,maxpar)
      common /valvar/ valvar(maxpar),numvar
      dimension coord(3,numatm)
      character elemnt*2, keywrd*241, getmop*80
_IF(ipsc,tools)
      if(oroot().and.odumpm) then
_ELSE
      if(odumpm) then
_ENDIF
      open(unit=9,file=getmop(3),
     +     status='unknown',form='unformatted')
      rewind 9
      open(unit=10,file=getmop(4),
     +     status='unknown',form='unformatted')
      rewind 10
      endif
      if(mode.ne.0) goto 10
*
*  mode=0: retrieve data from disk.
*
_IF(ipsc,tools)
      if(oroot()) then
_ENDIF
      read(9,end=30,err=30)iiium,dddum,efslst,n,
     +                     (xlast(i),i=1,n),m
      read(9)((q(j,i),j=1,m),i=1,m)
      read(9)((r(j,i),j=1,n),i=1,n)
      read(9)(valvar(i),i=1,n)
      if(index(keywrd,'aider').ne.0) read(9)(aicorr(i),i=1,n)
_IF(ipsc,tools)
      else
      write(mfgw,*)' restarts not available in parsav'
      go to 21
      endif
_ENDIF
      return
   10 continue
      if(mode.eq.1)then
         write(mfgw,'(//10x,'' **** time up ****'')')
         write(mfgw,
     +   '(//10x,'' current values of geometric variables'',//)')
         if(na(1) .eq. 99) then
c
c  convert from cartesian coordinates to internal
c
            do 20 i=1,natoms
               do 20 j=1,3
   20       coord(j,i)=geo(j,i)
            call mopxyz(coord,numat,na,nb,nc,1.d0,geo)
         endif
         call geout(6)
         write(mfgw,'(//10x,
     1''to restart calculation use the keyword "restart".'')')
      endif
_IF(ipsc,tools)
      if(oroot().and.odumpm) then
_ELSE
      if(odumpm) then
_ENDIF
      write(9)iiium,dddum,efslst,n,(xlast(i),i=1,n),m
      write(9)((q(j,i),j=1,m),i=1,m)
      write(9)((r(j,i),j=1,n),i=1,n)
      write(9)(valvar(i),i=1,n)
      if(index(keywrd,'aider').ne.0) write(9)(aicorr(i),i=1,n)
c*****
c     the density matrix is required by iter upon restart .
c
      linear=(norbs*(norbs+1))/2
      write(10)(pa(i),i=1,linear)
      if(nalpha.ne.0)write(10)(pb(i),i=1,linear)
c*****
      close(9)
      close(10)
      endif
      return
   30 write(mfgw,'(//10x,''no restart file exists!'')')
_IF(ipsc,tools)
   21 call pend
_ELSE
      stop
_ENDIF
      end
      subroutine partxy(c34,pq34)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      dimension c34(*),pq34(*)
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),
     1                nlast(numatm), norbs, nelecs,nalpha,nbeta,
     2                nclose,nopen,ndumy,fract
      common /wmatrc/ wj(n2elec), wk(n2elec)
      common /twoele/ gss(107),gsp(107),gpp(107),gp2(107),hsp(107)
     2               ,gsd(107),gpd(107),gdd(107)
      common /keywrd/ keywrd
      common /numcal/ numcal
      dimension w(n2elec*2)
      equivalence (w,wj)
      REAL wj, wk
      character*241 keywrd
c------------------------------------------------------------------
c
c    partxy works out  in mndo formalism the first 2-indices transfo.
c          required in the computation of 2-electrons repulsion over m.o
c  input
c     c34   : vector of the current charge distribution between two m.o.
c  output
c     pq34(pq) : <p(1),q(1)|c3(2),c4(2)> where p ,q  are a.o.
c                                          and c3,c4 are m.o.
c                p and q run in canonical order over the a.o belonging
c                to an atom 'a' only (basic assumption of mndo scheme)
c                and 'a' runs over the atoms of the system.
c     d.l. (dewar group) 1986
c----------------------------------------------------------------------
      dimension ld(9),ptot(numatm), nb(0:8), indx(numatm)
      data ld /0,2,5,9,14,20,27,35,44/
      data nb /1,0,0,10,0,0,0,0,45/
      save icalcn
      data icalcn/0/
      if(numcal.ne.icalcn)then
         icalcn=numcal
         indx(1)=1
         do 10 i=2,numat
   10    indx(i)=indx(i-1)+nb(nlast(i-1)-nfirst(i-1))
      endif
c     ij    : pointer of canonical packed location of couple ij.
c     kk    : pointer of supporting atom, sparkles skipped out.
c     ipqrs : current entry point in the <pq|rs> file.
      kk=0
      ipqrs=1
      ij=0
      ijold=0
c
c     loop over outer atom a, sparkles excluded.
c     ------------------------------------------
      nband=1
      kr=1
      ls=0
      do 30 ii=1,numat
         ia=nfirst(ii)
         ib=nmidle(ii)
         ic=nlast (ii)
         if(ic.lt.ia) go to 30
         kk=kk+1
         ls=ls+nband
         nband=nb(ic-ia)
         ij=ij+nband
c
c     pq34(ij) = <ij|kl> * c34(kl)  , 1-centre contributions.
         izn=nat(ii)
c     block ss
         ptot(kk)=c34(ls)
         pq34(ls)=c34(ls)*gss(izn)*0.25d0
         if(ib.gt.ia) then
c        block sp and pp
            hpp=0.5d0*(gpp(izn)-gp2(izn))
            lx=ls+ld(2)
            ly=ls+ld(3)
            lz=ls+ld(4)
            pp=c34(lx)+c34(ly)+c34(lz)
            pq34(ls+1)=hsp(izn)*c34(ls+1)
            pq34(lx  )=gpp(izn)*c34(lx  )*0.25d0
            pq34(ls+3)=hsp(izn)*c34(ls+3)
            pq34(ls+4)=hpp     *c34(ls+4)
            pq34(ly  )=gpp(izn)*c34(ly  )*0.25d0
            pq34(ls+6)=hsp(izn)*c34(ls+6)
            pq34(ls+7)=hpp     *c34(ls+7)
            pq34(ls+8)=hpp     *c34(ls+8)
            pq34(lz  )=gpp(izn)*c34(lz  )*0.25d0
            gspss=     gsp(izn)*c34(ls  )*0.25d0
            pq34(ls)=pq34(ls)+gsp(izn)*pp*0.25d0
            pq34(lx)=pq34(lx)+gp2(izn)*(c34(ly)+c34(lz))*0.25d0+gspss
            pq34(ly)=pq34(ly)+gp2(izn)*(c34(lz)+c34(lx))*0.25d0+gspss
            pq34(lz)=pq34(lz)+gp2(izn)*(c34(lx)+c34(ly))*0.25d0+gspss
            ptot(kk)=ptot(kk)+pp
            if(ic.gt.ib) then
c           block sd, pd and dd
c           --- waiting for 'd' parameters ---
c               take care : diagonal elements of c34 are doubled.
            endif
         endif
         if(kk.gt.1)then
c
c        loop over charge distribution of inner atoms  b < a .
c        -----------------------------------------------------
c        pq34(ij)=<ij|kl>*c34(kl) 2-centres contributions.
c
            jband=1
            js=0
            do 20 jj=1,ii-1
               js=js+jband
               jband=nb(nlast(jj)-nfirst(jj))
c
c   nband and jband are either 1 or 10
c
               call formxy
     1(w(kr), kr, pq34(ls), pq34(js), c34(ls), nband, c34(js), jband)
   20       ipqrs=ipqrs+ijold
         endif
         ijold=ij
   30 continue
      return
      end
      subroutine pathk
      implicit REAL (a-h,o-z)
_IF(ipsc,tools)
      logical oroot
_ENDIF
INCLUDE(common/sizes)
      common /iofile/ mfgr,mfgw
************************************************************************
*
*       written by manyin yi, aug 1989.
*       restartable reaction_path calculation.
*       the number of path_step and step value are read in through
*       keyword point and step.
*       the reaction profile is archived.
*
************************************************************************
      common /cmpg/ geo(3,numatm)
      common /geovar/ nvar,loc(2,maxpar), idumy, xparam(maxpar)
      common /gradnt/ grad(maxpar),gnorm
      common /gravec/ cosine
      common /path/ latom, lparam, react(200)
      common /pparam/ currt
      common /kloop/ kloop
      common /profilm/ profil
      common /keywrd/ keywrd
      dimension gd(maxpar),xlast(maxpar),mdfp(20),xdfp(20)
      dimension profil(200)
      character keywrd*241, getmop*80
      step=reada(keywrd,index(keywrd,'step')+5)
      npts=reada(keywrd,index(keywrd,'point')+6)
c
c  the smallest value in the path is
c      react(1) degree or geo(lparam,latom) radians
c
      degree=180.d0/3.14159265359d0
      if(lparam.ne.1)step=step/degree
c
c  now to sweep through the path
c
      if(lparam.ne.1) then
         c1=degree
      else
         c1=1.d0
      endif
c
      kloop=1
      cputot=0.0d0
      currt=geo(lparam,latom)
      profil(1)=0.0d0
      if (index(keywrd,'restart').ne.0) then
         mdfp(9)=0
         call dfpsav(cputot,xparam,gd,xlast,escf,mdfp,xdfp)
         write(mfgw,
     +   '(//10x,'' restarting at point '',i3)') kloop
      endif
c
      geo(lparam,latom)=currt
      do 10 iloop=kloop,npts
         cpu1=secmop()
         currt=geo(lparam,latom)
         call flepo(xparam, nvar, escf)
         kloop=kloop+1
         cpu2=secmop()
         cpu3=cpu2-cpu1
         cputot=cputot+cpu3
         profil(iloop)=escf
         write(mfgw,
     +   '(/''          variable        function'')')
         write(mfgw,
     +   '('' :'',f16.5,f16.6)')geo(lparam,latom)*c1,escf
         call geout(mfgw)
         geo(lparam,latom)=geo(lparam,latom)+step
   10 continue
      do 20 i=2,npts
   20 react(i)=react(i-1)+step*c1
      write(mfgw,'(/16x,''points on reaction path '',
     1          /16x,''and corresponding heats'',//)')
_IF(ipsc,tools)
      if(oroot()) then
_ENDIF
      open(unit=12,form='formatted',file=getmop(6),
     +             status='unknown')
      write(12,30)
      call wrttxt(12)
   30 format(' archive file for path calculation'/
     1 'a profil of coordinates - heats'/)
      write(12,'(/'' total cpu time in flepo : '',f10.3/)') cputot
c
      l=npts/8
      m=npts - l*8
      if (l.lt.1) go to 50
      do 40 k=0,l-1
         write(mfgw,'(8f7.2)') (react(i),i=k*8+1,k*8+8)
         write(mfgw,'(8f7.2,/)') (profil(i),i=k*8+1,k*8+8)
         write(12,'(8f7.2)') (react(i),i=k*8+1,k*8+8)
   40 write(12,'(8f7.2,/)') (profil(i),i=k*8+1,k*8+8)
   50 if (m.gt.0) then
         write(mfgw,'(8f7.2)') (react(i),i=l*8+1,l*8+m)
         write(mfgw,'(8f7.2,/)') (profil(i),i=l*8+1,l*8+m)
         write(12,'(8f7.2)') (react(i),i=l*8+1,l*8+m)
         write(12,'(8f7.2,/)') (profil(i),i=l*8+1,l*8+m)
_IF(ipsc,tools)
      endif
_ENDIF
      endif
      return
      end
      subroutine pdgrid
c
c     routine to calculate williams surface
c
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      common /iofile/ mfgr,mfgw
      dimension iz(100),xyz(3,100),vderw(53),dist(100)
      dimension xmin(3),xmax(3),coord(3,numatm)
      common /cmpg/   geo(3,numatm)
      common /geokst/ natoms,labels(numatm), nabc(3*numatm)
c
      common /abc/    co(3,numatm),ian(numatm),natom
      common /work1/    potpt(3,mesp), work1d(4*mesp)
      common /potesp/ xc,yc,zc,espnuc,espele,nesp
c
      data vderw/53*0.0d0/
      vderw(1)=2.4d0
      vderw(5)=3.0d0
      vderw(6)=2.9d0
      vderw(7)=2.7d0
      vderw(8)=2.6d0
      vderw(9)=2.55d0
      vderw(15)=3.1d0
      vderw(16)=3.05d0
      vderw(17)=3.0d0
      vderw(35)=3.15d0
      vderw(53)=3.35d0
      shell=1.2d0
      nesp=0
      grid=0.8d0
      closer=0.0d0
c     check if vderw is defined for all atoms
c
c     convert internal to cartesian coordinates
c
      call gmetry(geo,coord)
c
c     strip coordinates and atom label for dummies (i.e. 99)
c
      icntr = 0
      do 20 i=1,natoms
         do 10 j=1,3
   10    co(j,i) = coord(j,i)
         if(labels(i) .eq. 99) goto 20
         icntr = icntr + 1
         ian(icntr) = labels(i)
   20 continue
      natom=icntr
c
      do 30 i=1,natom
         j=ian(i)
         if (vderw(j).eq.0.0d0) go to 40
   30 continue
      go to 50
   40 continue
      write(mfgw,*) 'van der waals'' radius not defined for atom',i
      write(mfgw,*) 'in williams surface routine pdgrid!'
_IF(ipsc,tools)
      call pend
_ELSE
      stop
_ENDIF
c     now create limits for a box
   50 do 100 ix = 1,3
         xmin(ix)= 100000.0d0
         xmax(ix)=-100000.0d0
         do 90 ia = 1,natom
            if (co(ix,ia)-xmin(ix))60,70,70
   60       xmin(ix)=co(ix,ia)
   70       if (co(ix,ia)-xmax(ix))90,90,80
   80       xmax(ix)=co(ix,ia)
   90    continue
  100 continue
c     add (or subtract) the maximum vderw plus shell
      vdmax=0.0d0
      do 110 i=1,53
         if (vderw(i).gt.vdmax) vdmax=vderw(i)
  110 continue
      do 120 i=1,3
         xmin(i)=xmin(i)-vdmax-shell
  120 xmax(i)=xmax(i)+vdmax+shell
c step grid back from zero to find starting points
      xstart=0.0d0
  130 xstart=xstart-grid
      if (xstart.gt.xmin(1)) go to 130
      ystart=0.0d0
  140 ystart=ystart-grid
      if (ystart.gt.xmin(2)) go to 140
      zstart=0.0d0
  150 zstart=zstart-grid
      if (zstart.gt.xmin(3)) go to 150
      npnt=0
      zgrid=zstart
  160 ygrid=ystart
  170 xgrid=xstart
  180 do 190 l=1,natom
         jz=ian(l)
         dist(l)=dsqrt((co(1,l)-xgrid)**2+(co(2,l)-ygrid)**2+
     1 (co(3,l)-zgrid)**2)
c     reject grid point if any atom is too close
         if(dist(l).lt.(vderw(jz)-closer)) go to 220
  190 continue
c but at least one atom must be close enough
      do 200 l=1,natom
         jz=ian(l)
         if(dist(l).gt.(vderw(jz)+shell)) go to 200
         go to 210
  200 continue
      go to 220
  210 npnt=npnt+1
      nesp=nesp+1
      potpt(1,nesp)=xgrid
      potpt(2,nesp)=ygrid
      potpt(3,nesp)=zgrid
  220 xgrid=xgrid+grid
      if (xgrid.le.xmax(1)) go to 180
      ygrid=ygrid+grid
      if (ygrid.le.xmax(2)) go to 170
      zgrid=zgrid+grid
      if (zgrid.le.xmax(3)) go to 160
      return
      end
      subroutine perm(iperm,nels,nmos,maxmos,nperms)
      dimension iperm(maxmos,60), iadd(20), nel(20)
      common /iofile/ mfgr,mfgw
************************************************************************
*
*  perm permutes nels entities among nmos locations. the entities and
*       locations are each indistinguishable. the pauli exclusion
*       principle is followed. the number of states produced is given
*       by nmos!/(nels!*(nmos-nels)!).
* on input: nels  = number of indistinguishable entities
*           nmos  = number of indistinguishable locations
*
* on output iperm = array of permutations, a 0 indicates no entity,
*                   a 1 indicates an entity.
*           nperm = number of permutations.
*
************************************************************************
      if(nels.gt.nmos)then
         write(mfgw,
     +'('' number of particles,'',i3,'' greater than no. '',
     1''of states,'',i3)')nels,nmos
         nperms=0
         return
      endif
      nperms=1
      do 10 i=1,20
   10 nel(i)=1000
      do 20 i=1,nels
   20 nel(i)=1
      do 50 i12=1-12+nels,nmos,nel(12)
         iadd(12)=i12
         do 50 i11=i12+1,nmos,nel(11)
            iadd(11)=i11
            do 50 i10=i11+1,nmos,nel(10)
               iadd(10)=i10
               do 50 i9=i10+1,nmos,nel(9)
                  iadd(9)=i9
                  do 50 i8=i9+1,nmos,nel(8)
                     iadd(8)=i8
                     do 50 i7=i8+1,nmos,nel(7)
                        iadd(7)=i7
                        do 50 i6=i7+1,nmos,nel(6)
                           iadd(6)=i6
                           do 50 i5=i6+1,nmos,nel(5)
                              iadd(5)=i5
                              do 50 i4=i5+1,nmos,nel(4)
                                 iadd(4)=i4
                                 do 50 i3=i4+1,nmos,nel(3)
                                    iadd(3)=i3
                                    do 50 i2=i3+1,nmos,nel(2)
                                       iadd(2)=i2
                                       do 50 i1=i2+1,nmos,nel(1)
                                          iadd(1)=i1
                                          do 30 j=1,nmos
   30                                     iperm(j,nperms)=0
                                          do 40 j=1,nels
   40                                     iperm(iadd(j),nperms)=1
                                          nperms=nperms+1
                                          if(nperms.gt.61)then
                                             write(mfgw,
     + '('' number of permutations too great, limit 60'')')
                                             goto 60
                                          endif
   50 continue
   60 nperms=nperms-1
      return
      end
      subroutine polar
c.. 6/13/91
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      common /iofile/ mfgr,mfgw
c**********************************************************************
c
c   polar sets up the calculation of the molecular electric response
c   properties by ffhpol.
c
c**********************************************************************
      character*2 elemnt
      dimension x1(maxorb,maxorb), x2(maxorb,maxorb), x3(maxorb,maxorb)
      dimension x4(maxorb,maxorb), x5(maxorb,maxorb), x6(maxorb,maxorb)
      dimension x7(maxorb,maxorb), x8(maxorb,maxorb), x9(maxorb,maxorb)
      dimension x10(maxorb,maxorb),x11(maxorb,maxorb),x12(maxorb,maxorb)
      dimension x13(maxorb,maxorb)
      common /work1/ x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,
     1               xdumy(21*mpack-10*maxorb*maxorb)
      common /work3/ x11,x12,xdumy1(4*mpack-2*maxorb*maxorb)
      common /scrach/ x13, xdumy2(maxall*maxall-maxorb*maxorb)
c..
      common /titles/ koment,title
      common /polvol/ polvol(107)
      common /keywrd/ keywrd
      common /geokst/ natoms,labels(numatm),
     1                na(numatm),nb(numatm),nc(numatm)
      common /geovar/ nvar,loc(2,maxpar),idumy,xparam(maxpar)
      common /scftyp/ emin,limscf
      common /timcom/ time0
      common /elemts/ elemnt(107)
      common /corec/ core(107)
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),
     1                nlast(numatm), norbs, nelecs,nalpha,nbeta,
     2                nclose,nopen,ndumy,fract
      common /geosym/ ndep, locpar(maxpar), idepfn(maxpar),
     1                    locdep(maxpar)
      common /cmpg/ geo(3,numatm), coord(3,numatm)
      common /last/ last
      common /euler / tvec(3,3),idtvec
      common /omval/ omega
      common /chanel/ ifiles(30)
      common / readme / ird
      equivalence(iw,ifiles(6)), (ir,ifiles(5))
      dimension grad(maxpar),rotvec(3,3), tempv(3,3), dataev(10)
     1,value(10)
      character  keywrd*241, type*7, koment*81, title*81
      character  polkey*241, line*80
      logical let, limscf
      limscf=.false.
      type=' mndo  '
      let=(index(keywrd,'let').ne.0)
      if(index(keywrd,'mindo') .ne. 0) type='mindo/3'
      if(index(keywrd,'am1') .ne. 0)    type='  am1  '
      write(mfgw,10)
   10 format('1',20('*'),' tdhf polarizabilities ',
     1        20('*'),//)
      call gmetry(geo,coord)
c
c  orient the molecule with the moments of inertia.
c  this is done to ensure a unique, reproduceable set of directions.
c  if let is specified, the input orientation will be used.
c
      if (.not.let) then
         mass = 1.0d00
         call axis(coord,numat,a,b,c,sumw,mass,rotvec)
         write(mfgw,20)
   20    format (/' rotation matrix for orientation of molecule:'/)
         do 40 i = 1,3
            write(mfgw,30) (rotvec(i,j),j=1,3)
   30       format(5x,3f12.6)
   40    continue
c
c  rotate atoms
c
         do 70 i = 1,numat
            do 60 j = 1,3
               sum = 0.0d00
               do 50 k = 1,3
                  sum = sum + coord(k,i)*rotvec(k,j)
   50          continue
               geo(j,i) = sum
   60       continue
   70    continue
         do 90 i = 1,numat
            do 80 j = 1,3
               coord(j,i) = geo(j,i)
   80       continue
   90    continue
         write(mfgw,'(//10x,''cartesian coordinates '',/)')
         write(mfgw,'(4x,''no.'',7x,''atom'',9x,''x'',
     1  9x,''y'',9x,''z'',/)')
         l=0
         do 100 i=1,numat
            if(nat(i).eq.99.or.nat(i).eq.107) goto 100
            l=l+1
            write(mfgw,'(i6,8x,a2,4x,3f10.4)')
     1           l,elemnt(nat(i)),(coord(j,l),j=1,3)
  100    continue
c
c  if polymer, rotate tvec
c  (beware:  the polymer sections may not work yet)
c
         if (idtvec.gt.0) then
            do 130 i = 1,idtvec
               do 120 j = 1,3
                  sum = 0.0d00
                  do 110 k = 1,3
                     sum = sum + tvec(k,i)*rotvec(k,j)
  110             continue
                  tempv(j,i) = sum
  120          continue
  130       continue
            do 150 i = 1,3
               do 140 j = 1,idtvec
                  tvec(i,j) = tempv(i,j)
  140          continue
  150       continue
            write(mfgw,160)((tvec(j,i),j=1,3),i=1,idtvec)
  160       format(/' new translation vector:'/,
     1           ' ',3(3f15.5))
         endif
      endif
c
      last=1
      na(1)=99
c
c  set up the variables in xparam and loc, these are in cartesian
c  coordinates.
c
      ndep=0
      numat=0
      sumx=0.0d0
      sumy=0.0d0
      sumz=0.0d0
      do 180 i=1,natoms
         if((labels(i).ne.99).and.(labels(i).ne.107)) then
            numat=numat+1
            labels(numat)=labels(i)
            sumx=sumx+coord(1,numat)
            sumy=sumy+coord(2,numat)
            sumz=sumz+coord(3,numat)
            do 170 j=1,3
  170       geo(j,numat)=coord(j,numat)
         endif
  180 continue
      sumx=sumx/numat
      sumy=sumy/numat
      sumz=sumz/numat
      summax=0.0d0
      atpol=0.0d0
      do 190 i=1,numat
         if (labels(i).ne.107) then
            atpol=atpol+polvol(labels(i))
         endif
         geo(1,i)=geo(1,i)-sumx
         if(summax.lt.dabs(geo(1,i))) summax=dabs(geo(1,i))
         geo(2,i)=geo(2,i)-sumy
         if(summax.lt.dabs(geo(2,i))) summax=dabs(geo(2,i))
         geo(3,i)=geo(3,i)-sumz
         if(summax.lt.dabs(geo(3,i))) summax=dabs(geo(3,i))
  190 continue
c
      nvar=0
      natoms = numat
      call compfg(geo, .true., heat0, .true., grad, .false.)
      write(mfgw,200) heat0
  200 format(//' energy of "reoriented" system without field:',
     1        f20.10)
c...............................................................
c
c  variables used for time-dependent calculations
c
c    omega .........  frequency of light (actually input as energy
c                     in ev's.
c    iwfla .........  type of alpha calculation for storing matrices
c                     0 = static
c                     1 = omega
c                     2 = 2*omega
c                     3 = 3*omega
c    iwflb .........  type of beta calculation for storing matrices
c                     0 = (0,0)
c                     1 = (w,w) (shg)
c                     2 = (0,w) (eope)
c                     3 = (w,-w) (or)
c
c  input number of freqencies to run
c
c     ibet = 0  no beta calc
c            1  iterative beta
c           -1  noniter beta (shg)
c           -2  noniter eope
c           -3  noniter or
c
c     igam = 0  no gamma calc
c            1 third harmonic generation input n,0,1,1
c            2 dc-efishg input n,0,1,2
c            3 idri n,0,1,3
c            4 oke n,0,1,4
c            5 dc efior (not available)
c
      read(ird,'(a)') line
      call nuchar(line,value,nvalue)
      iwflb=value(1)
      ibet=value(2)
      igam=value(3)
      atol=value(4)
      maxitu=value(5)
      maxita=value(6)
      btol=value(7)
         do 220 i=1,3
  220    dataev(i)=(i-1)*0.25d0
         nfreq=3
  230 continue
      if (igam.ne.0) then
         ibet = 1
      endif
      write(mfgw,240) nfreq,iwflb,ibet,igam
  240 format(//'  nfreq=',i3,'  iwflb=',i3,'  ibet=',i3,'  igam=',i3)
c
c atol is the maximum tolerance in makeuf and btol is that in bmakuf
c maxitu is the maximum iteration in betaf and maxita is the maximum
c iteration in alphaf
c
c#      read(ir,*,end=99,err=99) atol,maxitu,maxita,btol
      write(mfgw,250) atol,btol,maxitu,maxita
  250 format('  atol=',d12.5,'  btol=',d12.5,'    maxitu=',i5,
     1        '    maxita=',i5)
c
c set up direct access file for t-d matrices
      call openda_mop(0)
c
c calculate alpha at static values
c
      if ((iwflb .eq. 2).or.(igam .eq. 2).or.(igam.eq.4).or.
     1   (ibet.le.-2)) then
         iwfla = 0
         omega = 0.0d00
         call alphaf(iwfla,atol,maxita,x1,x2,x3,x4,x5,x6,x7)
      endif
      if (igam.eq.4) then
         iwflb=0
         call betaf(iwflb,maxitu,btol,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,
     1              x11,x12,x13)
      endif
c
c calculate frequency dependent values
c
      do 280 i = 1, nfreq
c
c  read in freq:  actually read in as energy in ev.
c
         omega=dataev(i)
         omegau = omega/27.2113961d+00
         if (omega.lt.1.0d-8) then
            wavlen = 999999.99d0
c#           write(mfgw,401) omega
            write(mfgw,260)
  260       format(//,' ',65(1h*),/,
     1            ' calculation of static field quantities',/,
     2            ' ',65('*'))
         else
            write(mfgw,270) omega,omegau,1239.8424d0/omega,
     1 8065.541d0*omega
  270       format(//,' ',70(1h*),
     1          /' calculation for a frequency of ',f10.5,' ev  =',
     2           f14.5,' a.u. '/18x,'wavelength of ',f10.2,' nm  =',
     3           f14.5,' cm(-1)',/,
     4           ' ',70('*'))
         endif
c
c  calculate alpha(w)
c
         iwfla = 1
         call alphaf(iwfla,atol,maxita,x1,x2,x3,x4,x5,x6,x7)
c
c  perform noniterative beta calculations
c
c   optical rectification
         if (ibet.eq.-3) then
            call nonor(x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12)
         endif
c   electroptic pockels effect
         if (ibet.eq.-2) then
            call nonope(x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12)
         endif
c   second harmonic generation
         if (ibet.eq.-1) then
            iwfla = 2
            omega = omega*2.0d00
            call alphaf(iwfla,atol,maxita,x1,x2,x3,x4,x5,x6,x7)
            omega = omega/2.0d00
            call nonbet(x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12)
         endif
c
c  perform iterative beta (shg and static)calculations
c
c         if ((ibet.gt.0) .and.(igam .eq. 0)) then
         if ((ibet.eq.1) .and. (iwflb .le. 1) .and. (igam .eq. 0)) then
            call betaf(iwflb,maxitu,btol,x1,x2,x3,x4,x5,x6,x7,x8,
     1                 x9,x10,x11,x12,x13)
c
c perform iterative beta (eope and or) calculations
c
         elseif ((ibet.eq.1).and.(iwflb.gt.1).and.(igam.eq.0)) then
            call beopor(iwflb,maxitu,btol,x1,x2,x3,x4,x5,x6,x7,x8,
     1                  x9,x10,x11,x12,x13)
         endif
c.......................................................................
c calculate gamma values
c.......................................................................
         if ((ibet.gt.0).and.(igam .le. 3).and.(igam.ne.0)) then
            iwflb=1
            call betaf(iwflb,maxitu,btol,x1,x2,x3,x4,x5,x6,x7,x8,
     1                 x9,x10,x11,x12,x13)
         endif
c third harmonic genration
         if (igam.eq.1) then
            iwfla = 3
            omega = omega*3.0d00
            call alphaf(iwfla,atol,maxita,x1,x2,x3,x4,x5,x6,x7)
            omega = omega/3.0d00
            call ngamtg(igam,x1,x2,x3,x4,x5,x6,x7,x8,x9)
         endif
c dc-efishg
         if (igam.eq.2) then
            iwfla = 2
            omega = 2.0d00*omega
            call alphaf(iwfla,atol,maxita,x1,x2,x3,x4,x5,x6,x7)
            omega = omega/2.0d00
            iwflb = 2
            call beopor(iwflb,maxitu,btol,x1,x2,x3,x4,x5,x6,x7,x8,
     1                  x9,x10,x11,x12,x13)
            call ngefis(igam,x1,x2,x3,x4,x5,x6,x7,x8,x9)
         endif
c idri
         if (igam.eq.3) then
            iwflb=3
            call beopor(iwflb,maxitu,btol,x1,x2,x3,x4,x5,x6,x7,x8,
     1                  x9,x10,x11,x12,x13)
            call ngidri(igam,x1,x2,x3,x4,x5,x6,x7,x8,x9)
         endif
c oke
         if (igam.eq.4) then
            iwflb=2
            call beopor(iwflb,maxitu,btol,x1,x2,x3,x4,x5,x6,x7,x8,
     1                  x9,x10,x11,x12,x13)
            call ngoke(igam,x1,x2,x3,x4,x5,x6,x7,x8,x9)
         endif
  280 continue
c
      return
  290 write(mfgw,'('' data for polar calculation either'',
     1'' missing or faulty'')')
      return
      end
c***********************************************************************
      subroutine potcal
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      common /iofile/ mfgr,mfgw
c***********************************************************************
c
c     this routine calculates the total electrostatic potential
c     the nuclear contribution is evaluated by nucpot
c     the electronic contribution is evaluated by elesp
c     espfit fits the quantum potential to a classical point charge
c     model.
c     this routine was written by b.h.besler and k.m.merz in feb.
c     1989 at ucsf
c
c***********************************************************************
      common /keywrd/ keywrd
      common /corec/ core(107)
      common /elemts/ elemnt(107)
      common /densty/ p(mpack),pa(mpack),pb(mpack)
      common /potesp/ xc,yc,zc,espnuc,espele,nesp
      common /work1/  potpt(3,mesp), es(mesp), esp(mesp), work1d(2*mesp)
      common /abc/    co(3,numatm),ian(numatm),natom
      common /dipsto/ ux,uy,uz,ch(numatm)
      common /espf/  al((numatm+4)**2),a(numatm,numatm),b(numatm),
     1q(numatm+4),qsc(numatm+4),cf, espfd(maxorb**2-numatm-5)
      character*241 keywrd
      character *2  elemnt
      logical debug,wrtesp,cequiv(numatm,numatm)
c
c     debug printing - results in copious output
c
      debug = (index(keywrd,'debug') .ne. 0)
c
c
      call elesp
      bohr = 0.529167d00
c
c     now fit the electrostatic potential
c
      write(mfgw,'(//12x,''electrostatic potential charges'',/)')
      iz=0
      if(index(keywrd,'charge=') .ne. 0) iz=reada(keywrd,index(keywrd,
     1'charge='))
c
c     dipolar constraints if desired
c
      if(index(keywrd,'dipole') .ne. 0) then
         idip = 1
         if(iz .ne. 0)then
            idip = 0
            write(mfgw,'(/12x,''  dipole constraints not used'')')
            write(mfgw,'(12x,''        charged molecule'',/)')
         endif
      else
         idip = 0
      endif
      if (idip .eq. 1) then
         write(mfgw,'(/12x,''dipole constraints will be used'',/)')
      endif
c
c     get x,y,z dipole components if desired
c
      if(index(keywrd,'dipx=') .ne. 0) then
         dx = reada(keywrd,index(keywrd,'dipx='))
      else
         dx = ux
      endif
      if(index(keywrd,'dipy=') .ne. 0) then
         dy = reada(keywrd,index(keywrd,'dipy='))
      else
         dy = uy
      endif
      if(index(keywrd,'dipz=') .ne. 0) then
         dz = reada(keywrd,index(keywrd,'dipz='))
      else
         dz = uz
      endif
      call espfit(idip,natom,nesp,iz,esp,potpt,co,dx,dy,dz,rms,rrms)
c
c     write out our results to channel 6
c     the charges are scaled to reproduce 6-31g* charges for mndo only
c     am1 and mindo/3 charges are not scaled due to the low coorelation
c     coefficient. see besler,merz,kollman in j. comput. chem.
c     (in press)
c
      if((index(keywrd,'am1') .ne. 0) .or.
     1(index(keywrd,'mindo') .ne. 0) .or.
     2(index(keywrd,'pm3') .ne. 0))then
         write(mfgw,'(15x,''atom no.    type    charge'')')
         do 10 i=1,natom
            write(mfgw,'(17x,i2,9x,a2,1x,f10.4)')i,elemnt(ian(i)),q(i)
   10    continue
      else
c
c     mndo calculation-scale the charges. test for slope keyword
c
         if(index(keywrd,'slope=') .ne. 0) then
            slope = reada(keywrd,index(keywrd,'slope='))
         else
            slope = 1.422d0
         endif
         do 20 i=1,natom
            qsc(i) = slope*q(i)
   20    continue
         write(mfgw,
     +   '(7x,''atom no.    type    charge   scaled charge'')')
         do 30 i=1,natom
            write(mfgw,
     +   '(9x,i2,9x,a2,1x,f10.4,2x,f10.4)')i,elemnt(ian(i)),
     +     q(i),qsc(i)
   30    continue
      endif
      write(mfgw,'(/12x,a,4x,i6)') 
     +           'the number of points is:',nesp
      write(mfgw,'(12x,a,4x,f9.4)') 'the rms deviation is:',rms
      write(mfgw,'(12x,a,3x,f9.4)') 'the rrms deviation is:',rrms
c
c     calculate dipole moment if neutral molecule
c
      if (iz .ne. 0) then
         go to 60
      else
         write(mfgw,40)
   40    format (//5x,'dipole moment evaluated from '
     1,'the point charges',/)
         do 50 i=1,natom
            dipx=dipx+co(1,i)*q(i)/bohr
            dipy=dipy+co(2,i)*q(i)/bohr
            dipz=dipz+co(3,i)*q(i)/bohr
   50    continue
         dip=dsqrt(dipx**2+dipy**2+dipz**2)
         write(mfgw,'(12x,'' x        y        z       total'')')
         write(mfgw,'(8x,4f9.4)')dipx*cf,dipy*cf,dipz*cf,dip*cf
      endif
   60 continue
c     determine which charges should be equivalent by symmetry and
c     average them if desired
      if(index(keywrd,'symavg') .ne. 0) then
         do 70 i=1,natom
            do 70 j=1,natom
            cequiv(i,j)=.false.
            if(dabs(dabs(ch(i))-dabs(ch(j))) .lt. 1.d-5)  
     +         cequiv(i,j)=.true.
   70    continue
         do 90 i=1,natom
            ieq=0
            qsc(i)=0.0d0
            do 80 j=1,natom
               if(cequiv(i,j)) then
                  qsc(i)=qsc(i)+dabs(q(j))
                  ieq=ieq+1
               endif
   80       continue
            ch(i)=q(i)/dabs(q(i))*qsc(i)/ieq
   90    continue
         write(mfgw,*) ' '
         write(mfgw,*)'   electrostatic potential charges averaged for'
         write(mfgw,*)'   symmetry equivalent atoms'
         write(mfgw,*) ' '
         if((index(keywrd,'am1') .ne. 0) .or.
     1(index(keywrd,'mindo') .ne. 0) .or.
     2(index(keywrd,'pm3') .ne. 0))then
            write(mfgw,'(7x,''atom no.    type    charge'')')
            do 100 i=1,natom
               write(mfgw,'(9x,i2,9x,a2,1x,f10.4)')i,elemnt(ian(i)),
     1   ch(i)
  100       continue
         else
            write(mfgw,
     +      '(7x,''atom no.    type    charge   scaled charge'')
     1')
            do 110 i=1,natom
               write(mfgw,
     +         '(9x,i2,9x,a2,1x,f10.4,2x,f10.4)')i,elemnt(ian(i)), 
     +         ch(i),ch(i)*slope
  110       continue
         endif
      endif
      return
      end
      subroutine powsav(hess, grad, xparam, pmat, iloop, bmat, ipow)
      implicit REAL (a-h,o-z)
_IF(ipsc,tools)
      logical oroot
_ENDIF
INCLUDE(common/sizes)
INCLUDE(../m4/common/utilc)
      common /iofile/ mfgr,mfgw
      dimension hess(maxpar,*),grad(*),bmat(maxpar,*),ipow(9),
     1 xparam(*), pmat(*)
**********************************************************************
*
* powsav stores and restores data used in the sigma geometry
*        optimisation.
*
*  on input hess   = hessian matrix, partial or whole.
*           grad   = gradients.
*           xparam = current state of parameters.
*           iloop  = index of hessian, or flag of point reached so-far.
*           bmat   = "b" matrix!
*           ipow   = indices and flags.
*           ipow(9)= 0 for restore, 1 for dump
*
**********************************************************************
      common /geovar/ nvar,loc(2,maxpar), idumy, dumy(maxpar)
      common /errfn/ errfn(maxpar), aicorr(maxpar)
      common /elemts/ elemnt(107)
      common /geosym/ ndep,locpar(maxpar),idepfn(maxpar),
     1                     locdep(maxpar)
      common /geokst/ natoms,labels(numatm),
     1                na(numatm),nb(numatm),nc(numatm)
      common /cmpg/ geo(3,numatm)
      common /locvar/ locvar(2,maxpar)
      common /keywrd/ keywrd
      common /valvar/ valvar(maxpar),numvar
      dimension coord(3,numatm)
      character elemnt*2, keywrd*241, getmop*80
      common /densty/ p(mpack), pa(mpack), pb(mpack)
      common /alparm/ alparm(3,maxpar),x0, x1, x2, jloop
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),
     1                nlast(numatm), norbs, nelecs,nalpha,nbeta,
     2                nclose,nopen,ndumy,fract
      common /path/ latom,lparam,react(200)
_IF(ipsc,tools)
      if(oroot().and.odumpm) then
_ELSE
      if(odumpm) then
_ENDIF
      open(unit=9,file=getmop(3),
     +     status='unknown',form='unformatted')
      rewind 9
      open(unit=10,file=getmop(4),
     +     status='unknown',form='unformatted')
      rewind 10
      endif
      ir=9
      if(ipow(9) .ne. 0) then
         if(ipow(9) .eq. 1) then
            write(mfgw,
     +      '(//10x,''- - - - - - - time up - - - - - - -'',//)')
            write(mfgw,
     +      '(//10x,'' - the calculation is being dumped to disk'',/
     +      10x,''   restart it using the key-word "restart"'')')
            funct1=dsqrt(ddot(nvar,grad,1,grad,1))
            write(mfgw,'(//10x,''current value of gradient norm =''
     1  ,f12.6)')funct1
            do 10 i=1,nvar
               k=loc(1,i)
               l=loc(2,i)
   10       geo(l,k)=xparam(i)
            write(mfgw,'(/10x,''current value of geometry'',/)')
            if(na(1) .eq. 99) then
c
c  convert from cartesian coordinates to internal
c
               do 20 i=1,natoms
                  do 20 j=1,3
   20          coord(j,i)=geo(j,i)
               call mopxyz(coord,numat,na,nb,nc,1.d0,geo)
            endif
            call geout(6)
         endif
_IF(ipsc,tools)
         if(oroot().and.odumpm) then
_ELSE
         if(odumpm) then
_ENDIF
         write(ir)ipow,iloop
         write(ir)(xparam(i),i=1,nvar)
         write(ir)(  grad(i),i=1,nvar)
         write(ir)((hess(j,i),j=1,nvar),i=1,nvar)
         write(ir)((bmat(j,i),j=1,nvar),i=1,nvar)
         linear=(nvar*(nvar+1))/2
         write(ir)(pmat(i),i=1,linear)
         if(index(keywrd,'aider').ne.0) write(ir)(aicorr(i),i=1,nvar)
         linear=(norbs*(norbs+1))/2
         write(10)(pa(i),i=1,linear)
         if(nalpha.ne.0)write(10)(pb(i),i=1,linear)
         if(latom .ne. 0) then
            write(ir)((alparm(j,i),j=1,3),i=1,nvar)
            write(ir)jloop,x0, x1, x2
         endif
         close (9)
         close (10)
         endif
         return
      else
         write(mfgw,'(//10x,'' restoring data from disk''/)')
_IF(ipsc,tools)
         if(oroot()) then
_ENDIF
         read(ir)ipow,iloop
         read(ir)(xparam(i),i=1,nvar)
         read(ir)(  grad(i),i=1,nvar)
         read(ir)((hess(j,i),j=1,nvar),i=1,nvar)
         read(ir)((bmat(j,i),j=1,nvar),i=1,nvar)
         funct1=dsqrt(ddot(nvar,grad,1,grad,1))
         write(mfgw,'(10x,''function ='',f13.6//)')funct1
         linear=(nvar*(nvar+1))/2
         read(ir)(pmat(i),i=1,linear)
         if(index(keywrd,'aider').ne.0) read(ir)(aicorr(i),i=1,nvar)
         linear=(norbs*(norbs+1))/2
         read(10)(pa(i),i=1,linear)
         if(nalpha.ne.0)read(10)(pb(i),i=1,linear)
         if(latom.ne.0) then
            read(ir)((alparm(j,i),j=1,3),i=1,nvar)
            read(ir)jloop,x0, x1, x2
            iloop=iloop+1
         endif
         iloop=iloop+1
_IF(ipsc,tools)
         else
         write(mfgw,*)' restart not available in powsav'
         call pend
         endif
_ENDIF
         return
      endif
      end
      subroutine powsq(xparam, nvar, funct)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      common /iofile/ mfgr,mfgw
      dimension xparam(*)
      common /mesage/ iflepo,iscf
**********************************************************************
*
*   powsq optimizes the geometry by minimising the gradient norm.
*         thus both ground and transition state geometries can be
*         calculated. it is roughly equivalent to flepo, flepo minimizes
*         the energy, powsq minimizes the gradient norm.
*
*  on entry xparam = values of parameters to be optimized.
*           nvar   = number of parameters to be optimized.
*
*  on exit  xparam = optimized parameters.
*           funct  = heat of formation in kcals.
*
**********************************************************************
c        *****  routine performs  a least squares minimization  *****
c        *****  of a function which is a sum of squares.        *****
c        *****  initially written by j.w. mciver jr. at suny/   *****
c        *****  buffalo, summer 1971.  rewritten and modified   *****
c        *****  by a.k. at suny buffalo and the university of   *****
c        *****  texas.  december 1973                           *****
c
      common /geovar/ ndum,loc(2,maxpar), idumy, xaram(maxpar)
      common /cmpg/ geo(3,numatm)
      common /last/ last
      common /keywrd/ keywrd
      common /timem/ time0
      common /numscf/ nscf
      common /geosym/ ndep, locpar(maxpar), idepfn(maxpar),
     1                 locdep(maxpar)
      common /gradnt/ grad(maxpar),gnfina
      common /timdmp/ tleft, tdump
      common /geokst/ natoms,labels(numatm),
     1                na(numatm),nb(numatm),nc(numatm)
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),
     1                nlast(numatm), norbs, nelecs,nalpha,nbeta,
     2                nclose,nopen,ndumy,fract
      common /numcal/ numcal
      common /sigma1/ gnext, amin, anext
      common /sigma2/ gnext1(maxpar), gmin1(maxpar)
      common /nllcom/ hess(maxpar,maxpar),bmat(maxpar,maxpar),
     1pmat(maxpar*maxpar)
      common /scrach/ pvec
      dimension ipow(9), sig(maxpar),
     1          e1(maxpar), e2(maxpar),
     2          p(maxpar), work(maxpar),
     3          pvec(maxpar*maxpar), eig(maxpar), q(maxpar)
      logical debug, restrt, times, okf, scf1, resfil, log
      character*241 keywrd
c     save icalcn
      save icalcn,restrt,log,scf1,icyc,times,resfil,tol2,rho2,xinc
      data  icalcn /0/
      if(icalcn.ne.numcal) then
         icalcn=numcal
         restrt=(index(keywrd,'restart') .ne. 0)
         log=(index(keywrd,'nolog') .eq. 0)
         scf1=(index(keywrd,'1scf') .ne. 0)
         time1=secmop()
         time2=time1
         icyc=0
         times=(index(keywrd,'time') .ne. 0)
         tlast=tleft
         resfil=.false.
         last=0
         iloop=1
         xinc=0.00529167d0
         rho2=1.d-4
         tol2=4.d-1
         if(index(keywrd,'prec') .ne. 0) tol2=1.d-2
         if(index(keywrd,'gnorm') .ne. 0) then
            tol2=reada(keywrd,index(keywrd,'gnorm'))
            if(tol2.lt.0.01d0.and.index(keywrd,' let').eq.0)then
               write(mfgw,
     +         '(/,a)')'  gnorm has been set too low, reset to 0.01'
               tol2=0.01d0
            endif
         endif
         debug = (index(keywrd,'powsq') .ne. 0)
         if(restrt) then
c
c   restore stored data
c
            ipow(9)=0
            call powsav(hess,gmin1,xparam,pmat,iloop,bmat,ipow)
            if(scf1) goto 390
            nscf=ipow(8)
            do 10 i=1,nvar
               grad(i)=gmin1(i)
   10       gnext1(i)=gmin1(i)
            write(mfgw,'('' xparam'',6f10.6)')(xparam(i),i=1,nvar)
            if(iloop .gt. 0) then
c#               iloop=iloop+1
               write(mfgw,'(//10x,'' restarting at point'',i3)')iloop
            else
               write(mfgw,'(//10x,''restarting in optimisation'',
     1         '' routines'')')
            endif
         endif
*
*   definitions:   nvar   = number of geometric variables = 3*numat-6
*
      endif
      nvar=iabs(nvar)
      if(debug) then
         write(mfgw,'('' xparam'')')
         write(mfgw,'(5(2i3,f10.4))')
     +   (loc(1,i),loc(2,i),xparam(i),i=1,nvar)
      endif
      if( .not. restrt) then
         do 20 i=1,nvar
   20    grad(i)=0.0d0
         call compfg(xparam, .true., funct, .true., grad, .true.)
      endif
      if(debug) then
         write(mfgw,'('' starting gradients'')')
         write(mfgw,'(3x,8f9.4)')(grad(i),i=1,nvar)
      endif
      gmin=dsqrt(ddot(nvar,grad,1,grad,1))
      do 30 i=1,nvar
         gnext1(i)=grad(i)
         gmin1(i)=gnext1(i)
   30 continue
c
c    now to calculate the hessian matrix.
c
      if(iloop.lt.0) goto 140
c
c   check that hessian has not already been calculated.
c
      ilpr=iloop
      do 50 iloop=ilpr,nvar
         time1=secmop()
         xparam(iloop)=xparam(iloop) + xinc
         call compfg(xparam, .true., funct, .true., grad, .true.)
         if(scf1) goto 390
         if(debug)write(mfgw,'(i3,12(8f9.4,/3x))')
     1    iloop,(grad(if),if=1,nvar)
         grad(iloop)=grad(iloop)+1.d-5
         xparam(iloop)=xparam(iloop) - xinc
         do 40 j=1,nvar
   40    hess(iloop,j)=-(grad(j)-gnext1(j))/xinc
         time2=secmop()
         tstep=time2-time1
         if(times)write(mfgw,
     +   '('' time for step:'',f8.2,'' left'',f8.2)')
     1    tstep, tleft
         if(tlast-tleft.gt.tdump)then
            tlast=tleft
            resfil=.true.
            ipow(9)=2
            i=iloop
            ipow(8)=nscf
            call powsav(hess,gmin1,xparam,pmat,i,bmat,ipow)
         endif
         if( tleft .lt. tstep*2.d0) then
c
c  store results to date.
c
            ipow(9)=1
            i=iloop
            ipow(8)=nscf
            call powsav(hess,gmin1,xparam,pmat,i,bmat,ipow)
_IF(ipsc,tools)
            call pend
_ELSE
            stop
_ENDIF
         endif
   50 continue
c        *****  scale -hessian- matrix                           *****
      if( debug) then
         write(mfgw,'(//10x,''un-normalized hessian matrix'')')
         do 60 i=1,nvar
   60    write(mfgw,'(8f10.4)')(hess(j,i),j=1,nvar)
      endif
      do 80 i=1,nvar
         sum = 0.0d0
         do 70 j=1,nvar
   70    sum = sum+hess(i,j)**2
   80 work(i) = 1.0d0/dsqrt(sum)
      do 90 i=1,nvar
         do 90 j=1,nvar
   90 hess(i,j) = hess(i,j)*work(i)
      if( debug) then
         write(mfgw,'(//10x,''hessian matrix'')')
         do 100 i=1,nvar
  100    write(mfgw,'(8f10.4)')(hess(j,i),j=1,nvar)
      endif
c        *****  initialize b matirx                        *****
      do 120 i=1,nvar
         do 110 j=1,nvar
  110    bmat(i,j) = 0.0d0
  120 bmat(i,i) = work(i)*2.d0
************************************************************************
*
*  this is the start of the big loop to optimize the geometry
*
************************************************************************
      iloop=-99
      tstep=tstep*4
  130 continue
      if(tlast-tleft.gt.tdump)then
         tlast=tleft
         resfil=.true.
         ipow(9)=2
         i=iloop
         ipow(8)=nscf
         call powsav(hess,gmin1,xparam,pmat,i,bmat,ipow)
      endif
      if( tleft .lt. tstep*2.d0) then
c
c  store results to date.
c
         ipow(9)=1
         i=iloop
         ipow(8)=nscf
         call powsav(hess,gmin1,xparam,pmat,i,bmat,ipow)
         iflepo=-1
         return
      endif
  140 continue
c        *****  form-a- dagger-a- in pa slong with -p-     *****
      ij=0
      do 160 j=1,nvar
         do 160 i=1,j
            ij=ij+1
            sum = 0.0d0
            do 150 k=1,nvar
  150       sum = sum + hess(i,k)*hess(j,k)
  160 pmat(ij) = sum
      do 180 i=1,nvar
         sum = 0.0d0
         do 170 k=1,nvar
  170    sum = sum-hess(i,k)*gmin1(k)
  180 p(i) = -sum
      l=0
      if(debug) then
         write(mfgw,'(/10x,''p matrix in powsq'')')
         call vecprt(pmat,nvar)
      endif
      call rsp(pmat,nvar,nvar,eig,pvec)
c        *****  check for zero eigenvalue                  *****
c#      write(mfgw,'(''  eigs in powsq:'')')
c#      write(mfgw,'(6f13.8)')(eig(i),i=1,nvar)
      if(eig(1).lt.rho2) go to 240
c        *****  if matrix is not singular form inverse     *****
c        *****  by back transforming the eigenvectors      *****
      ij=0
      do 200 i=1,nvar
         do 200 j=1,i
            ij=ij+1
            sum = 0.0d0
            do 190 k=1,nvar
  190       sum = sum+pvec((k-1)*nvar+j)*pvec((k-1)*nvar+i)/eig(k)
  200 pmat(ij) = sum
c        *****  find -q- vector                            *****
      l=0
      il=l+1
      l=il+i-1
      do 230 i=1,nvar
         sum = 0.0d0
         do 210 k=1,i
            ik=(i*(i-1))/2+k
  210    sum = sum+pmat(ik)*p(k)
         ip1=i+1
         do 220 k=ip1,nvar
            ik=(k*(k-1))/2+i
  220    sum=sum+pmat(ik)*p(k)
  230 q(i) = sum
      go to 260
  240 continue
c        *****  take  -q- vector as eigenvector of zero     *****
c        *****  eigenvalue                                 *****
      do 250 i=1,nvar
  250 q(i) = pvec(i)
  260 continue
c        *****  find search direction                      *****
      do 270 i=1,nvar
         sig(i) = 0.0d0
         do 270 j=1,nvar
  270 sig(i) = sig(i) + q(j)*bmat(i,j)
c        *****  do a one dimensional search                *****
      if (debug) then
         write(mfgw,'('' search vector'')')
         write(mfgw,'(8f10.5)')(sig(i),i=1,nvar)
      endif
      call mopsrc(xparam, alpha, sig, nvar, gmin, okf, funct)
      if( nvar .eq. 1) goto 390
c
c  first we attempt to optimize geometry using search.
c  if this does not work, then switch to linmin, which always works,
c  but is twice as slow as search.
c
      rmx = 0.0d0
      do 280 k=1,nvar
         rt = dabs(gmin1(k))
         if(rt.gt.rmx)rmx = rt
  280 continue
      if(rmx.lt.tol2) go to 390
c        *****  two step estimation of derivatives         *****
      do 290 k=1,nvar
  290 e1(k) = (gmin1(k)-gnext1(k))/(amin-anext)
      rmu = ddot(nvar,e1,1,gmin1,1)/
     +      ddot(nvar,gmin1,1,gmin1,1)
      do 300 k=1,nvar
  300 e2(k) = e1(k) - rmu*gmin1(k)
c        *****  scale -e2- and -sig-                       *****
      sk = 1.0d0/dsqrt(ddot(nvar,e2,1,e2,1))
      do 310 k=1,nvar
  310 sig(k) = sk*sig(k)
      do 320 k=1,nvar
  320 e2(k) = sk*e2(k)
c        *****  find index of replacement direction        *****
      pmax = -1.0d+20
      do 330 i=1,nvar
         if(dabs(p(i)*q(i)).le.pmax) go to 330
         pmax = dabs(p(i)*q(i))
         id = i
  330 continue
c        *****  replace appropriate direction and derivative ***
      do 340 k=1,nvar
  340 hess(id,k) = -e2(k)
c        *****  replace starting point                     *****
      do 350 k=1,nvar
  350 bmat(k,id) = sig(k)/0.529167d0
      do 360 k=1,nvar
  360 gnext1(k) = gmin1(k)
      time1=time2
      time2=secmop()
      tleft=tleft-time2+time0
      tstep=time2-time1
      icyc=icyc+1
      if(resfil)then
         write(mfgw,370)dmin1(tleft,9999999.9d0),
     1dmin1(gmin,999999.999d0),funct
         if(log)write(11,370)dmin1(tleft,9999999.9d0),
     1dmin1(gmin,999999.999d0),funct
  370    format('  restart file written,  time left:',f9.1,
     1' grad.:',f10.3,' heat:',g14.7)
         resfil=.false.
      else
         write(mfgw,380)icyc,dmin1(tstep,9999.99d0),
     1dmin1(tleft,9999999.9d0),dmin1(gmin,999999.999d0),funct
         if(log)write(11,380)icyc,dmin1(tstep,9999.99d0),
     1dmin1(tleft,9999999.9d0),dmin1(gmin,999999.999d0),funct
  380    format(' cycle:',i5,' time:',f6.1,' time left:',f9.1,
     1' grad.:',f10.3,' heat:',g14.7)
      endif
      if(times)write(mfgw,
     +   '('' time for step:'',f8.2,'' left'',f8.2)')
     1tstep, tleft
      go to 130
  390 continue
      do 400 i=1,nvar
  400 grad(i)=0.0d0
      last=1
      call compfg(xparam, .true., funct, .true., grad, .true.)
      do 410 i=1,nvar
  410 grad(i)=gmin1(i)
      gnfina=dsqrt(ddot(nvar,grad,1,grad,1))
      iflepo=11
      if(scf1)iflepo=13
      return
      end
      subroutine prtdrc(escf,deltt,xparam,ref,ekin,gtot,etot,velo0,nvar)
      implicit REAL (a-h,o-z)
      common /iofile/ mfgr,mfgw
      dimension xparam(*), velo0(*), ref(*)
*********************************************************************
*
*    prtdrc prepares to print the geometry etc. for points in a drc
*    or irc
*    calculation.
*    on input  escf   = heat of formation for the current point
*              deltt  = change in time, previous to current point
*              xparam = current cartesian geometry
*              ekin   = current kinetic energy
*              gtot   = total gradient norm in irc calc'n.
*              velo0  = current velocity
*              nvar   = number of variables = 3 * number of atoms.
*
********************************************************************
INCLUDE(common/sizes)
      common /keywrd/ keywrd
      common /numcal/ numcal
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),
     1                nlast(numatm), norbs, nelecs,nalpha,nbeta,
     2                nclose,nopen,ndumy,xract
      common /geokst/ natoms,labels(numatm),
     1                na(numatm),nb(numatm),nc(numatm)
      common /drccom/  mcoprt(2,maxpar), ncoprt, parmax
      common /corec/ core(107)
      common /atmass/ atmass(numatm)
      common /densty/ p(mpack),pa(mpack),pb(mpack)
      common /fmatrx/ allxyz(3,maxpar),allvel(3,maxpar),parref(maxpar),
     1xyz3(3,maxpar),vel3(3,maxpar), allgeo(3,maxpar), geo3(3,maxpar),
     2 dummy(maxpar**2+1-16*maxpar), idumy(4)
      dimension escf3(3),ekin3(3), gtot3(3), charge(numatm), xold3(3),
     1geo(3*numatm), vref(maxpar), vref0(maxpar), tsteps(100), etot3(3),
     2xtot3(3)
      save  refscf, cotype
      logical  turn, parmax, ldrc, goturn
      character*241 keywrd, text1*3, text2*2,  cotype(3)*2
      save icalcn, goturn
      data icalcn/0/
      data refscf/0.d0/
      data cotype/'bl','ba','di'/
      if (icalcn.ne.numcal) then
         icalcn=numcal
         do 10 i=1,nvar
   10    parref(i)=xparam(i)
         etot=escf+ekin
         tlast=0.0d0
         goturn=.false.
         sum=0.0d0
         do 20 i=1,nvar
            sum=sum+velo0(i)**2
            vref0(i)=velo0(i)
   20    vref(i)=velo0(i)
         ione=1
         ldrc=(sum.gt.1.d0)
         iloop=1
         told1=0.0d0
c
c       determine type of print: time, energy or geometry priority
c       or print all points
c
         stept=0.0d0
         steph=0.0d0
         stepx=0.0d0
         if(index(keywrd,' t-prio').ne.0)then
            if(index(keywrd,' t-priority=').ne.0)then
               stept=reada(keywrd,index(keywrd,'t-prio')+5)
            else
               stept=0.1d0
            endif
            tref=-1.d-6
            write(mfgw,'(/,'' time priority, interval ='',f4.1,
     1'' femtoseconds'',/)')stept
         elseif(index(keywrd,' h-prio').ne.0)then
            if(index(keywrd,' h-priority=').ne.0)then
               steph=reada(keywrd,index(keywrd,'h-prio')+5)
            else
               steph=0.1d0
            endif
            write(mfgw,'(/,'' kinetic energy priority, step ='',f5.2,
     1'' kcal/mole'',/)')steph
         elseif(index(keywrd,' x-prio').ne.0)then
            if(index(keywrd,' x-priority=').ne.0)then
               stepx=reada(keywrd,index(keywrd,'x-prio')+5)
            else
               stepx=0.05d0
            endif
            write(mfgw,'(/,'' geometry priority, step ='',f5.2,
     1'' angstroms'',/)')stepx
         endif
         if(index(keywrd,' restart').ne.0.and.index(keywrd,'irc=').eq.0)
     1 then
            read(9,*)(parref(i),i=1,nvar)
            read(9,*)(ref(i),i=1,nvar)
            read(9,*)(vref0(i),i=1,nvar)
            read(9,*)(vref(i),i=1,nvar)
            read(9,*)(allgeo(3,i),i=1,nvar)
            read(9,*)(allgeo(2,i),i=1,nvar)
            read(9,*)(allgeo(1,i),i=1,nvar)
            read(9,*)(allvel(3,i),i=1,nvar)
            read(9,*)(allvel(2,i),i=1,nvar)
            read(9,*)(allvel(1,i),i=1,nvar)
            read(9,*)(allxyz(3,i),i=1,nvar)
            read(9,*)(allxyz(2,i),i=1,nvar)
            read(9,*)(allxyz(1,i),i=1,nvar)
            read(9,*)iloop,ldrc,ione,etot1,etot0,escf1,escf0,ekin1,ekin0
     1,told2,told1,gtot1,gtot0,xold2,xold1,xold0,totime,jloop,etot,refx
     2,xtot1,xtot0
         endif
      endif
      if(escf.lt.-1.d8) then
         write(9,*)(parref(i),i=1,nvar)
         write(9,*)(ref(i),i=1,nvar)
         write(9,*)(vref0(i),i=1,nvar)
         write(9,*)(vref(i),i=1,nvar)
         write(9,*)(allgeo(3,i),i=1,nvar)
         write(9,*)(allgeo(2,i),i=1,nvar)
         write(9,*)(allgeo(1,i),i=1,nvar)
         write(9,*)(allvel(3,i),i=1,nvar)
         write(9,*)(allvel(2,i),i=1,nvar)
         write(9,*)(allvel(1,i),i=1,nvar)
         write(9,*)(allxyz(3,i),i=1,nvar)
         write(9,*)(allxyz(2,i),i=1,nvar)
         write(9,*)(allxyz(1,i),i=1,nvar)
         write(9,*)iloop,ldrc,ione,etot1,etot0,escf1,escf0,ekin1,ekin0,
     1told2,told1,gtot1,gtot0,xold2,xold1,xold0,totime,jloop,etot,refx
     2,xtot1,xtot0
         return
      endif
      call chrge(p,charge)
      do 30 i=1,numat
         l=nat(i)
   30 charge(i)=core(l) - charge(i)
      deltat=deltt*1.d15
      na(2)=-1
      call mopxyz(xparam,numat,na,nb,nc,57.29577951d0,geo)
      na(1)=99
      if(iloop.eq.1)then
         etot1=etot0
         etot0=etot
         escf1=escf
         escf0=escf
         ekin1=ekin
         ekin0=ekin
         do 40 j=1,3
c$doit vbest
            do 40 i=1,nvar
               allgeo(j,i)=geo(i)
               allxyz(j,i)=xparam(i)
   40    allvel(j,i)=velo0(i)
      else
         do 50 i=1,nvar
            allgeo(3,i)=allgeo(2,i)
            allgeo(2,i)=allgeo(1,i)
            allgeo(1,i)=geo(i)
            allxyz(3,i)=allxyz(2,i)
            allxyz(2,i)=allxyz(1,i)
            allxyz(1,i)=xparam(i)
            allvel(3,i)=allvel(2,i)
            allvel(2,i)=allvel(1,i)
   50    allvel(1,i)=velo0(i)
      endif
c
c  form quadratic expression for position and velocity w.r.t. time.
c
      t1=dmax1(told2,0.02d0)
      t2=dmax1(told1,0.02d0)+t1
      do 60 i=1,nvar
         call quadr(allgeo(3,i),allgeo(2,i),allgeo(1,i),t1,t2,
     1geo3(1,i),geo3(2,i),geo3(3,i))
c
****************************************************
*                                                  *
*    quadr calculates the a, b and c in the equns. *
*                                                  *
*     a                   =   f0                   *
*     a + b.x0 + c.x0**2  =   f1                   *
*     a + b.x2 + c.x2**2  =   f2                   *
* given the argument list (f0,f1,f2, x1,x2, a,b,c) *
*                                                  *
****************************************************
         call quadr(allxyz(3,i),allxyz(2,i),allxyz(1,i),t1,t2,
     1xyz3(1,i),xyz3(2,i),xyz3(3,i))
         call quadr(allvel(3,i),allvel(2,i),allvel(1,i),t1,t2,
     1vel3(1,i),vel3(2,i),vel3(3,i))
   60 continue
      etot2=etot1
      etot1=etot0
      etot0=etot
      call quadr(etot2,etot1,etot0,t1,t2,etot3(1),etot3(2),
     1etot3(3))
      ekin2=ekin1
      ekin1=ekin0
      ekin0=ekin
      call quadr(ekin2,ekin1,ekin0,t1,t2,ekin3(1),ekin3(2),
     1ekin3(3))
      escf2=escf1
      escf1=escf0
      escf0=escf
      call quadr(escf2,escf1,escf0,t1,t2,escf3(1),escf3(2),
     1escf3(3))
      gtot2=gtot1
      gtot1=gtot0
      gtot0=gtot
      call quadr(gtot2,gtot1,gtot0,t1,t2,gtot3(1),gtot3(2),
     1gtot3(3))
      xtot2=xtot1
      xtot1=xtot0
      xold2=xold2+xold1
      xold1=xold0
c
c   calculate change in geometry
c
      xold0=0.0d0
      l=0
      xtot0=0.0d0
      sum1=0.0d0
      do 80 i=1,numat
         sum=0.0d0
         sum1=0.0d0
c$doit asis
         do 70 j=1,3
            l=l+1
            sum1=sum1+(allxyz(1,l)-ref(l))**2
   70    sum=sum+(allxyz(2,l)-allxyz(1,l))**2
         xold0=xold0+dsqrt(sum)
   80 xtot0=xtot0+dsqrt(sum1)
      call quadr(xtot2,xtot1,xtot0,t1,t2,
     1xtot3(1),xtot3(2),xtot3(3))
      call quadr(xold2,xold2+xold1,xold2+xold1+xold0,t1,t2,
     1xold3(1),xold3(2),xold3(3))
***********************************************************************
*   go through the criteria for deciding whether or not to print this *
*   point.  if yes, then also calculate the exact point as a fraction *
*   between the last point and the current point                      *
***********************************************************************
c   nfract is the number of points to be printed in the current domain
***********************************************************************
      if(iloop.lt.3) goto 170
      fract=-10.0d0
      nfract=1
      if(steph.ne.0) then
c
c   criterion for printing results  is a change in heat of formation =
c   -change in kinetic energy
c
         if(refscf.eq.0.d0) then
            i=escf2/steph
            refscf=i*steph
         endif
         dh=dabs(escf1-refscf)
         if(dh.gt.steph)then
            steph=dsign(steph,escf1-refscf)
            nfract=dabs(dh/steph)
            cc=escf3(1)
            bb=escf3(2)
            aa=escf3(3)
************************************************
* programmers! - be very careful if you change *
* this following section.  there is numerical  *
* instability if abs(bb/aa) is very large. near*
* inflection points aa changes sign.       jjps*
************************************************
            if(dabs(bb/aa).gt.30.0d0)then
c
c   use linear interpolation
c
               do 90 i=1,nfract
   90          tsteps(i)=-(cc-(refscf+i*steph))/bb
            else
c
c  use quadratic interpolation
c
               do 100 i=1,nfract
                  c1=cc-(refscf+i*steph)
  100          tsteps(i)=(-bb+dsign(dsqrt(bb*bb-4.d0*(aa*c1)),bb))/
     +                   (2.d0*aa)
            endif
            fract=-.1d0
            refscf=refscf+nfract*steph
         endif
      elseif(stept.ne.0.d0) then
c
c   criterion for printing results is a change in time.
c
         if(dabs(totime+told2-tref).gt.stept)then
            i=totime/stept
            fract=i*stept-totime
            i=(told2+totime)/stept
            j=totime/stept
            nfract=i-j+ ione
            ione=0
            do 110 i=1,nfract
  110       tsteps(i)=fract+i*stept
            tref=tref+nfract*stept
         endif
      elseif(stepx.ne.0.d0) then
c
c   criterion for printing results is a change in geometry.
c
         if(xold2+xold1-refx.gt.stepx)then
            nfract=(xold2+xold1-refx)/stepx
            cc=xold3(1)
            bb=xold3(2)
            aa=xold3(3)
            if(dabs(bb/aa).gt.30.0d0)then
c
c   use linear interpolation
c
               do 120 i=1,nfract
  120          tsteps(i)=-(cc-(refx+i*stepx))/bb
            else
c
c  use quadratic interpolation
c
               do 130 i=1,nfract
                  c1=cc-(refx+i*stepx)
  130          tsteps(i)=(-bb+dsign(dsqrt(bb*bb-4.d0*(aa*c1)),bb))/
     +                   (2.d0*aa)
            endif
            refx=refx+nfract*stepx
            fract=-.1d0
         endif
      else
c
c   print every point.
c
         fract=0.0d0
      endif
      if(fract.lt.-9.d0)goto 170
      turn=(turn.or.dabs(fract-1.d0).gt.1.d-6)
c
c  loop over all points in current domain
c
      if(fract.eq.0.d0.and.nfract.eq.1)then
         text1=' '
         text2=' '
         ii=0
         call drcout(xyz3,geo3,vel3,nvar,totime,escf3,ekin3,
     1gtot3,etot3,xtot3,iloop,charge,fract,text1,text2,ii,jloop)
         n=0
         do 140 i=1,ncoprt
            k=mcoprt(1,i)
            j=mcoprt(2,i)
            l=k*3-3+j
            if(dabs(geo3(3,l)).gt.1.d-20)
     +         fract=-geo3(2,l)/(geo3(3,l)*2.d0)
            if(fract.gt.0.d0.and.fract.lt.told2) then
               if(geo3(3,l).gt.0.d0)text1='min'
               if(geo3(3,l).lt.0.d0)text1='max'
               text2=cotype(j)
               if(n.eq.0)then
                  n=n+1
                  write(mfgw,'(/,20(''****''))')
               endif
               time=totime+fract
               call drcout(xyz3,geo3,vel3,nvar,time,escf3,ekin3,
     1gtot3,etot3,xtot3,iloop,charge,fract,text1,text2,k,jloop)
            endif
  140    continue
         if(n.ne.0)write(mfgw,'(/,20(''****''))')
         if(dabs(escf3(3)).gt.1.d-20)
     +      fract=-escf3(2)/(escf3(3)*2.d0)
         if(.not.goturn.and.fract.gt.0.d0.and.fract.lt.told2*1.04d0
     1.and. parmax) then
            goturn=.true.
            time=fract+totime
            if(escf3(3).gt.0.d0) then
               text1='min'
               if(ldrc) then
                  sum=ddot(nvar,velo0,1,vref,1)**2/
     +               (ddot(nvar,velo0,1,velo0,1)*
     1                ddot(nvar,vref,1,vref,1)+1.d-10)
                 sum1=ddot(nvar,velo0,1,vref0,1)**2/
     +               (ddot(nvar,velo0,1,velo0,1)*
     1                ddot(nvar,vref0,1,vref0,1)+1.d-10)
                  if(sum1.gt.0.1d0.and.dabs(sum1-1.d0).gt.1.d-6)
     1write(mfgw,'(/,a,f8.5,a,f8.5,a,g12.3,a)')' coef. of v(0)
     2=',sum1,'   last v(0)',sum,'   half-life =',
     3-0.6931472d0*time/log(sum1),' femtosecs'
               endif
               write(mfgw,'(//,a,f11.3,a)')' half-cycle time ='
     1,time-tlast,' femtoseconds'
               tlast=time
               do 150 i=1,nvar
  150          vref(i)=velo0(i)
            endif
            if(escf3(3).lt.0.d0)text1='max'
            text2=' '
            call drcout(xyz3,geo3,vel3,nvar,time,escf3,ekin3,
     1gtot3,etot3,xtot3,iloop,charge,fract,text1,text2,0,jloop)
         else
            goturn=.false.
         endif
      else
         do 160 i=1,nfract
            time=totime+tsteps(i)
            text1=' '
            text2=' '
c#           write(mfgw,'(a,4f12.4)')' kinetic energy, point',ekin3,tsteps(
            call drcout(xyz3,geo3,vel3,nvar,time,escf3,ekin3,
     1gtot3,etot3,xtot3,iloop,charge,tsteps(i),text1,text2,0,jloop)
  160    continue
      endif
  170 continue
c
c buffer total time to 3 points back!
c
      totime=totime+told2
      told2=told1
      told1=deltat
      iloop=iloop+1
      return
      end
      subroutine prthes(eigval,nvar)
      implicit REAL (a-h,o-z)                                       
INCLUDE(common/sizes)
      common /iofile/ mfgr,mfgw
      common /nllcom/ hess(maxpar,maxpar),bmat(maxpar,maxpar),                  
     *pmat(maxpar)                                                              
      common/fmatrx/oldf(maxpar),d(maxpar),vmode(maxpar),                        
     $u(maxpar,maxpar),dd,rmin,rmax,omin,xlamd,xlamd0,skal,
     $mode,nstep,negreq,iprnt
      dimension eigval(maxpar)
         if (iprnt.ge.4) then                                                   
         write(mfgw,*)' '                                                          
         write(mfgw,*)'              hessian matrix'                               
         low=1                                                                  
         nup=8                                                                  
540      nup=min(nup,nvar)                                                      
         write(mfgw,1000) (i,i=low,nup)                                            
         do 550 i=1,nvar                                                        
         write(mfgw,1010) i,(hess(i,j),j=low,nup)                                  
550      continue                                                               
         nup=nup+8                                                              
         low=low+8                                                              
         if(low.le.nvar) goto 540                                               
         endif                                                                  
         write(mfgw,*)' '                                                          
         write(mfgw,*)
     +   '              hessian eigenvalues and -vectors'             
         low=1                                                                  
         nup=8                                                                  
560      nup=min(nup,nvar)                                                      
         write(mfgw,1000) (i,i=low,nup)                                            
         write(mfgw,1020) (eigval(i),i=low,nup)                                    
         do 570 i=1,nvar                                                        
         write(mfgw,1030) i,(u(i,j),j=low,nup)                                     
570      continue                                                               
         nup=nup+8                                                              
         low=low+8                                                              
         if(low.le.nvar) goto 560                                               
1000     format(/,3x,8i9)                                                       
1010     format(1x,i3,8f9.1)                                                    
1020     format(/,4x,8f9.1,/)                                                   
1030     format(1x,i3,8f9.4)                                                    
      return
      end
      subroutine pulay(f,p,n,fppf,fock,emat,lfock,nfock,msize,start,pl)
      implicit REAL (a-h,o-z)
      dimension f(*), p(*), fppf(*), fock(*)
      logical start
************************************************************************
*
*   pulay uses dr. peter pulay's method for convergence.
*         a mathematical description can be found in
*         "p. pulay, j. comp. chem. 3, 556 (1982).
*
* arguments:-
*         on input f      = fock matrix, packed, lower half triangle.
*                  p      = density matrix, packed, lower half triangle.
*                  n      = number of orbitals.
*                  fppf   = workstore of size msize, contents will be
*                           overwritten.
*                  fock   =      "       "              "         "
*                  emat   = workstore of at least 15**2 elements.
*                  start  = logical, = true to start pulay.
*                  pl     = undefined element.
*      on output   f      = "best" fock matrix, = linear combination
*                           of known fock matrices.
*                  start  = false
*                  pl     = measure of non-self-consistency
*                         = [f*p] = f*p - p*f.
*
************************************************************************
      common /iofile/ mfgr,mfgw
      common /keywrd/ keywrd
      common /numcal/ numcal
      dimension emat(20,20), evec(1000), coeffs(20)
      character*241 keywrd
      logical  debug
******
      save
******
      data icalcn/0/
      if (icalcn.ne.numcal) then
         icalcn=numcal
         maxlim=6
         debug=(index(keywrd,'debugpulay') .ne.0)
      endif
      if(start) then
         linear=(n*(n+1))/2
         mfock=msize/linear
         if(mfock.gt.maxlim)mfock=maxlim
         if(debug)
     1    write(mfgw,'('' maximum size:'',i5)')mfock
         nfock=1
         lfock=1
         start=.false.
      else
         if(nfock.lt.mfock)      nfock=nfock+1
         if(lfock.ne.mfock)then
            lfock=lfock+1
         else
            lfock=1
         endif
      endif
      lbase=(lfock-1)*linear
*
*   first, store fock matrix for future reference.
*
      do 10 i=1,linear
   10 fock((i-1)*mfock+lfock)=f(i)
*
*   now form /fock*density-density*fock/, and store this in fppf
*
      call mamult(p,f,fppf(lbase+1),n,0.d0)
      call mamult(f,p,fppf(lbase+1),n,-1.d0)
*
*   fppf now contains the result of fp - pf.
*
      nfock1=nfock+1
      do 20 i=1,nfock
         emat(nfock1,i)=-1.d0
         emat(i,nfock1)=-1.d0
         emat(lfock,i)=
     +     ddot(linear,fppf((i-1)*linear+1),1,fppf(lbase+1),1)
   20 emat(i,lfock)=emat(lfock,i)
      pl=emat(lfock,lfock)/linear
      emat(nfock1,nfock1)=0.0d0
      const=1.d0/emat(lfock,lfock)
      do 30 i=1,nfock
         do 30 j=1,nfock
   30 emat(i,j)=emat(i,j)*const
      if(debug) then
         write(mfgw,'('' emat'')')
         do 40 i=1,nfock1
   40    write(mfgw,'(6e13.6)')(emat(j,i),j=1,nfock1)
      endif
      l=0
      do 50 i=1,nfock1
         do 50 j=1,nfock1
            l=l+1
   50 evec(l)=emat(i,j)
      const=1.d0/const
      do 60 i=1,nfock
         do 60 j=1,nfock
   60 emat(i,j)=emat(i,j)*const
*********************************************************************
*   the matrix emat should have form
*
*      |<e(1)*e(1)>  <e(1)*e(2)> ...   -1.0|
*      |<e(2)*e(1)>  <e(2)*e(2)> ...   -1.0|
*      |<e(3)*e(1)>  <e(3)*e(2)> ...   -1.0|
*      |<e(4)*e(1)>  <e(4)*e(2)> ...   -1.0|
*      |     .            .      ...     . |
*      |   -1.0         -1.0     ...    0. |
*
*   where <e(i)*e(j)> is the scalar product of [f*p] for iteration i
*   times [f*p] for iteration j.
*
*********************************************************************
      call osinv(evec,nfock1,d)
      if(dabs(d).lt.1.d-6)then
         start=.true.
         return
      endif
      if(nfock.lt.2) return
      il=nfock*nfock1
      do 70 i=1,nfock
   70 coeffs(i)=-evec(i+il)
      if(debug) then
         write(mfgw,'('' evec'')')
         write(mfgw,'(6f12.6)')(coeffs(i),i=1,nfock)
         write(mfgw,'(''    lagrangian multiplier (error) =''
     1             ,f13.6)')evec(nfock1*nfock1)
      endif
      do 90 i=1,linear
         sum=0
         l=0
         ii=(i-1)*mfock
         do 80 j=1,nfock
   80    sum=sum+coeffs(j)*fock(j+ii)
   90 f(i)=sum
      return
      end
      subroutine quadr(f0,f1,f2, x1,x2, a,b,c)
      implicit REAL (a-h,o-z)
****************************************************
*                                                  *
*    quadr calculates the a, b and c in the equns. *
*                                                  *
*     a                   =   f0                   *
*     a + b.x0 + c.x0**2  =   f1                   *
*     a + b.x2 + c.x2**2  =   f2                   *
*                                                  *
****************************************************
      c=(x2*(f1-f0)-x1*(f2-f0))/(x2*x1**2-x1*x2**2)
      b=(f1-f0-c*x1**2)/x1
      a=f0
      return
      end
      subroutine react1(escf)
      implicit REAL (a-h,o-z)
      REAL pastor, pbstor
INCLUDE(common/sizes)
      common /iofile/ mfgr,mfgw
      common /readme/ ird
      common /cmpg/ geo(3,numatm)
      dimension geoa(3,numatm), geovec(3,numatm),
     1          pastor(mpack),
     2          pbstor(mpack), xold(maxpar), grold(maxpar)
      common /geokst/ natoms,labels(numatm),
     1                na(numatm), nb(numatm), nc(numatm)
      common /densty/ p(mpack),pa(mpack),pb(mpack)
      common /geosym/ ndep,locpar(maxpar),idepfn(maxpar),locdep(maxpar)
      common /geovar/ nvar,loc(2,maxpar), idumy, xparam(maxpar)
      common /gradnt/ grad(maxpar),gnorm
      common /istope/ ams(107)
      common /gravec/ cosine
      common /keywrd/ keywrd
      common /mesage/ iflepo,iscf
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),
     2                nlast(numatm), norbs, nelecs,nalpha,nbeta,
     3                nclose,nopen,ndumy,fract
      common /reactn/ step, geoa, geovec,calcst
      logical gradnt, finish, xyz, int, gok(2)
      save gradnt, finish, xyz,int, gok
************************************************************************
*
*  react1 determines the transition state of a chemical reaction.
*
*   react works by using two systems simultaneously, the heats of
*   formation of both are calculated, then the more stable one
*   is moved in the direction of the other. after a step the
*   energies are compared, and the now lower-energy form is moved
*   in the direction of the higher-energy form. this is repeated
*   until the saddle point is reached.
*
*   if one form is moved 3 times in succession, then the higher energy
*   form is re-optimized without shortening the distance between the two
*   forms. this reduces the chance of being caught on the side of a
*   transition state.
*
************************************************************************
      dimension idum1(numatm), idum2(numatm), xstore(maxpar),
     1idum3(numatm), coord(3,numatm), irot(2,3)
      dimension idummy(3*numatm)
      save irot
      character*241 keywrd
      equivalence (idummy,coord)
      data irot/1,2,1,3,2,3/
      gold=0.0d0
      linear=0
      iflag=1
      gok(1)=.false.
      gok(2)=.false.
      xyz=(index(keywrd,' xyz') .ne. 0)
      gradnt=(index(keywrd,'grad') .ne. 0)
      i=(index(keywrd,' bar'))
      stepmx=0.15d0
      if(i.ne.0) stepmx=reada(keywrd,i)
      maxstp=1000
c
c    read in the second geometry.
c
      if(xyz) then
         call getgeo(ird,labels,geoa,loc,na,nb,nc,ams,natoms,int)
      else
         call getgeo(ird,idum1,geoa,idummy,
     1         idum1,idum2,idum3,ams,natoms,int)
c
c  if internal coordinates are to be used, check the connectivity
c
         l=0
         do 10 i=1,natoms
            if(idum1(i).ne.na(i))then
               l=l+1
               if(l.eq.1)write(mfgw,
     +         '(10x,''errors detected in connectivity'')')
               write(mfgw,'(a,i3,a,i3,a,i3,a)')' for atom',i,
     +         ' the bond labels are different:      ',
     +         idum1(i),' and',na(i)
            endif
            if(idum2(i).ne.nb(i))then
               l=l+1
               if(l.eq.1)write(mfgw,
     +         '(10x,''errors detected in connectivity'')')
               write(mfgw,'(a,i3,a,i3,a,i3,a)')' for atom',i,
     +         ' the bond angle labels are different:',
     +         idum2(i),' and',nb(i)
            endif
            if(idum3(i).ne.nc(i))then
               l=l+1
               if(l.eq.1)write(mfgw,
     +         '(10x,''errors detected in connectivity'')')
               write(mfgw,
     + '(a,i3,a,i3,a,i3,a)')' for atom',i,
     + ' the dihedral labels are different:  ',idum3(i),' and',nc(i)
            endif
   10    continue
         if(l.ne.0)write(mfgw,'(10x,a)')
     +   ' correct before resubmission'
         if(l.ne.0) then
_IF(ipsc,tools)
          call pend
_ELSE
          stop
_ENDIF
         endif
      endif
      time0= secmop()
c
c  swap first and second geometries around
c  so that geout can output data on second geometry.
c
      numat2=0
      do 20 i=1,natoms
         if(labels(i).ne.99) numat2=numat2+1
         x=geoa(1,i)
         geoa(1,i)=geo(1,i)
         geo(1,i)=x
         x=geoa(2,i)*0.0174532925d0
         geoa(2,i)=geo(2,i)
         geo(2,i)=x
         x=geoa(3,i)*0.0174532925d0
         geoa(3,i)=geo(3,i)
         geo(3,i)=x
   20 continue
      if(numat2.ne.numat) then
         write(mfgw,'(//10x,'' number of atoms in second system is '',
     1''incorrect'',/)')
         write(mfgw,
     +   '('' number of atoms in first  system ='',i4)')numat
         write(mfgw,
     +   '('' number of atoms in second system ='',i4)')numat2
         goto 280
      endif
      write(mfgw,'(//10x,'' geometry of second system'',/)')
      if(ndep.ne.0) call mopsym()
      call geout(1)
c
c     convert to cartesian, if necessary
c
      if(   xyz   )then
         call gmetry(geo,coord)
         sumx=0.0d0
         sumy=0.0d0
         sumz=0.0d0
         do 30 j=1,numat
            sumx=sumx+coord(1,j)
            sumy=sumy+coord(2,j)
   30    sumz=sumz+coord(3,j)
         sumx=sumx/numat
         sumy=sumy/numat
         sumz=sumz/numat
         do 40 j=1,numat
            geo(1,j)=coord(1,j)-sumx
            geo(2,j)=coord(2,j)-sumy
   40    geo(3,j)=coord(3,j)-sumz
         write(mfgw,
     +   '(//,''  cartesian geometry of first system'',//)')
         write(mfgw,'(3f14.5)')((geo(j,i),j=1,3),i=1,numat)
         sumx=0.0d0
         sumy=0.0d0
         sumz=0.0d0
         do 50 j=1,numat
            sumx=sumx+geoa(1,j)
            sumy=sumy+geoa(2,j)
   50    sumz=sumz+geoa(3,j)
         sum=0.0d0
         sumx=sumx/numat
         sumy=sumy/numat
         sumz=sumz/numat
         do 60 j=1,numat
            geoa(1,j)=geoa(1,j)-sumx
            geoa(2,j)=geoa(2,j)-sumy
            geoa(3,j)=geoa(3,j)-sumz
            sum=sum+(geo(1,j)-geoa(1,j))**2
     1           +(geo(2,j)-geoa(2,j))**2
     2           +(geo(3,j)-geoa(3,j))**2
   60    continue
         do 110 l=3,1,-1
c
c     docking is done in steps of 16, 4, and 1 degrees at a time.
c
            ca=dcos(4.d0**(l-1)*0.01745329d0)
            sa=dsqrt(dabs(1.d0-ca**2))
            do 100 j=1,3
               ir=irot(1,j)
               jr=irot(2,j)
               do 90 i=1,10
                  summ=0.0d0
                  do 70 k=1,numat
                     x         = ca*geoa(ir,k)+sa*geoa(jr,k)
                     geoa(jr,k)=-sa*geoa(ir,k)+ca*geoa(jr,k)
                     geoa(ir,k)=x
                     summ=summ+(geo(1,k)-geoa(1,k))**2
     1                         +(geo(2,k)-geoa(2,k))**2
     2                         +(geo(3,k)-geoa(3,k))**2
   70             continue
                  if(summ.gt.sum) then
                     if(i.gt.1)then
                        sa=-sa
                        do 80 k=1,numat
                           x         = ca*geoa(ir,k)+sa*geoa(jr,k)
                           geoa(jr,k)=-sa*geoa(ir,k)+ca*geoa(jr,k)
                           geoa(ir,k)=x
   80                   continue
                        goto 100
                     endif
                     sa=-sa
                  endif
   90          sum=summ
  100       continue
  110    continue
         write(mfgw,
     +   '(//,''  cartesian geometry of second system'',//)')
         write(mfgw,'(3f14.5)')((geoa(j,i),j=1,3),i=1,numat)
         write(mfgw,'(//,''   "distance":'',f13.6)')sum
         write(mfgw,'(//,''  reaction coordinate vector'',//)')
         write(mfgw,
     +   '(3f14.5)')((geoa(j,i)-geo(j,i),j=1,3),i=1,numat)
         na(1)=99
         j=0
         nvar=0
         do 130 i=1,natoms
            if(labels(i).ne.99)then
               j=j+1
               do 120 k=1,3
                  nvar=nvar+1
                  loc(2,nvar)=k
  120          loc(1,nvar)=j
               labels(j)=labels(i)
            endif
  130    continue
         natoms=numat
      endif
c
c   xparam holds the variable parameters for geometry in geo
c   xold   holds the variable parameters for geometry in geoa
c
      if(nvar.eq.0)then
         write(mfgw,
     +'(///10x,''there are no variables in the saddle'',
     1'' calculation!'')')
_IF(ipsc,tools)
         call pend
_ELSE
         stop
_ENDIF
      endif
      sum=0.0d0
      do 140 i=1,nvar
         grold(i)=1.d0
         xparam(i)=geo(loc(2,i),loc(1,i))
         xold(i)=geoa(loc(2,i),loc(1,i))
  140 sum=sum+(xparam(i)-xold(i))**2
      step0=dsqrt(sum)
      if(step0.lt.1.d-5)then
         write(mfgw,'(//,3(5x,a,/))')
     +' both geometries are identical',
     1' a saddle calculation involves a reactant and a product',
     2' these must be different geometries'
_IF(ipsc,tools)
         call pend
_ELSE
         stop
_ENDIF
      endif
      one=1.d0
      dell=0.1d0
      eold=-2000.d0
      time1=secmop()
      swap=0.0d0
      do 240 iloop=1,maxstp
         write(mfgw,'('' '',40(''*+''))')
c
c   this method of calculating 'step' is quite arbitary, and needs
c   to be improved by intelligent guesswork!
c
         if (gnorm.lt.1.d-3)gnorm=1.d-3
         step=dmin1(swap,0.5d0, 6.d0/gnorm, dell,stepmx*step0+0.005d0)
         step=dmin1(0.2d0,step/step0)*step0
         swap=swap+1.d0
         dell=dell+0.1d0
         write(mfgw,'(''  bar shortened by'',f12.7,'' percent'')')
     1step/step0*100.d0
         step0=step0-step
         if(step0.lt.0.01d0) goto 250
         step=step0
         do 150 i=1,nvar
  150    xstore(i)=xparam(i)
         call flepo(xparam, nvar, escf)
         if(linear.eq.0)then
            linear=(norbs*(norbs+1))/2
            do 160 i=1,linear
               pastor(i)=pa(i)
  160       pbstor(i)=pb(i)
         endif
         do 170 i=1,nvar
  170    xparam(i)=geo(loc(2,i),loc(1,i))
         if(iflag.eq.1)then
            write(mfgw,
     +      '(//10x,''for point'',i3,'' second structure'')')iloop
         else
            write(mfgw,
     +      '(//10x,''for point'',i3,'' first  structure'')')iloop
         endif
         write(mfgw,'('' distance a - b  '',f12.6)')step
c
c   now to calculate the "correct" gradients, switch off 'step'.
c
         step=0.0d0
         do 180 i=1,nvar
  180    grad(i)=grold(i)
         call compfg (xparam, .true., funct1,.true.,grad,.true.)
         do 190 i=1,nvar
  190    grold(i)=grad(i)
         if (gradnt) then
            write(mfgw,'(''  actual gradients of this point'')')
            write(mfgw,'(8f10.4)')(grad(i),i=1,nvar)
         endif
         write(mfgw,'('' heat            '',f12.6)')funct1
         gnorm=dsqrt(ddot(nvar,grad,1,grad,1))
         write(mfgw,'('' gradient norm   '',f12.6)')gnorm
         cosine=cosine*one
         write(mfgw,'('' direction cosine'',f12.6)')cosine
         call geout(6)
         if(swap.gt.2.9d0 .or. iloop .gt. 3 .and. cosine .lt. 0.d0
     1  .or. escf .gt. eold)
     2  then
            if(swap.gt.2.9d0)then
               swap=0.0d0
            else
               swap=0.5d0
            endif
c
c   swap reactant and product around
c
            finish=(gok(1).and.gok(2) .and. cosine .lt. 0.d0)
            if(finish) then
               write(mfgw,
     +'(//10x,'' both systems are on the same side of t
     1he '',''transition state -'',/10x,'' geometries of the systems'',
     2'' on each side of the t.s. are as follows'')')
               do 200 i=1,nvar
  200          xparam(i)=xstore(i)
               call compfg (xparam, .true., funct1,.true.,grad,.true.)
               write(mfgw,
     +'(//10x,'' geometry on one side of the transition
     1'','' state'')')
               call writmo(time0,funct1)
            endif
            time2=secmop()
            write(mfgw,'('' time='',f9.2)')time2-time1
            time1=time2
            write(mfgw,'(''  reactants and products swapped around'')')
            iflag=1-iflag
            one=-1.d0
            eold=escf
            sum=gold
            gold=gnorm
            i=1.7d0+one*0.5d0
            if(gnorm.gt.10.d0)gok(i)=.true.
            gnorm=sum
            do 210 i=1,natoms
               do 210 j=1,3
                  x=geo(j,i)
                  geo(j,i)=geoa(j,i)
  210       geoa(j,i)=x
            do 220 i=1,nvar
               x=xold(i)
               xold(i)=xparam(i)
  220       xparam(i)=x
c
c
c    swap around the density matrices.
c
            do 230 i=1,linear
               x=pastor(i)
               pastor(i)=pa(i)
               pa(i)=x
               x=pbstor(i)
               pbstor(i)=pb(i)
               pb(i)=x
               p(i)=pa(i)+pb(i)
  230       continue
            if(finish) goto 250
         else
            one=1.d0
         endif
  240 continue
  250 continue
      write(mfgw,'('' at end of reaction'')')
      gold=dsqrt(ddot(nvar,grad,1,grad,1))
      call compfg (xparam, .true., funct1,.true.,grad,.true.)
      gnorm=dsqrt(ddot(nvar,grad,1,grad,1))
      do 260 i=1,nvar
  260 grold(i)=xparam(i)
      call writmo(time0,funct1)
*
* the geometries have (a) been optimized correctly, or
*                     (b) both ended up on the same side of the t.s.
*
*  transition state lies between the two geometries
*
      c1=gold/(gold+gnorm)
      c2=1.d0-c1
      write(mfgw,
     + '('' best estimate geometry of the transition state'')')
      write(mfgw,'(//10x,'' c1='',f8.3,''c2='',f8.3)')c1,c2
      do 270 i=1,nvar
  270 xparam(i)=c1*grold(i)+c2*xold(i)
      step=0.0d0
      call compfg (xparam, .true., funct1,.true.,grad,.true.)
      call writmo(time0,funct1)
  280 return
      end
      REAL function reada(string,istart)
c     fortran function to extract number from string
c
      character string*(*)
      REAL digit
      logical expnnt
c
c     define ascii values of numeric field characters
      i0=ichar('0')
      i9=ichar('9')
      idot=ichar('.')
      ineg=ichar('-')
      ipos=ichar('+')
      icapd=ichar('D')
      icape=ichar('E')
      ismld=ichar('d')
      ismle=ichar('e')
c
      l=len(string)
c
c     find the start of the numeric field
      do 10 i=istart,l
         iadd=0
         n=ichar(string(i:i))
c
c       signal start of numeric field if digit found
         if(n.ge.i0.and.n.le.i9)goto 20
c
c       account for consecutive signs [- and(or) +]
         if(n.eq.ineg.or.n.eq.ipos)then
            iadd=iadd+1
            if(i+iadd.gt.l)goto 50
            n=ichar(string(i+iadd:i+iadd))
            if(n.ge.i0.and.n.le.i9)goto 20
         endif
c
c       account for consecutive decimal points (.)
         if(n.eq.idot)then
            iadd=iadd+1
            if(i+iadd.gt.l)goto 50
            n=ichar(string(i+iadd:i+iadd))
            if(n.ge.i0.and.n.le.i9)goto 20
         endif
   10 continue
      goto 50
c
c     find the end of the numeric field
   20 expnnt=.false.
      do 30 j=i+1,l
         iadd=0
         n=ichar(string(j:j))
c
c       continue search for end if digit found
         if(n.ge.i0.and.n.le.i9)goto 30
c
c       continue search for end if sign found and expnnt true
         if(n.eq.ineg.or.n.eq.ipos)then
            if(.not.expnnt)goto 40
            iadd=iadd+1
            if(j+iadd.gt.l)goto 40
            n=ichar(string(j+iadd:j+iadd))
            if(n.ge.i0.and.n.le.i9)goto 30
         endif
         if(n.eq.idot)then
            iadd=iadd+1
            if(j+iadd.gt.l)goto 40
            n=ichar(string(j+iadd:j+iadd))
            if(n.ge.i0.and.n.le.i9)goto 30
            if(n.eq.icape.or.n.eq.ismle.or.n.eq.icapd.or.n.eq.ismld)
     1    goto 30
         endif
         if(n.eq.icape.or.n.eq.ismle.or.n.eq.icapd.or.n.eq.ismld)then
            if(expnnt)goto 40
            expnnt=.true.
            goto 30
         endif
         goto 40
   30 continue
      j=l+1
   40 n=ichar(string(j-1:j-1))
      if(n.eq.icape.or.n.eq.ismle.or.n.eq.icapd.or.n.eq.ismld)j=j-1
c
c     found the end of the numeric field (it runs 'i' thru 'j-1')
      n=0
      n=n+index(string(i:j-1),'e')
      n=n+index(string(i:j-1),'E')
      n=n+index(string(i:j-1),'d')
      n=n+index(string(i:j-1),'D')
      if(n.eq.0)then
         reada=digit(string(i:j-1),1)
      else
         reada=digit(string(:i+n-2),i)*1.d1**digit(string(:j-1),i+n)
      endif
      return
c
c     default value returned because no numeric field found
   50 reada=0.0d0
      return
      end
      subroutine refer
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      common /iofile/ mfgr,mfgw
      common /refs/ allref(107,4)
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),
     3                nlast(numatm), norbs, nelecs,nalpha,nbeta,
     4                nclose,nopen,ndumy,fract
      common /keywrd/ keywrd
      logical allok, elemns(107), mixok, mix
      save mix
      character keywrd*241, allref*80
      data mix/.false./
      mixok=(index(keywrd,'parasok').ne.0)
      do 10 i=1,102
   10 elemns(i)=.false.
      if(index(keywrd,'pm3').ne.0)then
         mode=4
      elseif(index(keywrd,'am1').ne.0)then
         mode=3
      elseif(index(keywrd,'mindo').ne.0)then
         mode=2
      else
         mode=1
      endif
      allref(99,mode)=' dummy atoms are used; these do not affect '
     1//'the calculation'
      allref(100,mode)=' '
      do 20 i=1,numat
         j=nat(i)
   20 elemns(j)=.true.
      allok=.true.
      do 30 i=1,102
         if(elemns(i))then
            if(i.lt.99.and..not.mix.and.mode.eq.3)
     1mix=(index(allref(i,3),'mndo').ne.0)
            if(allref(i,mode)(1:1).ne.' ')then
               write(mfgw,'(a,i3)')
     +         ' data are not available for element no.',i
               allok=.false.
            else
               write(mfgw,'(a)')allref(i,mode)
            endif
         endif
   30 continue
      if(mix.and..not.mixok)then
         write(mfgw,40)
     1  'some elements have been specified for which only mndo',
     2  'parameters are available.  such mixtures of methods are',
     3  'very risky and have not been fully tested.  if you feel',
     4  'the risk is worth while - check the manual first - then',
     5  'specify "parasok" in the keywords'
_IF(ipsc,tools)
         call pend
_ELSE
         stop
_ENDIF
      endif
      if(allok)return
      write(mfgw,40)
     1 'some elements have been specified for which',
     2 'no parameters are available.  calculation stopped.'
_IF(ipsc,tools)
      call pend
_ELSE
      stop
_ENDIF
   40 format(/////10x,a,4(/10x,a))
      end
      subroutine reppp(ni,nj,rij,ri,core)
c***********************************************************************
c
c..vector version written by ernest r. davidson, indiana university
c
c
c  repp calculates the two-electron repulsion integrals and the
c       nuclear attraction integrals.
c
c     on input rij     = interatomic distance
c              ni      = atom number of first atom
c              nj      = atom number of second atom
c    (ref)     add     = array of gamma, or two-electron one-center,
c                        integrals.
c    (ref)     tore    = array of nuclear charges of the elements
c    (ref)     dd      = array of dipole charge separations
c    (ref)     qq      = array of quadrupole charge separations
c
c     the common blocks are initialized in block-data, and never changed
c
c    on output ri      = array of two-electron repulsion integrals
c              core    = 4 x 2 array of electron-core attraction
c                        integrals
c
c
c *** this routine computes the two-centre repulsion integrals and the
c *** nuclear attraction integrals.
c *** the two-centre repulsion integrals (over local coordinates) are
c *** stored as follows (where p-sigma = o,  and p-pi = p and p* )
c     (ss/ss)=1,   (so/ss)=2,   (oo/ss)=3,   (pp/ss)=4,   (ss/os)=5,
c     (so/so)=6,   (sp/sp)=7,   (oo/so)=8,   (pp/so)=9,   (po/sp)=10,
c     (ss/oo)=11,  (ss/pp)=12,  (so/oo)=13,  (so/pp)=14,  (sp/op)=15,
c     (oo/oo)=16,  (pp/oo)=17,  (oo/pp)=18,  (pp/pp)=19,  (po/po)=20,
c     (pp/p*p*)=21,   (p*p/p*p)=22.
c *** the storage of the nuclear attraction integrals  core(kl/ij) is
c     (ss/)=1,   (so/)=2,   (oo/)=3,   (pp/)=4
c     where ij=1 if the orbitals centred on atom i,  =2 if on atom j.
c *** ni and nj are the atomic numbers of the two elements.
c
c***********************************************************************
      implicit REAL (a-h,o-z)
c     patas
INCLUDE(common/sizes)
      character*241 keywrd
c     patas
      logical si,sj
      common /keywrd/ keywrd
      common /multip/ dd(107),qq(107),add(107,3)
      common /corec/ tore(107)
      common /cmporb/ natorb(107)
c     patas
      common /mstq/ qs(1500),mflag
c     patas
      dimension ri(22),core(4,2)
      dimension arg(72),sqr(72)
      data  td/2.d00/
      data pp/0.5d00/
      data a0/0.529167d0/ ,ev/27.21d0/, ev1/13.605d0/, ev2/6.8025d0/,
     1 ev3/3.40125d0/, ev4/1.700625d0/
c
c     atomic units are used in the calculation,
c     final results are converted to ev
c
c     patas
      do 999 i=1,22
      ri(i)=0.0d0
999   continue
      do 998 i=1,4
      core(i,1)=0.0d0
998   core(i,2)=0.0d0
c     patas
      r=rij/a0
c     patas
      if (index(keywrd,'tom').ne.0.and.(mflag.eq.2.or.
     1mflag.eq.5)) go to 700
c     patas
c
      si = (natorb(ni).ge.3)
      sj = (natorb(nj).ge.3)
c
      if ((.not.si) .and. (.not.sj)) then
c
c     hydrogen - hydrogen  (ss/ss)
c
         aee = pp/add(ni,1) + pp/add(nj,1)
         aee = aee * aee
         ri(1) = ev/dsqrt(r*r+aee)
         core(1,1) = tore(nj)*ri(1)
         core(1,2) = tore(ni)*ri(1)
c
      else if (si .and. (.not.sj)) then
c
c     heavy atom - hydrogen
c
         aee = pp/add(ni,1) + pp/add(nj,1)
         aee = aee * aee
         da=dd(ni)
         qa=qq(ni) * td
         ade = pp/add(ni,2) + pp/add(nj,1)
         ade = ade * ade
         aqe = pp/add(ni,3) + pp/add(nj,1)
         aqe = aqe * aqe
         rsq = r*r
         arg(1) = rsq + aee
         xxx = r+da
         arg(2) = xxx*xxx + ade
         xxx = r-da
         arg(3) = xxx*xxx + ade
         xxx = r+qa
         arg(4) = xxx*xxx + aqe
         xxx = r-qa
         arg(5) = xxx*xxx + aqe
         arg(6) = rsq + aqe
         arg(7) = arg(6) + qa*qa
c$doit asis
         do 10 i = 1,7
            sqr(i) = dsqrt(arg(i))
   10    continue
         ee = ev/sqr(1)
         ri(1) = ee
         ri(2) = ev1/sqr(2) - ev1/sqr(3)
         ri(3) = ee + ev2/sqr(4) + ev2/sqr(5) - ev1/sqr(6)
         ri(4) = ee + ev1/sqr(7) - ev1/sqr(6)
         core(1,1) = tore(nj)*ri(1)
         core(1,2) = tore(ni)*ri(1)
         core(2,1) = tore(nj)*ri(2)
         core(3,1) = tore(nj)*ri(3)
         core(4,1) = tore(nj)*ri(4)
c
      else if ((.not.si).and.sj) then
c
c     hydrogen - heavy atom
c
         aee = pp/add(ni,1) + pp/add(nj,1)
         aee = aee * aee
         db=dd(nj)
         qb=qq(nj) * td
         aed = pp/add(ni,1) + pp/add(nj,2)
         aed = aed * aed
         aeq = pp/add(ni,1) + pp/add(nj,3)
         aeq = aeq * aeq
         rsq = r*r
         arg(1) = rsq + aee
         xxx = r-db
         arg(2) = xxx*xxx + aed
         xxx = r+db
         arg(3) = xxx*xxx + aed
         xxx = r-qb
         arg(4) = xxx*xxx + aeq
         xxx = r+qb
         arg(5) = xxx*xxx + aeq
         arg(6) = rsq + aeq
         arg(7) = arg(6) + qb*qb
c$doit asis
         do 20 i = 1,7
            sqr(i) = dsqrt(arg(i))
   20    continue
         ee = ev/sqr(1)
         ri(1) = ee
         ri(5) = ev1/sqr(2)  - ev1/sqr(3)
         ri(11) = ee + ev2/sqr(4) + ev2/sqr(5) - ev1/sqr(6)
         ri(12) = ee + ev1/sqr(7) - ev1/sqr(6)
         core(1,1) = tore(nj)*ri(1)
         core(1,2) = tore(ni)*ri(1)
         core(2,2) = tore(ni)*ri(5)
         core(3,2) = tore(ni)*ri(11)
         core(4,2) = tore(ni)*ri(12)
c
      else
c
c     heavy atom - heavy atom
c
c     define charge separations.
         da=dd(ni)
         db=dd(nj)
         qa=qq(ni) * td
         qb=qq(nj) * td
c
         aee = pp/add(ni,1) + pp/add(nj,1)
         aee = aee * aee
c
         ade = pp/add(ni,2) + pp/add(nj,1)
         ade = ade * ade
         aqe = pp/add(ni,3) + pp/add(nj,1)
         aqe = aqe * aqe
         aed = pp/add(ni,1) + pp/add(nj,2)
         aed = aed * aed
         aeq = pp/add(ni,1) + pp/add(nj,3)
         aeq = aeq * aeq
         axx = pp/add(ni,2) + pp/add(nj,2)
         axx = axx * axx
         adq = pp/add(ni,2) + pp/add(nj,3)
         adq = adq * adq
         aqd = pp/add(ni,3) + pp/add(nj,2)
         aqd = aqd * aqd
         aqq = pp/add(ni,3) + pp/add(nj,3)
         aqq = aqq * aqq
         rsq = r * r
         arg(1) = rsq + aee
         xxx = r + da
         arg(2) = xxx * xxx + ade
         xxx = r - da
         arg(3) = xxx*xxx + ade
         xxx = r - qa
         arg(4) = xxx*xxx + aqe
         xxx = r + qa
         arg(5) = xxx*xxx + aqe
         arg(6) = rsq + aqe
         arg(7) = arg(6) + qa*qa
         xxx = r-db
         arg(8) = xxx*xxx + aed
         xxx = r+db
         arg(9) = xxx*xxx + aed
         xxx = r - qb
         arg(10) = xxx*xxx + aeq
         xxx = r + qb
         arg(11) = xxx*xxx + aeq
         arg(12) = rsq + aeq
         arg(13) = arg(12) + qb*qb
         xxx = da-db
         arg(14) = rsq + axx + xxx*xxx
         xxx = da+db
         arg(15) = rsq + axx + xxx*xxx
         xxx = r + da - db
         arg(16) = xxx*xxx + axx
         xxx = r - da + db
         arg(17) = xxx*xxx + axx
         xxx = r - da - db
         arg(18) = xxx*xxx + axx
         xxx = r + da + db
         arg(19) = xxx*xxx + axx
         xxx = r + da
         arg(20) = xxx*xxx + adq
         arg(21) = arg(20) + qb*qb
         xxx = r - da
         arg(22) = xxx*xxx + adq
         arg(23) = arg(22) + qb*qb
         xxx = r - db
         arg(24) = xxx*xxx + aqd
         arg(25) = arg(24) + qa*qa
         xxx = r + db
         arg(26) = xxx*xxx + aqd
         arg(27) = arg(26) + qa*qa
         xxx = r + da - qb
         arg(28) = xxx*xxx + adq
         xxx = r - da - qb
         arg(29) = xxx*xxx + adq
         xxx = r + da + qb
         arg(30) = xxx*xxx + adq
         xxx = r - da + qb
         arg(31) = xxx*xxx + adq
         xxx = r + qa - db
         arg(32) = xxx*xxx + aqd
         xxx = r + qa + db
         arg(33) = xxx*xxx + aqd
         xxx = r - qa - db
         arg(34) = xxx*xxx + aqd
         xxx = r - qa + db
         arg(35) = xxx*xxx + aqd
         arg(36) = rsq + aqq
         xxx = qa - qb
         arg(37) = arg(36) + xxx*xxx
         xxx = qa + qb
         arg(38) = arg(36) + xxx*xxx
         arg(39) = arg(36) + qa*qa
         arg(40) = arg(36) + qb*qb
         arg(41) = arg(39) + qb*qb
         xxx = r - qb
         arg(42) = xxx*xxx + aqq
         arg(43) = arg(42) + qa*qa
         xxx = r + qb
         arg(44) = xxx*xxx + aqq
         arg(45) = arg(44) + qa*qa
         xxx = r + qa
         arg(46) = xxx*xxx + aqq
         arg(47) = arg(46) + qb*qb
         xxx = r - qa
         arg(48) = xxx*xxx + aqq
         arg(49) = arg(48) + qb*qb
         xxx = r + qa - qb
         arg(50) = xxx*xxx + aqq
         xxx = r + qa + qb
         arg(51) = xxx*xxx + aqq
         xxx = r - qa - qb
         arg(52) = xxx*xxx + aqq
         xxx = r - qa + qb
         arg(53) = xxx*xxx + aqq
         qa=qq(ni)
         qb=qq(nj)
         xxx = da - qb
         xxx = xxx*xxx
         yyy = r - qb
         yyy = yyy*yyy
         zzz = da + qb
         zzz = zzz*zzz
         www = r + qb
         www = www*www
         arg(54) = xxx + yyy + adq
         arg(55) = xxx + www + adq
         arg(56) = zzz + yyy + adq
         arg(57) = zzz + www + adq
         xxx = qa - db
         xxx = xxx*xxx
         yyy = qa + db
         yyy = yyy*yyy
         zzz = r + qa
         zzz = zzz*zzz
         www = r - qa
         www = www*www
         arg(58) = zzz + xxx + aqd
         arg(59) = www + xxx + aqd
         arg(60) = zzz + yyy + aqd
         arg(61) = www + yyy + aqd
         xxx = qa - qb
         xxx = xxx*xxx
         arg(62) = arg(36) + td*xxx
         yyy = qa + qb
         yyy = yyy*yyy
         arg(63) = arg(36) + td*yyy
         arg(64) = arg(36) + td*(qa*qa+qb*qb)
         zzz = r + qa - qb
         zzz = zzz*zzz
         arg(65) = zzz + xxx + aqq
         arg(66) = zzz + yyy + aqq
         zzz = r + qa + qb
         zzz = zzz*zzz
         arg(67) = zzz + xxx + aqq
         arg(68) = zzz + yyy + aqq
         zzz = r - qa - qb
         zzz = zzz*zzz
         arg(69) = zzz + xxx + aqq
         arg(70) = zzz + yyy + aqq
         zzz = r - qa + qb
         zzz = zzz*zzz
         arg(71) = zzz + xxx + aqq
         arg(72) = zzz + yyy + aqq
         do 30 i = 1,72
            sqr(i) = dsqrt(arg(i))
   30    continue
         ee = ev/sqr(1)
         dze = -ev1/sqr(2) + ev1/sqr(3)
         qzze = ev2/sqr(4) + ev2/sqr(5) - ev1/sqr(6)
         qxxe = ev1/sqr(7) - ev1/sqr(6)
         edz = - ev1/sqr(8) + ev1/sqr(9)
         eqzz  = ev2/sqr(10) + ev2/sqr(11) - ev1/sqr(12)
         eqxx  = ev1/sqr(13) - ev1/sqr(12)
         dxdx  = ev1/sqr(14) - ev1/sqr(15)
         dzdz  = ev2/sqr(16) + ev2/sqr(17) - ev2/sqr(18) - ev2/sqr(19)
         dzqxx =  ev2/sqr(20) - ev2/sqr(21) - ev2/sqr(22) + ev2/sqr(23)
         qxxdz =  ev2/sqr(24) - ev2/sqr(25) - ev2/sqr(26) + ev2/sqr(27)
         dzqzz = -ev3/sqr(28) + ev3/sqr(29) - ev3/sqr(30) + ev3/sqr(31)
     1       - ev2/sqr(22) + ev2/sqr(20)
         qzzdz = -ev3/sqr(32) + ev3/sqr(33) - ev3/sqr(34) + ev3/sqr(35)
     1       + ev2/sqr(24) - ev2/sqr(26)
         qxxqxx = ev3/sqr(37) + ev3/sqr(38) - ev2/sqr(39) - ev2/sqr(40)
     1       + ev2/sqr(36)
         qxxqyy = ev2/sqr(41) - ev2/sqr(39) - ev2/sqr(40) + ev2/sqr(36)
         qxxqzz = ev3/sqr(43) + ev3/sqr(45) - ev3/sqr(42) - ev3/sqr(44)
     1       - ev2/sqr(39) + ev2/sqr(36)
         qzzqxx = ev3/sqr(47) + ev3/sqr(49) - ev3/sqr(46) - ev3/sqr(48)
     1       - ev2/sqr(40) + ev2/sqr(36)
         qzzqzz = ev4/sqr(50) + ev4/sqr(51) + ev4/sqr(52) + ev4/sqr(53)
     1       - ev3/sqr(48) - ev3/sqr(46) - ev3/sqr(42) - ev3/sqr(44)
     2       + ev2/sqr(36)
         dxqxz = -ev2/sqr(54) + ev2/sqr(55) + ev2/sqr(56) - ev2/sqr(57)
         qxzdx = -ev2/sqr(58) + ev2/sqr(59) + ev2/sqr(60) - ev2/sqr(61)
         qxzqxz = ev3/sqr(65) - ev3/sqr(67) - ev3/sqr(69) + ev3/sqr(71)
     1       - ev3/sqr(66) + ev3/sqr(68) + ev3/sqr(70) - ev3/sqr(72)
         ri(1) = ee
         ri(2) = -dze
         ri(3) = ee + qzze
         ri(4) = ee + qxxe
         ri(5) = -edz
         ri(6) = dzdz
         ri(7) = dxdx
         ri(8) = -edz -qzzdz
         ri(9) = -edz -qxxdz
         ri(10) = -qxzdx
         ri(11) =  ee + eqzz
         ri(12) =  ee + eqxx
         ri(13) = -dze -dzqzz
         ri(14) = -dze -dzqxx
         ri(15) = -dxqxz
         ri(16) = ee +eqzz +qzze +qzzqzz
         ri(17) = ee +eqzz +qxxe +qxxqzz
         ri(18) = ee +eqxx +qzze +qzzqxx
         ri(19) = ee +eqxx +qxxe +qxxqxx
         ri(20) = qxzqxz
         ri(21) = ee +eqxx +qxxe +qxxqyy
         ri(22) = pp * (qxxqxx -qxxqyy)
c
c     calculate core-electron attractions.
c
         core(1,1) = tore(nj)*ri(1)
         core(2,1) = tore(nj)*ri(2)
         core(3,1) = tore(nj)*ri(3)
         core(4,1) = tore(nj)*ri(4)
         core(1,2) = tore(ni)*ri(1)
         core(2,2) = tore(ni)*ri(5)
         core(3,2) = tore(ni)*ri(11)
         core(4,2) = tore(ni)*ri(12)
c
      end if
c
      return
c     patas
  700 continue
c
c     compute electron-charge integrals for mst model
c
      ppp=2.d0
      p2=4.d0
      od=1.d0
      fd=4.d0
c     define charge separation of atom a
      da=dd(ni)
      qa=qq(ni)
c     hydrogen-charge
c     aee=0.25d0*(od/add(ni,1))**2
c     modification: august 1992
      aee=0.0d0
      ee=od/dsqrt(r**2+aee)
      ri(1)=ee*27.21d0
      core(1,1)=qs(nj)*ri(1)
      if (natorb(ni).lt.3) go to 800
c     heavy atom-charge
c     ade=0.25d0*(od/add(ni,2))**2
c     aqe=0.25d0*(od/add(ni,3))**2
c     modification: august 1992
      ade=0.0d0
      aqe=0.0d0
      dze=-od/dsqrt((r+da)**2+ade)+
     1    od/dsqrt((r-da)**2+ade)
      qzze=od/dsqrt((r-td*qa)**2+aqe)
     1     -td/dsqrt(r**2+aqe)
     2     +od/dsqrt((r+td*qa)**2+aqe)
      qxxe=td/dsqrt(r**2+fd*qa**2+aqe)
     1     -td/dsqrt(r**2+aqe)
      dze=dze/ppp
      qxxe=qxxe/p2
      qzze=qzze/p2
      ri(2)=-dze
      ri(3)=ee+qzze
      ri(4)=ee+qxxe
c     convert into ev
  800 continue
      ri(2)=ri(2)*27.21d0
      ri(3)=ri(3)*27.21d0
      ri(4)=ri(4)*27.21d0
c     calculate electron-charge integrals
      core(2,1)=qs(nj)*ri(2)
      core(3,1)=qs(nj)*ri(3)
      core(4,1)=qs(nj)*ri(4)
      return
c     patas
c
      end
      subroutine rsp(a,n,matz,w,z)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      dimension a(*),  w(n), z(n,n)
*******************************************************************
*
*   eispack diagonalization routines: to find the eigenvalues and
*           eigenvectors (if desired) of a real symmetric packed matrix.
* on input-      n  is the order of the matrix  a,
*                a  contains the lower triangle of the real symmetric
*                   packed matrix stored row-wise,
*             matz  is an integer variable set equal to zero if only
*                   eigenvalues are desired,  otherwise it is set to
*                   any non-zero integer for both eigenvalues and
*                   eigenvectors.
* on output-     w  contains the eigenvalues in ascending order,
*                z  contains the eigenvectors if matz is not zero,
*
*******************************************************************
* this routine was chosen as being the most reliable. (jjps)
c     questions and comments should be directed to b. s. garbow,
c     applied mathematics division, argonne national laboratory
c
c     ------------------------------------------------------------------
c
      dimension fv1(maxhev*4+maxlit*3),fv2(maxhev*4+maxlit*3)
      save first, eps, eta, nv
      logical first
      data first /.true./
      if (first) then
         first=.false.
         call epseta(eps,eta)
      endif
      nv=(n*(n+1))/2
      nm=n
      call  tred3(n,nv,a,w,fv1,fv2,eps,eps)
      if (matz .ne. 0) go to 10
c     ********** find eigenvalues only **********
      call  mtqlrt(n,w,fv2,ierr,eps)
      go to 40
c     ********** find both eigenvalues and eigenvectors **********
   10 do 30    i = 1, n
c
         do 20    j = 1, n
            z(j,i)=0.0d0
   20    continue
c
         z(i,i)=1.0d0
   30 continue
c
      call  mtql2(nm,n,w,fv1,z,ierr,eps)
      if (ierr .ne. 0) go to 40
      call  trbak3(nm,n,nv,a,n,z)
c     ********** last card of rsp **********
   40 return
      end
      subroutine schmib(u,n,ndim)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
c
c     same as schmidt but works from right to left.
c
      dimension u(ndim,ndim)
      save zero, small, one
      data zero,small,one/0.0d0,0.01d0,1.0d0/
      n1=n+1
      ii=0
      do 110 k=1,n
         k1=k-1
c
c     normalize kth column vector
c
         dot = zero
         do 10 i=1,n
   10    dot=dot+u(i,n1-k)*u(i,n1-k)
         if(dot.eq.zero) go to 100
         scale=one/dsqrt(dot)
         do 20 i=1,n
   20    u(i,n1-k)=scale*u(i,n1-k)
   30    if(k1.eq.0) go to 110
         npass=0
c
c     project out k-1 previous orthonormal vectors from kth vector
c
   40    npass=npass+1
         do 70 j=1,k1
            dot=zero
            do 50 i=1,n
   50       dot=dot+u(i,n1-j)*u(i,n1-k)
            do 60 i=1,n
   60       u(i,n1-k)=u(i,n1-k)-dot*u(i,n1-j)
   70    continue
c
c     second normalization (after projection)
c     if kth vector is small but not zero then normalize
c     and project again to control round-off errors.
c
         dot=zero
         do 80 i=1,n
   80    dot=dot+u(i,n1-k)*u(i,n1-k)
         if(dot.eq.zero) go to 100
         if(dot.lt.small.and.npass.gt.2) go to 100
         scale=one/dsqrt(dot)
         do 90 i=1,n
   90    u(i,n1-k)=scale*u(i,n1-k)
         if(dot.lt.small) go to 40
         go to 110
c
c     replace linearly dependent kth vector by a unit vector.
c
  100    ii=ii+1
c     if(ii.gt.n) stop
         u(ii,n1-k)=one
         go to 30
  110 continue
      return
      end
      subroutine schmit(u,n,ndim)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      dimension u(ndim,ndim)
      save zero, small, one
      data zero,small,one/0.0d0,0.01d0,1.0d0/
      ii=0
      do 110 k=1,n
         k1=k-1
c
c     normalize kth column vector
c
         dot = zero
         do 10 i=1,n
   10    dot=dot+u(i,k)*u(i,k)
         if(dot.eq.zero) go to 100
         scale=one/dsqrt(dot)
         do 20 i=1,n
   20    u(i,k)=scale*u(i,k)
   30    if(k1.eq.0) go to 110
         npass=0
c
c     project out k-1 previous orthonormal vectors from kth vector
c
   40    npass=npass+1
         do 70 j=1,k1
            dot=zero
            do 50 i=1,n
   50       dot=dot+u(i,j)*u(i,k)
            do 60 i=1,n
   60       u(i,k)=u(i,k)-dot*u(i,j)
   70    continue
c
c     second normalization (after projection)
c     if kth vector is small but not zero then normalize
c     and project again to control round-off errors.
c
         dot=zero
         do 80 i=1,n
   80    dot=dot+u(i,k)*u(i,k)
         if(dot.eq.zero) go to 100
         if(dot.lt.small.and.npass.gt.2) go to 100
         scale=one/dsqrt(dot)
         do 90 i=1,n
   90    u(i,k)=scale*u(i,k)
         if(dot.lt.small) go to 40
         go to 110
c
c     replace linearly dependent kth vector by a unit vector.
c
  100    ii=ii+1
c     if(ii.gt.n) stop
         u(ii,k)=one
         go to 30
  110 continue
      return
      end
      function secmop()
_IF(ipsc,tools)
      REAL  secmop, cpulft, shut
_ELSE
      REAL  secmop, cpu ,cpulft, shut
_ENDIF
      common/iofile/mfgr,mfgw
c******************************************************
c
c   secmop, on exit, contains the number of cpu seconds
c   since the start of the calculation.
c
c******************************************************
_IFN(ipsc,tools)
      logical setok
      character*1 x
      character*80 getmop
      data setok   /  .true.    /, shut/0.d0/
*     print *, 'calling timclk'
      call timclk(cpu)
*     print *, 'returned from timclk, cpu = ', cpu
***********************************************************************
*
*   now to see if a file logically called shutdown exists, if it does
*   then increment cpu time by 1,000,000 seconds.
*
************************************************************************
      open(unit=4, file=getmop(14),status='unknown')
c      open(unit=4, file='shutdown',status='unknown')
      read(4,'(a)',end=10, err=10)x
*
*          file exists, therefore increment time
*
      shut=1.0d6
      if( setok) then
       write(mfgw,'(///10x,''****   job stopped by operator   ****'')')
       setok=.false.
      endif
   10 continue
      close (4,status='delete')
      secmop=cpu+shut
_ELSE
      secmop=cpulft(1)
_ENDIF
      return
      end
      subroutine set (s1,s2,na,nb,rab,ii)
      implicit REAL (a-h,o-z)
      common /cmops/ a(7),b(7),sa,sb,factor,isp,ips
c***********************************************************************
c
c     set is part of the overlap calculation, called by overlp.
c         it calls aintgs and bintgs
c
c***********************************************************************
      if (na.gt.nb) go to 10
      isp=1
      ips=2
      sa=s1
      sb=s2
      goto 20
   10 isp=2
      ips=1
      sa=s2
      sb=s1
   20 j=ii+2
      if (ii.gt.3) j=j-1
      alpha=0.5d00*rab*(sa+sb)
      beta=0.5d00*rab*(sb-sa)
      jcall=j-1
      call aintgs (alpha,jcall)
      call bintgs (beta,jcall)
      return
c
      end
      subroutine setup3
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      common /natype/ nztype(107),mtype(30),ltype
      common /sto6g/ allc(6,5,2),allz(6,5,2)
c     set-up the stewart's sto-3g expansions
c     from j. chem. phys. 52 431.
c                                            1s
      allz(1,1,1) =2.227660584d00
      allz(2,1,1) =4.057711562d-01
      allz(3,1,1) =1.098175104d-01
c
      allc(1,1,1) =1.543289673d-01
      allc(2,1,1) =5.353281423d-01
      allc(3,1,1) =4.446345422d-01
c                                      2s
      allz(1,2,1) =2.581578398d00
      allz(2,2,1) =1.567622104d-01
      allz(3,2,1) =6.018332272d-02
c
      allc(1,2,1) =-5.994474934d-02
      allc(2,2,1) =5.960385398d-01
      allc(3,2,1) =4.581786291d-01
c                                     2p
      allz(1,2,2) =9.192379002d-01
      allz(2,2,2) =2.359194503d-01
      allz(3,2,2) =8.009805746d-02
c
      allc(1,2,2) =1.623948553d-01
      allc(2,2,2) =5.661708862d-01
      allc(3,2,2) =4.223071752d-01
c                                      3s
      allz(1,3,1) =5.641487709d-01
      allz(2,3,1) =6.924421391d-02
      allz(3,3,1) =3.269529097d-02
c
      allc(1,3,1) =-1.782577972d-01
      allc(2,3,1) =8.612761663d-01
      allc(3,3,1) =2.261841969d-01
c                                     3p
      allz(1,3,2) =2.692880368d00
      allz(2,3,2) =1.489359592d-01
      allz(3,3,2) =5.739585040d-02
c
      allc(1,3,2) =-1.061945788d-02
      allc(2,3,2) =5.218564264d-01
      allc(3,3,2) =5.450015143d-01
c                                      4s
      allz(1,4,1) =2.267938753d-01
      allz(2,4,1) =4.448178019d-02
      allz(3,4,1) =2.195294664d-02
c
      allc(1,4,1) =-3.349048323d-01
      allc(2,4,1) =1.056744667d00
      allc(3,4,1) =1.256661680d-01
c                                     4p
      allz(1,4,2) =4.859692220d-01
      allz(2,4,2) =7.430216918d-02
      allz(3,4,2) =3.653340923d-02
c
      allc(1,4,2) =-6.147823411d-02
      allc(2,4,2) =6.604172234d-01
      allc(3,4,2) =3.932639495d-01
c                                      5s
      allz(1,5,1) =1.080198458d-01
      allz(2,5,1) =4.408119382d-02
      allz(3,5,1) =2.610811810d-02
c
      allc(1,5,1) =-6.617401158d-01
      allc(2,5,1) =7.467595004d-01
      allc(3,5,1) =7.146490945d-01
c                                     5p
      allz(1,5,2) =2.127482317d-01
      allz(2,5,2) =4.729648620d-02
      allz(3,5,2) =2.604865324d-02
c
      allc(1,5,2) =-1.389529695d-01
      allc(2,5,2) =8.076691064d-01
      allc(3,5,2) =2.726029342d-01
c
      return
      end
      subroutine setupg
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      common /expont/ zs(107),zp(107),zd(107)
      common /natype/ nztype(107),mtype(30),ltype
      common /temp/  cc(60,6),zz(60,6)
      common /sto6g/ allc(6,6,2),allz(6,6,2)
c     set-up the stewart's sto-6g expansions
c                                            1s
      allz(1,1,1) =2.310303149d01
      allz(2,1,1) =4.235915534d00
      allz(3,1,1) =1.185056519d00
      allz(4,1,1) =4.070988982d-01
      allz(5,1,1) =1.580884151d-01
      allz(6,1,1) =6.510953954d-02
c
      allc(1,1,1) =9.163596280d-03
      allc(2,1,1) =4.936149294d-02
      allc(3,1,1) =1.685383049d-01
      allc(4,1,1) =3.705627997d-01
      allc(5,1,1) =4.164915298d-01
      allc(6,1,1) =1.303340841d-01
c                                      2s
      allz(1,2,1) =2.768496241d01
      allz(2,2,1) =5.077140627d00
      allz(3,2,1) =1.426786050d00
      allz(4,2,1) =2.040335729d-01
      allz(5,2,1) =9.260298399d-02
      allz(6,2,1) =4.416183978d-02
c
      allc(1,2,1) =-4.151277819d-03
      allc(2,2,1) =-2.067024148d-02
      allc(3,2,1) =-5.150303337d-02
      allc(4,2,1) =3.346271174d-01
      allc(5,2,1) =5.621061301d-01
      allc(6,2,1) =1.712994697d-01
c                                     2p
      allz(1,2,2) =5.868285913d00
      allz(2,2,2) =1.530329631d00
      allz(3,2,2) =5.475665231d-01
      allz(4,2,2) =2.288932733d-01
      allz(5,2,2) =1.046655969d-01
      allz(6,2,2) =4.948220127d-02
c
      allc(1,2,2) =7.924233646d-03
      allc(2,2,2) =5.144104825d-02
      allc(3,2,2) =1.898400060d-01
      allc(4,2,2) =4.049863191d-01
      allc(5,2,2) =4.012362861d-01
      allc(6,2,2) =1.051855189d-01
c                                      3s
      allz(1,3,1) =3.273031938d00
      allz(2,3,1) =9.200611311d-01
      allz(3,3,1) =3.593349765d-01
      allz(4,3,1) =8.636686991d-02
      allz(5,3,1) =4.797373812d-02
      allz(6,3,1) =2.724741144d-02
      allc(1,3,1) =-6.775596947d-03
      allc(2,3,1) =-5.639325779d-02
      allc(3,3,1) =-1.587856086d-01
      allc(4,3,1) =5.534527651d-01
      allc(5,3,1) =5.015351020d-01
      allc(6,3,1) =7.223633674d-02
c                                     3p
      allz(1,3,2) =5.077973607d00
      allz(2,3,2) =1.340786940d00
      allz(3,3,2) =2.248434849d-01
      allz(4,3,2) =1.131741848d-01
      allz(5,3,2) =6.076408893d-02
      allz(6,3,2) =3.315424265d-02
      allc(1,3,2) =-3.329929840d-03
      allc(2,3,2) =-1.419488340d-02
      allc(3,3,2) =1.639395770d-01
      allc(4,3,2) =4.485358256d-01
      allc(5,3,2) =3.908813050d-01
      allc(6,3,2) =7.411456232d-02
c                                     4s
      allz(1,4,1) = 1.365346 d+00
      allz(2,4,1) = 4.393213 d-01
      allz(3,4,1) = 1.877069 d-01
      allz(4,4,1) = 9.360270 d-02
      allz(5,4,1) = 5.052263 d-02
      allz(6,4,1) = 2.809354 d-02
      allc(1,4,1) = 3.775056 d-03
      allc(2,4,1) =-5.585965 d-02
      allc(3,4,1) =-3.192946 d-01
      allc(4,4,1) =-2.764780 d-02
      allc(5,4,1) = 9.049199 d-01
      allc(6,4,1) = 3.406258 d-01
c                                   4p
      allc(1,4,2) =-7.052075 d-03
      allc(2,4,2) =-5.259505 d-02
      allc(3,4,2) =-3.773450 d-02
      allc(4,4,2) = 3.874773 d-01
      allc(5,4,2) = 5.791672 d-01
      allc(6,4,2) = 1.221817 d-01
      allz(1,4,2) = 1.365346 d+00
      allz(2,4,2) = 4.393213 d-01
      allz(3,4,2) = 1.877069 d-01
      allz(4,4,2) = 9.360270 d-02
      allz(5,4,2) = 5.052263 d-02
      allz(6,4,2) = 2.809354 d-02
c                                     5s
      allz(1,5,1) = 7.701420258d-01
      allz(2,5,1) = 2.756268915d-01
      allz(3,5,1) = 1.301847480d-01
      allz(4,5,1) = 6.953441940d-02
      allz(5,5,1) = 4.002545502d-02
      allz(6,5,1) = 2.348388309d-02
      allc(1,5,1) = 1.267447151d-02
      allc(2,5,1) = 3.266734789d-03
      allc(3,5,1) =-4.307553999d-01
      allc(4,5,1) =-3.231998963d-01
      allc(5,5,1) = 1.104322879d+00
      allc(6,5,1) = 4.368498703d-01
c                                      5p
      allz(1,5,2) = 7.701420258d-01
      allz(2,5,2) = 2.756268915d-01
      allz(3,5,2) = 1.301847480d-01
      allz(4,5,2) = 6.953441940d-02
      allz(5,5,2) = 4.002545502d-02
      allz(6,5,2) = 2.348388309d-02
      allc(1,5,2) =-1.105673292d-03
      allc(2,5,2) =-6.243132446d-02
      allc(3,5,2) =-1.628476766d-01
      allc(4,5,2) = 3.210328714d-01
      allc(5,5,2) = 6.964579592d-01
      allc(6,5,2) = 1.493146125d-01
c                                   6s
      allz(1,6,1) = 5.800292686d-01
      allz(2,6,1) = 2.718262251d-01
      allz(3,6,1) = 7.938523262d-02
      allz(4,6,1) = 4.975088254d-02
      allz(5,6,1) = 2.983643556d-02
      allz(6,6,1) = 1.886067216d-02
      allc(1,6,1) = 4.554359511d-03
      allc(2,6,1) = 5.286443143d-02
      allc(3,6,1) =-7.561016358d-01
      allc(4,6,1) =-2.269803820d-01
      allc(5,6,1) = 1.332494651d+00
      allc(6,6,1) = 3.622518293d-01
c                                   6p
      allz(1,6,2) = 6.696537714d-01
      allz(2,6,2) = 1.395089793d-01
      allz(3,6,2) = 8.163894960d-02
      allz(4,6,2) = 4.586329272d-02
      allz(5,6,2) = 2.961305556d-02
      allz(6,6,2) = 1.882221321d-02
      allc(1,6,2) = 2.782723680d-03
      allc(2,6,2) =-1.282887780d-01
      allc(3,6,2) =-2.266255943d-01
      allc(4,6,2) = 4.682259383d-01
      allc(5,6,2) = 6.752048848d-01
      allc(6,6,2) = 1.091534212d-01
      do 30 i=1,10
         if(mtype(i).eq.0)goto 30
         ni=mtype(i)
         xi=zs(ni)
         ia=i*4-3
         ib=ia+3
         if(ni.lt.2) then
            nqn=1
         elseif(ni.lt.10)then
            nqn=2
         elseif(ni.lt.18)then
            nqn=3
         elseif(ni.lt.36)then
            nqn=4
         elseif(ni.lt.54)then
            nqn=5
         else
            nqn=6
         endif
         do 20 k=ia,ib
            l=1
            if(k.gt.ia) l=2
            if(k.gt.ia) xi=zp(ni)
            do 10 j=1,6
               cc(k,j)=allc(j,nqn,l)
   10       zz(k,j)=allz(j,nqn,l)*xi**2
   20    continue
   30 continue
      return
      end
c
c=======================================================================
c
      function sisms (c12,cc,lm6)
c     scalar product.
*******************************************************************
*     function need for green function calculations               *
*******************************************************************
      implicit REAL (a-h,o-z)
      dimension c12(*),cc(*)
      sisms=0.0d0
      do 10 i=1,lm6
   10 sisms=sisms+c12(i)*cc(i)
      return
      end
      subroutine solrot (ni,nj,xi,xj,wj,wk,kr,e1b,e2a,enuc,cutoff)
      implicit REAL (a-h,o-z)
      dimension xi(3), xj(3), wj(100), wk(100), e1b(10), e2a(10)
************************************************************************
*
*   solrot forms the two-electron two-atom j and k integral strings.
*          on exit wj = "j"-type integrals
*                  wk = "k"-type integrals
*
*      for molecules, wj = wk.
************************************************************************
      common /euler/ tvec(3,3), id
      common /ucell/ l1l,l2l,l3l,l1u,l2u,l3u
      common /numcal/ numcal
      dimension wsum(100), wbits(100), lims(3,2), xjuc(3), e1bits(10),
     1e2bits(10), wmax(100)
      save icalcn
      equivalence (l1l,lims(1,1))
      data icalcn/0/
      if(icalcn.ne.numcal)then
         icalcn=numcal
c$doit asis
         do 10 i=1,id
            lims(i,1)=-1
   10    lims(i,2)= 1
c$doit asis
         do 20 i=id+1,3
            lims(i,1)=0
   20    lims(i,2)=0
      endif
      one=1.d0
      if(xi(1).eq.xj(1) .and. xi(2).eq.xj(2) .and. xi(3).eq. xj(3))
     1one=0.5d0
      do 30 i=1,100
         wmax(i)=0.0d0
         wsum(i)=0.0d0
   30 wbits(i)=0.0d0
      do 40 i=1,10
         e1b(i)=0.0d0
   40 e2a(i)=0.0d0
      enuc=0.0d0
      do 90 i=l1l,l1u
         do 90 j=l2l,l2u
            do 90 k=l3l,l3u
c$doit asis
               do 50 l=1,3
   50          xjuc(l)=xj(l)+tvec(l,1)*i+tvec(l,2)*j+tvec(l,3)*k
               kb=1
               call moprat(ni,nj,xi,xjuc,wbits,kb,e1bits,e2bits,
     1enubit,cutoff)
               kb=kb-1
               do 60 ii=1,kb
   60          wsum(ii)=wsum(ii)+wbits(ii)
               if(wmax(1).lt.wbits(1))then
                  do 70 ii=1,kb
   70             wmax(ii)=wbits(ii)
               endif
               do 80 ii=1,10
                  e1b(ii)=e1b(ii)+e1bits(ii)
   80          e2a(ii)=e2a(ii)+e2bits(ii)
               enuc=enuc+enubit*one
   90 continue
      if(one.lt.0.9d0) then
         do 100 i=1,kb
  100    wmax(i)=0.0d0
      endif
      do 110 i=1,kb
         wk(i)=wmax(i)
  110 wj(i)=wsum(i)
      kr=kb+kr
      return
      end
      subroutine space(mreset, mset, xparam, grad, heat, nvar,
     1xset, gset, eset, frst)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      dimension xparam(nvar), grad(nvar)
      dimension xset(mreset*nvar),gset(mreset*nvar), eset(mreset)
      logical frst
c
c     update parameter and gradient subspace
c
      if(frst)then
         nreset=min(nvar/2,mreset)
         frst=.false.
         mset=0
      endif
c
      if (mset .eq. nreset) then
         do 10 i=1,mset-1
            mi = nvar*(i-1)
            ni = nvar*i
            eset(i)=eset(i+1)
            do 10 k=1,nvar
               xset(mi+k) = xset(ni+k)
   10    gset(mi+k) = gset(ni+k)
         mset=nreset-1
      endif
c
c     store the current point
c
      do 20 k=1,nvar
         nmk = nvar*mset+k
         xset(nmk) = xparam(k)
   20 gset(nmk) = grad(k)
      mset=mset+1
      eset(mset)=heat
c
      return
      end
      subroutine spline
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      logical skip1,skip2
c
c     fit f(x) by a cubic spline given values of the function
c     and its first derivative at n pnts.
c     routine returns values of xmin,fmin, and dfmin
c     and may reorder the data.
c     calling program supplies all other values in the
c     common block.
c     xlow and xhigh set limits on the interval within which
c     to search.  routine may further reduce this interval.
c
      common/fit/n,idum2,xlow,xhigh,xmin,fmin,dfmin,x(12),f(12),df(12)
      save close, big, huge, ustep, dstep
      data close, big, huge, ustep, dstep/
     +     1.0d-8,500.0d0,1.0d+10,1.0d0,2.0d0/
c
c     routine assumes that the first n-1 data pnts have been
c     previously ordered,  x(i).lt.x(i+1) for i=1,2,...,n-2
c     now move nth point to its proper place.
c
      xmin=x(n)
      fmin=f(n)
      dfmin=df(n)
      n1=n-1
      k=n1
   10 if(x(k).lt.xmin) go to 20
      x(k+1)=x(k)
      f(k+1)=f(k)
      df(k+1)=df(k)
      k=k-1
      if(k.gt.0) go to 10
   20 x(k+1)=xmin
      f(k+1)=fmin
      df(k+1)=dfmin
c
c     define the interval within which we trust the spline fit.
c     ustep =  up hill step size factor
c     dstep = down hill step size factor
c
      if(df(1).gt.0.0d0) step=dstep
      if(df(1).le.0.0d0) step=ustep
      xstart=x(1)-step*(x(2)-x(1))
      xstart=dmax1(xstart,xlow)
      if(df(n).gt.0.0d0) step=ustep
      if(df(n).le.0.0d0) step=dstep
      xstop=x(n)+step*(x(n)-x(n1))
      xstop=dmin1(xstop,xhigh)
c
c     search for minimum
c
      do 110 k=1,n1
         skip1=k.ne.1
         skip2=k.ne.n1
         if(f(k).ge.fmin) go to 30
         xmin=x(k)
         fmin=f(k)
         dfmin=df(k)
   30    dx=x(k+1)-x(k)
c
c     skip interval if pnts are too close together
c
         if(dx.le.close) go to 110
         x1=0.d0
         if(k.eq.1) x1=xstart-x(1)
         x2=dx
         if(k.eq.n1) x2=xstop-x(n1)
c
c     (a,b,c)=coef of (cubic,quadratic,linear) terms
c
         dum=(f(k+1)-f(k))/dx
         a=(df(k)+df(k+1)-dum-dum)/(dx*dx)
         b=(dum+dum+dum-df(k)-df(k)-df(k+1))/dx
         c=df(k)
c
c     xk = x-x(k) at the minimum within the kth subinterval
c     test for pathological cases.
c
         bb=b*b
         ac3=(a+a+a)*c
         if(bb.lt.ac3) go to 90
         if( b.gt.0.0d0) go to 40
         if(dabs(b).gt.huge*dabs(a)) go to 90
         go to 50
   40    if(bb.gt.big*dabs(ac3)) go to 60
c
c     well behaved cubic
c
   50    xk=(-b+dsqrt(bb-ac3))/(a+a+a)
         go to 70
c
c     cubic is dominated by quadratic term
c
   60    r=ac3/bb
         xk=-(((0.0390d0*r+0.0625d0)*r+0.125d0)*r+0.5d0)*c/b
   70    if(xk.lt.x1.or.xk.gt.x2) go to 90
   80    fm=((a*xk+b)*xk+c)*xk+f(k)
         if(fm.gt.fmin) go to 90
         xmin=xk+x(k)
         fmin=fm
         dfmin=((a+a+a)*xk+b+b)*xk+c
c
c     extrapolate to end of interval if k=1 and/or k=n1
c
   90    if(skip1) go to 100
         skip1=.true.
         xk=x1
         go to 80
  100    if(skip2) go to 110
         skip2=.true.
         xk=x2
         go to 80
  110 continue
      return
      end
      REAL function ss(na,nb,la1,lb1,m1,ua,ub,r1)
      implicit REAL (a-h,o-z)
      logical first
      dimension fa(0:13),aff(0:2,0:2,0:2),af(0:19),bf(0:19),
     1bi(0:12,0:12)
      save aff, fa, bi, first
      data first /.true./
      data aff/27*0.0d0/
      data fa/1.d0,1.d0,2.d0,6.d0,24.d0,120.d0,720.d0,5040.d0,40320.d0,
     1362880.d0,3628800.d0,39916800.d0,479001600.d0,6227020800.d0/
      m=m1-1
      lb=lb1-1
      la=la1-1
      r=r1/0.529167d0
      if(first) then
         first=.false.
c
c           initialise some constants
c
c                  binomials
c
         do 10 i=0,12
            bi(i,0)=1.d0
            bi(i,i)=1.d0
   10    continue
         do 20 i=0,11
            i1=i-1
            do 20 j=0,i1
               bi(i+1,j+1)=bi(i,j+1)+bi(i,j)
   20    continue
         aff(0,0,0)=1.d0
         aff(1,0,0)=1.d0
         aff(1,1,0)=1.d0
         aff(2,0,0)=1.5d0
         aff(2,1,0)=1.73205d0
         aff(2,2,0)=1.224745d0
         aff(2,0,2)=-0.5d0
      endif
      p=(ua+ub)*r*0.5d0
      b=(ua-ub)*r*0.5d0
      quo=1/p
      af(0)=quo*dexp(-p)
      do 30 n=1,19
         af(n)=n*quo*af(n-1)+af(0)
   30 continue
      call bfn(b,bf)
      sum=0.0d0
      lam1=la-m
      lbm1=lb-m
c
c          start of overlap calculation proper
c
      do 50 i=0,lam1,2
         ia=na+i-la
         ic=la-i-m
         do 50 j=0,lbm1,2
            ib=nb+j-lb
            id=lb-j-m
            sum1=0.0d0
            iab=ia+ib
            do 40 k1=0,ia
               do 40 k2=0,ib
                  do 40 k3=0,ic
                     do 40 k4=0,id
                        do 40 k5=0,m
                           iaf=iab-k1-k2+k3+k4+2*k5
                           do 40 k6=0,m
                              ibf=k1+k2+k3+k4+2*k6
                              jx=(-1)**(m+k2+k4+k5+k6)
                              sum1=sum1+bi(id,k4)*
     1bi(m,k5)*bi(ic,k3)*bi(ib,k2)*bi(ia,k1)*
     2bi(m,k6)*jx*af(iaf)*bf(ibf)
   40       continue
            sum=sum+sum1*aff(la,m,i)*aff(lb,m,j)
   50 continue
      ss=sum*r**(na+nb+1)*ua**na*ub**nb/(2.d0**(m+1))*
     1   dsqrt(ua*ub/(fa(na+na)*fa(nb+nb))*((la+la+1)*(lb+lb+1)))
      return
      end
      subroutine supdot(s,h,g,n,ig)
      implicit REAL (a-h,o-z)
c     (s)=(h)*(g) with  h  in packed form (canonical order).
c     ig is the increment for the vector g.
      dimension s(*),h(*),g(*)
c     cray-1 version
ccc      k=1
ccc      l=1
ccc      do 10 i=1,n
ccc      s(i)=ddot(i,h(k),1,g,ig,i)
ccc      if(i.gt.1) then
ccc         l=l+ig
ccc         call saxpy(i-1,g(l),h(k),1,s,1)
ccc      endif
ccc   10 k=k+i
ccc      return
ccc      end
c     scalar version ok with ig=1 only.
      k=0
      do 20 i=1,n
         sum=0.0d0
         do 10 j=1,i
   10    sum=sum+g(j)*h(k+j)
         s(i)=sum
   20 k=k+i
      if (n.eq.1) return
      k=1
      do 40 i=2,n
         gi=g(i)
         do 30 j=1,i-1
   30    s(j)=s(j)+h(k+j)*gi
   40 k=k+i
      return
      end
c***********************************************************************
      subroutine surfac(scale,dens,ipt)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      common /iofile/ mfgr,mfgw
c***********************************************************************
c
c      this routine calculates the molecular surface of a molecule
c      given the coordinates of its atoms.  van der waals' radii for
c      the atoms and the probe radius must also be specified.
c
c      on input    scale = initial van der waals' scale factor
c                  dens  = density of points per unit area
c
c      this routine was lifted from michael connolly's surface
c      program for ucsf graphics system by u.chandra singh and
c      p.a.kollman and modified for use in quest. k.m.merz
c      adapted and cleaned up this program for use in ampac/mopac
c      in feb. 1989 at ucsf.
c
c***********************************************************************
      common /cmpg/   geo(3,numatm)
      common /geokst/ natoms,labels(numatm),
     1                na(numatm),nb(numatm),nc(numatm)
      common /keywrd/ keywrd
c
      common /abc/    co(3,numatm),ian(numatm),natom
      common /work1/    potpt(3,mesp), pad1(2*mesp), rad(mesp),
     1ias(mesp)
      common /potesp/ xc,yc,zc,espnuc,espele,nesp
c
      character*241 keywrd
c
c     cartesian coordinate and atom labels
c
      dimension coord(3,numatm),vander(100)
      dimension con(3,1000),rot(3,3)
c
c     neighbor arrays
c
c     this same dimension for the maximum number of neighbors
c     is used to dimension arrays in the logical function collidm
c
      dimension inbr(200),cnbr(3,200),rnbr(200)
      logical snbr(200),mnbr(200)
c
c     arrays for all atoms
c
c     iatom, jatom and katom coordinates
c
      dimension ci(3), ieldat(56), temp0(3)
c
c     geometric construction vectors
c
      dimension cw(3,2)
c
c     logical variables
c
      logical si
c
c     logical functions
c
      logical collidm
c
c     data for vander vall radii
c
      character marker*3, markss*3, mynam*3, ieldat*4, namatm*4
      data vander/1.20d0,1.20d0,1.37d0,1.45d0,1.45d0,1.50d0,1.50d0,
     1            1.40d0,1.35d0,1.30d0,1.57d0,1.36d0,1.24d0,1.17d0,
     2            1.80d0,1.75d0,1.70d0,17*0.0d0,2.3d0,65*0.0d0/
      data marker/'a  '/,markss/'ss0'/,mynam/'uc '/
c
      data ieldat/'  bq','  h ','  he','  li','  be','  b ',
     1            '  c ','  n ','  o ','  f ','  ne','  na',
     2            '  mg','  al','  si','  p ','  s ','  cl',
     3            '  ar','  k ','  ca','  sc','  ti','  v ',
     4            '  cr','  mn','  fe','  co','  ni','  cu',
     5            '  zn','  ga','  ge','  as','  se','  br',
     6            '  kr','  rb','  sr','   y','  zr','  nb',
     7            '  mo','  tc','  ru','  rh','  pd','  ag',
     8            '  cd','  in','  sn','  sb','  te','   i',
     9            '   x','  cs'/
      pi=4.d0*datan(1.d0)
c     insert van der waal radii for zinc
      vander(30)=1.00d0
c
c     convert internal to cartesian coordinates
c
      call gmetry(geo,coord)
c
c     strip coordinates and atom label for dummies (i.e. 99)
c
      icntr = 0
      do 20 i=1,natoms
         do 10 j=1,3
   10    co(j,i) = coord(j,i)
         if(labels(i) .eq. 99) goto 20
         icntr = icntr + 1
         ian(icntr) = labels(i)
   20 continue
c
c     only van der waals' type surface is generated
c
      iop = 1
      rw =0.0d0
      natom = icntr
      den = dens
      do 30 i=1,natom
         ipoint = ian(i)
         rad(i) = vander(ipoint)*scale
         if (rad(i) .lt. 0.01d0) then
            write(mfgw,
     +      '(t2,''van der waals'''' radius for atom '',i3,
     1         '' is zero, supply a value in subroutine surfac)''
     2         )')
         endif
         ias(i) = 2
   30 continue
c
c     big loop for each atom
c
      do 110 iatom = 1, natom
         if (ias(iatom) .eq. 0) go to 110
c
c     transfer values from large arrays to iatom variables
c
         namatm =ieldat(ian(iatom)+1)
         ri = rad(iatom)
         si = ias(iatom) .eq. 2
         do 40 k = 1,3
            ci(k) = co(k,iatom)
   40    continue
c
c     gather the neighboring atoms of iatom
c
         nnbr = 0
         do 60 jatom = 1, natom
            if (iatom .eq. jatom .or. ias(jatom) .eq. 0) go to 60
            d2 = dist2m(ci,co(1,jatom))
            if (d2 .ge. (2*rw+ri+rad(jatom)) ** 2) go to 60
c
c     we have a new neighbor
c     transfer atom coordinates, radius and surface request number
c
            nnbr = nnbr + 1
            if (nnbr .gt. 200)then
               write (mfgw,
     +         '(''error'',2x,''too many neighbors:'',i5)')nnbr
_IF(ipsc,tools)
               call pend
_ELSE
               stop
_ENDIF
            endif
            inbr(nnbr) = jatom
            do 50 k = 1,3
               cnbr(k,nnbr) = co(k,jatom)
   50       continue
            rnbr(nnbr) = rad(jatom)
            snbr(nnbr) = ias(jatom) .eq. 2
   60    continue
c
c     contact surface
c
         if (.not. si) go to 110
         ncon = (4 * pi * ri ** 2) * den
         if (ncon .gt. 1000) ncon = 1000
c
c     this call may decrease ncon somewhat
c
         if ( ncon .eq. 0) then
            write(mfgw,
     +      '(t2,''vector length of zero in surfac'')')
_IF(ipsc,tools)
            call pend
_ELSE
            stop
_ENDIF
         endif
         call genunm(con,ncon)
         area = (4 * pi * ri ** 2) / ncon
c
c     contact probe placement loop
c
         do 100 i = 1,ncon
            do 70 k = 1,3
               cw(k,1) = ci(k) + (ri + rw) * con(k,i)
   70       continue
c
c     check for collision with neighboring atoms
c
            if (collidm(cw(1,1),rw,cnbr,rnbr,mnbr,nnbr,1,
     1      jnbr,knbr)) go to 100
            do 80 kk=1,3
               temp0(kk) =ci(kk)+ri*con(kk,i)
   80       continue
c
c     store point in potpt and increment nesp
c
            nesp = nesp + 1
            if (nesp .gt. mesp) then
               write(mfgw,90)
   90          format(/'error - to many points generated in surfac')
               write(mfgw,
     +         '(''    reduce nsurf, scale, den, or scincr'')')
_IF(ipsc,tools)
               call pend
_ELSE
               stop
_ENDIF
            endif
            potpt(1,nesp) = temp0(1)
            potpt(2,nesp) = temp0(2)
            potpt(3,nesp) = temp0(3)
  100    continue
  110 continue
      return
      end
      subroutine timclk(secs)
      implicit  REAL  (a-h,o-z)
_IFN(ipsc)
_IFN(rs6000)
_IFN1(k)      real *4  etime, dum, tarray(2)
_IF1(k)      REAL tarray(2)
c for convex etc :-
cjvl      dum = etime(tarray)
cjvl      secs = tarray(1)
      secs = cpulft(1)
_ELSE
c for cdc, ibm rs6000, iris :-
      secs = mclock () / 100.d0
_ENDIF
_ELSE
      logical first
      data first/.true./
      save first,slast
c
      if(first) then
         first = .false.
         slast = dclock()
         secs = 0.0d0
      else
         xtemp = dclock()
         secs = xtemp - slast
         slast = xtemp
      endif
_ENDIF
      return
      end
      subroutine timop(a)
      implicit REAL (a-h,o-z)
      common/iofile/mfgr,mfgw
      character*(*) a
      logical first
      data first/.true./
      if(first)then
c
c  define the zero of time
c
         t0=secmop()
         t1=t0
         first=.false.
      endif
c
c   the act of calling this routine costs 0.026 seconds
c
      t0=t0+0.026d0
      t2=secmop()
      if(index(a,'bef').eq.0.and.a.ne.' ')then
         write(mfgw,'(2x,a,a,f7.2,a,f8.2)')
     1a,' interval:',t2-t1,' integral:',t2-t0
      else
         write(mfgw,'(40x,''time lost:'',f7.2)')t2-t1
      endif
      t1=t2+0.026d0
      return
      end
      subroutine mtql2(nm,n,d,e,z,ierr,eps)
      implicit REAL (a-h,o-z)
c               ===== processed by augment, version 4n =====
c     approved for vax 11/780 on may 6,1980.  j.d.neece
c               ----- local variables -----
c               ----- global variables -----
      dimension d(n), e(n), z(nm,n)
c               ----- supporting package functions -----
c               ===== translated program =====
c
c
c     this routine is a translation of the algol procedure tql2,
c     num. math. 11, 293-306(1968) by bowdler, martin, reinsch, and
c     wilkinson.
c     handbook for auto. comp., vol.ii-linear algebra, 227-240(1971).
c
c     this routine finds the eigenvalues and eigenvectors
c     of a symmetric tridiagonal matrix by the ql method.
c     the eigenvectors of a full symmetric matrix can also
c     be found if  tred2  has been used to reduce this
c     full matrix to tridiagonal form.
c
c     on input-
c
c        nm must be set to the row dimension of two-dimensional
c          array parameters as declared in the calling program
c          dimension statement,
c
c        n is the order of the matrix,
c
c        d contains the diagonal elements of the input matrix,
c
c        e contains the subdiagonal elements of the input matrix
c          in its last n-1 positions.  e(1) is arbitrary,
c
c        z contains the transformation matrix produced in the
c          reduction by  tred2, if performed.  if the eigenvectors
c          of the tridiagonal matrix are desired, z must contain
c          the identity matrix.
c
c      on output-
c
c        d contains the eigenvalues in ascending order.  if an
c          error exit is made, the eigenvalues are correct but
c          unordered for indices 1,2,...,ierr-1,
c
c        e has been destroyed,
c
c        z contains orthonormal eigenvectors of the symmetric
c          tridiagonal (or full) matrix.  if an error exit is made,
c          z contains the eigenvectors associated with the stored
c          eigenvalues,
c
c        ierr is set to
c          zero       for normal return,
c          j          if the j-th eigenvalue has not been
c                     determined after 30 iterations.
c
c     questions and comments should be directed to b. s. garbow,
c     applied mathematics division, argonne national laboratory
c
c     ------------------------------------------------------------------
c
c
      ierr = 0
      if (n .eq. 1) go to 160
c
      do 10   i = 2, n
   10 e(i-1) = e(i)
c
      f=0.0d0
      b=0.0d0
      e(n)=0.0d0
c
      do 110   l = 1, n
         j = 0
         h=eps*(dabs(d(l))+dabs(e(l)))
         if (b .lt. h) b=h
c     ********** look for small sub-diagonal element **********
         do 20   m = l, n
            if (dabs(e(m)).le.b)  go to 30
c     ********** e(n) is always zero, so there is no exit
c                through the bottom of the loop **********
   20    continue
c
   30    if (m .eq. l) go to 100
   40    if (j .eq. 30) go to 150
         j = j + 1
c     ********** form shift **********
         l1 = l + 1
         g = d(l)
         p=(d(l1)-g)/(2.0d0*e(l))
         r=dsqrt(p*p+1.0d0)
         d(l)=e(l)/(p+dsign(r,p))
         h = g - d(l)
c
         do 50   i = l1, n
   50    d(i) = d(i) - h
c
         f = f + h
c     ********** ql transformation **********
         p = d(m)
         c=1.0d0
         s=0.0d0
         mml = m - l
c     ********** for i=m-1 step -1 until l do -- **********
         do 90   ii = 1, mml
            i = m - ii
            g = c * e(i)
            h = c * p
            if (dabs(p).lt.dabs(e(i)))  go to 60
            c = e(i) / p
            r=dsqrt(c*c+1.0d0)
            e(i+1) = s * p * r
            s = c / r
            c=1.0d0/r
            go to 70
   60       c = p / e(i)
            r=dsqrt(c*c+1.0d0)
            e(i+1) = s * e(i) * r
            s=1.0d0/r
            c = c * s
   70       p = c * d(i) - s * g
            d(i+1) = h + s * (c * g + s * d(i))
c     ********** form vector **********
            do 80   k = 1, n
               h = z(k,i+1)
               z(k,i+1) = s * z(k,i) + c * h
               z(k,i) = c * z(k,i) - s * h
   80       continue
c
   90    continue
c
         e(l) = s * p
         d(l) = c * p
         if (dabs(e(l)).gt.b)  go to 40
  100    d(l) = d(l) + f
  110 continue
c     ********** order eigenvalues and eigenvectors **********
      do 140   ii = 2, n
         i = ii - 1
         k = i
         p = d(i)
c
         do 120   j = ii, n
            if (d(j) .ge. p) go to 120
            k = j
            p = d(j)
  120    continue
c
         if (k .eq. i) go to 140
         d(k) = d(i)
         d(i) = p
c
         do 130   j = 1, n
            p = z(j,i)
            z(j,i) = z(j,k)
            z(j,k) = p
  130    continue
c
  140 continue
c
      go to 160
c     ********** set error -- no convergence to an
c                eigenvalue after 30 iterations **********
  150 ierr = l
  160 return
c     ********** last card of mtql2 **********
      end
      subroutine mtqlrt(n,d,e2,ierr,eps)
      implicit REAL (a-h,o-z)
c               ===== processed by augment, version 4n =====
c     approved for vax 11/780 on may 6,1980.  j.d.neece
c               ----- local variables -----
c               ----- global variables -----
      dimension d(n), e2(n)
c               ----- supporting package functions -----
c               ===== translated program =====
c
c
c     this routine is a translation of the algol procedure tqlrat,
c     algorithm 464, comm. acm 16, 689(1973) by reinsch.
c
c     this routine finds the eigenvalues of a symmetric
c     tridiagonal matrix by the rational ql method.
c
c     on input-
c
c        n is the order of the matrix,
c
c        d contains the diagonal elements of the input matrix,
c
c        e2 contains the squares of the subdiagonal elements of the
c          input matrix in its last n-1 positions.  e2(1) is arbitrary.
c
c      on output-
c
c        d contains the eigenvalues in ascending order.  if an
c          error exit is made, the eigenvalues are correct and
c          ordered for indices 1,2,...ierr-1, but may not be
c          the smallest eigenvalues,
c
c        e2 has been destroyed,
c
c        ierr is set to
c          zero       for normal return,
c          j          if the j-th eigenvalue has not been
c                     determined after 30 iterations.
c
c     questions and comments should be directed to b. s. garbow,
c     applied mathematics division, argonne national laboratory
c
c     ------------------------------------------------------------------
c
c
      ierr = 0
      if (n .eq. 1) go to 140
c
      do 10   i = 2, n
   10 e2(i-1) = e2(i)
c
      f=0.0d0
      b=0.0d0
      e2(n)=0.0d0
c
      do 120   l = 1, n
         j = 0
         h=eps*(dabs(d(l))+dsqrt(e2(l)))
         if (b .gt. h) go to 20
         b = h
         c = b * b
c     ********** look for small squared sub-diagonal element **********
   20    do 30   m = l, n
            if (e2(m) .le. c) go to 40
c     ********** e2(n) is always zero, so there is no exit
c                through the bottom of the loop **********
   30    continue
c
   40    if (m .eq. l) go to 80
   50    if (j .eq. 30) go to 130
         j = j + 1
c     ********** form shift **********
         l1 = l + 1
         s=dsqrt(e2(l))
         g = d(l)
         p=(d(l1)-g)/(2.0d0*s)
         r=dsqrt(p*p+1.0d0)
         d(l)=s/(p+dsign(r,p))
         h = g - d(l)
c
         do 60   i = l1, n
   60    d(i) = d(i) - h
c
         f = f + h
c     ********** rational ql transformation **********
         g = d(m)
         if (g.eq.0.0d0) g=b
         h = g
         s=0.0d0
         mml = m - l
c     ********** for i=m-1 step -1 until l do -- **********
         do 70   ii = 1, mml
            i = m - ii
            p = g * h
            r = p + e2(i)
            e2(i+1) = s * r
            s = e2(i) / r
            d(i+1) = h + s * (h + d(i))
            g = d(i) - e2(i) / g
            if (g.eq.0.0d0) g=b
            h = g * p / r
   70    continue
c
         e2(l) = s * g
         d(l) = h
c     ********** guard against underflow in convergence test **********
         if (h.eq.0.0d0)  go to 80
         if (dabs(e2(l)).le.dabs(c/h))  go to 80
         e2(l) = h * e2(l)
         if (e2(l).ne.0.0d0)  go to 50
   80    p = d(l) + f
c     ********** order eigenvalues **********
         if (l .eq. 1) go to 100
c     ********** for i=l step -1 until 2 do -- **********
         do 90   ii = 2, l
            i = l + 2 - ii
            if (p .ge. d(i-1)) go to 110
            d(i) = d(i-1)
   90    continue
c
  100    i = 1
  110    d(i) = p
  120 continue
c
      go to 140
c     ********** set error -- no convergence to an
c                eigenvalue after 30 iterations **********
  130 ierr = l
  140 return
c     ********** last card of mtqlrt **********
      end
      block data tom
      implicit REAL (a-h,o-z)
      common/herm1e/hr(10),hw(10)
      common/t2w21e/lent(4),lind(4),iadr(4),s(4),ycut(4),t2(1030),
     1 w2(1030)
      data hr(   1)/.500000000000000d+00/,hw(   1)/.886226925452800d+00/
      data hr(   2)/.275255128608411d+00/,hw(   2)/.804914090005500d+00/
      data hr(   3)/.272474487139159d+01/,hw(   3)/.813128354472500d-01/
      data hr(   4)/.190163509193489d+00/,hw(   4)/.724629595224400d+00/
      data hr(   5)/.178449274854325d+01/,hw(   5)/.157067320322900d+00/
      data hr(   6)/.552534374226326d+01/,hw(   6)/.453000990550900d-02/
      data hr(   7)/.145303521503317d+00/,hw(   7)/.661147012558200d+00/
      data hr(   8)/.133909728812636d+01/,hw(   8)/.207802325814900d+00/
      data hr(   9)/.392696350135829d+01/,hw(   9)/.170779830074100d-01/
      data hr(  10)/.858863568901203d+01/,hw(  10)/.199604072211400d-03/
      data lind/0,1,3,6/,lent/4*103/,iadr/1,104,310,619/,ycut/4*0.96999e
     10/
      data t2(   1)/.340356529396388d+00/,w2(   1)/.105425787260118d+01/
      data t2(   2)/.336866892496096d+00/,w2(   2)/.102689779637686d+01/
      data t2(   3)/.333333333333333d+00/,w2(   3)/.100000000000000d+01/
      data t2(   4)/.329755756605947d+00/,w2(   4)/.973564412199074d+00/
      data t2(   5)/.326134110223798d+00/,w2(   5)/.947590797960082d+00/
      data t2(   6)/.322468388585779d+00/,w2(   6)/.922078755530430d+00/
      data t2(   7)/.318758636000759d+00/,w2(   7)/.897027713530460d+00/
      data t2(   8)/.315004950251030d+00/,w2(   8)/.872436928182995d+00/
      data t2(   9)/.311207486295568d+00/,w2(   9)/.848305480671510d+00/
      data t2(  10)/.307366460108990d+00/,w2(  10)/.824632274637857d+00/
      data t2(  11)/.303482152650496d+00/,w2(  11)/.801416033830680d+00/
      data t2(  12)/.299554913955247d+00/,w2(  12)/.778655299915924d+00/
      data t2(  13)/.295585167338620d+00/,w2(  13)/.756348430461019d+00/
      data t2(  14)/.291573413701521d+00/,w2(  14)/.734493597104524d+00/
      data t2(  15)/.287520235922427d+00/,w2(  15)/.713088783923123d+00/
      data t2(  16)/.283426303319098d+00/,w2(  16)/.692131786008038d+00/
      data t2(  17)/.279292376159886d+00/,w2(  17)/.671620208262925d+00/
      data t2(  18)/.275119310201296d+00/,w2(  18)/.651551464435442d+00/
      data t2(  19)/.270908061224931d+00/,w2(  19)/.631922776394594d+00/
      data t2(  20)/.266659689543144d+00/,w2(  20)/.612731173665986d+00/
      data t2(  21)/.262375364438676d+00/,w2(  21)/.593973493236979d+00/
      data t2(  22)/.258056368499263d+00/,w2(  22)/.575646379643618d+00/
      data t2(  23)/.253704101803684d+00/,w2(  23)/.557746285351034d+00/
      data t2(  24)/.249320085911035d+00/,w2(  24)/.540269471438763d+00/
      data t2(  25)/.244905967600128d+00/,w2(  25)/.523212008602160d+00/
      data t2(  26)/.240463522301038d+00/,w2(  26)/.506569778480738d+00/
      data t2(  27)/.235994657155774d+00/,w2(  27)/.490338475323886d+00/
      data t2(  28)/.231501413640185d+00/,w2(  28)/.474513608003987d+00/
      data t2(  29)/.226985969674406d+00/,w2(  29)/.459090502386470d+00/
      data t2(  30)/.222450641144615d+00/,w2(  30)/.444064304065812d+00/
      data t2(  31)/.217897882754780d+00/,w2(  31)/.429429981475917d+00/
      data t2(  32)/.213330288123406d+00/,w2(  32)/.415182329382711d+00/
      data t2(  33)/.208750589037460d+00/,w2(  33)/.401315972766111d+00/
      data t2(  34)/.204161653773589d+00/,w2(  34)/.387825371097864d+00/
      data t2(  35)/.199566484395856d+00/,w2(  35)/.374704823021004d+00/
      data t2(  36)/.194968212939614d+00/,w2(  36)/.361948471435948d+00/
      data t2(  37)/.190370096393081d+00/,w2(  37)/.349550308997434d+00/
      data t2(  38)/.185775510391938d+00/,w2(  38)/.337504184025729d+00/
      data t2(  39)/.181187941548071d+00/,w2(  39)/.325803806834662d+00/
      data t2(  40)/.176610978341680d+00/,w2(  40)/.314442756478165d+00/
      data t2(  41)/.172048300516651d+00/,w2(  41)/.303414487916104d+00/
      data t2(  42)/.167503666932511d+00/,w2(  42)/.292712339599190d+00/
      data t2(  43)/.162980901842716d+00/,w2(  43)/.282329541471746d+00/
      data t2(  44)/.158483879588575d+00/,w2(  44)/.272259223390002d+00/
      data t2(  45)/.154016507720934d+00/,w2(  45)/.262494423952352d+00/
      data t2(  46)/.149582708587826d+00/,w2(  46)/.253028099736682d+00/
      data t2(  47)/.145186399455647d+00/,w2(  47)/.243853134938341d+00/
      data t2(  48)/.140831471263780d+00/,w2(  48)/.234962351400596d+00/
      data t2(  49)/.136521766147863d+00/,w2(  49)/.226348519027388d+00/
      data t2(  50)/.132261053904423d+00/,w2(  50)/.218004366565902d+00/
      data t2(  51)/.128053007609052d+00/,w2(  51)/.209922592743678d+00/
      data t2(  52)/.123901178640719d+00/,w2(  52)/.202095877741857d+00/
      data t2(  53)/.119808971405433d+00/,w2(  53)/.194516894982342d+00/
      data t2(  54)/.115779618092026d+00/,w2(  54)/.187178323202349d+00/
      data t2(  55)/.111816153830185d+00/,w2(  55)/.180072858784734d+00/
      data t2(  56)/.107921392654278d+00/,w2(  56)/.173193228306701d+00/
      data t2(  57)/.104097904704628d+00/,w2(  57)/.166532201262870d+00/
      data t2(  58)/.100347995118615d+00/,w2(  58)/.160082602911294d+00/
      data t2(  59)/.966736850756001d-01/,w2(  59)/.153837327182773d+00/
      data t2(  60)/.930766954601653d-01/,w2(  60)/.147789349584857d+00/
      data t2(  61)/.895584335955835d-01/,w2(  61)/.141931740022367d+00/
      data t2(  62)/.861199834720750d-01/,w2(  62)/.136257675446262d+00/
      data t2(  63)/.827620998506241d-01/,w2(  63)/.130760452232545d+00/
      data t2(  64)/.794852065617851d-01/,w2(  64)/.125433498183026d+00/
      data t2(  65)/.762893992393405d-01/,w2(  65)/.120270384030558d+00/
      data t2(  66)/.731744526309407d-01/,w2(  66)/.115264834323538d+00/
      data t2(  67)/.701398325129289d-01/,w2(  67)/.110410737558586d+00/
      data t2(  68)/.671847121065003d-01/,w2(  68)/.105702155427222d+00/
      data t2(  69)/.643079927505321d-01/,w2(  69)/.101133331042900d+00/
      data t2(  70)/.615083284376647d-01/,w2(  70)/.966986960196688d-01/
      data t2(  71)/.587841536708516d-01/,w2(  71)/.923928762839300d-01/
      data t2(  72)/.561337139555247d-01/,w2(  72)/.882106965166978d-01/
      data t2(  73)/.535550981169235d-01/,w2(  73)/.841471831460173d-01/
      data t2(  74)/.510462715332070d-01/,w2(  74)/.801975658376118d-01/
      data t2(  75)/.486051093131227d-01/,w2(  75)/.763572774660682d-01/
      data t2(  76)/.462294284320421d-01/,w2(  76)/.726219525878417d-01/
      data t2(  77)/.439170178798807d-01/,w2(  77)/.689874244794109d-01/
      data t2(  78)/.416656659731728d-01/,w2(  78)/.654497208467106d-01/
      data t2(  79)/.394731841406836d-01/,w2(  79)/.620050583526308d-01/
      data t2(  80)/.373374267003077d-01/,w2(  80)/.586498361446446d-01/
      data t2(  81)/.352563063903231d-01/,w2(  81)/.553806285912343d-01/
      data t2(  82)/.332278056790578d-01/,w2(  82)/.521941774508560d-01/
      data t2(  83)/.312499841272064d-01/,w2(  83)/.490873836987548d-01/
      data t2(  84)/.293209822881369d-01/,w2(  84)/.460572992244769d-01/
      data t2(  85)/.274390227784339d-01/,w2(  85)/.431011185876240d-01/
      data t2(  86)/.256024092172802d-01/,w2(  86)/.402161709842633d-01/
      data t2(  87)/.238095237161702d-01/,w2(  87)/.373999125359084d-01/
      data t2(  88)/.220588235124402d-01/,w2(  88)/.346499189722651d-01/
      data t2(  89)/.203488372068759d-01/,w2(  89)/.319638787427673d-01/
      data t2(  90)/.186781609192821d-01/,w2(  90)/.293395865636829d-01/
      data t2(  91)/.170454545454356d-01/,w2(  91)/.267749373885484d-01/
      data t2(  92)/.154494382022463d-01/,w2(  92)/.242679207791346d-01/
      data t2(  93)/.138888888888889d-01/,w2(  93)/.218166156499291d-01/
      data t2(  94)/.123626373626374d-01/,w2(  94)/.194191853587281d-01/
      data t2(  95)/.108695652173913d-01/,w2(  95)/.170738731173358d-01/
      data t2(  96)/.940860215053764d-02/,w2(  96)/.147789976983391d-01/
      data t2(  97)/.797872340425532d-02/,w2(  97)/.125329494159167d-01/
      data t2(  98)/.657894736842106d-02/,w2(  98)/.103341863604927d-01/
      data t2(  99)/.520833333333334d-02/,w2(  99)/.818123086872343d-02/
      data t2( 100)/.386597938144330d-02/,w2( 100)/.607266621183595d-02/
      data t2( 101)/.255102040816327d-02/,w2( 101)/.400713348672168d-02/
      data t2( 102)/.126262626262627d-02/,w2( 102)/.198332869544811d-02/
      data t2( 103)/.000000000000000d+00/,w2( 103)/.000000000000000d+00/
      data t2( 104)/.116809100330144d+00/,w2( 104)/.433979403505602d+00/
      data t2( 105)/.116202074745553d+00/,w2( 105)/.429645383656600d+00/
      data t2( 106)/.115587109997048d+00/,w2( 106)/.425293303010694d+00/
      data t2( 107)/.114964063285315d+00/,w2( 107)/.420923292270390d+00/
      data t2( 108)/.114332788850161d+00/,w2( 108)/.416535491906746d+00/
      data t2( 109)/.113693137915673d+00/,w2( 109)/.412130052508836d+00/
      data t2( 110)/.113044958635569d+00/,w2( 110)/.407707135142496d+00/
      data t2( 111)/.112388096038859d+00/,w2( 111)/.403266911718401d+00/
      data t2( 112)/.111722391976003d+00/,w2( 112)/.398809565369472d+00/
      data t2( 113)/.111047685065713d+00/,w2( 113)/.394335290837622d+00/
      data t2( 114)/.110363810642622d+00/,w2( 114)/.389844294869801d+00/
      data t2( 115)/.109670600706018d+00/,w2( 115)/.385336796623265d+00/
      data t2( 116)/.108967883869893d+00/,w2( 116)/.380813028079972d+00/
      data t2( 117)/.108255485314563d+00/,w2( 117)/.376273234469964d+00/
      data t2( 118)/.107533226740153d+00/,w2( 118)/.371717674703550d+00/
      data t2( 119)/.106800926322279d+00/,w2( 119)/.367146621812053d+00/
      data t2( 120)/.106058398670263d+00/,w2( 120)/.362560363396858d+00/
      data t2( 121)/.105305454788285d+00/,w2( 121)/.357959202086402d+00/
      data t2( 122)/.104541902039907d+00/,w2( 122)/.353343456000723d+00/
      data t2( 123)/.103767544116434d+00/,w2( 123)/.348713459223093d+00/
      data t2( 124)/.102982181009644d+00/,w2( 124)/.344069562278216d+00/
      data t2( 125)/.102185608989470d+00/,w2( 125)/.339412132616357d+00/
      data t2( 126)/.101377620587272d+00/,w2( 126)/.334741555102727d+00/
      data t2( 127)/.100558004585411d+00/,w2( 127)/.330058232511320d+00/
      data t2( 128)/.997265460139054d-01/,w2( 128)/.325362586022344d+00/
      data t2( 129)/.988830261550547d-01/,w2( 129)/.320655055722249d+00/
      data t2( 130)/.980272225569827d-01/,w2( 130)/.315936101105275d+00/
      data t2( 131)/.971589090571892d-01/,w2( 131)/.311206201575320d+00/
      data t2( 132)/.962778558173058d-01/,w2( 132)/.306465856946821d+00/
      data t2( 133)/.953838293703991d-01/,w2( 133)/.301715587943216d+00/
      data t2( 134)/.944765926823253d-01/,w2( 134)/.296955936691427d+00/
      data t2( 135)/.935559052288243d-01/,w2( 135)/.292187467210712d+00/
      data t2( 136)/.926215230902576d-01/,w2( 136)/.287410765894081d+00/
      data t2( 137)/.916731990661413d-01/,w2( 137)/.282626441980390d+00/
      data t2( 138)/.907106828119164d-01/,w2( 138)/.277835128015102d+00/
      data t2( 139)/.897337210007361d-01/,w2( 139)/.273037480297646d+00/
      data t2( 140)/.887420575134506d-01/,w2( 140)/.268234179313221d+00/
      data t2( 141)/.877354336604371d-01/,w2( 141)/.263425930146885d+00/
      data t2( 142)/.867135884394848d-01/,w2( 142)/.258613462877768d+00/
      data t2( 143)/.856762588346045d-01/,w2( 143)/.253797532951350d+00/
      data t2( 144)/.846231801614288d-01/,w2( 144)/.248978921527879d+00/
      data t2( 145)/.835540864658181d-01/,w2( 145)/.244158435805273d+00/
      data t2( 146)/.824687109834309d-01/,w2( 146)/.239336909315244d+00/
      data t2( 147)/.813667866693965d-01/,w2( 147)/.234515202191922d+00/
      data t2( 148)/.802480468088913d-01/,w2( 148)/.229694201413052d+00/
      data t2( 149)/.791122257214392d-01/,w2( 149)/.224874821014832d+00/
      data t2( 150)/.779590595742018d-01/,w2( 150)/.220058002282883d+00/
      data t2( 151)/.767882873224900d-01/,w2( 151)/.215244713923590d+00/
      data t2( 152)/.755996517993404d-01/,w2( 152)/.210435952222398d+00/
      data t2( 153)/.743929009803724d-01/,w2( 153)/.205632741198604d+00/
      data t2( 154)/.731677894554631d-01/,w2( 154)/.200836132769946d+00/
      data t2( 155)/.719240801452142d-01/,w2( 155)/.196047206945073d+00/
      data t2( 156)/.706615463079764d-01/,w2( 156)/.191267072067886d+00/
      data t2( 157)/.693799738925810d-01/,w2( 157)/.186496865145198d+00/
      data t2( 158)/.680791643031870d-01/,w2( 158)/.181737752298251d+00/
      data t2( 159)/.667589376560728d-01/,w2( 159)/.176990929389891d+00/
      data t2( 160)/.654191366240672d-01/,w2( 160)/.172257622892740d+00/
      data t2( 161)/.640596309828693d-01/,w2( 161)/.167539091080110d+00/
      data t2( 162)/.626803229948832d-01/,w2( 162)/.162836625640690d+00/
      data t2( 163)/.612811537903360d-01/,w2( 163)/.158151553840620d+00/
      data t2( 164)/.598621109319538d-01/,w2( 164)/.153485241382157d+00/
      data t2( 165)/.584232373773691d-01/,w2( 165)/.148839096136335d+00/
      data t2( 166)/.569646420809103d-01/,w2( 166)/.144214572956563d+00/
      data t2( 167)/.554865125003305d-01/,w2( 167)/.139613179808601d+00/
      data t2( 168)/.539891292893709d-01/,w2( 168)/.135036485475780d+00/
      data t2( 169)/.524728834561612d-01/,w2( 169)/.130486129110125d+00/
      data t2( 170)/.509382962391622d-01/,w2( 170)/.125963831890177d+00/
      data t2( 171)/.493860418809438d-01/,w2( 171)/.121471411000063d+00/
      data t2( 172)/.478169733444729d-01/,w2( 172)/.117010796041255d+00/
      data t2( 173)/.462321507899268d-01/,w2( 173)/.112584047801088d+00/
      data t2( 174)/.446328722805845d-01/,w2( 174)/.108193378996568d+00/
      data t2( 175)/.430207056805783d-01/,w2( 175)/.103841176150171d+00/
      data t2( 176)/.413975200169760d-01/,w2( 176)/.995300210999941d-01/
      data t2( 177)/.397655136937506d-01/,w2( 177)/.952627097788015d-01/
      data t2( 178)/.381272358942409d-01/,w2( 178)/.910422648309857d-01/
      data t2( 179)/.364855963873249d-01/,w2( 179)/.868719374581350d-01/
      data t2( 180)/.348438579563525d-01/,w2( 180)/.827551927869849d-01/
      data t2( 181)/.332056051219335d-01/,w2( 181)/.786956723783842d-01/
      data t2( 182)/.315746831817740d-01/,w2( 182)/.746971277401636d-01/
      data t2( 183)/.299551033683642d-01/,w2( 183)/.707633204723517d-01/
      data t2( 184)/.283509135826502d-01/,w2( 184)/.668978885061445d-01/
      data t2( 185)/.267660398320887d-01/,w2( 185)/.631041839976079d-01/
      data t2( 186)/.252041106803146d-01/,w2( 186)/.593850962738752d-01/
      data t2( 187)/.236682843027462d-01/,w2( 187)/.557428812243984d-01/
      data t2( 188)/.221611028540217d-01/,w2( 188)/.521790240570036d-01/
      data t2( 189)/.206843991279411d-01/,w2( 189)/.486941623313340d-01/
      data t2( 190)/.192392739540838d-01/,w2( 190)/.452880884130621d-01/
      data t2( 191)/.178261494789215d-01/,w2( 191)/.419598351573761d-01/
      data t2( 192)/.164448864292567d-01/,w2( 192)/.387078293819390d-01/
      data t2( 193)/.150949382853649d-01/,w2( 193)/.355300811131281d-01/
      data t2( 194)/.137755082083359d-01/,w2( 194)/.324243696698271d-01/
      data t2( 195)/.124856790921216d-01/,w2( 195)/.293883939915083d-01/
      data t2( 196)/.112245013529962d-01/,w2( 196)/.264198715400544d-01/
      data t2( 197)/.999103987068770d-02/,w2( 197)/.235165891805109d-01/
      data t2( 198)/.878439255558430d-02/,w2( 198)/.206764214186365d-01/
      data t2( 199)/.760369463179172d-02/,w2( 199)/.178973325186612d-01/
      data t2( 200)/.644811794003337d-02/,w2( 200)/.151773731693242d-01/
      data t2( 201)/.531686917862402d-02/,w2( 201)/.125146761220744d-01/
      data t2( 202)/.420918809974401d-02/,w2( 202)/.990745192997554d-02/
      data t2( 203)/.312434580599556d-02/,w2( 203)/.735398493771380d-02/
      data t2( 204)/.206164315089503d-02/,w2( 204)/.485262951672272d-02/
      data t2( 205)/.102040923630158d-02/,w2( 205)/.240180652847893d-02/
      data t2( 206)/.000000000000000d+00/,w2( 206)/.000000000000000d+00/
      data t2( 207)/.743821249110112d+00/,w2( 207)/.129115724292794d+00/
      data t2( 208)/.742702182797244d+00/,w2( 208)/.125027587123386d+00/
      data t2( 209)/.741555747145809d+00/,w2( 209)/.121002993285602d+00/
      data t2( 210)/.740380961339279d+00/,w2( 210)/.117042684599691d+00/
      data t2( 211)/.739176798897849d+00/,w2( 211)/.113147384433447d+00/
      data t2( 212)/.737942185101070d+00/,w2( 212)/.109317796271943d+00/
      data t2( 213)/.736675994242492d+00/,w2( 213)/.105554602242687d+00/
      data t2( 214)/.735377046704250d+00/,w2( 214)/.101858461596855d+00/
      data t2( 215)/.734044105838522d+00/,w2( 215)/.982300091475203d-01/
      data t2( 216)/.732675874641865d+00/,w2( 216)/.946698536659962d-01/
      data t2( 217)/.731270992207324d+00/,w2( 217)/.911785762377648d-01/
      data t2( 218)/.729828029938131d+00/,w2( 218)/.877567285797056d-01/
      data t2( 219)/.728345487505530d+00/,w2( 219)/.844048313207128d-01/
      data t2( 220)/.726821788532036d+00/,w2( 220)/.811233722481295d-01/
      data t2( 221)/.725255275980010d+00/,w2( 221)/.779128045228257d-01/
      data t2( 222)/.723644207224004d+00/,w2( 222)/.747735448661626d-01/
      data t2( 223)/.721986748783755d+00/,w2( 223)/.717059717225348d-01/
      data t2( 224)/.720280970693108d+00/,w2( 224)/.687104234016678d-01/
      data t2( 225)/.718524840478417d+00/,w2( 225)/.657871962053571d-01/
      data t2( 226)/.716716216718200d+00/,w2( 226)/.629365425438849d-01/
      data t2( 227)/.714852842154000d+00/,w2( 227)/.601586690479286d-01/
      data t2( 228)/.712932336320481d+00/,w2( 228)/.574537346823859d-01/
      data t2( 229)/.710952187660924d+00/,w2( 229)/.548218488691862d-01/
      data t2( 230)/.708909745092320d+00/,w2( 230)/.522630696268296d-01/
      data t2( 231)/.706802208982448d+00/,w2( 231)/.497774017350983d-01/
      data t2( 232)/.704626621499504d+00/,w2( 232)/.473647949341140d-01/
      data t2( 233)/.702379856293247d+00/,w2( 233)/.450251421676661d-01/
      data t2( 234)/.700058607465230d+00/,w2( 234)/.427582778815058d-01/
      data t2( 235)/.697659377784662d+00/,w2( 235)/.405639763880880d-01/
      data t2( 236)/.695178466105853d+00/,w2( 236)/.384419503100330d-01/
      data t2( 237)/.692611953943294d+00/,w2( 237)/.363918491153764d-01/
      data t2( 238)/.689955691161341d+00/,w2( 238)/.344132577584576d-01/
      data t2( 239)/.687205280737534d+00/,w2( 239)/.325056954410674d-01/
      data t2( 240)/.684356062562038d+00/,w2( 240)/.306686145092080d-01/
      data t2( 241)/.681403096241056d+00/,w2( 241)/.289013995015168d-01/
      data t2( 242)/.678341142879719d+00/,w2( 242)/.272033663660303d-01/
      data t2( 243)/.675164645830592d+00/,w2( 243)/.255737618625303d-01/
      data t2( 244)/.671867710408262d+00/,w2( 244)/.240117631681637d-01/
      data t2( 245)/.668444082589457d+00/,w2( 245)/.225164777043744d-01/
      data t2( 246)/.664887126742840d+00/,w2( 246)/.210869432033783d-01/
      data t2( 247)/.661189802464470d+00/,w2( 247)/.197221280324400d-01/
      data t2( 248)/.657344640635487d+00/,w2( 248)/.184209317940371d-01/
      data t2( 249)/.653343718869927d+00/,w2( 249)/.171821862195959d-01/
      data t2( 250)/.649178636585003d+00/,w2( 250)/.160046563738157d-01/
      data t2( 251)/.644840490006557d+00/,w2( 251)/.148870421856359d-01/
      data t2( 252)/.640319847522050d+00/,w2( 252)/.138279803206036d-01/
      data t2( 253)/.635606725916211d+00/,w2( 253)/.128260464077295d-01/
      data t2( 254)/.630690568174951d+00/,w2( 254)/.118797576318466d-01/
      data t2( 255)/.625560223726321d+00/,w2( 255)/.109875756999653d-01/
      data t2( 256)/.620203932209052d+00/,w2( 256)/.101479101871227d-01/
      data t2( 257)/.614609312125584d+00/,w2( 257)/.935912226371413d-02/
      data t2( 258)/.608763356054272d+00/,w2( 258)/.861952880225381d-02/
      data t2( 259)/.602652434470820d+00/,w2( 259)/.792740685690347d-02/
      data t2( 260)/.596262310668094d+00/,w2( 260)/.728099850393305d-02/
      data t2( 261)/.589578169770385d+00/,w2( 261)/.667851602551808d-02/
      data t2( 262)/.582584665414345d+00/,w2( 262)/.611814741294694d-02/
      data t2( 263)/.575265988310783d+00/,w2( 263)/.559806215842352d-02/
      data t2( 264)/.567605961597871d+00/,w2( 264)/.511641729723990d-02/
      data t2( 265)/.559588168624695d+00/,w2( 265)/.467136365421335d-02/
      data t2( 266)/.551196119525264d+00/,w2( 266)/.426105224000330d-02/
      data t2( 267)/.542413463595446d+00/,w2( 267)/.388364073434979d-02/
      data t2( 268)/.533224254976592d+00/,w2( 268)/.353729998453955d-02/
      data t2( 269)/.523613279348419d+00/,w2( 269)/.322022043869309d-02/
      data t2( 270)/.513566449059970d+00/,w2( 270)/.293061842503019d-02/
      data t2( 271)/.503071273144584d+00/,w2( 271)/.266674218046381d-02/
      data t2( 272)/.492117406674955d+00/,w2( 272)/.242687752520501d-02/
      data t2( 273)/.480697280562804d+00/,w2( 273)/.220935307526871d-02/
      data t2( 274)/.468806807800716d+00/,w2( 274)/.201254488293265d-02/
      data t2( 275)/.456446154890826d+00/,w2( 275)/.183488039787986d-02/
      data t2( 276)/.443620557493957d+00/,w2( 276)/.167484165117196d-02/
      data t2( 277)/.430341147049482d+00/,w2( 277)/.153096758341090d-02/
      data t2( 278)/.416625740514682d+00/,w2( 278)/.140185547143153d-02/
      data t2( 279)/.402499529292351d+00/,w2( 279)/.128616145939885d-02/
      data t2( 280)/.387995587520975d+00/,w2( 280)/.118260027519855d-02/
      data t2( 281)/.373155106886278d+00/,w2( 281)/.108994431510912d-02/
      data t2( 282)/.358027258767948d+00/,w2( 282)/.100702240838528d-02/
      data t2( 283)/.342668589545370d+00/,w2( 283)/.932718719449840d-03/
      data t2( 284)/.327141876182805d+00/,w2( 284)/.865972385468445d-03/
      data t2( 285)/.311514410770153d+00/,w2( 285)/.805778578103670d-03/
      data t2( 286)/.295855745762938d+00/,w2( 286)/.751191656385356d-03/
      data t2( 287)/.280235012727555d+00/,w2( 287)/.701330867620280d-03/
      data t2( 288)/.264718016434490d+00/,w2( 288)/.655388594676531d-03/
      data t2( 289)/.249364386135794d+00/,w2( 289)/.612640440053535d-03/
      data t2( 290)/.234225114576817d+00/,w2( 290)/.572455590324588d-03/
      data t2( 291)/.219340810013485d+00/,w2( 291)/.534305167868945d-03/
      data t2( 292)/.204740911564238d+00/,w2( 292)/.497765998343563d-03/
      data t2( 293)/.190443973726792d+00/,w2( 293)/.462517715505557d-03/
      data t2( 294)/.176458934589450d+00/,w2( 294)/.428332470353442d-03/
      data t2( 295)/.162787090325211d+00/,w2( 295)/.395058398820027d-03/
      data t2( 296)/.149424365955695d+00/,w2( 296)/.362599751581989d-03/
      data t2( 297)/.136363451364730d+00/,w2( 297)/.330897424376161d-03/
      data t2( 298)/.123595478268870d+00/,w2( 298)/.299913107564455d-03/
      data t2( 299)/.111111108367785d+00/,w2( 299)/.269618632790077d-03/
      data t2( 300)/.989010987059053d-01/,w2( 300)/.239990188657338d-03/
      data t2( 301)/.869565217005612d-01/,w2( 301)/.211005864987450d-03/
      data t2( 302)/.752688171746145d-01/,w2( 302)/.182644861590639d-03/
      data t2( 303)/.638297872089028d-01/,w2( 303)/.154887283840937d-03/
      data t2( 304)/.526315789266392d-01/,w2( 304)/.127714076149543d-03/
      data t2( 305)/.416666666502560d-01/,w2( 305)/.101106976951722d-03/
      data t2( 306)/.309278350393653d-01/,w2( 306)/.750484777373607d-04/
      data t2( 307)/.204081632572683d-01/,w2( 307)/.495217846294149d-04/
      data t2( 308)/.101010100970318d-01/,w2( 308)/.245107822913266d-04/
      data t2( 309)/.000000000000000d+00/,w2( 309)/.000000000000000d+00/
      data t2( 310)/.578441031735049d-01/,w2( 310)/.224793165593118d+00/
      data t2( 311)/.573935835058997d-01/,w2( 311)/.221866341550964d+00/
      data t2( 312)/.569391159670073d-01/,w2( 312)/.218943450167297d+00/
      data t2( 313)/.564806649702140d-01/,w2( 313)/.216024720479163d+00/
      data t2( 314)/.560181950751322d-01/,w2( 314)/.213110384909851d+00/
      data t2( 315)/.555516710233460d-01/,w2( 315)/.210200679262667d+00/
      data t2( 316)/.550810577764692d-01/,w2( 316)/.207295842711514d+00/
      data t2( 317)/.546063205566405d-01/,w2( 317)/.204396117788062d+00/
      data t2( 318)/.541274248895876d-01/,w2( 318)/.201501750365327d+00/
      data t2( 319)/.536443366503950d-01/,w2( 319)/.198612989637424d+00/
      data t2( 320)/.531570221121191d-01/,w2( 320)/.195730088095286d+00/
      data t2( 321)/.526654479973972d-01/,w2( 321)/.192853301498097d+00/
      data t2( 322)/.521695815332033d-01/,w2( 322)/.189982888840183d+00/
      data t2( 323)/.516693905089090d-01/,w2( 323)/.187119112313111d+00/
      data t2( 324)/.511648433378128d-01/,w2( 324)/.184262237262686d+00/
      data t2( 325)/.506559091223064d-01/,w2( 325)/.181412532140559d+00/
      data t2( 326)/.501425577228496d-01/,w2( 326)/.178570268450120d+00/
      data t2( 327)/.496247598309309d-01/,w2( 327)/.175735720686329d+00/
      data t2( 328)/.491024870461927d-01/,w2( 328)/.172909166269125d+00/
      data t2( 329)/.485757119579046d-01/,w2( 329)/.170090885470016d+00/
      data t2( 330)/.480444082309683d-01/,w2( 330)/.167281161331439d+00/
      data t2( 331)/.475085506966399d-01/,w2( 331)/.164480279578452d+00/
      data t2( 332)/.469681154481552d-01/,w2( 332)/.161688528522268d+00/
      data t2( 333)/.464230799414442d-01/,w2( 333)/.158906198955156d+00/
      data t2( 334)/.458734231011173d-01/,w2( 334)/.156133584036147d+00/
      data t2( 335)/.453191254319087d-01/,w2( 335)/.153370979167007d+00/
      data t2( 336)/.447601691357556d-01/,w2( 336)/.150618681857874d+00/
      data t2( 337)/.441965382346953d-01/,w2( 337)/.147876991581937d+00/
      data t2( 338)/.436282186997617d-01/,w2( 338)/.145146209618527d+00/
      data t2( 339)/.430551985860665d-01/,w2( 339)/.142426638883965d+00/
      data t2( 340)/.424774681742614d-01/,w2( 340)/.139718583749522d+00/
      data t2( 341)/.418950201185942d-01/,w2( 341)/.137022349845846d+00/
      data t2( 342)/.413078496018058d-01/,w2( 342)/.134338243853294d+00/
      data t2( 343)/.407159544971605d-01/,w2( 343)/.131666573277647d+00/
      data t2( 344)/.401193355379819d-01/,w2( 344)/.129007646210855d+00/
      data t2( 345)/.395179964951782d-01/,w2( 345)/.126361771076656d+00/
      data t2( 346)/.389119443634050d-01/,w2( 346)/.123729256361190d+00/
      data t2( 347)/.383011895567471d-01/,w2( 347)/.121110410329197d+00/
      data t2( 348)/.376857461151316d-01/,w2( 348)/.118505540726932d+00/
      data t2( 349)/.370656319231355d-01/,w2( 349)/.115914954473795d+00/
      data t2( 350)/.364408689434767d-01/,w2( 350)/.113338957345723d+00/
      data t2( 351)/.358114834683215d-01/,w2( 351)/.110777853654910d+00/
      data t2( 352)/.351775063926734d-01/,w2( 352)/.108231945932375d+00/
      data t2( 353)/.345389735156244d-01/,w2( 353)/.105701534622485d+00/
      data t2( 354)/.338959258772465d-01/,w2( 354)/.103186917801952d+00/
      data t2( 355)/.332484101415218d-01/,w2( 355)/.100688390940252d+00/
      data t2( 356)/.325964790391240d-01/,w2( 356)/.982062467241115d-01/
      data t2( 357)/.319401918882546d-01/,w2( 357)/.957407749760521d-01/
      data t2( 358)/.312796152173625d-01/,w2( 358)/.932922627062955d-01/
      data t2( 359)/.306148235206676d-01/,w2( 359)/.908609943490513d-01/
      data t2( 360)/.299459001862764d-01/,w2( 360)/.884472522488354d-01/
      data t2( 361)/.292729386475705d-01/,w2( 361)/.860513174804123d-01/
      data t2( 362)/.285960438217012d-01/,w2( 362)/.836734711076488d-01/
      data t2( 363)/.279153339145164d-01/,w2( 363)/.813139960122046d-01/
      data t2( 364)/.272309426889130d-01/,w2( 364)/.789731794524058d-01/
      data t2( 365)/.265430223128305d-01/,w2( 365)/.766513165449938d-01/
      data t2( 366)/.258517469225313d-01/,w2( 366)/.743487148957678d-01/
      data t2( 367)/.251573170539818d-01/,w2( 367)/.720657006357008d-01/
      data t2( 368)/.244599651059263d-01/,w2( 368)/.698026261405790d-01/
      data t2( 369)/.237599619962598d-01/,w2( 369)/.675598797145751d-01/
      data t2( 370)/.230576251491878d-01/,w2( 370)/.653378974864938d-01/
      data t2( 371)/.223533278916031d-01/,w2( 371)/.631371776808824d-01/
      data t2( 372)/.216475102267162d-01/,w2( 372)/.609582972575840d-01/
      data t2( 373)/.209406907723940d-01/,w2( 373)/.588019306304199d-01/
      data t2( 374)/.202334793825502d-01/,w2( 374)/.566688697457552d-01/
      data t2( 375)/.195265896006445d-01/,w2( 375)/.545600442011689d-01/
      data t2( 376)/.188208496302377d-01/,w2( 376)/.524765393159129d-01/
      data t2( 377)/.181172099855000d-01/,w2( 377)/.504196091820571d-01/
      data t2( 378)/.174167454896961d-01/,w2( 378)/.483906808630982d-01/
      data t2( 379)/.167206489678996d-01/,w2( 379)/.463913453065046d-01/
      data t2( 380)/.160302140352722d-01/,w2( 380)/.444233305458894d-01/
      data t2( 381)/.153468050419386d-01/,w2( 381)/.424884537892922d-01/
      data t2( 382)/.146718136744092d-01/,w2( 382)/.405885513488891d-01/
      data t2( 383)/.140066039365954d-01/,w2( 383)/.387253891099654d-01/
      data t2( 384)/.133524499556269d-01/,w2( 384)/.369005609059127d-01/
      data t2( 385)/.127104736514180d-01/,w2( 385)/.351153866904714d-01/
      data t2( 386)/.120815909035926d-01/,w2( 386)/.333708252506567d-01/
      data t2( 387)/.114664746185831d-01/,w2( 387)/.316674159008741d-01/
      data t2( 388)/.108655406619518d-01/,w2( 388)/.300052594241135d-01/
      data t2( 389)/.102789583574015d-01/,w2( 389)/.283840411171328d-01/
      data t2( 390)/.970668231903226d-02/,w2( 390)/.268030901819487d-01/
      data t2( 391)/.914849831634354d-02/,w2( 391)/.252614626153611d-01/
      data t2( 392)/.860407395515127d-02/,w2( 392)/.237580314578262d-01/
      data t2( 393)/.807300565421465d-02/,w2( 393)/.222915695801034d-01/
      data t2( 394)/.755485617005735d-02/,w2( 394)/.208608151367448d-01/
      data t2( 395)/.704918053463218d-02/,w2( 395)/.194645161940650d-01/
      data t2( 396)/.655554138813103d-02/,w2( 396)/.181014564923845d-01/
      data t2( 397)/.607351645884719d-02/,w2( 397)/.167704673461895d-01/
      data t2( 398)/.560270125365991d-02/,w2( 398)/.154704311599719d-01/
      data t2( 399)/.514270936336427d-02/,w2( 399)/.142002808226997d-01/
      data t2( 400)/.469317183176880d-02/,w2( 400)/.129589975342928d-01/
      data t2( 401)/.425373626700338d-02/,w2( 401)/.117456082520677d-01/
      data t2( 402)/.382406593700319d-02/,w2( 402)/.105591831761015d-01/
      data t2( 403)/.340383891095889d-02/,w2( 403)/.939883337652991d-02/
      data t2( 404)/.299274725504598d-02/,w2( 404)/.826370857260118d-02/
      data t2( 405)/.259049627990539d-02/,w2( 405)/.715299505477844d-02/
      data t2( 406)/.219680383615077d-02/,w2( 406)/.606591373946257d-02/
      data t2( 407)/.181139965436993d-02/,w2( 407)/.500171834657440d-02/
      data t2( 408)/.143402472637620d-02/,w2( 408)/.395969369103807d-02/
      data t2( 409)/.106443072473285d-02/,w2( 409)/.293915407994578d-02/
      data t2( 410)/.702379457816914d-03/,w2( 410)/.193944180785538d-02/
      data t2( 411)/.347642357909382d-03/,w2( 411)/.959925743281959d-03/
      data t2( 412)/.000000000000000d+00/,w2( 412)/.000000000000000d+00/
      data t2( 413)/.441305197528607d+00/,w2( 413)/.142441884637376d+00/
      data t2( 414)/.439270341637504d+00/,w2( 414)/.136193177705453d+00/
      data t2( 415)/.437197852751094d+00/,w2( 415)/.130148912588167d+00/
      data t2( 416)/.435086825811673d+00/,w2( 416)/.124305593075154d+00/
      data t2( 417)/.432936333077139d+00/,w2( 417)/.118659676130785d+00/
      data t2( 418)/.430745423799364d+00/,w2( 418)/.113207574334119d+00/
      data t2( 419)/.428513123931650d+00/,w2( 419)/.107945658425439d+00/
      data t2( 420)/.426238435869896d+00/,w2( 420)/.102870259957876d+00/
      data t2( 421)/.423920338232595d+00/,w2( 421)/.979776740522593d-01/
      data t2( 422)/.421557785685268d+00/,w2( 422)/.932641622529193d-01/
      data t2( 423)/.419149708815446d+00/,w2( 423)/.887259554817674d-01/
      data t2( 424)/.416695014064906d+00/,w2( 424)/.843592570875320d-01/
      data t2( 425)/.414192583726460d+00/,w2( 425)/.801602459866038d-01/
      data t2( 426)/.411641276013221d+00/,w2( 426)/.761250798914699d-01/
      data t2( 427)/.409039925208975d+00/,w2( 427)/.722498986222578d-01/
      data t2( 428)/.406387341908976d+00/,w2( 428)/.685308274964247d-01/
      data t2( 429)/.403682313361237d+00/,w2( 429)/.649639807911432d-01/
      data t2( 430)/.400923603919194d+00/,w2( 430)/.615454652724402d-01/
      data t2( 431)/.398109955617392d+00/,w2( 431)/.582713837846510d-01/
      data t2( 432)/.395240088882715d+00/,w2( 432)/.551378388932526d-01/
      data t2( 433)/.392312703394524d+00/,w2( 433)/.521409365736468d-01/
      data t2( 434)/.389326479107954d+00/,w2( 434)/.492767899379769d-01/
      data t2( 435)/.386280077455467d+00/,w2( 435)/.465415229915811d-01/
      data t2( 436)/.383172142742696d+00/,w2( 436)/.439312744102235d-01/
      data t2( 437)/.380001303755411d+00/,w2( 437)/.414422013287932d-01/
      data t2( 438)/.376766175595330d+00/,w2( 438)/.390704831317385d-01/
      data t2( 439)/.373465361763273d+00/,w2( 439)/.368123252351006d-01/
      data t2( 440)/.370097456508917d+00/,w2( 440)/.346639628496447d-01/
      data t2( 441)/.366661047467104d+00/,w2( 441)/.326216647142493d-01/
      data t2( 442)/.363154718601263d+00/,w2( 442)/.306817367884216d-01/
      data t2( 443)/.359577053475039d+00/,w2( 443)/.288405258925550d-01/
      data t2( 444)/.355926638873685d+00/,w2( 444)/.270944232843441d-01/
      data t2( 445)/.352202068797144d+00/,w2( 445)/.254398681596210d-01/
      data t2( 446)/.348401948847056d+00/,w2( 446)/.238733510657827d-01/
      data t2( 447)/.344524901030242d+00/,w2( 447)/.223914172159456d-01/
      data t2( 448)/.340569569001577d+00/,w2( 448)/.209906696919834d-01/
      data t2( 449)/.336534623769654d+00/,w2( 449)/.196677725246936d-01/
      data t2( 450)/.332418769889495d+00/,w2( 450)/.184194536394812d-01/
      data t2( 451)/.328220752167903d+00/,w2( 451)/.172425076561480d-01/
      data t2( 452)/.323939362909278d+00/,w2( 452)/.161337985316319d-01/
      data t2( 453)/.319573449733201d+00/,w2( 453)/.150902620348357d-01/
      data t2( 454)/.315121924000433d+00/,w2( 454)/.141089080430101d-01/
      data t2( 455)/.310583769891958d+00/,w2( 455)/.131868226494999d-01/
      data t2( 456)/.305958054197239d+00/,w2( 456)/.123211700729948d-01/
      data t2( 457)/.301243936884361d+00/,w2( 457)/.115091943587201d-01/
      data t2( 458)/.296440682547632d+00/,w2( 458)/.107482208622323d-01/
      data t2( 459)/.291547672859699d+00/,w2( 459)/.100356575065833d-01/
      data t2( 460)/.286564420197529d+00/,w2( 460)/.936899580355450d-02/
      data t2( 461)/.281490582667615d+00/,w2( 461)/.874581162935000d-02/
      data t2( 462)/.276325980828770d+00/,w2( 462)/.816376574451701d-02/
      data t2( 463)/.271070616504055d+00/,w2( 463)/.762060404683649d-02/
      data t2( 464)/.265724694190321d+00/,w2( 464)/.711415754441212d-02/
      data t2( 465)/.260288645716860d+00/,w2( 465)/.664234203409693d-02/
      data t2( 466)/.254763158974804d+00/,w2( 466)/.620315746766952d-02/
      data t2( 467)/.249149211733735d+00/,w2( 467)/.579468698479123d-02/
      data t2( 468)/.243448111773232d+00/,w2( 468)/.541509558781843d-02/
      data t2( 469)/.237661544767625d+00/,w2( 469)/.506262842924520d-02/
      data t2( 470)/.231791631540421d+00/,w2( 470)/.473560867840203d-02/
      data t2( 471)/.225840996399113d+00/,w2( 471)/.443243493091855d-02/
      data t2( 472)/.219812848191637d+00/,w2( 472)/.415157812382387d-02/
      data t2( 473)/.213711075377845d+00/,w2( 473)/.389157792323901d-02/
      data t2( 474)/.207540355627624d+00/,w2( 474)/.365103856363901d-02/
      data t2( 475)/.201306279048013d+00/,w2( 475)/.342862414198664d-02/
      data t2( 476)/.195015481889853d+00/,w2( 476)/.322305341208680d-02/
      data t2( 477)/.188675784296612d+00/,w2( 477)/.303309419021515d-02/
      data t2( 478)/.182296321244414d+00/,w2( 478)/.285755757754377d-02/
      data t2( 479)/.175887650427124d+00/,w2( 479)/.269529232982253d-02/
      data t2( 480)/.169461815015500d+00/,w2( 480)/.254517985440486d-02/
      data t2( 481)/.163032334104737d+00/,w2( 481)/.240613047040346d-02/
      data t2( 482)/.156614091086843d+00/,w2( 482)/.227708169268877d-02/
      data t2( 483)/.150223092530310d+00/,w2( 483)/.215699933726149d-02/
      data t2( 484)/.143876079848009d+00/,w2( 484)/.204488212215738d-02/
      data t2( 485)/.137589994554893d+00/,w2( 485)/.193977008692404d-02/
      data t2( 486)/.131381324438339d+00/,w2( 486)/.184075654676307d-02/
      data t2( 487)/.125265388235658d+00/,w2( 487)/.174700248942372d-02/
      data t2( 488)/.119255642661966d+00/,w2( 488)/.165775148222537d-02/
      data t2( 489)/.113363108281032d+00/,w2( 489)/.157234255222966d-02/
      data t2( 490)/.107596001932283d+00/,w2( 490)/.149021842490137d-02/
      data t2( 491)/.101959631270663d+00/,w2( 491)/.141092713311080d-02/
      data t2( 492)/.964565578668365d-01/,w2( 492)/.133411627579428d-02/
      data t2( 493)/.910869829362476d-01/,w2( 493)/.125952077424719d-02/
      data t2( 494)/.858492701484871d-01/,w2( 494)/.118694633619603d-02/
      data t2( 495)/.807405049057775d-01/,w2( 495)/.111625153580007d-02/
      data t2( 496)/.757570015942016d-01/,w2( 496)/.104733125586855d-02/
      data t2( 497)/.708947023366782d-01/,w2( 497)/.980103366665122d-03/
      data t2( 498)/.661494493097791d-01/,w2( 498)/.914499338143330d-03/
      data t2( 499)/.615171443650341d-01/,w2( 499)/.850458451188665d-03/
      data t2( 500)/.569938266401111d-01/,w2( 500)/.787924683698256d-03/
      data t2( 501)/.525757007828002d-01/,w2( 501)/.726845242759486d-03/
      data t2( 502)/.482591408083263d-01/,w2( 502)/.667169934651737d-03/
      data t2( 503)/.440406844455997d-01/,w2( 503)/.608850884364018d-03/
      data t2( 504)/.399170248533828d-01/,w2( 504)/.551842374589784d-03/
      data t2( 505)/.358850021409214d-01/,w2( 505)/.496100720590764d-03/
      data t2( 506)/.319415953122487d-01/,w2( 506)/.441584157888482d-03/
      data t2( 507)/.280839147189820d-01/,w2( 507)/.388252737853641d-03/
      data t2( 508)/.243091949986887d-01/,w2( 508)/.336068230077614d-03/
      data t2( 509)/.206147884639336d-01/,w2( 509)/.284994030977673d-03/
      data t2( 510)/.169981589088575d-01/,w2( 510)/.234995078174572d-03/
      data t2( 511)/.134568758028455d-01/,w2( 511)/.186037770221536d-03/
      data t2( 512)/.998860884334927d-02/,w2( 512)/.138089891298460d-03/
      data t2( 513)/.659112284221007d-02/,w2( 513)/.911205405166710d-04/
      data t2( 514)/.326227292190196d-02/,w2( 514)/.451000655082514d-04/
      data t2( 515)/.000000000000000d+00/,w2( 515)/.000000000000000d+00/
      data t2( 516)/.871373268080422d+00/,w2( 516)/.345141070016873d-01/
      data t2( 517)/.870449948023419d+00/,w2( 517)/.318508901779573d-01/
      data t2( 518)/.869499394918262d+00/,w2( 518)/.293520816889804d-01/
      data t2( 519)/.868520431467643d+00/,w2( 519)/.270105833454958d-01/
      data t2( 520)/.867511814079600d+00/,w2( 520)/.248194225593783d-01/
      data t2( 521)/.866472228320128d+00/,w2( 521)/.227717582282933d-01/
      data t2( 522)/.865400284002960d+00/,w2( 522)/.208608864155481d-01/
      data t2( 523)/.864294509884065d+00/,w2( 523)/.190802458044667d-01/
      data t2( 524)/.863153347925319d+00/,w2( 524)/.174234229066208d-01/
      data t2( 525)/.861975147088345d+00/,w2( 525)/.158841570033785d-01/
      data t2( 526)/.860758156615752d+00/,w2( 526)/.144563448004743d-01/
      data t2( 527)/.859500518752876d+00/,w2( 527)/.131340447756810d-01/
      data t2( 528)/.858200260858551d+00/,w2( 528)/.119114812001739d-01/
      data t2( 529)/.856855286848516d+00/,w2( 529)/.107830478148374d-01/
      data t2( 530)/.855463367909598d+00/,w2( 530)/.974331114356927d-02/
      data t2( 531)/.854022132416899d+00/,w2( 531)/.878701342660467d-02/
      data t2( 532)/.852529054979774d+00/,w2( 532)/.790907515801008d-02/
      data t2( 533)/.850981444535380d+00/,w2( 533)/.710459721278896d-02/
      data t2( 534)/.849376431401021d+00/,w2( 534)/.636886255050418d-02/
      data t2( 535)/.847710953188387d+00/,w2( 535)/.569733748395229d-02/
      data t2( 536)/.845981739474038d+00/,w2( 536)/.508567250322416d-02/
      data t2( 537)/.844185295111296d+00/,w2( 537)/.452970264745040d-02/
      data t2( 538)/.842317882058869d+00/,w2( 538)/.402544741865516d-02/
      data t2( 539)/.840375499591469d+00/,w2( 539)/.356911023441850d-02/
      data t2( 540)/.838353862747195d+00/,w2( 540)/.315707741846825d-02/
      data t2( 541)/.836248378856003d+00/,w2( 541)/.278591673087192d-02/
      data t2( 542)/.834054121983348d+00/,w2( 542)/.245237544216372d-02/
      data t2( 543)/.831765805113474d+00/,w2( 543)/.215337795850223d-02/
      data t2( 544)/.829377749888438d+00/,w2( 544)/.188602300778817d-02/
      data t2( 545)/.826883853712549d+00/,w2( 545)/.164758039955597d-02/
      data t2( 546)/.824277554028450d+00/,w2( 546)/.143548737435796d-02/
      data t2( 547)/.821551789571935d+00/,w2( 547)/.124734456125681d-02/
      data t2( 548)/.818698958419523d+00/,w2( 548)/.108091156489585d-02/
      data t2( 549)/.815710872658108d+00/,w2( 549)/.934102206393362d-03/
      data t2( 550)/.812578709532512d+00/,w2( 550)/.804979444966599d-03/
      data t2( 551)/.809292958968441d+00/,w2( 551)/.691750009696485d-03/
      data t2( 552)/.805843367429860d+00/,w2( 552)/.592758773152067d-03/
      data t2( 553)/.802218878157330d+00/,w2( 553)/.506482900665825d-03/
      data t2( 554)/.798407567955233d+00/,w2( 554)/.431525810845174d-03/
      data t2( 555)/.794396580860448d+00/,w2( 555)/.366610984383486d-03/
      data t2( 556)/.790172059245202d+00/,w2( 556)/.310575659358593d-03/
      data t2( 557)/.785719073196870d+00/,w2( 557)/.262364451944702d-03/
      data t2( 558)/.781021549395421d+00/,w2( 558)/.221022941785891d-03/
      data t2( 559)/.776062201196021d+00/,w2( 559)/.185691261162477d-03/
      data t2( 560)/.770822462244726d+00/,w2( 560)/.155597726508835d-03/
      data t2( 561)/.765282426737349d+00/,w2( 561)/.130052549803813d-03/
      data t2( 562)/.759420800406033d+00/,w2( 562)/.108441665852424d-03/
      data t2( 563)/.753214867516507d+00/,w2( 563)/.902207095195527d-04/
      data t2( 564)/.746640480610898d+00/,w2( 564)/.749091745822994d-04/
      data t2( 565)/.739672081458565d+00/,w2( 565)/.620847830675808d-04/
      data t2( 566)/.732282763687420d+00/,w2( 566)/.513780907761533d-04/
      data t2( 567)/.724444389839781d+00/,w2( 567)/.424673512143106d-04/
      data t2( 568)/.716127778063678d+00/,w2( 568)/.350736564204241d-04/
      data t2( 569)/.707302976177301d+00/,w2( 569)/.289563692540064d-04/
      data t2( 570)/.697939643194614d+00/,w2( 570)/.239088576855955d-04/
      data t2( 571)/.688007560199435d+00/,w2( 571)/.197545375668163d-04/
      data t2( 572)/.677477293148180d+00/,w2( 572)/.163432263543363d-04/
      data t2( 573)/.666321028994727d+00/,w2( 573)/.135478063919542d-04/
      data t2( 574)/.654513602452189d+00/,w2( 574)/.112611927020067d-04/
      data t2( 575)/.642033722505887d+00/,w2( 575)/.939359687589539d-05/
      data t2( 576)/.628865394117350d+00/,w2( 576)/.787007565198979d-05/
      data t2( 577)/.614999510152399d+00/,w2( 577)/.662835018722047d-05/
      data t2( 578)/.600435560642138d+00/,w2( 578)/.561687991722245d-05/
      data t2( 579)/.585183371305327d+00/,w2( 579)/.479317330147000d-05/
      data t2( 580)/.569264742871922d+00/,w2( 580)/.412231669960068d-05/
      data t2( 581)/.552714821769634d+00/,w2( 581)/.357570215102480d-05/
      data t2( 582)/.535582998912058d+00/,w2( 582)/.312993494953139d-05/
      data t2( 583)/.517933117413621d+00/,w2( 583)/.276590261461323d-05/
      data t2( 584)/.499842784506908d+00/,w2( 584)/.246798811524708d-05/
      data t2( 585)/.481401638982840d+00/,w2( 585)/.222341187510141d-05/
      data t2( 586)/.462708528665412d+00/,w2( 586)/.202168893656915d-05/
      data t2( 587)/.443867697609443d+00/,w2( 587)/.185418929919202d-05/
      data t2( 588)/.424984250376195d+00/,w2( 588)/.171379038852617d-05/
      data t2( 589)/.406159317435499d+00/,w2( 589)/.159461041139817d-05/
      data t2( 590)/.387485450332655d+00/,w2( 590)/.149180987279953d-05/
      data t2( 591)/.369042790874337d+00/,w2( 591)/.140144620952971d-05/
      data t2( 592)/.350896466685651d+00/,w2( 592)/.132036445511396d-05/
      data t2( 593)/.333095476148690d+00/,w2( 593)/.124610658877026d-05/
      data t2( 594)/.315673078631302d+00/,w2( 594)/.117682490723009d-05/
      data t2( 595)/.298648460073701d+00/,w2( 595)/.111119043458822d-05/
      data t2( 596)/.282029259532528d+00/,w2( 596)/.104829464104327d-05/
      data t2( 597)/.265814461152544d+00/,w2( 597)/.987549221170703d-06/
      data t2( 598)/.249997189134805d+00/,w2( 598)/.928592235105119d-06/
      data t2( 599)/.234567068284074d+00/,w2( 599)/.871208682916664d-06/
      data t2( 600)/.219511983241848d+00/,w2( 600)/.815270342591456d-06/
      data t2( 601)/.204819232072614d+00/,w2( 601)/.760695317554426d-06/
      data t2( 602)/.190476182725590d+00/,w2( 602)/.707424126422377d-06/
      data t2( 603)/.176470587178474d+00/,w2( 603)/.655407428301861d-06/
      data t2( 604)/.162790697542860d+00/,w2( 604)/.604600620733801d-06/
      data t2( 605)/.149425287319755d+00/,w2( 605)/.554961814693078d-06/
      data t2( 606)/.136363636335922d+00/,w2( 606)/.506451166351618d-06/
      data t2( 607)/.123595505593089d+00/,w2( 607)/.459030645149265d-06/
      data t2( 608)/.111111111088742d+00/,w2( 608)/.412663913315823d-06/
      data t2( 609)/.989010988811880d-01/,w2( 609)/.367316230533862d-06/
      data t2( 610)/.869565217216243d-01/,w2( 610)/.322954366942816d-06/
      data t2( 611)/.752688171891479d-01/,w2( 611)/.279546521923621d-06/
      data t2( 612)/.638297872211923d-01/,w2( 612)/.237062248075046d-06/
      data t2( 613)/.526315789367726d-01/,w2( 613)/.195472379991705d-06/
      data t2( 614)/.416666666582783d-01/,w2( 614)/.154748967493433d-06/
      data t2( 615)/.309278350453200d-01/,w2( 615)/.114865212984816d-06/
      data t2( 616)/.204081632611976d-01/,w2( 616)/.757954126498448d-07/
      data t2( 617)/.101010100989766d-01/,w2( 617)/.375149012105293d-07/
      data t2( 618)/.000000000000000d+00/,w2( 618)/.000000000000000d+00/
      data t2( 619)/.343015088985127d-01/,w2( 619)/.135466272897877d+00/
      data t2( 620)/.339758535528594d-01/,w2( 620)/.133498846052356d+00/
      data t2( 621)/.336482680675069d-01/,w2( 621)/.131539526725643d+00/
      data t2( 622)/.333187503260208d-01/,w2( 622)/.129588439028071d+00/
      data t2( 623)/.329872987857706d-01/,w2( 623)/.127645707282457d+00/
      data t2( 624)/.326539125076569d-01/,w2( 624)/.125711455987788d+00/
      data t2( 625)/.323185911871152d-01/,w2( 625)/.123785809781709d+00/
      data t2( 626)/.319813351864495d-01/,w2( 626)/.121868893401776d+00/
      data t2( 627)/.316421455685458d-01/,w2( 627)/.119960831645484d+00/
      data t2( 628)/.313010241320231d-01/,w2( 628)/.118061749329031d+00/
      data t2( 629)/.309579734478731d-01/,w2( 629)/.116171771244824d+00/
      data t2( 630)/.306129968976507d-01/,w2( 630)/.114291022117690d+00/
      data t2( 631)/.302660987132660d-01/,w2( 631)/.112419626559796d+00/
      data t2( 632)/.299172840184441d-01/,w2( 632)/.110557709024245d+00/
      data t2( 633)/.295665588719027d-01/,w2( 633)/.108705393757329d+00/
      data t2( 634)/.292139303123109d-01/,w2( 634)/.106862804749420d+00/
      data t2( 635)/.288594064050836d-01/,w2( 635)/.105030065684461d+00/
      data t2( 636)/.285029962910663d-01/,w2( 636)/.103207299888025d+00/
      data t2( 637)/.281447102371632d-01/,w2( 637)/.101394630273896d+00/
      data t2( 638)/.277845596889528d-01/,w2( 638)/.995921792891176d-01/
      data t2( 639)/.274225573253360d-01/,w2( 639)/.978000688574237d-01/
      data t2( 640)/.270587171152462d-01/,w2( 640)/.960184203209829d-01/
      data t2( 641)/.266930543764473d-01/,w2( 641)/.942473543803276d-01/
      data t2( 642)/.263255858364249d-01/,w2( 642)/.924869910323297d-01/
      data t2( 643)/.259563296953676d-01/,w2( 643)/.907374495060543d-01/
      data t2( 644)/.255853056912068d-01/,w2( 644)/.889988481962662d-01/
      data t2( 645)/.252125351666631d-01/,w2( 645)/.872713045943285d-01/
      data t2( 646)/.248380411382169d-01/,w2( 646)/.855549352161691d-01/
      data t2( 647)/.244618483668823d-01/,w2( 647)/.838498555269245d-01/
      data t2( 648)/.240839834306264d-01/,w2( 648)/.821561798617973d-01/
      data t2( 649)/.237044747982263d-01/,w2( 649)/.804740213425823d-01/
      data t2( 650)/.233233529043077d-01/,w2( 650)/.788034917892284d-01/
      data t2( 651)/.229406502252523d-01/,w2( 651)/.771447016257191d-01/
      data t2( 652)/.225564013556123d-01/,w2( 652)/.754977597794795d-01/
      data t2( 653)/.221706430846190d-01/,w2( 653)/.738627735734621d-01/
      data t2( 654)/.217834144723432d-01/,w2( 654)/.722398486100552d-01/
      data t2( 655)/.213947569250610d-01/,w2( 655)/.706290886460175d-01/
      data t2( 656)/.210047142694228d-01/,w2( 656)/.690305954578248d-01/
      data t2( 657)/.206133328251445d-01/,w2( 657)/.674444686971683d-01/
      data t2( 658)/.202206614761805d-01/,w2( 658)/.658708057369724d-01/
      data t2( 659)/.198267517407524d-01/,w2( 659)/.643097015093123d-01/
      data t2( 660)/.194316578412805d-01/,w2( 660)/.627612483381839d-01/
      data t2( 661)/.190354367763007d-01/,w2( 661)/.612255357724340d-01/
      data t2( 662)/.186381483979999d-01/,w2( 662)/.597026504276060d-01/
      data t2( 663)/.182398555012605d-01/,w2( 663)/.581926758503924d-01/
      data t2( 664)/.178406239333185d-01/,w2( 664)/.566956924263277d-01/
      data t2( 665)/.174405227376386d-01/,w2( 665)/.552117773609702d-01/
      data t2( 666)/.170396243517787d-01/,w2( 666)/.537410047778994d-01/
      data t2( 667)/.166380048873279d-01/,w2( 667)/.522834459943636d-01/
      data t2( 668)/.162357445309660d-01/,w2( 668)/.508391700584072d-01/
      data t2( 669)/.158329281198320d-01/,w2( 669)/.494082446608461d-01/
      data t2( 670)/.154296459621030d-01/,w2( 670)/.479907375724093d-01/
      data t2( 671)/.150259949950841d-01/,w2( 671)/.465867188009796d-01/
      data t2( 672)/.146220803976720d-01/,w2( 672)/.451962637151672d-01/
      data t2( 673)/.142180178001285d-01/,w2( 673)/.438194574351625d-01/
      data t2( 674)/.138139362581508d-01/,w2( 674)/.424564008428698d-01/
      data t2( 675)/.134099821738304d-01/,w2( 675)/.411072185977365d-01/
      data t2( 676)/.130063243427447d-01/,w2( 676)/.397720695410428d-01/
      data t2( 677)/.126031602683659d-01/,w2( 677)/.384511597973029d-01/
      data t2( 678)/.122007237907211d-01/,w2( 678)/.371447586922339d-01/
      data t2( 679)/.117992938999126d-01/,w2( 679)/.358532172478874d-01/
      data t2( 680)/.113992043213423d-01/,w2( 680)/.345769884322226d-01/
      data t2( 681)/.110008530542059d-01/,w2( 681)/.333166474994561d-01/
      data t2( 682)/.106047105335374d-01/,w2( 682)/.320729096855655d-01/
      data t2( 683)/.102113245384124d-01/,w2( 683)/.308466413592317d-01/
      data t2( 684)/.982131953185748d-02/,w2( 684)/.296388597752204d-01/
      data t2( 685)/.943538802028932d-02/,w2( 685)/.284507163162682d-01/
      data t2( 686)/.905427203234931d-02/,w2( 686)/.272834591225182d-01/
      data t2( 687)/.867873414500725d-02/,w2( 687)/.261383737550823d-01/
      data t2( 688)/.830951960891627d-02/,w2( 688)/.250167050133626d-01/
      data t2( 689)/.794731365011984d-02/,w2( 689)/.239195684122865d-01/
      data t2( 690)/.759270016830228d-02/,w2( 690)/.228478644614011d-01/
      data t2( 691)/.724612887349269d-02/,w2( 691)/.218022107380142d-01/
      data t2( 692)/.690789675755047d-02/,w2( 692)/.207829043777246d-01/
      data t2( 693)/.657814677302148d-02/,w2( 693)/.197899211634528d-01/
      data t2( 694)/.625688262756256d-02/,w2( 694)/.188229488783540d-01/
      data t2( 695)/.594399510666413d-02/,w2( 695)/.178814450515345d-01/
      data t2( 696)/.563929350817010d-02/,w2( 696)/.169647052801804d-01/
      data t2( 697)/.534253602666004d-02/,w2( 697)/.160719288772631d-01/
      data t2( 698)/.505345479432420d-02/,w2( 698)/.152022726534031d-01/
      data t2( 699)/.477177377262307d-02/,w2( 699)/.143548890313623d-01/
      data t2( 700)/.449721982365481d-02/,w2( 700)/.135289493011457d-01/
      data t2( 701)/.422952852417243d-02/,w2( 701)/.127236554705526d-01/
      data t2( 702)/.396844658715071d-02/,w2( 702)/.119382447915580d-01/
      data t2( 703)/.371373244015362d-02/,w2( 703)/.111719903364989d-01/
      data t2( 704)/.346515597303377d-02/,w2( 704)/.104241998217468d-01/
      data t2( 705)/.322249799186436d-02/,w2( 705)/.969421384012361d-02/
      data t2( 706)/.298554961011875d-02/,w2( 706)/.898140399895770d-02/
      data t2( 707)/.275411165584639d-02/,w2( 707)/.828517113082233d-02/
      data t2( 708)/.252799411431550d-02/,w2( 708)/.760494361597651d-02/
      data t2( 709)/.230701560781939d-02/,w2( 709)/.694017581737717d-02/
      data t2( 710)/.209100291045802d-02/,w2( 710)/.629034662099354d-02/
      data t2( 711)/.187979049526024d-02/,w2( 711)/.565495807341843d-02/
      data t2( 712)/.167322011116571d-02/,w2( 712)/.503353410930652d-02/
      data t2( 713)/.147114038759497d-02/,w2( 713)/.442561936180573d-02/
      data t2( 714)/.127340646453113d-02/,w2( 714)/.383077804973507d-02/
      data t2( 715)/.107987964621333d-02/,w2( 715)/.324859293579357d-02/
      data t2( 716)/.890427076702220d-03/,w2( 716)/.267866435056663d-02/
      data t2( 717)/.704921435722591d-03/,w2( 717)/.212060927753191d-02/
      data t2( 718)/.523240653319862d-03/,w2( 718)/.157406049466286d-02/
      data t2( 719)/.345267641986576d-03/,w2( 719)/.103866576858706d-02/
      data t2( 720)/.207576459290453d-03/,w2( 720)/.624450531735268d-03/
      data t2( 721)/.000000000000000d+00/,w2( 721)/.000000000000000d+00/
      data t2( 722)/.280171144482725d+00/,w2( 722)/.108498002427218d+00/
      data t2( 723)/.278190918498770d+00/,w2( 723)/.103352001288090d+00/
      data t2( 724)/.276184313872465d+00/,w2( 724)/.984118596679542d-01/
      data t2( 725)/.274150979361942d+00/,w2( 725)/.936715318120313d-01/
      data t2( 726)/.272090564728210d+00/,w2( 726)/.891250520082803d-01/
      data t2( 727)/.270002721248762d+00/,w2( 727)/.847665369607428d-01/
      data t2( 728)/.267887102268802d+00/,w2( 728)/.805901880783520d-01/
      data t2( 729)/.265743363791970d+00/,w2( 729)/.765902936750071d-01/
      data t2( 730)/.263571165112432d+00/,w2( 730)/.727612310768208d-01/
      data t2( 731)/.261370169490306d+00/,w2( 731)/.690974686325721d-01/
      data t2( 732)/.259140044872323d+00/,w2( 732)/.655935676235356d-01/
      data t2( 733)/.256880464659726d+00/,w2( 733)/.622441840690180d-01/
      data t2( 734)/.254591108525320d+00/,w2( 734)/.590440704241022d-01/
      data t2( 735)/.252271663281648d+00/,w2( 735)/.559880771662895d-01/
      data t2( 736)/.249921823802179d+00/,w2( 736)/.530711542679370d-01/
      data t2( 737)/.247541293997370d+00/,w2( 737)/.502883525516078d-01/
      data t2( 738)/.245129787847399d+00/,w2( 738)/.476348249256891d-01/
      data t2( 739)/.242687030493245d+00/,w2( 739)/.451058274978868d-01/
      data t2( 740)/.240212759387707d+00/,w2( 740)/.426967205644738d-01/
      data t2( 741)/.237706725507734d+00/,w2( 741)/.404029694734518d-01/
      data t2( 742)/.235168694629316d+00/,w2( 742)/.382201453600849d-01/
      data t2( 743)/.232598448665894d+00/,w2( 743)/.361439257535715d-01/
      data t2( 744)/.229995787070983d+00/,w2( 744)/.341700950539475d-01/
      data t2( 745)/.227360528305348d+00/,w2( 745)/.322945448786473d-01/
      data t2( 746)/.224692511368680d+00/,w2( 746)/.305132742784948d-01/
      data t2( 747)/.221991597395221d+00/,w2( 747)/.288223898232529d-01/
      data t2( 748)/.219257671312247d+00/,w2( 748)/.272181055572248d-01/
      data t2( 749)/.216490643559663d+00/,w2( 749)/.256967428257683d-01/
      data t2( 750)/.213690451868225d+00/,w2( 750)/.242547299739647d-01/
      data t2( 751)/.210857063093073d+00/,w2( 751)/.228886019190596d-01/
      data t2( 752)/.207990475098312d+00/,w2( 752)/.215949995986777d-01/
      data t2( 753)/.205090718687353d+00/,w2( 753)/.203706692971884d-01/
      data t2( 754)/.202157859572601d+00/,w2( 754)/.192124618529798d-01/
      data t2( 755)/.199192000376931d+00/,w2( 755)/.181173317497594d-01/
      data t2( 756)/.196193282658221d+00/,w2( 756)/.170823360953554d-01/
      data t2( 757)/.193161888947142d+00/,w2( 757)/.161046334918229d-01/
      data t2( 758)/.190098044787548d+00/,w2( 758)/.151814828009607d-01/
      data t2( 759)/.187002020768405d+00/,w2( 759)/.143102418096063d-01/
      data t2( 760)/.183874134536439d+00/,w2( 760)/.134883657992774d-01/
      data t2( 761)/.180714752780138d+00/,w2( 761)/.127134060248530d-01/
      data t2( 762)/.177524293178860d+00/,w2( 762)/.119830081070048d-01/
      data t2( 763)/.174303226316504d+00/,w2( 763)/.112949103429591d-01/
      data t2( 764)/.171052077568552d+00/,w2( 764)/.106469419398447d-01/
      data t2( 765)/.167771428985899d+00/,w2( 765)/.100370211742964d-01/
      data t2( 766)/.164461921220650d+00/,w2( 766)/.946315348104455d-02/
      data t2( 767)/.161124255570741d+00/,w2( 767)/.892342947182981d-02/
      data t2( 768)/.157759196265048d+00/,w2( 768)/.841602288398432d-02/
      data t2( 769)/.154367573172791d+00/,w2( 769)/.793918845526245d-02/
      data t2( 770)/.150950285205289d+00/,w2( 770)/.749125971777475d-02/
      data t2( 771)/.147508304789920d+00/,w2( 771)/.707064669896320d-02/
      data t2( 772)/.144042683940805d+00/,w2( 772)/.667583351123196d-02/
      data t2( 773)/.140554562632566d+00/,w2( 773)/.630537580393830d-02/
      data t2( 774)/.137045180403435d+00/,w2( 774)/.595789804190085d-02/
      data t2( 775)/.133515892366702d+00/,w2( 775)/.563209056360232d-02/
      data t2( 776)/.129968191077384d+00/,w2( 776)/.532670636052928d-02/
      data t2( 777)/.126403735947084d+00/,w2( 777)/.504055750807097d-02/
      data t2( 778)/.122824392056892d+00/,w2( 778)/.477251117078232d-02/
      data t2( 779)/.119232280175660d+00/,w2( 779)/.452148510505122d-02/
      data t2( 780)/.115629839384467d+00/,w2( 780)/.428644259703359d-02/
      data t2( 781)/.112019902713784d+00/,w2( 781)/.406638681245173d-02/
      data t2( 782)/.108405784350205d+00/,w2( 782)/.386035460896854d-02/
      data t2( 783)/.104791374007069d+00/,w2( 783)/.366740998306470d-02/
      data t2( 784)/.101181229846005d+00/,w2( 784)/.348663749917212d-02/
      data t2( 785)/.975806560730420d-01/,w2( 785)/.331713627475997d-02/
      data t2( 786)/.939957457786146d-01/,w2( 786)/.315801534364515d-02/
      data t2( 787)/.904333653197525d-01/,w2( 787)/.300839142932946d-02/
      data t2( 788)/.869010559556797d-01/,w2( 788)/.286739023062547d-02/
      data t2( 789)/.834068343052459d-01/,w2( 789)/.273415212937658d-02/
      data t2( 790)/.799588874625067d-01/,w2( 790)/.260784267128279d-02/
      data t2( 791)/.765651807702038d-01/,w2( 791)/.248766723555613d-02/
      data t2( 792)/.732330218717966d-01/,w2( 792)/.237288815453722d-02/
      data t2( 793)/.699686454815035d-01/,w2( 793)/.226284151463466d-02/
      data t2( 794)/.667768898951834d-01/,w2( 794)/.215695040497540d-02/
      data t2( 795)/.636610226940103d-01/,w2( 795)/.205473181300456d-02/
      data t2( 796)/.606227411910656d-01/,w2( 796)/.195579570327587d-02/
      data t2( 797)/.576623331000426d-01/,w2( 797)/.185983665433906d-02/
      data t2( 798)/.547789488942286d-01/,w2( 798)/.176662010994563d-02/
      data t2( 799)/.519709207577491d-01/,w2( 799)/.167596623085083d-02/
      data t2( 800)/.492360671965747d-01/,w2( 800)/.158773427403088d-02/
      data t2( 801)/.465719419377451d-01/,w2( 801)/.150180957210276d-02/
      data t2( 802)/.439760106416460d-01/,w2( 802)/.141809400523943d-02/
      data t2( 803)/.414457597728494d-01/,w2( 803)/.133649982582863d-02/
      data t2( 804)/.389787536734400d-01/,w2( 804)/.125694608946746d-02/
      data t2( 805)/.365726584416941d-01/,w2( 805)/.117935678993113d-02/
      data t2( 806)/.342252478667783d-01/,w2( 806)/.110365994287955d-02/
      data t2( 807)/.319344013029475d-01/,w2( 807)/.102978712136552d-02/
      data t2( 808)/.296980986919806d-01/,w2( 808)/.957673177225474d-03/
      data t2( 809)/.275144149647154d-01/,w2( 809)/.887256031836742d-03/
      data t2( 810)/.253815145798576d-01/,w2( 810)/.818476494484854d-03/
      data t2( 811)/.232976463877512d-01/,w2( 811)/.751278095922874d-03/
      data t2( 812)/.212611388363744d-01/,w2( 812)/.685606933691853d-03/
      data t2( 813)/.192703954996352d-01/,w2( 813)/.621411527915463d-03/
      data t2( 814)/.173238909037124d-01/,w2( 814)/.558642686711881d-03/
      data t2( 815)/.154201666285792d-01/,w2( 815)/.497253380479806d-03/
      data t2( 816)/.135578276637750d-01/,w2( 816)/.437198624383211d-03/
      data t2( 817)/.117355389992891d-01/,w2( 817)/.378435368417726d-03/
      data t2( 818)/.995202243404757d-02/,w2( 818)/.320922394494059d-03/
      data t2( 819)/.820605358596905d-02/,w2( 819)/.264620220021417d-03/
      data t2( 820)/.649645908889217d-02/,w2( 820)/.209491007516955d-03/
      data t2( 821)/.482211396288903d-02/,w2( 821)/.155498479806400d-03/
      data t2( 822)/.318193914557984d-02/,w2( 822)/.102607840416468d-03/
      data t2( 823)/.191299612589480d-02/,w2( 823)/.616882951629693d-04/
      data t2( 824)/.000000000000000d+00/,w2( 824)/.000000000000000d+00/
      data t2( 825)/.639252522759614d+00/,w2( 825)/.602331534419924d-01/
      data t2( 826)/.636992342566312d+00/,w2( 826)/.546127883842042d-01/
      data t2( 827)/.634677476234637d+00/,w2( 827)/.494533244845529d-01/
      data t2( 828)/.632306142544216d+00/,w2( 828)/.447231787648175d-01/
      data t2( 829)/.629876494194626d+00/,w2( 829)/.403924041316824d-01/
      data t2( 830)/.627386615565238d+00/,w2( 830)/.364326425537828d-01/
      data t2( 831)/.624834520463715d+00/,w2( 831)/.328170773386353d-01/
      data t2( 832)/.622218149874898d+00/,w2( 832)/.295203846321984d-01/
      data t2( 833)/.619535369723809d+00/,w2( 833)/.265186842661523d-01/
      data t2( 834)/.616783968668918d+00/,w2( 834)/.237894900797805d-01/
      data t2( 835)/.613961655944340d+00/,w2( 835)/.213116598446047d-01/
      data t2( 836)/.611066059272657d+00/,w2( 836)/.190653449205947d-01/
      data t2( 837)/.608094722873270d+00/,w2( 837)/.170319397728724d-01/
      data t2( 838)/.605045105594872d+00/,w2( 838)/.151940314772989d-01/
      data t2( 839)/.601914579204633d+00/,w2( 839)/.135353493421991d-01/
      data t2( 840)/.598700426871200d+00/,w2( 840)/.120407147716950d-01/
      data t2( 841)/.595399841883466d+00/,w2( 841)/.106959914937220d-01/
      data t2( 842)/.592009926652465d+00/,w2( 842)/.948803627276220d-02/
      data t2( 843)/.588527692049539d+00/,w2( 843)/.840465022367420d-02/
      data t2( 844)/.584950057140260d+00/,w2( 844)/.743453083873549d-02/
      data t2( 845)/.581273849380317d+00/,w2( 845)/.656722483515717d-02/
      data t2( 846)/.577495805346811d+00/,w2( 846)/.579308192491578d-02/
      data t2( 847)/.573612572085953d+00/,w2( 847)/.510320960279650d-02/
      data t2( 848)/.569620709166081d+00/,w2( 848)/.448942904209725d-02/
      data t2( 849)/.565516691533080d+00/,w2( 849)/.394423218054368d-02/
      data t2( 850)/.561296913273444d+00/,w2( 850)/.346074007166319d-02/
      data t2( 851)/.556957692398462d+00/,w2( 851)/.303266256920939d-02/
      data t2( 852)/.552495276770761d+00/,w2( 852)/.265425940427988d-02/
      data t2( 853)/.547905851301800d+00/,w2( 853)/.232030270658837d-02/
      data t2( 854)/.543185546555200d+00/,w2( 854)/.202604101300429d-02/
      data t2( 855)/.538330448895938d+00/,w2( 855)/.176716479802636d-02/
      data t2( 856)/.533336612328712d+00/,w2( 856)/.153977355238251d-02/
      data t2( 857)/.528200072169891d+00/,w2( 857)/.134034442751792d-02/
      data t2( 858)/.522916860695773d+00/,w2( 858)/.116570245541700d-02/
      data t2( 859)/.517483024904834d+00/,w2( 859)/.101299234507633d-02/
      data t2( 860)/.511894646522767d+00/,w2( 860)/.879651849071447d-03/
      data t2( 861)/.506147864366013d+00/,w2( 861)/.763386686107988d-03/
      data t2( 862)/.500238899161841d+00/,w2( 862)/.662146998279761d-03/
      data t2( 863)/.494164080901071d+00/,w2( 863)/.574105315029696d-03/
      data t2( 864)/.487919878773790d+00/,w2( 864)/.497635989576877d-03/
      data t2( 865)/.481502933710336d+00/,w2( 865)/.431296067878398d-03/
      data t2( 866)/.474910093521724d+00/,w2( 866)/.373807545076841d-03/
      data t2( 867)/.468138450609619d+00/,w2( 867)/.324040959871679d-03/
      data t2( 868)/.461185382201583d+00/,w2( 868)/.281000273366834d-03/
      data t2( 869)/.454048593070953d+00/,w2( 869)/.243808975698560d-03/
      data t2( 870)/.446726160733650d+00/,w2( 870)/.211697361139782d-03/
      data t2( 871)/.439216583191322d+00/,w2( 871)/.183990910401947d-03/
      data t2( 872)/.431518829430190d+00/,w2( 872)/.160099717496479d-03/
      data t2( 873)/.423632393110583d+00/,w2( 873)/.139508897749487d-03/
      data t2( 874)/.415557350218780d+00/,w2( 874)/.121769913350987d-03/
      data t2( 875)/.407294421926649d+00/,w2( 875)/.106492753121717d-03/
      data t2( 876)/.398845044537400d+00/,w2( 876)/.933389039480585d-04/
      data t2( 877)/.390211449195927d+00/,w2( 877)/.820150525159067d-04/
      data t2( 878)/.381396754990479d+00/,w2( 878)/.722674575131701d-04/
      data t2( 879)/.372405080098526d+00/,w2( 879)/.638769343171173d-04/
      data t2( 880)/.363241676579959d+00/,w2( 880)/.566543962966667d-04/
      data t2( 881)/.353913095013965d+00/,w2( 881)/.504368992219768d-04/
      data t2( 882)/.344427384953086d+00/,w2( 882)/.450841379019993d-04/
      data t2( 883)/.334794335448370d+00/,w2( 883)/.404753471388620d-04/
      data t2( 884)/.325025755773017d+00/,w2( 884)/.365065625476432d-04/
      data t2( 885)/.315135788882626d+00/,w2( 885)/.330882009855467d-04/
      data t2( 886)/.305141238151599d+00/,w2( 886)/.301429255932081d-04/
      data t2( 887)/.295061871201177d+00/,w2( 887)/.276037671177796d-04/
      data t2( 888)/.284920644327698d+00/,w2( 888)/.254124814591272d-04/
      data t2( 889)/.274743770771726d+00/,w2( 889)/.235181330014300d-04/
      data t2( 890)/.264560542707757d+00/,w2( 890)/.218759031295668d-04/
      data t2( 891)/.254402820153009d+00/,w2( 891)/.204461309748584d-04/
      data t2( 892)/.244304130161183d+00/,w2( 892)/.191935951946957d-04/
      data t2( 893)/.234298382082073d+00/,w2( 893)/.180870373806776d-04/
      data t2( 894)/.224418293422443d+00/,w2( 894)/.170989071738616d-04/
      data t2( 895)/.214693714600206d+00/,w2( 895)/.162052786734331d-04/
      data t2( 896)/.205150106143258d+00/,w2( 896)/.153858561830587d-04/
      data t2( 897)/.195807425883489d+00/,w2( 897)/.146239687158205d-04/
      data t2( 898)/.186679612333291d+00/,w2( 898)/.139064598077995d-04/
      data t2( 899)/.177774720293773d+00/,w2( 899)/.132234155008626d-04/
      data t2( 900)/.169095619286392d+00/,w2( 900)/.125677282946770d-04/
      data t2( 901)/.160641055229054d+00/,w2( 901)/.119345476980663d-04/
      data t2( 902)/.152406834542550d+00/,w2( 902)/.113206986398800d-04/
      data t2( 903)/.144386920420861d+00/,w2( 903)/.107241486401262d-04/
      data t2( 904)/.136574308687208d+00/,w2( 904)/.101435790981908d-04/
      data t2( 905)/.128961639228575d+00/,w2( 905)/.957808040025232d-05/
      data t2( 906)/.121541568188099d+00/,w2( 906)/.902695999077602d-05/
      data t2( 907)/.114306961925042d+00/,w2( 907)/.848963561775240d-05/
      data t2( 908)/.107250978761436d+00/,w2( 908)/.796558298683047d-05/
      data t2( 909)/.100367090864111d+00/,w2( 909)/.745431305082596d-05/
      data t2( 910)/.936490794701572d-01/,w2( 910)/.695536302636106d-05/
      data t2( 911)/.870910206877483d-01/,w2( 911)/.646829278443532d-05/
      data t2( 912)/.806872691668591d-01/,w2( 912)/.599268302074079d-05/
      data t2( 913)/.744324420996727d-01/,w2( 913)/.552813394935960d-05/
      data t2( 914)/.683214041604553d-01/,w2( 914)/.507426416698180d-05/
      data t2( 915)/.623492534471288d-01/,w2( 915)/.463070960693094d-05/
      data t2( 916)/.565113083678096d-01/,w2( 916)/.419712256508348d-05/
      data t2( 917)/.508030954013642d-01/,w2( 917)/.377317079083262d-05/
      data t2( 918)/.452203376649505d-01/,w2( 918)/.335853663799387d-05/
      data t2( 919)/.397589442271546d-01/,w2( 919)/.295291627108640d-05/
      data t2( 920)/.344150001106015d-01/,w2( 920)/.255601892282210d-05/
      data t2( 921)/.291847569326986d-01/,w2( 921)/.216756619898895d-05/
      data t2( 922)/.240646241374883d-01/,w2( 922)/.178729142723651d-05/
      data t2( 923)/.190511607755116d-01/,w2( 923)/.141493904656223d-05/
      data t2( 924)/.141410677921323d-01/,w2( 924)/.105026403456166d-05/
      data t2( 925)/.933118078800568d-02/,w2( 925)/.693031369744768d-06/
      data t2( 926)/.560994785908327d-02/,w2( 926)/.416653576573576d-06/
      data t2( 927)/.000000000000000d+00/,w2( 927)/.000000000000000d+00/
      data t2( 928)/.923561115881115d+00/,w2( 928)/.135062077721094d-01/
      data t2( 929)/.922870216950324d+00/,w2( 929)/.117788778570931d-01/
      data t2( 930)/.922156608492059d+00/,w2( 930)/.102472165594920d-01/
      data t2( 931)/.921419193135486d+00/,w2( 931)/.889226774100278d-02/
      data t2( 932)/.920656804071154d+00/,w2( 932)/.769655042323210d-02/
      data t2( 933)/.919868199657175d+00/,w2( 933)/.664397904843192d-02/
      data t2( 934)/.919052057532662d+00/,w2( 934)/.571978521229653d-02/
      data t2( 935)/.918206968187200d+00/,w2( 935)/.491044103728925d-02/
      data t2( 936)/.917331427929217d+00/,w2( 936)/.420358434581925d-02/
      data t2( 937)/.916423831189521d+00/,w2( 937)/.358794578254630d-02/
      data t2( 938)/.915482462088785d+00/,w2( 938)/.305327802422965d-02/
      data t2( 939)/.914505485189474d+00/,w2( 939)/.259028720389836d-02/
      data t2( 940)/.913490935343210d+00/,w2( 940)/.219056666379288d-02/
      data t2( 941)/.912436706534098d+00/,w2( 941)/.184653313857966d-02/
      data t2( 942)/.911340539606554d+00/,w2( 942)/.155136545687195d-02/
      data t2( 943)/.910200008752913d+00/,w2( 943)/.129894583519139d-02/
      data t2( 944)/.909012506621017d+00/,w2( 944)/.108380382428750d-02/
      data t2( 945)/.907775227885210d+00/,w2( 945)/.901062953304717d-03/
      data t2( 946)/.906485151105277d+00/,w2( 946)/.746390102768799d-03/
      data t2( 947)/.905139018676765d+00/,w2( 947)/.615947622876996d-03/
      data t2( 948)/.903733314652585d+00/,w2( 948)/.506348199245028d-03/
      data t2( 949)/.902264240189533d+00/,w2( 949)/.414612454214197d-03/
      data t2( 950)/.900727686344321d+00/,w2( 950)/.338129258179700d-03/
      data t2( 951)/.899119203911517d+00/,w2( 951)/.274618712289904d-03/
      data t2( 952)/.897433969960608d+00/,w2( 952)/.222097751405192d-03/
      data t2( 953)/.895666750690903d+00/,w2( 953)/.178848304507758d-03/
      data t2( 954)/.893811860181609d+00/,w2( 954)/.143387938925542d-03/
      data t2( 955)/.891863114570258d+00/,w2( 955)/.114442904870430d-03/
      data t2( 956)/.889813781146563d+00/,w2( 956)/.909234879769090d-04/
      data t2( 957)/.887656521801715d+00/,w2( 957)/.719015698334629d-04/
      data t2( 958)/.885383330226936d+00/,w2( 958)/.565902899813048d-04/
      data t2( 959)/.882985462212327d+00/,w2( 959)/.443256975535460d-04/
      data t2( 960)/.880453358361484d+00/,w2( 960)/.345502766656056d-04/
      data t2( 961)/.877776558514556d+00/,w2( 961)/.267982268497306d-04/
      data t2( 962)/.874943607169878d+00/,w2( 962)/.206823782399980d-04/
      data t2( 963)/.871941949222854d+00/,w2( 963)/.158826208280529d-04/
      data t2( 964)/.868757815414857d+00/,w2( 964)/.121357278754369d-04/
      data t2( 965)/.865376097024458d+00/,w2( 965)/.922645542022800d-05/
      data t2( 966)/.861780209564907d+00/,w2( 966)/.697980267292112d-05/
      data t2( 967)/.857951945610839d+00/,w2( 967)/.525432186430232d-05/
      data t2( 968)/.853871317410258d+00/,w2( 968)/.393637068006087d-05/
      data t2( 969)/.849516390705182d+00/,w2( 969)/.293520567725677d-05/
      data t2( 970)/.844863112262952d+00/,w2( 970)/.217882090404123d-05/
      data t2( 971)/.839885135106444d+00/,w2( 971)/.161044220990918d-05/
      data t2( 972)/.834553647442848d+00/,w2( 972)/.118559431204781d-05/
      data t2( 973)/.828837213965887d+00/,w2( 973)/.869664448908411d-06/
      data t2( 974)/.822701641700705d+00/,w2( 974)/.635893284781708d-06/
      data t2( 975)/.816109887034578d+00/,w2( 975)/.463730516323865d-06/
      data t2( 976)/.809022026172412d+00/,w2( 976)/.337499271079648d-06/
      data t2( 977)/.801395318054795d+00/,w2( 977)/.245319788505428d-06/
      data t2( 978)/.793184396729087d+00/,w2( 978)/.178248958791140d-06/
      data t2( 979)/.784341638982309d+00/,w2( 979)/.129598001514855d-06/
      data t2( 980)/.774817762046325d+00/,w2( 980)/.943958475636246d-07/
      data t2( 981)/.764562714088110d+00/,w2( 981)/.689706116511546d-07/
      data t2( 982)/.753526924871668d+00/,w2( 982)/.506258915451696d-07/
      data t2( 983)/.741662982209382d+00/,w2( 983)/.373924997076728d-07/
      data t2( 984)/.728927787176270d+00/,w2( 984)/.278396314798472d-07/
      data t2( 985)/.715285212044112d+00/,w2( 985)/.209324196058352d-07/
      data t2( 986)/.700709233658106d+00/,w2( 986)/.159253445950907d-07/
      data t2( 987)/.685187436943112d+00/,w2( 987)/.122830973420577d-07/
      data t2( 988)/.668724677838534d+00/,w2( 988)/.962226204507738d-08/
      data t2( 989)/.651346569554902d+00/,w2( 989)/.766864367111061d-08/
      data t2( 990)/.633102329938460d+00/,w2( 990)/.622624551575506d-08/
      data t2( 991)/.614066434559134d+00/,w2( 991)/.515484844537343d-08/
      data t2( 992)/.594338505284694d+00/,w2( 992)/.435389164657845d-08/
      data t2( 993)/.574040973976225d+00/,w2( 993)/.375093935804703d-08/
      data t2( 994)/.553314323271887d+00/,w2( 994)/.329346917657824d-08/
      data t2( 995)/.532310106415610d+00/,w2( 995)/.294306039768049d-08/
      data t2( 996)/.511182412244945d+00/,w2( 996)/.267131592562128d-08/
      data t2( 997)/.490078844281606d+00/,w2( 997)/.245703509241389d-08/
      data t2( 998)/.469132284595798d+00/,w2( 998)/.228428182322940d-08/
      data t2( 999)/.448454618715673d+00/,w2( 999)/.214107786391493d-08/
      data t2(1000)/.428133208523804d+00/,w2(1000)/.201851030079248d-08/
      data t2(1001)/.408230324713844d+00/,w2(1001)/.191009144315484d-08/
      data t2(1002)/.388785164796863d+00/,w2(1002)/.181125698593283d-08/
      data t2(1003)/.369817656606180d+00/,w2(1003)/.171893618687073d-08/
      data t2(1004)/.351333078724678d+00/,w2(1004)/.163116918034037d-08/
      data t2(1005)/.333326617828883d+00/,w2(1005)/.154677363408459d-08/
      data t2(1006)/.315787247955264d+00/,w2(1006)/.146507257557818d-08/
      data t2(1007)/.298700642484404d+00/,w2(1007)/.138569100757058d-08/
      data t2(1008)/.282051112774032d+00/,w2(1008)/.130841863126551d-08/
      data t2(1009)/.265822747429100d+00/,w2(1009)/.123312689011815d-08/
      data t2(1010)/.249999993201208d+00/,w2(1010)/.115972444427907d-08/
      data t2(1011)/.234567900358296d+00/,w2(1011)/.108813611917003d-08/
      data t2(1012)/.219512195169506d+00/,w2(1012)/.101829420028463d-08/
      data t2(1013)/.204819277260133d+00/,w2(1013)/.950135276820765d-09/
      data t2(1014)/.190476190627246d+00/,w2(1014)/.883599192284088d-09/
      data t2(1015)/.176470588375903d+00/,w2(1015)/.818628663391472d-09/
      data t2(1016)/.162790697804157d+00/,w2(1016)/.755169077079926d-09/
      data t2(1017)/.149425287475409d+00/,w2(1017)/.693168331835211d-09/
      data t2(1018)/.136363636472314d+00/,w2(1018)/.632576694437027d-09/
      data t2(1019)/.123595505716479d+00/,w2(1019)/.573346666868017d-09/
      data t2(1020)/.111111111199663d+00/,w2(1020)/.515432862133875d-09/
      data t2(1021)/.989010989799200d-01/,w2(1021)/.458791888273009d-09/
      data t2(1022)/.869565218084321d-01/,w2(1022)/.403382239930858d-09/
      data t2(1023)/.752688172642880d-01/,w2(1023)/.349164196929399d-09/
      data t2(1024)/.638297872849129d-01/,w2(1024)/.296099729310949d-09/
      data t2(1025)/.526315789893142d-01/,w2(1025)/.244152408379204d-09/
      data t2(1026)/.416666666998737d-01/,w2(1026)/.193287323300203d-09/
      data t2(1027)/.309278350761949d-01/,w2(1027)/.143471002862006d-09/
      data t2(1028)/.204081632815708d-01/,w2(1028)/.946713420245893d-10/
      data t2(1029)/.122694795557315d-01/,w2(1029)/.569168366333727d-10/
      data t2(1030)/.000000000000000d+00/,w2(1030)/.000000000000000d+00/
      end
      subroutine tranfgc(f,g,c,norb)
      implicit REAL (a-h,o-z)
c
c  this routine forms the g matrix by transforming f with c
c
      dimension c(norb,norb),f(norb,norb),g(norb,norb)
c
      do 40 i = 1,norb
         do 30 j = 1,norb
c            ij = i*(i-1)/2 + j
            term2 = 0.0d00
            do 20 k = 1,norb
               term = 0.0d00
               do 10 l = 1,norb
c                  ki = max(k,l)
c                  li = min(k,l)
c                  kl = ki*(ki-1)/2 + li
                  term = term + f(k,l)*c(l,j)
   10          continue
               term2 = term2 + term*c(k,i)
   20       continue
            g(i,j) = term2
   30    continue
   40 continue
      return
      end
      subroutine trbak3(nm,n,nv,a,m,z)
      implicit REAL (a-h,o-z)
c               ===== processed by augment, version 4n =====
c     approved for vax 11/780 on may 6,1980.  j.d.neece
c               ----- local variables -----
c               ----- global variables -----
      dimension a(nv), z(nm,m)
c               ===== translated program =====
c
c
c     this routine is a translation of the algol procedure trbak3,
c     num. math. 11, 181-195(1968) by martin, reinsch, and wilkinson.
c     handbook for auto. comp., vol.ii-linear algebra, 212-226(1971).
c
c     this routine forms the eigenvectors of a real symmetric
c     matrix by back transforming those of the corresponding
c     symmetric tridiagonal matrix determined by  tred3.
c
c     on input-
c
c        nm must be set to the row dimension of two-dimensional
c          array parameters as declared in the calling program
c          dimension statement,
c
c        n is the order of the matrix,
c
c        nv must be set to the dimension of the array parameter a
c          as declared in the calling program dimension statement,
c
c        a contains information about the orthogonal transformations
c          used in the reduction by  tred3  in its first
c          n*(n+1)/2 positions,
c
c        m is the number of eigenvectors to be back transformed,
c
c        z contains the eigenvectors to be back transformed
c          in its first m columns.
c
c     on output-
c
c        z contains the transformed eigenvectors
c          in its first m columns.
c
c     note that trbak3 preserves vector euclidean norms.
c
c     questions and comments should be directed to b. s. garbow,
c     applied mathematics division, argonne national laboratory
c
c     ------------------------------------------------------------------
c
      if (m .eq. 0) go to 50
      if (n .eq. 1) go to 50
c
      do 40   i = 2, n
         l = i - 1
         iz = (i * l) / 2
         ik = iz + i
         h = a(ik)
         if (h.eq.0.0d0)  go to 40
c
         do 30   j = 1, m
            s=0.0d0
            ik = iz
c
            do 10   k = 1, l
               ik = ik + 1
               s = s + a(ik) * z(k,j)
   10       continue
c     ********** double division avoids possible underflow **********
            s = (s / h) / h
            ik = iz
c
            do 20   k = 1, l
               ik = ik + 1
               z(k,j) = z(k,j) - s * a(ik)
   20       continue
c
   30    continue
c
   40 continue
c
   50 return
c     ********** last card of trbak3 **********
      end
      subroutine tred3(n,nv,a,d,e,e2,eps,eta)
      implicit REAL (a-h,o-z)
c               ===== processed by augment, version 4n =====
c     approved for vax 11/780 on may 6,1980.  j.d.neece
c               ----- local variables -----
c               ----- global variables -----
      dimension a(nv), d(n), e(n), e2(n)
c               ----- supporting package functions -----
c               ===== translated program =====
c
c
c     this routine is a translation of the algol procedure tred3,
c     num. math. 11, 181-195(1968) by martin, reinsch, and wilkinson.
c     handbook for auto. comp., vol.ii-linear algebra, 212-226(1971).
c
c     this routine reduces a real symmetric matrix, stored as
c     a one-dimensional array, to a symmetric tridiagonal matrix
c     using orthogonal similarity transformations.
c
c     on input-
c
c        n is the order of the matrix,
c
c        nv must be set to the dimension of the array parameter a
c          as declared in the calling program dimension statement,
c
c        a contains the lower triangle of the real symmetric
c          input matrix, stored row-wise as a one-dimensional
c          array, in its first n*(n+1)/2 positions.
c
c     on output-
c
c        a contains information about the orthogonal
c          transformations used in the reduction,
c
c        d contains the diagonal elements of the tridiagonal matrix,
c
c        e contains the subdiagonal elements of the tridiagonal
c          matrix in its last n-1 positions.  e(1) is set to zero,
c
c        e2 contains the squares of the corresponding elements of e.
c          e2 may coincide with e if the squares are not needed.
c
c     questions and comments should be directed to b. s. garbow,
c     applied mathematics division, argonne national laboratory
c
c     ------------------------------------------------------------------
c
c     ********** for i=n step -1 until 1 do -- **********
      do 100   ii = 1, n
         i = n + 1 - ii
         l = i - 1
         iz = ( i * l ) / 2
         h=0.0d0
         scale=0.0d0
         do 10   k = 1, l
            iz = iz + 1
            d(k) = a(iz)
            scale=scale+dabs(d(k))
   10    continue
c
         if ( scale.ne.0.d0 ) go to 20
         e(i)=0.0d0
         e2(i)=0.0d0
         go to 90
c
   20    do 30   k = 1, l
            d(k) = d(k) / scale
            h = h + d(k) * d(k)
   30    continue
c
         e2(i) = scale * scale * h
         f = d(l)
         g=-dsign(dsqrt(h),f)
         e(i) = scale * g
         h = h - f * g
         d(l) = f - g
         a(iz) = scale * d(l)
         if (l .eq. 1) go to 90
         f=0.0d0
c
         do 70   j = 1, l
            g=0.0d0
            jk = (j * (j-1)) / 2
c     ********** form element of a*u **********
            k = 0
   40       k = k + 1
            jk = jk + 1
            g = g + a(jk) * d(k)
            if ( k .lt. j ) go to 40
            if ( k .eq. l ) go to 60
   50       jk = jk + k
            k = k + 1
            g = g + a(jk) * d(k)
            if ( k .lt. l ) go to 50
c     ********** form element of p **********
   60       continue
            e(j) = g / h
            f = f + e(j) * d(j)
   70    continue
c
         hh = f / (h + h)
         jk = 0
c     ********** form reduced a **********
         do 80   j = 1, l
            f = d(j)
            g = e(j) - hh * f
            e(j) = g
c
            do 80   k = 1, j
               jk = jk + 1
               a(jk) = a(jk) - f * e(k) - g * d(k)
   80    continue
c
   90    d(i) = a(iz+1)
         a(iz+1)=scale*dsqrt(h)
  100 continue
c
      return
c     ********** last card of tred3 **********
      end
      function trsub(ul,x,ur,l1,lm,ndim)
c this program calculates traces of matrices
      implicit REAL (a-h,o-z)
      dimension ul(ndim,ndim),x(ndim,ndim),ur(ndim,ndim)
c
      sum = 0.0d00
      do 30 i = 1,l1
         do 20 k = 1,lm
            suml = 0.0d00
            do 10 l = 1,lm
               suml = suml + x(k,l)*ur(l,i)
   10       continue
            sum = sum + suml*ul(i,k)
   20    continue
   30 continue
      trsub = 2.0d00*sum
      return
      end
      function trudgu(ul,x,ur,l1,lm,ndim)
      implicit REAL (a-h,o-z)
      dimension ul(ndim,ndim),x(ndim,ndim),ur(ndim,ndim)
c
      sum = 0.0d00
      do 30 i = 1,l1
         do 20 k = 1,lm
            suml = 0.0d00
            do 10 l = 1,lm
               suml = suml + x(k,l)*ur(l,i)
   10       continue
            sum = sum + suml*ul(k,i)
   20    continue
   30 continue
      trudgu = 2.0d00*sum
      return
      end
      function trugdu(ul,x,ur,l1,lm,ndim)
      implicit REAL (a-h,o-z)
      dimension ul(ndim,ndim),x(ndim,ndim),ur(ndim,ndim)
c
      sum = 0.0d00
      do 30 i = 1,l1
         do 20 k = 1,lm
            suml = 0.0d00
            do 10 l = 1,lm
               suml = suml + x(l,k)*ur(l,i)
   10       continue
            sum = sum + suml*ul(i,k)
   20    continue
   30 continue
      trugdu = 2.0d00*sum
      return
      end
      function trugud(ul,x,ur,l1,lm,ndim)
      implicit REAL (a-h,o-z)
      dimension ul(ndim,ndim),x(ndim,ndim),ur(ndim,ndim)
c
      sum = 0.0d00
      do 30 i = 1,l1
         do 20 k = 1,lm
            suml = 0.0d00
            do 10 l = 1,lm
               suml = suml + x(k,l)*ur(i,l)
   10       continue
            sum = sum + suml*ul(i,k)
   20    continue
   30 continue
      trugud = 2.0d00*sum
      return
      end
      subroutine upcase(keywrd)
      character*241 keywrd
      icapa=ichar('a')
      ilowa=ichar('a')
      ilowz=ichar('z')
      do 10 i=1,241
         iline=ichar(keywrd(i:i))
         if(iline.ge.ilowa.and.iline.le.ilowz) then
            keywrd(i:i)=char(iline+icapa-ilowa)
         endif
   10 continue
      return
      end
      subroutine vecprt (a,numm)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      dimension  a(*)
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),
     1                nlast(numatm), norbs, nelecs,nalpha,nbeta,
     2                nclose,nopen,ndumy,fract
      common /elemts/ elemnt(107)
      common /iofile/ mfgr,mfgw
c**********************************************************************
c
c  vecprt prints a lower-half triangle of a square matrix, the
c         lower-half triangle being stored in packed form in the
c         array "a"
c
c on input:
c      a      = array to be printed
c      numm   = size of array to be printed
c(ref) numat  = number of atoms in the molecule (this is needed to
c               decide if an atomic array or atomic orbital array is
c               to be printed
c(ref) nat    = list of atomic numbers
c(ref) nfirst = list of orbital counters
c(ref) nlast  = list of orbital counters
c
c  none of the arguments are altered by the call of vecprt
c
c*********************************************************************
      dimension natom(maxorb)
      character * 6 line(21)
      character*2 elemnt,atorbs(9), itext(maxorb), jtext(maxorb)
      save atorbs
      data atorbs/' s','px','py','pz','x2','xz','z2','yz','xy'/
      if(numat.ne.0.and.numat.eq.numm) then
c
c    print over atom count
c
         do 10 i=1,numat
            itext(i)='  '
            jtext(i)=elemnt(nat(i))
            natom(i)=i
   10    continue
      else
         if (numat.ne.0.and.nlast(numat) .eq. numm) then
            do 30 i=1,numat
               jlo=nfirst(i)
               jhi=nlast(i)
               l=nat(i)
               k=0
               do 20 j=jlo,jhi
                  k=k+1
                  itext(j)=atorbs(k)
                  jtext(j)=elemnt(l)
                  natom(j)=i
   20          continue
   30       continue
         else
            numb=iabs(numm)
            do 40 i=1,numb
               itext(i) = '  '
               jtext(i) = '  '
   40       natom(i)=i
         endif
      endif
      numb=iabs(numm)
      do 50 i=1,21
   50 line(i)='------'
      limit=(numb*(numb+1))/2
      kk=8
      na=1
   60 ll=0
      m=min((numb+1-na),6)
      ma=2*m+1
      m=na+m-1
      write(mfgw,100)(itext(i),jtext(i),natom(i),i=na,m)
      write (mfgw,110) (line(k),k=1,ma)
      do 80 i=na,numb
         ll=ll+1
         k=(i*(i-1))/2
         l=min((k+m),(k+i))
         k=k+na
         if ((kk+ll).le.50) go to 70
         write (mfgw,120)
         write (mfgw,100) (itext(n),jtext(n),natom(n),n=na,m)
         write (mfgw,110) (line(n),n=1,ma)
         kk=4
         ll=0
   70    write (mfgw,130) itext(i),jtext(i),natom(i),(a(n),n=k,l)
   80 continue
      if (l.ge.limit) go to 90
      kk=kk+ll+4
      na=m+1
      if ((kk+numb+1-na).le.50) go to 60
      kk=4
      write (mfgw,120)
      go to 60
   90 return
c
  100 format (1h0/13x,10(1x,a2,1x,a2,i3,2x))
  110 format (1h ,21a6)
  120 format (1h1)
  130 format (1h ,a2,1x,a2,i5,10f11.6)
c
      end
      subroutine writmo(time0,funct)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
INCLUDE(../m4/common/utilc)
      character keywrd*241
      REAL meci
_IF(ipsc,tools)
      logical oroot
_ENDIF
      common /keywrd/ keywrd
      common /elemts/ elemnt(107)
      common /cmpg/ geo(3,numatm)
      common /geokst/ natoms,labels(numatm),
     1                na(numatm),nb(numatm),nc(numatm)
      common /hmatrx/ h(mpack)
      common /fokmat/ f(mpack), fb(mpack)
      common /vector/ c(morb2),eigs(maxorb),cbeta(morb2),eigb(maxorb)
      common /densty/ p(mpack),pa(mpack),pb(mpack)
      common /geosym/ ndep, locpar(maxpar), idepfn(maxpar),
     1                    locdep(maxpar)
      common /euler/  tvec(3,3), id
      common /rjks/ rjkab(nmeci,nmeci), rjkaa(nmeci,nmeci)
      common /errfn/ errfn(maxpar), aicorr(maxpar)
      common /work1/  fmat2d(npulay*4), sec(npulay*2), vec(npulay*2),
     1                alband(npulay*13)
      common /path/ latom,lparam,react(200)
      common /numcal/ numcal
      common /numscf/ nscf
      common /wmatrc/ wj(n2elec), wk(n2elec)
      common /atheat/ atheat
      parameter (mxdim=maxorb+numatm)
      common /symres/ trans,rtr,sig,name,namo(mxdim),indx(mxdim),ista(2)
      common /corec/ core(107)
      common /last/ last
      common /scrach/ rxyz(mpack), xdumy(maxpar**2-mpack)
      common /cimats/ engyci(3),vectci(9),eci(6)
      common /mesage/ iflepo,iiter
      common /atmass/ atmass(numatm)
      common /enuclr/ enuclr
      common /elect/ elect
      common /xyzgra/ dxyz(9*numatm)
      common /gradnt/ grad(maxpar), gnorm
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),
     1                nlast(numatm), norbs, nelecs,nalpha,nbeta,
     2                nclose,nopen,ndumy,fract
      common /geovar/ nvar, loc(2,maxpar), idumy, xparam(maxpar)
c cosmo change
      logical iseps, useps, upda
      common /iseps/ iseps, useps, upda
c end of cosmo change
c     patas
      common /mstpo/ hq(mpack),ezq,eeq
      common /mstq/ qs(1500),mflag,iterq
      common /mopfin/ gvw,gvws,elc1,ec1
      common /iofile/ mfgr,mfgw
c     patas
************************************************************************
*
*   write prints out most of the results.
*         it should not alter any parameters, so that it can be called
*         at any convenient time.
*
************************************************************************
      dimension q(maxorb), q2(maxorb), coord(3,numatm)
     1,iel1(107), nelemt(107), iel2(107)
      dimension w(n2elec), dumy(3)
      logical uhf, ci, singlt, triplt, excitd, prtgra, still
c     patas
      logical tom, jiali
c     patas
      character type(3)*11, idate*24, calcn(2)*5, gtype*13, grtype*14,
     1          flepo(16)*58, iter(2)*58, numbrs(11)*1, getmop*80
      character*2 elemnt, ielemt(20), caltyp*7, namfil*80, name*4
      save icalcn, numbrs, calcn, type, flepo, iter
      equivalence (w,wj)
      REAL wj, wk
      data icalcn/0/
      data type/'bond       ','angle      ','dihedral   '/
      data calcn /'     ','alpha'/
      data numbrs /'0','1','2','3','4','5','6','7','8','9',' '/
      data flepo(1),flepo(2),flepo(3)/
     1' 1scf was specified, so bfgs was not used                 ',
     2' gradients were initially acceptably small                ',
     3' herberts test was satisfied in bfgs                      '/
      data flepo(4),flepo(5),flepo(6)/
     1' the line minimization failed twice in a row.   take care!',
     2' bfgs failed due to counts exceeded. take care!           ',
     3' peters test was satisfied in bfgs optimization           '/
      data flepo(7),flepo(8),flepo(9)/
     1' this message should never appear, consult a programmer!! ',
     2' gradient test not passed, but further work not justified ',
     3' a failure has occurred, treat results with caution!!     '/
      data flepo(10),flepo(11),flepo(12)/
     1' geometry optimized using nllsq. gradient norm minimized  ',
     2' geometry optimized using powsq. gradient norm minimized  ',
     3' cycles exceeded, gradient not fully minimized in nllsq   '/
      data flepo(13),flepo(14),flepo(15)/
     1' 1scf run after restart.  geometry might not be optimized ',
     2' heat of formation minimized in one line search           ',
     3' geometry optimised using eigenvector following (ef).     '/
      data flepo(16)/
     1' ef-optimized geometry.  number of -ve roots incorrect    '/
      data iter/
     1' scf field was achieved                                   ',
     2'  ++++----**** failed to achieve scf. ****----++++        '/
c     patas
      data zero/0.d0/
      data thres /0.0010d0/
c     patas
c
c summary of results (note: this is in a subroutine so it
c          can be used by the path option)
      if(icalcn.eq.0)namfil='**null**'
      idate=' '
      if(iflepo.eq.0) iflepo=7
      iuhf=min(index(keywrd,' uhf'),1)+1
      prtgra=(index(keywrd,' grad').ne.0.and.nvar.gt.0)
      linear=(norbs*(norbs+1))/2
      singlt=(index(keywrd,' sing') .ne. 0)
      triplt=(index(keywrd,' trip') .ne. 0)
      excitd=(index(keywrd,' exci') .ne. 0)
      ci=(index(keywrd,' c.i.') .ne. 0)
      if(index(keywrd,' mindo') .ne. 0) then
         caltyp='mindo/3'
      elseif(index(keywrd,' am1') .ne. 0) then
         caltyp='  am1  '
      elseif(index(keywrd,' pm3') .ne. 0) then
         caltyp='  pm3  '
      else
         caltyp=' mndo  '
      endif
c     patas
      tom=(index(keywrd,'tom').ne.0)
      jiali=(index(keywrd,'jiali').ne.0)
      if (tom.and.jiali) goto 9999
      if (mflag.ge.1.and.mflag.le.3) then
      e3=elect+enuclr
      e3s=e3-(ezq+eeq)*0.5d0
         if(dabs(e3s-e3sold).gt.thres) then
         e3sold=e3s
         return
         end if
      end if
c     patas
 9999 uhf=(iuhf.eq.2)
      call gtnv('mopacdate',idate)
      degree=57.29577951d0
      if(na(1).eq.99)then
         degree=1.d0
         type(1)='cartesian x'
         type(2)='cartesian y'
         type(3)='cartesian z'
      endif
      gnorm=0.0d0
      if(nvar.ne.0)gnorm=dsqrt(ddot(nvar,grad,1,grad,1))
      write(mfgw,'(/,'' ----'',15(''-----''))')
      call wrttxt(mfgw)
      write(mfgw,'(//4x,a58)')flepo(iflepo)
      iiter=max(1,iiter)
      write(mfgw,'(4x,a58)')iter(iiter)
      write(mfgw,'(//30x,a7,''  calculation'')')caltyp
      write(mfgw,'(55x,''version '',f5.2)')verson
      write(mfgw,'(55x,a24)')idate
      if(iiter.eq.2)then
c
c   results are meaningless. don't print anything!
c
         write(mfgw,
     +   '(//,'' for some reason the scf calculation failed.'',/
     1,'' the results would be meaningless, so will not be printed.'')')
         write(mfgw,
     +   '('' try to find the reason for the failure by using ''
     1,''"pl".'',/,
     2'' check your geometry and also try using shift or pulay. '')')
         call geout(1)
_IF(ipsc,tools)
         call pend
_ELSE
         stop
_ENDIF
      endif
      write(mfgw,
     +   '(////10x,''final heat of formation ='',f17.5,'' kcal''
     1)')funct
      if(latom.eq.0) write(mfgw,'(/)')
      write(mfgw,
     +   '(    10x,''total energy            ='',f17.5,'' ev''
     1)')elect+enuclr
      write(mfgw,
     +   '(    10x,''electronic energy       ='',f17.5,'' ev''
     1)')elect
      write(mfgw,
     +   '(    10x,''core-core repulsion     ='',f17.5,'' ev''
     1)')enuclr
c cosmo change
      if (iseps) then
        call dielen(edie)
        write(mfgw,
     +  '(    10x,''dielectric energy       ='',f17.5,'' ev'')')edie
      endif
c end of cosmo change
      if(latom.eq.0) write(mfgw,'(1x)')
      prtgra=(prtgra .or. gnorm .gt. 2.d0)
      if(prtgra)
     1write(mfgw,'(    10x,''gradient norm           ='',f17.5)')gnorm
      still=.true.
      if(latom.eq.0) then
      if(index(keywrd,' aider').ne.0) goto 45
      if(index(keywrd,'1scf').ne.0.and.index(keywrd,'grad').eq.0)goto 45
c
c   check that the cartesian coordinate gradient is also small
c
            if(ddot(3*numat,dxyz,1,dxyz,1).gt.dmax1(16.d0,4*gnorm**2)
     1.and.gnorm.lt.2.d0.and.nclose.eq.nopen.and.id.eq.0) then
               write(mfgw,'(a)')
     +   ' warning -- geometry is not at a stationary point'
               still=.false.
            endif
  45  continue
      else
c
c   we need to calculate the reaction coordinate gradient.
c
         mvar=nvar
         loc11=loc(1,1)
         loc21=loc(2,1)
         nvar=1
         loc(1,1)=latom
         loc(2,1)=lparam
         xreact=geo(lparam,latom)
         call mopdv(geo,gcoord)
         nvar=mvar
         loc(1,1)=loc11
         loc(2,1)=loc21
         grtype=' kcal/angstrom'
         if(lparam.eq.1)then
            write(mfgw,'(    10x,''for reaction coordinate ='',f17.5
     1        ,'' angstroms'')')xreact
         else
            if(na(1).ne.99)grtype=' kcal/radian  '
            write(mfgw,'(    10x,''for reaction coordinate ='',f17.5
     1        ,'' degrees'')')xreact*degree
         endif
         write(mfgw,'(    10x,''reaction gradient       ='',f17.5,a14
     1    )')gcoord,grtype
      endif
      if(nalpha.gt.0)then
         eionis=-dmax1(eigs(nalpha), eigb(nbeta))
      elseif(nelecs.eq.1)then
         eionis=-eigs(1)
      elseif(nelecs.gt.1) then
         eionis=-dmax1(eigs(nclose), eigs(nopen))
      else
         eionis=0.0d0
      endif
      i=nclose
      if(fract.gt.1.99d0)i=nopen
      nopn=nopen-i
c   correction to i.p. of doublets
      if(nopn.eq.1)then
         i=nclose*norbs+1
         eionis=eionis+0.5d0*rjkab(1,1)
      endif
      if(dabs(eionis).gt.1.d-5)
     1write(mfgw,
     +'(       10x,''ionization potential    ='',f17.5)')eionis
      if( uhf ) then
         write(mfgw,
     +'(      10x,''no. of alpha electrons  ='',i11)')nalpha
         write(mfgw,
     +'(      10x,''no. of beta  electrons  ='',i11)')nbeta
      else
         write(mfgw,
     +'(      10x,''no. of filled levels    ='',i11)')
     1 nopen-nopn
         if(nopn.ne.0) then
            write(mfgw,
     +'(   10x,''and no. of open levels  ='',i11)')nopn
         endif
      endif
      sumw=0
      do 10 i=1,numat
   10 sumw=sumw+atmass(i)
      if(sumw.gt.0.1d0)
     1write(mfgw,'(    10x,''molecular weight        ='',f11.3)')sumw
      if(latom.eq.0) write(mfgw,'(/)')
      write(mfgw,'(10x,''scf calculations  =   '',i14 )') nscf
      tim=secmop()-time0
      i=tim*0.000001d0
      tim=tim-i*1000000
      call moptim(mfgw,tim)
c     patas
      if (mflag.eq.0) ezero=elect+enuclr
      if (tom.and.mflag.ge.1) then
      write(mfgw,'(/,10x,''miertus-scrocco-tomasi solvation model'',/)')
      e3=zero
      e3s=zero
      e3=elect+enuclr
      e3s=e3-(ezq+eeq)*0.5d0
      write(mfgw,'(10x,''scrf iteration    = '',i3)') iterq
      write(mfgw,'(10x,''solute energy     = '',f15.6,'' ev'')') e3
      write(mfgw,'(10x,''delta energy      = '',f15.6,'' kcal/mol'')')
     1(e3-ezero)*23.061d0
      write(mfgw,'(10x,''free energy       = '',f15.6,'' ev'')') e3s
      write(mfgw,'(10x,''delta free energy = '',f15.6,'' kcal/mol'')')
     1(e3s-ezero)*23.061d0
      write(mfgw,'(10x,''solute-solvent e  = '',f15.6,'' ev'')')
     1ezq+eeq
      write(mfgw,'(10x,''____nuclei-solvent= '',f15.6,'' ev'')') ezq
      write(mfgw,'(10x,''__electron-solvent= '',f15.6,'' ev'')') eeq
      if (iterq.eq.1) then
         e3sold=e3s
         go to 300
      endif
      if (dabs(e3s-e3sold).lt.thres) then
         if (mflag.eq.4) goto 302
         mflag=3
302   write(mfgw,'(/10x,''*********************'')')
      write(mfgw,'(10x,''*** final results ***'')')
      write(mfgw,'(10x,''*********************'')')
      write(mfgw,'(10x,''delta free energy = '',f15.6,'' kcal/mol'')')
     1(e3s-ezero)*23.061d0
      write(mfgw,'(10x,''free e cavitation = '',f15.6,'' kcal/mol'')')
     1elc1
      write(mfgw,'(10x,''v. der w. free e  = '',f15.6,'' kcal/mol'')')
     1gvw
      write(mfgw,'(10x,''vdw f e (tomasi)  = '',f15.6,'' kcal/mol'')')
     1gvws
      gsolv=(e3s-ezero)*23.061d0+elc1+gvw
      write(mfgw,'(10x,''solvation free e  = '',f15.6,'' kcal/mol'')')
     1gsolv
      else
        e3sold=e3s
      endif
      endif
c    patas
 300  if( ndep .ne. 0 )call mopsym()
      do 20 i=1,nvar
   20 xparam(i)=geo(loc(2,i),loc(1,i))
      call gmetry(geo,coord)
      if(prtgra)then
         write(mfgw,'(///7x,''final  point  and  derivatives'',/)')
         write(mfgw,'(''   parameter     atom    type  ''
     1    ,''          value       gradient'')')
      endif
      sum=0.5d0
      do 30 i=1,numat
   30 sum=sum+core(nat(i))
      i=sum
      kchrge=i-nclose-nopen-nalpha-nbeta
c
c    write out the geometric variables
c
      if(prtgra) then
         do 40 i=1,nvar
            j=loc(2,i)
            k=loc(1,i)
            l=labels(k)
            xi=xparam(i)
            if(j.ne.1) xi=xi*degree
            if(j.eq.1.or.na(1).eq.99)then
               gtype='kcal/angstrom'
            else
               gtype='kcal/radian  '
            endif
   40    write(mfgw,'(i7,i11,1x,a2,4x,a11,f13.6,f13.6,2x,a13)')
     1i,k,elemnt(l),type(j),xi,grad(i),gtype
      endif
c
c     write out the geometry
c
      write(mfgw,'(///)')
      call geout(1)
      if (index(keywrd,' nointer') .eq. 0) then
c
c   write out the interatomic distances
c
         l=0
         do 50 i=1,numat
            do 50 j=1,i
               l=l+1
   50    rxyz(l)=dsqrt((coord(1,i)-coord(1,j))**2+
     +                 (coord(2,i)-coord(2,j))**2+
     +                 (coord(3,i)-coord(3,j))**2)
         write(mfgw,'(//10x,''  interatomic distances'')')
         call vecprt(rxyz,numat)
      endif
      do 60 i=1,norbs
   60 if(eigs(i).lt.-999.d0.or.eigs(i).gt.1000.d0)eigs(i)=0.0d0
      do 70 i=1,norbs
   70 if(eigb(i).lt.-999.d0.or.eigb(i).gt.1000.d0)eigs(i)=0.0d0
      if(isybyl.eq.1) then
_IF(ipsc,tools)
      if(oroot().and.odumpm) then
_ELSE
      if(odumpm) then
_ENDIF
c
c  the following open statements are non-standard.  if this causes
c  difficulty replace them with
      open(unit=16,file=getmop(8),status='new',err=31)
      goto 32
  31  open(unit=16,file=getmop(8),status='old')
      write(mfgw,'(a)') 'error opening sybyl mopac output'
  32  continue
c#      open(unit=16,file=getnam('for016'),carriagecontrol='list',
c#     +status='new',err=31)
c#      goto 32
c#  31  open(unit=16,file=getnam('for016'),carriagecontrol='list',
c#     +status='old')
c#      write(mfgw,'(a)') 'error opening sybyl mopac output'
c#  32  continue
      endif
      endif
      if(norbs.gt.0)then
      call symtrz(coord,c,norbs,norbs,.false.,.true.)
      write(mfgw,'(//''      molecular point group   :   '',a4)')name
         if (index(keywrd,'vect') .ne. 0) then
            write(mfgw,'(//10x,a5,'' eigenvectors  '')')calcn(iuhf)
            call mopmat1(c,eigs,norbs,norbs,maxorb,2)
            if(uhf) then
               write(mfgw,'(//10x,'' beta eigenvectors  '')')
               call mopmat1(cbeta,eigb,norbs,norbs,maxorb,2)
            endif
         else
            write(mfgw,'(//10x,a5,''   eigenvalues'',/)')calcn(iuhf)
            write(mfgw,'(8f10.5)')(eigs(i),i=1,norbs)
            if(uhf) then
               write(mfgw,'(//10x,'' beta eigenvalues '')')
               write(mfgw,'(8f10.5)')(eigb(i),i=1,norbs)
            endif
         endif
      endif
      write(mfgw,'(//13x,'' net atomic charges and dipole '',
     1''contributions'',/)')
      write(mfgw,
     +      '(8x,'' atom no.   type          charge        atom''
     1,''  electron density'')')
      call chrge(p,q)
      do 80 i=1,numat
         l=nat(i)
         q2(i)=core(l) - q(i)
   80 write(mfgw,'(i12,9x,a2,4x,f13.4,f16.4)')
     1i,elemnt(l),q2(i),q(i)
      dip= dipmop(p,q2,coord,dumy,1)
      if (index(keywrd,' noxyz') .eq. 0) then
         write(mfgw,'(//10x,''cartesian coordinates '',/)')
         write(mfgw,'(4x,''no.'',7x,''atom'',15x,''x'',
     1  9x,''y'',9x,''z'',/)')
         write(mfgw,'(i6,8x,a2,14x,3f10.4)')
     1  (i,elemnt(nat(i)),(coord(j,i),j=1,3),i=1,numat)
      endif
      if(norbs.gt.0) then
         if (index(keywrd,' k=') .ne. 0)then
c
c  go into brillouin zone mode
c
            i=index(keywrd,' k=')
            step=reada(keywrd,i)
            mono3=nlast(nint(reada(keywrd(i:),index(keywrd(i:),','))))
         if(uhf)write(mfgw,'(a)')'  alpha bands'
            call brlzon(f, fmat2d, norbs, sec, vec, alband,mono3,step,2)
         if(uhf)then
         write(mfgw,'(a)')'  beta bands'
         call brlzon(fb, fmat2d, norbs, sec, vec, alband,mono3,step,2)
         endif
         endif
         if(isybyl.eq.1)then
            nfilld=max(nclose,nalpha,nbeta)
            call mpcsyb(numat,coord,q2,1,eigs,nfilld,funct,eionis
     1                 ,kchrge,dip)
         endif
         if (index(keywrd,' fock') .ne. 0) then
            write(mfgw,'('' fock matrix is '')')
            call vecprt(f,norbs)
         endif
         if (index(keywrd,' dens') .ne. 0) then
            write(mfgw,'(//,20x,'' density matrix is '')')
            call vecprt(p,norbs)
         else
            write(mfgw,
     +      '(//10x,''atomic orbital electron populations'',/)')
            write(mfgw,'(8f10.5)')(p((i*(i+1))/2),i=1,norbs)
         endif
         if(index(keywrd,' pi') .ne. 0) then
            write(mfgw,'(//10x,''sigma-pi bond-order matrix'')')
            call denrot
         endif
         if(uhf) then
            sz=iabs(nalpha-nbeta)*0.5d0
            ss2=sz*sz
            l=0
            do 100 i=1,norbs
               do 90 j=1,i
                  l=l+1
                  pa(l)=pa(l)-pb(l)
   90          ss2=ss2+pa(l)**2
  100       ss2=ss2-0.5d0*pa(l)**2
            write(mfgw,'(//20x,''(sz)    ='',f10.6)')sz
            write(mfgw,'(  20x,''(s**2)  ='',f10.6)')ss2
            if(index(keywrd,' spin') .ne. 0) then
               write(mfgw,'(//10x,''spin density matrix'')')
               call vecprt(pa,norbs)
            else
               write(mfgw,
     +         '(//10x,''atomic orbital spin populations'',/)')
               write(mfgw,'(8f10.5)')(pa((i*(i+1))/2),i=1,norbs)
            endif
            if(index(keywrd,' hyperfine') .ne. 0) then
c
c  work out the hyperfine coupling constants.
c
               write(mfgw,
     +         '(//10x,''    hyperfine coupling coefficients'',/)')
               j=(nalpha-1)*norbs
               do 110 k=1,numat
                  i=nfirst(k)
c#          write(mfgw,'('' pa:'',f13.6,'' c('',i2,''+'',i3,''):'',
c#     +f13.5)')pa((i*(i+1))/2),i,j,c(i+j)
  110          q(k)=pa((i*(i+1))/2)*0.3333333d0+c(i+j)**2*0.66666666d0
               write(mfgw,'(5(2x,a2,i2,f9.5,1x))')
     1    (elemnt(nat(i)),i,q(i),i=1,numat)
            endif
            do 120 i=1,linear
  120       pa(i)=p(i)-pb(i)
         endif
         if (index(keywrd,' bonds') .ne. 0) then
            if(nbeta.eq.0)then
               write(mfgw,
     +         '(/10x,''bonding contribution of each m.o.'',/)')
               call molval(c,p,norbs,2.d0)
            else
               write(mfgw,
     +         '(/10x,''bonding contribution of each alpha m.o.'',/)')
               call molval(c,p,norbs,1.d0)
               write(mfgw,
     +         '(/10x,''bonding contribution of each beta  m.o.'',/)')
               call molval(c,p,norbs,1.d0)
            endif
            call bonds(p)
         endif
         i=nclose+nalpha
         if (index(keywrd,' local') .ne. 0) then
            call moplo(c,norbs,i,eigs)
            if(nbeta.ne.0)then
               write(mfgw,
     +         '(//10x,'' localized beta molecular orbitals'')')
               call moplo(cbeta,norbs,nbeta,eigb)
            endif
         endif
         if (index(keywrd,' 1ele') .ne. 0) then
            write(mfgw,'('' final one-electron matrix '')')
            call vecprt(h,norbs)
         endif
         if(index(keywrd,' enpart') .ne. 0)
     1call enpart(uhf,h,pa,pb,p,q,coord)
      endif
      do 130 i=1,107
  130 nelemt(i)=0
      do 140 i=1,numat
         igo=nat(i)
         if (igo.gt.107) go to 140
         nelemt(igo)=nelemt(igo)+1
  140 continue
      ichfor=0
      if (nelemt(6).eq.0) go to 150
      ichfor=1
      ielemt(1)=elemnt(6)
      nzs=nelemt(6)
      if (nzs.lt.10) then
         if (nzs.eq.1) then
            iel1(1)=11
         else
            iel1(1)=nzs+1
         endif
         iel2(1)=11
      else
         kfrst=nzs/10
         ksec=nzs-(10*kfrst)
         iel1(1)=kfrst+1
         iel2(1)=ksec+1
      endif
  150 nelemt(6)=0
      do 160 i=1,107
         if (nelemt(i).eq.0) go to 160
         ichfor=ichfor+1
         ielemt(ichfor)=elemnt(i)
         nzs=nelemt(i)
         if (nzs.lt.10) then
            if (nzs.eq.1) then
               iel1(ichfor)=11
            else
               iel1(ichfor)=nzs+1
            endif
            iel2(ichfor)=11
         else
            kfrst=nzs/10
            ksec=nzs-(10*kfrst)
            iel1(ichfor)=kfrst+1
            iel2(ichfor)=ksec+1
         endif
  160 continue
      if(index(keywrd,' denout') .ne. 0) then
_IF(ipsc,tools)
       if(oroot().and.odumpm) then
_ELSE
       if(odumpm) then
_ENDIF
         open(unit=10,file=getmop(4),
     +status='unknown',form='unformatted')
         rewind 10
         write(10)(pa(i),i=1,linear)
         if(uhf)write(10)(pb(i),i=1,linear)
         close (10)
       endif
      endif
      if((ci.or.nopen.ne.nclose.and.fract.ne.2.d0.and.fract.ne.0.d0
     1 .or.index(keywrd,' size').ne.0)
     2 .and. index(keywrd,' meci')+index(keywrd,' esr').ne.0)then
         write(mfgw,'(//10x,
     1''multi-electron configuration interaction calculation'',//)')
         last=3
         x=meci(eigs,c)
      endif
      if (index(keywrd,' mullik') +index(keywrd,' graph') .ne. 0) then
         if (index(keywrd,' mullik') .ne. 0)
     1   write(mfgw,'(/10x,'' mulliken population analysis'')')
      do 172 i=1,norbs
  172 q(i) = p((i*(i+1))/2)
         call mullik(c,h,f,norbs,p,rxyz)
      do 174 i=1,norbs
  174 p((i*(i+1))/2) = q(i)
         if (index(keywrd,' graph') .ne. 0)
     1   write(mfgw,'(/10x,'' data for graph written to disk'')')
      endif
c
c  note that the density, h and f matrices are corrupted by a
c  call to mullik.
      if(isybyl.eq.1) then
         if (index(keywrd,'mullik').eq.0) then
            call mpcpop(c,0)
         else
            call mpcpop(c,1)
         endif
         close(16)
      endif
      if(icalcn.ne.numcal)then
         if(namfil.eq.'**null**') then
         namfil=getmop(6)
         inam=ichar('a')
         jnam=inam
         jend=index(namfil,' ')
         iend=jend+1
         endif
  162    if(odumpm) close (12)
         if(odumpm) open(unit=12,file=namfil,status='new',err=163)
         goto 164
  163    namfil(iend:iend)=char(inam)
         namfil(jend:jend)=char(jnam)
         if(inam.eq.ichar('z'))then
         inam=inam-26
         jnam=jnam+1
         endif
         inam=inam+1
         goto 162
  164    if(odumpm) rewind 12
         icalcn=numcal
      endif
      if(index(keywrd,'greenf') .ne. 0) call greenf
      iwrite=12
      if(.not.odumpm) go to 2000
  170 write(iwrite,'(//20x,'' summary of '',a7,
     1'' calculation'',/)')caltyp
      write(iwrite,'(60x,''version '',f5.2)')verson
      write (iwrite,180) (ielemt(i),numbrs(iel1(i)),numbrs(iel2(i))
     1,i=1,ichfor)
  180 format (//,1x,17(a2,a1,a1))
      write(iwrite,'(55x,a24)')idate
      call wrttxt(iwrite)
      write(iwrite,'(//4x,a58)')flepo(iflepo)
      write(iwrite,'(4x,a58)')iter(iiter)
      write(iwrite,'(//10x,''heat of formation       =''
     1,f17.6,'' kcal'')')funct
      write(iwrite,'(  10x,''electronic energy       =''
     1,f17.6,'' ev'')')elect
      write(iwrite,'(  10x,''core-core repulsion     =''
     1,f17.6,'' ev'')')enuclr
      if(prtgra)
     1write(iwrite,'(  10x,''gradient norm           =''
     2,f17.6)')gnorm
      if(latom.eq.0) then
         if(.not.still) write(iwrite,'(a)')
     1' warning -- geometry is not at a stationary point'
      else
         grtype=' kcal/angstrom'
         if(lparam.eq.1)then
            write(iwrite,'(    10x,''for reaction coordinate ='',f17.4
     1        ,'' angstroms'')')xreact
         else
            if(na(1).ne.99)grtype=' kcal/radian  '
            write(iwrite,'(    10x,''for reaction coordinate ='',f17.4
     1        ,'' degrees'')')xreact*degree
         endif
         write(iwrite,'(    10x,''reaction gradient       ='',f17.6,a14
     1    )')gcoord,grtype
      endif
      write(iwrite,'(  10x,''dipole                  =''
     1,f16.5, '' debye'')')dip
      if(uhf) then
         write(iwrite,'(  10x,''(sz)                    ='',f17.6)')sz
         write(iwrite,'(  10x,''(s**2)                  ='',f17.6)')ss2
         write(iwrite,'(  10x,''no. of alpha electrons  ='',i10)')nalpha
         write(iwrite,'(  10x,''no. of beta  electrons  ='',i10)')nbeta
      else
         write(iwrite,'(  10x,''no. of filled levels    ='',i10)')
     1 nopen-nopn
         if(nopn.ne.0)
     1write(iwrite,'(  10x,''and no. of open levels  ='',i10)')nopn
      endif
      if(ci)
     1write(iwrite,'(  10x,''configuration interaction was used'')')
      if(kchrge.ne.0)
     1write(iwrite,'(  10x,''charge on system        ='',i10)')kchrge
      write(iwrite,'(  10x,''ionization potential    =''
     1,f17.6,'' ev'')')eionis
      write(iwrite,'(  10x,''molecular weight        ='',f14.3)')sumw
      write(iwrite,'(  10x,''scf calculations        =''
     1,i10)') nscf
      tim=secmop()-time0
      call moptim(iwrite,tim)
      write(iwrite,'(//10x,''final geometry obtained'',36x,''charge'')')
      call geout(iwrite)
      if(index(keywrd,' aigout').ne.0)then
         write(iwrite,'(//,a)')'  geometry in gaussian z-matrix style'
         call wrttxt(iwrite)
         call geoutg(iwrite,.false.)
      endif
      if(index(keywrd,' out=gamess').ne.0)then
        if(iwrite.ne.11) then
          write(iwrite,'(//10x,''cartesian coordinates '',/)')
          write(iwrite,*)'geometry mopac'
          do 2300 i=1,numat
2300      write(iwrite,2310)(coord(j,i),j=1,3),elemnt(nat(i))
2310      format( 10x,3f15.8,5x,a2)
          write(iwrite,*)'end'
        endif
         write(iwrite,'(//,a)')'  geometry in gamess z-matrix style'
         call wrttxt(iwrite)
         call geoutg(iwrite,.true.)
      endif
      if(iwrite.ne.11.and.index(keywrd,' nolog').eq.0)then
       if(index(keywrd,' out=gamess').ne.0 .and.
     +   index(keywrd,' vect') .ne. 0) then
            write(iwrite,'(//10x,a5,'' eigenvectors  '')')calcn(iuhf)
            call moppun(c,eigs,norbs,norbs,norbs,iwrite)
            if(uhf) then
               write(iwrite,'(//10x,'' beta eigenvectors  '')')
               call moppun(cbeta,eigb,norbs,norbs,norbs,iwrite)
            endif
       endif
       iwrite=11
       goto 170
      endif
2000  nscf=0
      return
      end
      subroutine wrtkey(keywrd)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
INCLUDE(../m4/common/utilc)
      character*241 keywrd, allkey
***********************************************************************
*
*  wrtkey checks all key-words and prints those it recognizes.  if it
*  finds a word it does not recognize the program will be stopped.
*
***********************************************************************
      common /numcal/ numcal
      common /timdmp/ tleft, tdump
      common /iofile/ mfgr,mfgw
      logical uhf, trip, birad, exci, ci, myword
      logical am1, mndo, mindo3, pm3
      character ch*1, chrono*7
      save am1, mndo, mindo3
      data am1, mndo, mindo3, pm3 /4*.false./
      allkey=keywrd
c    dummy if statement to remove ampersand and plus signs, if present
      if(myword(allkey(160:),' setup'))i=1
      if(myword(allkey,'&'))i=2
      if(myword(allkey,' +'))i=3
      if(myword(allkey,'author')) then
         write(mfgw,
     +   '(10x,'' mopac - a general molecular orbital package'',
     +/         ,10x,''   original version written in 1983'')')
         write(mfgw,'(10x,''     by james j. p. stewart at the'',/
     1         ,10x,''     university of texas at austin'',/
     2         ,10x,''          austin, texas, 78712'')')
      endif
      if (myword(allkey,'vect') ) write(mfgw,220)
      if (myword(allkey,' exte') ) then
         i=index(keywrd,' exte')
         j=index(keywrd(i:),'=')+i
         i=index(keywrd(j:),' ')+j-1
         write(mfgw,230)keywrd(j:i)
      endif
      maxgeo=0
      if (myword(allkey,' dens') ) write(mfgw,240)
      if (myword(allkey,'spin') ) write(mfgw,250)
      if (myword(allkey,' depvar') )
     1write(mfgw,260)reada(keywrd,index(keywrd,'depvar'))
      if (myword(allkey,' dep ') )write(mfgw,270)
      if (myword(allkey,'velo') )write(mfgw,280)
      if (myword(allkey,' greenf') ) write(mfgw,10)
   10 format(' *  green    - run danovich''s green''s function calcn.')
      if (myword(allkey,'times') )write(mfgw,290)
      if (myword(allkey,'parasok') ) write(mfgw,300)
      if (myword(allkey,'nodiis') ) write(mfgw,310)
c  *** following line added as noted
c  in qcpe bulletin vol. 11, no. 3, pp. 52-54 (1991).
      if (myword(allkey,'nothie') ) write(mfgw,305)
      if (myword(allkey,'bonds') ) write(mfgw,320)
      if (myword(allkey,' nodump') ) then
       write(mfgw,1275)
       odumpm = .false.
      endif
      if (myword(allkey,'geo-ok') ) write(mfgw,330)
      if (myword(allkey,'fock') ) write(mfgw,340)
      if (myword(allkey,'large') ) write(mfgw,350)
      if (myword(allkey,' k=') ) write(mfgw,360)
      if (myword(allkey,'nolog') ) write(mfgw,370)
      if (myword(allkey,'aigin') ) write(mfgw,380)
      if (myword(allkey,'in=gamess') ) write(mfgw,375)
      if (myword(allkey,'aigout') ) write(mfgw,390)
      if (myword(allkey,'out=gamess') ) write(mfgw,385)
      if (myword(allkey,'abinitio') ) write(mfgw,387)
      if (myword(allkey,'aider') ) write(mfgw,400)
      if (myword(allkey,' s1978') ) write(mfgw,410)
      if (myword(allkey,' si1978') ) write(mfgw,420)
      if (myword(allkey,' p1994') ) write(mfgw,430)
      if (myword(allkey,' grap') ) write(mfgw,440)
      if (myword(allkey,'noanci') ) write(mfgw,460)
      if (myword(allkey,'1elec') ) write(mfgw,450)
      if (myword(allkey(:162),' setup') ) write(mfgw,490)
      if (myword(allkey,' nomm') ) write(mfgw,480)
      if (myword(allkey,' mmok') ) write(mfgw,500)
      if (myword(allkey,'interp') ) write(mfgw,510)
      if (myword(allkey,' esr') ) write(mfgw,470)
      if (myword(allkey,'dfp') ) write(mfgw,520)
      if (myword(allkey,'analyt') ) write(mfgw,530)
      if (myword(allkey,' meci') ) write(mfgw,540)
      if (myword(allkey,'local') ) write(mfgw,580)
      if (myword(allkey,'mullik') ) write(mfgw,590)
      if (myword(allkey,' xyz') ) write(mfgw,600)
      if (myword(allkey,' pi') ) write(mfgw,610)
      if (myword(allkey,'echo') ) write(mfgw,620)
      if (myword(allkey, 'sing') ) write(mfgw,930)
      if (myword(allkey, 'doub') ) write(mfgw,940)
      if (myword(allkey, 'quar') ) write(mfgw,960)
      if (myword(allkey, 'quin') ) write(mfgw,970)
      if (myword(allkey, 'sext') ) write(mfgw,980)
      if (myword(allkey,'h-prio') ) write(mfgw,630)
      if (myword(allkey,'x-prio') ) write(mfgw,640)
      if (myword(allkey,'t-prio') ) write(mfgw,650)
      if (myword(allkey,'compfg') ) write(mfgw,670)
      if (myword(allkey,'polar') ) write(mfgw,660)
      if (myword(allkey,'debug ') ) write(mfgw,680)
      if (myword(allkey,'restart') ) write(mfgw,690)
c
c     keywords added for esp mopac
c
      if (myword(allkey,'esp ') ) write(mfgw,700)
      if (myword(allkey,'nsurf') ) write(mfgw,710)
      if (myword(allkey,'scale') ) write(mfgw,720)
      if (myword(allkey,'scincr') ) write(mfgw,730)
      if (myword(allkey,'slope') ) write(mfgw,740)
      if (myword(allkey,'dipole') ) write(mfgw,750)
      if (myword(allkey,'dipx') ) write(mfgw,760)
      if (myword(allkey,'dipy') ) write(mfgw,770)
      if (myword(allkey,'dipz') ) write(mfgw,780)
      if (myword(allkey,'connolly') ) write(mfgw,790)
      if (myword(allkey,'esprst') ) write(mfgw,800)
      if (myword(allkey,' potwrt') ) write(mfgw,810)
c
c     keywords added for cosmo mopac
c
      if (myword(allkey,'rsolv') ) write(mfgw,1640)
      if (myword(allkey,'eps') ) write(mfgw,1650)
      if (myword(allkey,'delsc') ) write(mfgw,1660)
      if (myword(allkey,'disex') ) write(mfgw,1670)
      if (myword(allkey,'nspa') ) write(mfgw,1680)
c
c                       keywords added for pmep by bingze wang aug 1993
c
      if (myword(allkey,' pmep ') ) write(mfgw,881)
      if (myword(allkey,' pmepr ') ) write(mfgw,891)
      if (myword(allkey,' prtmep') ) write(mfgw,911)
      if (myword(allkey,' minmep') ) write(mfgw,921)
      if (myword(allkey,' qpmep ') ) then
         write(mfgw,901)
         if (myword(allkey,' williams') ) write(mfgw,931)
      endif
c                                       end of pmep addition by b wang
      if (myword(allkey,'williams') ) write(mfgw,820)
      if (myword(allkey,'symavg') ) write(mfgw,830)
      if (myword(allkey,'sto3g') ) write(mfgw,840)
      if (myword(allkey,'iupd')) then
         ii=nint(reada(keywrd,index(keywrd,'iupd=')))
         if (ii.eq.0) write(mfgw,100)
         if (ii.eq.1) write(mfgw,110)
         if (ii.eq.2) write(mfgw,120)
      endif
      if (myword(allkey,'hess')) then
         ii=nint(reada(keywrd,index(keywrd,'hess=')))
         if (ii.eq.0) write(mfgw,130)
         if (ii.eq.1) write(mfgw,140)
         if (ii.eq.2) write(mfgw,150)
         if (ii.eq.3) write(mfgw,160)
      endif
      if (myword(allkey,' mode')) write(mfgw,170)
     1 nint(reada(keywrd,index(keywrd,'mode=')))
      if (myword(allkey,' recalc')) write(mfgw,180)
     1 nint(reada(keywrd,index(keywrd,'recalc')))
      if (myword(allkey,' dmax')) write(mfgw,190)
     1 reada(keywrd,index(keywrd,'dmax='))
      if (myword(allkey,' ms=')) write(mfgw,200)
     1 nint(reada(keywrd,index(keywrd,' ms=')))
      if (myword(allkey,' prnt')) write(mfgw,210)
      if (myword(allkey,'irc=') ) then
         maxgeo=1
      write(mfgw,850)nint(reada(keywrd,index(keywrd,'irc=')))
      elseif (myword(allkey,'irc') ) then
         maxgeo=1
         write(mfgw,860)
      endif
      if (myword(allkey,'charge') )
     1 write(mfgw,870)
     + nint(reada(keywrd,index(keywrd,'charge')))
      if (myword(allkey,'grad') ) write(mfgw,880)
      uhf=(myword(allkey,'uhf') )
      if(uhf)write(mfgw,890)
      birad=(myword(allkey,'birad') )
      if(birad)write(mfgw,910)
      exci=(myword(allkey,'excited') )
      if(exci) write(mfgw,920)
      trip=(myword(allkey,'trip') )
      if(trip)write(mfgw,950)
      if (myword(allkey,'sym') ) write(mfgw,990)
      if (myword(allkey,' group') ) then
         write(mfgw,1000)
         if (myword(allkey,' rmat') )    write(mfgw,1010)
         if (myword(allkey,' ipo') )     write(mfgw,1020)
         if (myword(allkey,' nodegen') ) write(mfgw,1030)
      endif
      if (myword(allkey,' rmat') ) then
         write(mfgw,'(//,10x,''rmat must be specified with '',
     1   ''group'')')
_IF(ipsc,tools)
         call pend
_ELSE
         stop
_ENDIF
      endif
      if (myword(allkey,' ipo') ) then
         write(mfgw,'(//,10x,''ipo must be specified with '',
     1   ''group'')')
_IF(ipsc,tools)
         call pend
_ELSE
         stop
_ENDIF
      endif
      if (myword(allkey,' nodegen') ) then
         write(mfgw,'(//,10x,''nodegen must be specified with '',
     1   ''group'')')
_IF(ipsc,tools)
         call pend
_ELSE
         stop
_ENDIF
      endif
      if(myword(allkey,'open('))then
         i=index(keywrd,'open(')
         ielec=reada(keywrd,i)
         ilevel=reada(keywrd,i+7)
         write(mfgw,1050)ielec,ilevel
      endif
      if(myword(allkey,'micros'))
     1write(mfgw,1040)int(reada(keywrd,index(keywrd,'micros')))
      if(myword(allkey,'drc='))then
         maxgeo=1
         write(mfgw,560)reada(keywrd,index(keywrd,'drc='))
      elseif (myword(allkey,' drc') ) then
         maxgeo=1
         write(mfgw,550)
      endif
      if(myword(allkey,'kine'))
     1write(mfgw,570)reada(keywrd,index(keywrd,'kine'))
      chrono='seconds'
      time=1
      if(myword(allkey,' t=')) then
         i=index(keywrd,' t=')
         tleft=reada(keywrd,i)
         do 20 j=i+3,241
            if( j.eq.241.or.keywrd(j+1:j+1).eq.' ') then
               ch=keywrd(j:j)
               if( ch .eq. 'm') chrono='minutes'
               if( ch .eq. 'm') time=60
               if( ch .eq. 'h') chrono='hours'
               if( ch .eq. 'h') time=3600
               if( ch .eq. 'd') chrono='days'
               if( ch .eq. 'd') time=86400
               goto 30
            endif
   20    continue
   30    continue
         if(tleft.lt.99999.9d0)then
            write(mfgw,1060)tleft,chrono
         else
            write(mfgw,1070)tleft,chrono
         endif
         tleft=tleft*time
      elseif(numcal.eq.1)then
         tleft=maxtim
         write(mfgw,1060)tleft,'seconds'
      else
         write(mfgw,1060)tleft,'seconds'
      endif
      time=1
      chrono='seconds'
      if(myword(allkey,' dump')) then
         i=index(keywrd,' dump')
         tdump=reada(keywrd,i)
         do 40 j=i+6,241
            if( j.eq.241.or.keywrd(j+1:j+1).eq.' ') then
               ch=keywrd(j:j)
               if( ch .eq. 'm') chrono='minutes'
               if( ch .eq. 'm') time=60.d0
               if( ch .eq. 'h') chrono='hours'
               if( ch .eq. 'h') time=3600.d0
               if( ch .eq. 'd') chrono='days'
               if( ch .eq. 'd') time=86400.d0
               goto 50
            endif
   40    continue
   50    continue
         if(tdump.lt.99999.9d0)then
            write(mfgw,1080)tdump,chrono
         else
            write(mfgw,1090)tdump,chrono
         endif
         tdump=tdump*time
      elseif(numcal.eq.1)then
         tdump=maxdmp
         write(mfgw,1080)tdump,'seconds'
      else
         write(mfgw,1080)tdump,'seconds'
      endif
      if (myword(allkey,'1scf') ) then
         write(mfgw,1100)
         if(index(keywrd,'restart').eq.0)maxgeo=maxgeo+1
      endif
      ci=myword(allkey,'c.i.')
      if (ci) then
         j=index(keywrd,'c.i.=(')
         if(j.ne.0)then
            write(mfgw,1120)
     +      int(reada(keywrd,index(keywrd,'c.i.=(')+7)),
     1      int(reada(keywrd,index(keywrd,'c.i.=(')+5))
         else
            write(mfgw,1110)
     +      int(reada(keywrd,index(keywrd,'c.i.')+5))
         endif
      endif
      if (myword(allkey,' force') ) then
         write(mfgw,1130)
         maxgeo=maxgeo+1
      endif
      if (myword(allkey,' ef')) then
         write(mfgw,80)
         maxgeo=maxgeo+1
      endif
      if (myword(allkey,' ts')) then
         write(mfgw,90)
         maxgeo=maxgeo+1
      endif
      method=0
      if (myword(allkey,'mindo') ) then
         write(mfgw,1140)
         mindo3=.true.
         method=1
      endif
      if (myword(allkey,'am1') ) then
         write(mfgw,1150)
         am1=.true.
         method=method+1
      endif
      if (myword(allkey,'pm3') ) then
         write(mfgw,1160)
         pm3=.true.
         method=method+1
      endif
      if (myword(allkey,'mndo') ) then
         mndo=.true.
         method=method+1
      endif
      if (myword(allkey,'oldgeo') ) write(mfgw,1180)
      if (myword(allkey,'prec') ) write(mfgw,1170)
      if (myword(allkey,'nointer') ) write(mfgw,1190)
      if (myword(allkey,'isotope') ) write(mfgw,1200)
      if (myword(allkey,'denout') ) write(mfgw,1210)
      if (myword(allkey,'shift') ) write(mfgw,1220)
     1 reada(keywrd,index(keywrd,'shift'))
      if (myword(allkey,'oldens') ) write(mfgw,1230)
      if (myword(allkey,'scfcrt') ) write(mfgw,1240)
     1 reada(keywrd,index(keywrd,'scfcrt'))
      if (myword(allkey,'enpart') ) write(mfgw,1250)
      if (myword(allkey,'noxyz') ) write(mfgw,1260)
      if (myword(allkey,'sigma') ) then
         write(mfgw,1270)
         maxgeo=maxgeo+1
      endif
      if (myword(allkey,'nllsq') ) then
         write(mfgw,1280)
         maxgeo=maxgeo+1
      endif
      if (myword(allkey,'root') ) write(mfgw,1290)
     1 nint(reada(keywrd,index(keywrd,'root')))
      if (myword(allkey,'trans=') ) then
         write(mfgw,1310)
     +   nint(reada(keywrd,index(keywrd,'trans=')))
      elseif (myword(allkey,'trans') ) then
         write(mfgw,1300)
      endif
      if (myword(allkey,'saddle') ) then
         write(mfgw,1320)
         maxgeo=maxgeo+1
      endif
      if (myword(allkey,' let') ) write(mfgw,1330)
      if (myword(allkey,'compfg') ) write(mfgw,1340)
      if (myword(allkey,'gnorm') ) write(mfgw,1350)
     1 reada(keywrd,index(keywrd,'gnorm'))
      if (myword(allkey,'pulay') ) write(mfgw,1360)
      if (myword(allkey,' step1')  )write(mfgw,1370)
     1 reada(keywrd,index(keywrd,'step1')+6)
      if (myword(allkey,' step2')  )write(mfgw,1380)
     1 reada(keywrd,index(keywrd,'step2')+6)
      if (myword(allkey,' step')  )write(mfgw,1570)
     1 reada(keywrd,index(keywrd,'step')+5)
      if (myword(allkey,' point1')  )then
         ip1=reada(keywrd,index(keywrd,'point1')+7)
         write(mfgw,1390) ip1
      endif
      if (myword(allkey,' point2')  )then
         ip2=reada(keywrd,index(keywrd,'point2')+7)
         write(mfgw,1400) ip2
      endif
      if (myword(allkey,' max') ) write(mfgw,1410)
      if (myword(allkey,' point')  )then
         ip=reada(keywrd,index(keywrd,'point')+6)
         write(mfgw,1580) ip
      endif
      if (myword(allkey,'bar') ) write(mfgw,1420)
     1 reada(keywrd,index(keywrd,'bar'))
      if (myword(allkey,'camp') ) write(mfgw,1430)
      if (myword(allkey,'king') ) write(mfgw,1430)
      if (myword(allkey,'eigs') ) write(mfgw,1440)
      if (myword(allkey,'eiginv') ) write(mfgw,1450)
      if (myword(allkey,'nonr') ) write(mfgw,1460)
      if (myword(allkey,'oride') ) write(mfgw,1470)
      if (myword(allkey,'hyperf') ) write(mfgw,1480)
      if (myword(allkey,' pl') ) write(mfgw,1490)
      if (myword(allkey,'fill') ) write(mfgw,1500)
     1 nint(reada(keywrd,index(keywrd,'fill')))
      if (myword(allkey,'itry') ) write(mfgw,1540)
     1 nint(reada(keywrd,index(keywrd,'itry')))
      if (myword(allkey,'0scf') ) write(mfgw,1560)
      if(uhf)then
         if(birad.or.exci.or.ci)then
            write(mfgw,'(//10x,
     1'' uhf used with either birad, excited or c.i. '')')
            write(mfgw,1550)
            goto 70
         endif
      else
         if(exci.and. trip) then
            write(mfgw,'(//10x,'' excited used with triplet'')')
            write(mfgw,1550)
            goto 70
         endif
      endif
      if (index(keywrd,'t-prio').ne.0.and.
     1index(keywrd,'drc').eq.0) then
         write (mfgw,'(//10x,''t-prio and no drc'')')
         write (mfgw,1550)
         goto 70
      endif
      if ( method .gt. 1) then
         write(mfgw,'(//10x,
     1'' only one of mindo, mndo, am1 and pm3 allowed'')')
         write (mfgw,1550)
         goto 70
      endif
c     patas
      if (myword(allkey,'mep=')) then
         i=nint(reada(keywrd,index(keywrd,'mep=')))
         if (i.eq.1) then
            write(mfgw,1590)
         else
            write(mfgw,1600)
         endif
      endif
      if (myword(allkey,'ort')) write(mfgw,1610)
      if (myword(allkey,'tom')) write(mfgw,1620)
      if (myword(allkey,'jiali')) write(mfgw,1630)
c     patas
      if (myword(allkey,' field') )then
         write(mfgw,1510)
      endif
      if (myword(allkey,'thermo') )then
         write(mfgw,1520)
         if(myword(allkey,' rot')) then
            write(mfgw,1530)
     +      nint(reada(keywrd,index(keywrd,' rot')))
         else
            write(mfgw,'
     1    (//10x,'' you must supply the symmetry number "rot"'')')
_IF(ipsc,tools)
            call pend
_ELSE
            stop
_ENDIF
         endif
      endif
      if(maxgeo.gt.1)then
         write(mfgw,
     +   '(//10x,''more than one geometry option has been '',
     1''specified'',/10x,
     2''conflict must be resolved before job will run'')')
_IF(ipsc,tools)
         call pend
_ELSE
         stop
_ENDIF
      endif
      if(index(keywrd,'mullik').ne.0.and.uhf)then
         write(mfgw,'(a)')
     +   ' mulliken population not available with uhf'
_IF(ipsc,tools)
         call pend
_ELSE
         stop
_ENDIF
      endif
      if(allkey.ne.' ')then
         j=0
         do 60 i=1,240
            if(allkey(i:i).ne.' '.or.allkey(i:i+1).ne.'  ')then
               j=j+1
               ch=allkey(i:i)
               allkey(j:j)=ch
            endif
   60    continue
         if(allkey(241:241).ne.' ')then
            j=j+1
            ch=allkey(241:241)
            allkey(j:j)=ch
         endif
         j=max(1,j)
         l=index(keywrd,'debug')
         if(l.ne.0)then
            write(mfgw,'('' *  debug keywords used:  '',a)')allkey(:j)
         else
            write(mfgw,
     +      '(///10x,''unrecognized key-words: ('',a,'')'')')
     1allkey(:j)
            write(mfgw,
     +      '(///10x,''calculation stopped to avoid wasting time.'')')
            write(mfgw,'(///10x,
     +      ''if these are debug keywords, add the keyword "debug"'')')
_IF(ipsc,tools)
            call pend
_ELSE
            stop
_ENDIF
         endif
      endif
      return
   70 write(mfgw,'(//10x,'' calculation abandoned, sorry!'')')
_IF(ipsc,tools)
         call pend
_ELSE
         stop
_ENDIF
c ***********************************************************
c ***********************************************************
   80 format(' *  ef       - use ef routine for minimum search')
   90 format(' *  ts       - use ef routine for ts search')
  100 format(' *  iupd=    - hessian will not be updated')
  110 format(' *  iupd=    - hessian will be updated using powell')
  120 format(' *  iupd=    - hessian will be updated using bfgs')
  130 format(' *  hess=    - diagonal hessian used as initial guess')
  140 format(' *  hess=    - initial hessian will be calculated')
  150 format(' *  hess=    - initial hessian read from disk')
  160 format(' *  hess=    - initial hessian read from input')
  170 format(' *  mode=    - follow hessian mode',i3,' toward ts')
  180 format(' *  recalc=  - do',i4,' cycles between hessian recalc')
  190 format(' *  dmax=    - take maximum stepsize of',f5.3,' ang/rad')
  200 format(' *  ms=      - in meci, magnetic component of spin =',i3)
  210 format(' *  prnt     - extra printing in ef routine')
c ***********************************************************
  220 format(' *  vectors  - final eigenvectors to be printed')
  230 format(' *  external - use atomic parameters from the following '
     1,'file',/15x,a)
  240 format(' *  density  - final density matrix to be printed')
  250 format(' *  spin     - final uhf spin matrix to be printed')
  260 format(' *  depvar=n - specified distance is',f7.4,
     1' times bond length')
  270 format(' *  dep      - output fortran code for block-data')
  280 format(' *  velocity - input starting velocities for drc')
  290 format(' *  times    - times of various stages to be printed')
  300 format(' *  parasok  - use some mndo parameters in an am1 calcula'
     1,'tion')
c  *** following line added as noted
c  in qcpe bulletin vol. 11, no. 3, pp. 52-54 (1991).
  305 format(' *  nothiel  - do not use thiel''s fstmin option')
  310 format(' *  nodiis   - do not use gdiis geometry optimizer')
  320 format(' *  bonds    - final bond-order matrix to be printed')
  330 format(' *  geo-ok   - override interatomic distance check')
  340 format(' *  fock     - last fock matrix to be printed')
  350 format(' *  large    - expanded output to be printed')
  360 format(' *   k=      - brillouin zone structure to be calculated')
  370 format(' *  nolog    - suppress log file trail, where possible')
  380 format(' *  aigin    - geometry must be in gaussian format')
  375 format(' *  in=gamess- geometry must be in gamess format')
  390 format(' *  aigout   - in arc file, include ab-initio geometry')
  385 format(' *  out=gamess - in arc file, include gamess geometry')
  387 format(' *  abinitio - mopac run + abinitio calculation')
  400 format(' *  aider    - read in ab initio derivatives')
  410 format(' *  s1978    - 1978 sulfur parameters to be used')
  420 format(' *  si1978   - 1978 silicon parameters to be used')
  430 format(' *  p1994    - the alternate set of am1 phosphorus ',
     1'parameters to be used')
  440 format(' *  graph    - generate file for graphics')
  450 format(' *  1electron- final one-electron matrix to be printed')
  460 format(' *  noanci   - do not use analytical c.i. derivatives')
  470 format(' *  esr      - rhf spin density calculation requested')
  480 format(' *  nomm     - do not make mm correction to conh barrier')
  490 format(' *  setup    - extra keywords to be read from file setup')
  500 format(' *  mmok     - apply mm correction to conh barrier')
  510 format(' *  interp   - print details of camp-king converger')
  520 format(' *  dfp      - use davidon fletcher powell optimizer')
  530 format(' *  analyt   - use analytic derivatives ')
  540 format(' *  meci     - m.e.c.i. working to be printed')
  550 format(' *  drc      - dynamic reaction coordinate calculation')
  560 format(' *  drc=     - half-life for kinetic energy loss =',f9.2,
     1' * 10**(-15) seconds')
  570 format(' *  kinetic= - ',f9.3,' kcal kinetic energy added to drc')
  580 format(' *  localize - localized orbitals to be printed')
  590 format(' *  mullik   - the mulliken analysis to be performed')
  600 format(' *   xyz     - cartesian coordinate system to be used')
  610 format(' *   pi      - bonds matrix, split into sigma-pi-dell',
     1' components, to be printed')
  620 format(' *  echo     - all input data to be echoed before run')
  630 format(' *  h-prior  - heat of formation takes priority in drc')
  640 format(' *  x-prior  - geometry changes take priority in drc')
  650 format(' *  t-prior  - time takes priority in drc')
  660 format(' *  polar    - calculate first, second and third-order'
     1,' polarizabilities')
  670 format(' *  compfg   - print heat of formation calc''d in compfg')
  680 format(' *  debug    - debug option turned on')
  690 format(' *  restart  - calculation restarted')
c
c     keywords added for esp mopac
c
  700 format(' *  esp      - electrostatic potential calculation')
  710 format(' *  nsurf    - number of layers')
  720 format(' *  scale    - scaling factor for van der waals distance')
  730 format(' *  scincr   - increment between layers')
  740 format(' *  slope    - slope - used to scale mndo esp charges')
  750 format(' *  dipole   - fit the esp to the calculated dipole')
  760 format(' *  dipx     - x component of dipole to be fit')
  770 format(' *  dipy     - y component of dipole to be fit')
  780 format(' *  dipz     - z component of dipole to be fit')
  790 format(' *  connolly - use connolly surface')
  800 format(' *  esprst   - restart of electric potential calculation')
  810 format(' *  potwrt   - write out electric pot. data to file 21')
  820 format(' *  williams - use williams surface')
  830 format(' *  symavg   - average symmetry equivalent esp charges')
  840 format(' *  sto3g    - deorthogonalize orbitals in sto-3g basis')
  850 format(' *  irc=n    - intrinsic reaction coordinate',i3,
     1' defined')
  860 format(' *  irc      - intrinsic reaction coordinate calculation')
  870 format(3(' *',/),' *',15x,'  charge on system =',i3,3(/,' *'))
  880 format(' *  gradients- all gradients to be printed')
  890 format(' *  uhf      - unrestricted hartree-fock calculation')
  881 format(' *  pmep     - complete semiempirical mep calculation')
  891 format(' *  pmepr    - complete semiempirical mep in a plane to',
     1                       ' be defined')
  901 format(' *  qpmep    - charges derived from wang-ford type am1',
     1                       ' mep')
  911 format(' *  prtmep   - mep contour data output to <filename>.mep')
  921 format(' *  minmep   - minimize mep minima in the plane defined')
  931 format(' *  williams - use williams surface')
  900 format(' *  singlet  - state required must be a singlet')
  910 format(' *  biradical- system has two unpaired electrons')
  920 format(' *  excited  - first excited state is to be optimized')
  930 format(' *  singlet  - spin state defined as a singlet')
  940 format(' *  doublet  - spin state defined as a doublet')
  950 format(' *  triplet  - spin state defined as a triplet')
  960 format(' *  quartet  - spin state defined as a quartet')
  970 format(' *  quintet  - spin state defined as a quintet')
  980 format(' *  sextet   - spin state defined as a sextet')
  990 format(' *  symmetry - symmetry conditions to be imposed')
 1000 format(' *  group    - frequencies to be symmetrized')
 1010 format(' *  rmat     - print r matrices')
 1020 format(' *  ipo      - print permutation operator')
 1030 format(' *  nodegen  - do not collapse degenerate frequencies')
 1040 format(' *  micros=n -',i4,' microstates to be supplied for c.i.')
 1050 format(' *  open(n,n)- there are',i2,' electrons in',i2,' levels')
 1060 format(' *   t=      - a time of',f8.1,' ',a7,' requested')
 1070 format(' *   t=      - a time of',g11.3,' ',a7,' requested')
 1080 format(' *  dump=n   - restart file written every',f8.1,
     1' ',a7)
 1090 format(' *  dump=n   - restart file written every',g11.3,
     1' ',a7)
 1100 format(' *  1scf     - do 1 scf and then stop ')
 1110 format(' *  c.i.=n   -',i2,' m.o.s to be used in c.i.')
 1120 format(' * c.i.=(n,m)-',i2,' doubly filled levels used in a ',/
     1,      ' *             c.i. involving ',i2,' m.o.''s')
 1130 format(' *  force    - force calculation specified')
 1140 format(' *  mindo/3  - the mindo/3 hamiltonian to be used')
 1150 format(' *  am1      - the am1 hamiltonian to be used')
 1160 format(' *  pm3      - the pm3 hamiltonian to be used')
 1170 format(' *  precise  - criteria to be increased by 100 times')
 1180 format(' *  oldgeo   - previous geometry to be used')
 1190 format(' *  nointer  - interatomic distances not to be printed')
 1200 format(' *  isotope  - force matrix written to disk (chan. 9 )')
 1210 format(' *  denout   - density matrix output on channel 10')
 1220 format(' *  shift    - a damping factor of',f8.2,' defined')
 1230 format(' *  oldens   - initial density matrix read of disk')
 1240 format(' *  scfcrt   - default scf criterion replaced by',g12.3)
 1250 format(' *  enpart   - energy to be partitioned into components')
 1260 format(' *  noxyz    - cartesian coordinates not to be printed')
 1270 format(' *  sigma    - geometry to be optimized using sigma.')
 1275 format(' *  nodump   - suppress writing of restart files')
 1280 format(' *  nllsq    - gradients to be minimized using nllsq.')
 1290 format(' *  root     - in a c.i. calculation, root',i2,
     1                       ' to be optimized.')
 1300 format(' *  trans    - the reaction vibration to be deleted from',
     1' the thermo calculation')
 1310 format(' *  trans=   - ',i4,' vibrations are to be deleted from',
     1' the thermo calculation')
 1320 format(' *  saddle   - transition state to be optimized')
 1330 format(' *   let     - override some safety checks')
 1340 format(' *  compfg   - print heat of formation calc''d in compfg')
 1350 format(' *  gnorm=   - exit when gradient norm drops below ',g8.3)
 1360 format(' *  pulay    - pulay''s method to be used in scf')
 1370 format(' *  step1    - first  step-size in grid =',f7.2)
 1380 format(' *  step2    - second step-size in grid =',f7.2)
 1390 format(' *  point1   - number of rows in grid =',i3)
 1400 format(' *  point2   - number of columns in grid =',i3)
 1410 format(' *  max      - grid size 23*23 ')
 1420 format(' *  bar=     - reduce bar length by a max. of',f7.2)
 1430 format(' *  camp,king- the camp-king converger to be used')
 1440 format(' *  eigs     - print all eigenvalues in iter')
 1450 format(' *  eiginv   - use hessian eigenvalue reversion in ef')
 1460 format(' *  nonr     - do not use newton-raphson step in ef')
 1470 format(' *  oride    - unconditionally, use calculated lamdas in'
     1//' ef')
 1480 format(' *  hyperfine- hyperfine coupling constants to be'
     1,' printed')
 1490 format(' *   pl      - monitor convergance in density matrix')
 1500 format(' *  fill=    - in rhf closed shell, force m.o.',i3,' to be
     1 filled')
 1510 format(' *  field    - apply a static electric field')
 1520 format(' *  thermo   - thermodynamic quantities to be calculated')
 1530 format(' *  rot      - symmetry number of',i3,' specified')
 1540 format(' *  itry=    - do a maximum of',i6,' iterations for scf')
 1550 format( //10x,' impossible option requested,')
 1560 format(' *  0scf     - after reading and printing data, stop')
 1570 format(' *  step     - step-size in path=',f7.3)
 1580 format(' *  point    - number of points in path=',i3)
c     patas
 1590 format(' *  mep=1    - mep in a cubic grid')
 1600 format(' *  mep=2    - mep in connolly surface')
 1610 format(' *  ort      - reynolds-richards mep')
c     keywords for miertus-scrocco-tomasi model
 1620 format(' *  tom      - miertus-scrocco-tomasi solvation model')
 1630 format(' *  jiali    - details of mst computation')
c     patas
c     cosmo
 1640 format(' *  rsolv    - effective van der waals radius of solvent')
 1650 format(' *  eps      - dielectric constant of solvent')
 1660 format(' *  delsc    - effective charge radius of solvent')
 1670 format(' *  disex    - distance of solvent interaction')
 1680 format(' *  nspa     - number of segments per atom')
c     cosmo
      end
      subroutine wrttxt(iprt)
      common /keywrd/ keywrd
      common /titles/ koment,title
      character keywrd*241, koment*81, title*81
      do 10 i=81,2,-1
   10 if(keywrd(i:i).ne.' ')goto 20
   20 write(iprt,'(a)')keywrd(:i)
      if(index(keywrd(1:81),' +')+index(keywrd(1:81),'&')+
     1index(keywrd,'setup').ne.0) then
         do 30 i=161,82,-1
   30    if(keywrd(i:i).ne.' ')goto 40
   40    if(keywrd(81:81).ne.' ')then
            write(iprt,'(1x,a)')keywrd(81:i)
         else
            write(iprt,'(a)')keywrd(81:i)
         endif
      endif
      if(index(keywrd(81:241),' +')+index(keywrd(81:241),'&') +
     1index(keywrd,'setup').ne.0) then
         do 50 i=241,161,-1
   50    if(keywrd(i:i).ne.' ')goto 60
   60    if(keywrd(161:161).ne.' ')then
            write(iprt,'(1x,a)')keywrd(161:i)
         else
            write(iprt,'(a)')keywrd(161:i)
         endif
      endif
      do 70 i=81,2,-1
   70 if(koment(i:i).ne.' ')goto 80
   80 if(index(koment,' null ').eq.0)write(iprt,'(a)')koment(:i)
      do 90 i=81,2,-1
   90 if(title(i:i).ne.' ')goto 100
  100 if(index(title,' null ').eq.0)write(iprt,'(a)')title(:i)
      end
      subroutine xxx(type,i,j,k,l,r)
      character type*1, r*(*)
************************************************************************
*
*    xxx will form a unique string label 'r' for gaussian-type input
*    the label will be letter (either r, p, or f, normally), followed
*    by the connectivity, in the order i, j, k, l.
*    'r' is 13 characters long in order to accommodate 3 digits per
*    label, when necessary
*
************************************************************************
      dimension ijk(4)
      r=type
      ijk(1)=i
      ijk(2)=j
      ijk(3)=k
      ijk(4)=l
      m=1
      do 10 loop=1,4
         ii=ijk(loop)
         if(ii.eq.0) goto 10
c
c   if labels greater than 99 are used, uncomment the following code
c
c#         i2=ii/100
c#         if(i2.ne.0) then
c#            m=m+1
c#            r(m:m)=char(ichar('0')+i2)
c#            ii=ii-i2*100
c#         endif
         i2=ii/10
         if(i2.ne.0) then
            m=m+1
            r(m:m)=char(ichar('0')+i2)
            ii=ii-i2*10
         endif
         m=m+1
         r(m:m)=char(ichar('0')+ii)
   10 continue
      return
      end
      subroutine xyzgeo(xyz,numat,na,nb,nc,degree,geo)
      implicit REAL (a-h,o-z)
      dimension xyz(3,*), na(*), nb(*), nc(*), geo(3,*)
***********************************************************************
*
*   xyzgeo converts coordinates from cartesian to internal.
*
*     on input xyz  = array of cartesian coordinates
*              numat= number of atoms
*              na   = numbers of atom to which atoms are related
*                     by distance
*              nb   = numbers of atom to which atoms are related
*                     by angle
*              nc   = numbers of atom to which atoms are related
*                     by dihedral
*
*    on output geo  = internal coordinates in angstroms, radians,
*                     and radians
*
***********************************************************************
      do 30 i=2,numat
         j=na(i)
         k=nb(i)
         l=nc(i)
         if(i.lt.3) goto 30
         ii=i
         call bangle(xyz,ii,j,k,geo(2,i))
         geo(2,i)=geo(2,i)*degree
         if(i.lt.4) goto 30
c
c   make sure dihedral is meaninglful
c
         call bangle(xyz,j,k,l,angl)
         tol=0.2617994d0
         if(angl.gt.3.1415926d0-tol.or.angl.lt.tol)then
c
c  angle is unsatisfactory, let's search for another atom for
c  defining the dihedral.
   10       sum=100.d0
            do 20 i1=1,ii-1
               r=(xyz(1,i1)-xyz(1,k))**2+
     1          (xyz(2,i1)-xyz(2,k))**2+
     2          (xyz(3,i1)-xyz(3,k))**2
               if(r.lt.sum.and.i1.ne.j.and.i1.ne.k) then
                  call bangle(xyz,j,k,i1,angl)
                  if(angl.lt.3.1415926d0-tol.and.angl.gt.tol)then
                     sum=r
                     l=i1
                     nc(ii)=l
                  endif
               endif
   20       continue
            if(sum.gt.99.d0.and.tol.gt.0.1d0)then
c
c anything within 5 degrees?
c
               tol=0.087266d0
               goto 10
            endif
         endif
         call dihed(xyz,ii,j,k,l,geo(3,i))
         geo(3,i)=geo(3,i)*degree
   30 geo(1,i)= dsqrt((xyz(1,i)-xyz(1,j))**2+
     1                   (xyz(2,i)-xyz(2,j))**2+
     2                   (xyz(3,i)-xyz(3,j))**2)
      geo(1,1)=0.0d0
      geo(2,1)=0.0d0
      geo(3,1)=0.0d0
      geo(2,2)=0.0d0
      geo(3,2)=0.0d0
      geo(3,3)=0.0d0
      return
      end
_IF(ipsc,tools)
_IF(tools)
      function cpulft(i)
      implicit REAL  (a-h,p-w),integer    (i-n),logical    (o)
      implicit character *8 (z),character *1 (x)
      implicit character *4 (y)
      common/timez/timemx,timlim(11),isec
c
c ------ return the clock time in seconds if i=1
c ------        the cpu time remaining if i=0
c
_IF(rs6000)
      ak = dfloat(mclock() ) / 100.0d0
_ELSE
      real*4 etime,t4(2)
      dum = etime(t4)
      ak=t4(1)
_ENDIF
      if(i.eq.1) then
        cpulft=ak
      else if(i.eq.0) then
        cpulft=timemx-ak
c
c  if file STOP exists kill GAMESS orderly
c
         inquire(file='STOP',exist=oex)
         if (oex) cpulft = 0.5d0
      else
       write(6,*) ' called cpulft with invalid i ',i,' returning 0'
       cpulft = 0.0d0
      endif
      return
      end
      subroutine ininod
c
c...  set few parameters needed in node proces
c
      REAL  tgoptm,tfndtm,tgettm,tputtm
      common/nodinf/mpid,minode,mihost,ldim,nnode,noddim
      common/nodtim/ tgoptm,topen(10),tfndtm(10),tgettm(10),tputtm(10)
      parameter (nreal=8,nint=4,iroot=0)
c
      mpid = 0
      minode = nodeid()
      mihost = 0
      nnode = nnodes()
      noddim = 1
c
      tgoptm = 0.0d0
      do 100 loop=1,10
      topen (loop) = 0.0d0
      tfndtm(loop) = 0.0d0
      tgettm(loop) = 0.0d0
100   tputtm(loop) = 0.0d0
c
      return
      end
      subroutine initia
      implicit REAL  (a-h,p-w),integer   (i-n),logical    (o)
      implicit character *8 (z),character *1 (x)
      implicit character *4 (y)
      character*20 fname
      common/iofile/iread,iwr
INCLUDE(../m4/common/utilc)
      common/timez/timlim(12),isec
      common/prints/oprntd(60)
c
c
c***   ***MPP***
      common/nodinf/mpid,minode,mihost,ldim,nnodes,nodscr
c***   ***MPP***
      opnode = .false.
      odumpm = .false.
      call ininod
      iwr = 6
      iread = 5
      opkill=.true.
      oprntd(28)=.true.
c
c...  set iwr to 94 to seperate output of nodes
c
      if (.not.oroot()) then
         iwr = 94
c...      different numbers are not needed / different names are
c...      if no node output is requested send it to sink
         nn = 100+minode
         write(fname,'(a,i3)') 'out_mopac_',nn
c        if (opkill) oprnts(60) = .false.
         if (opnode) then
          open(iwr,form='formatted',file=fname,err=9998)
         else
          open(iwr,form='formatted',file='/dev/null',err=9998)
         endif
c
      end if
      call synch(88888)
      call pproc
      return
9998  write(6,9997)
9997  format(/' *** failed to open output file *** '/)
      call pend
      return
      end
      function oipsci()
      implicit REAL  (a-h,o-z)
      logical oipsci
c
c...   decide  if we should process this integral batch
c...   called from jkin70 (integs) etc.
c
      common/nodinf/mpid,minode,mihost,ldim,nnodes,nodscr
      common/nodin2/icount
c
       icount = icount + 1
       oipsci = mod(icount,nnodes).ne.minode
c
       return
       end
       function  iipsci()
c
c...   initialise
c
       common/nodin2/icount
c
       icount = 0
       iipsci = 0
c
       return
       end
      logical function oroot()
c...   tells me if i am the root
      common/nodinf/mpid,minode,mihost,ldim,nnodes,nodscr
      oroot = minode.eq.0
c
      return
      end
      subroutine mxm(a,nar,b,nac,c,nbc)
      implicit REAL  (a-h,p-w),integer (i-n),logical  (o)
      implicit character *8 (z),character *1 (x)
      implicit character *4 (y)
      dimension a(nar,nac),b(nac,nbc),c(nar,nbc)
_IFN1(tpbds)      call dgemm ( 'n' , 'n' , nar , nbc , nac , 1.0d0 , a , nar ,
_IF1(tpds)      call dgemmx( 'n' , 'n' , nar , nbc , nac , 1.0d0 , a , nar ,
_IF1(b)      call blas_$dgemm( 
_IF1(b)     + 'n' , 'n' , nar , nbc , nac , 1.0d0 , a , nar ,
     *                         b , nac , 0.0d0 , c , nar )
      return
      end
      subroutine caserr(log)
      implicit REAL  (a-h,p-w),integer   (i-n),logical    (o)
      implicit character *8 (z),character *1 (x)
      implicit character *4 (y)
      character*(*) log
INCLUDE(../m4/common/utilc)
      character*80 ia
      common/iofile/iread,iwr
c
      ia = log
      write(iwr,30)ia
30    format(//65('*#')//50x,'error detected'/50x,'**************'/
     1/20x,a80//65('*#')//)
      call parerr(12345)
      return
      end
      subroutine pproc
      implicit logical (o)
      character*30 host, user, mach
      dimension  ibuff(91)
      call hostcc(host,30)
      call namcc(user,30)
      mach=
_IF1(x)     *'CONVEX  version 3.0'
_IF1(a)     *'ALLIANT version 2.0'
_IF1(s)     *'  SUN   version 2.0'
_IF1(p)     *'APOLLO  version 2.1'
_IF1(g)     *'  SGI   version 2.0'
_IF1(b)     *'HP-700  version 1.0'
_IF1(d)     *'  DEC   version 1.0'
_IF1(r)     *'RS-6000 version 1.0'
_IF1(t)     *' TITAN  version 2.0'
_IF1(c)     *'UNICOS  version 2.0'
      call pidcc(ipid)
      if(oroot())then
         write(6,1000)
         write(6,1001)ipid,host(1:12),user(1:12),mach
         do 10 i=1,nnodes()-1
            call rcv(100,ibuff,91*4,il,i,if,0)
            call itoch(ibuff(1),host)
            call itoch(ibuff(31),user)
            call itoch(ibuff(61),mach)
            ipid=ibuff(91)
         write(6,1002)i,ipid,host(1:12),user(1:12),mach
   10    continue
      else
         call chtoi(ibuff(1),host)
         call chtoi(ibuff(31),user)
         call chtoi(ibuff(61),mach)
         ibuff(91)=ipid
         call snd(100,ibuff,91*4,0,0)
      endif
1000  format(//,40x,'node information',/,40x,16('-'),
     & //,40x,'node     pid   hostname     user           version',/)
 1001 format(40x,'root',i8,3x,a12,1x,a12,1x,a30)
 1002 format(40x,   i4 ,i8,3x,a12,1x,a12,1x,a30)
      end
      function dclock()
      implicit REAL  (a-h,p-w),integer    (i-n),logical    (o)
      implicit character *8 (z),character *1 (x)
      implicit character *4 (y)
      call timef(dum)
      dclock = dum * 0.001d0
      return
      end
      subroutine timef(elapse)
      implicit REAL  (a-h,p-w),integer   (i-n),logical    (o)
      implicit character *8 (z),character *1 (x)
      implicit character *4 (y)
c
c return wall time in milli-seconds
c
      save ienter,tst
      data ienter/0/
      if (ienter.eq.0) then
        ienter = 1
        call cputm(ii)
        tst = dfloat(ii) * 10.0d0
        elapse = 0.0d0
      else
        call cputm(ii)
        elapse = dfloat(ii)*10.0d0 - tst
      endif
      return
      end
      subroutine chtoi(i,s)
      integer i(*)
      character s*(*)
      ilen=len(s)
      do 10 ii = 1,ilen
        i(ii)=ichar(s(ii:ii))
10    continue
      return
      end
      subroutine itoch(i,s)
      integer i(*)
      character s*(*)
      ilen=len(s)
      do 10 ii = 1,ilen
        s(ii:ii)=char(i(ii))
10    continue
      return
      end
_IFN(blas)
      function ddot(n,sx,incx,sy,incy)
c
c     returns the dot product of real sx and sy.
c
      implicit REAL  (a-h,p-w),integer    (i-n),logical    (o)
      implicit character *8 (z),character *1 (x)
      implicit character *4 (y)
      dimension sx(*),sy(*)
      ddot = 0.0d0
      if(n.le.0)return
      if(incx.eq.incy) if(incx-1) 1, 2, 6
    1 continue
c
c         code for unequal or nonpositive increments.
c
      ix = 1
      iy = 1
      if(incx.lt.0)ix = (-n+1)*incx + 1
      if(incy.lt.0)iy = (-n+1)*incy + 1
      ddot = vec_$ddot_i(sx(ix),incx,sy(iy),incy,n)
      return
c        code for both increments equal to 1.
c
    2 continue
      ddot = vec_$ddot(sx,sy,n)
      return
c
c         code for positive equal increments .ne.1.
c
    6 continue
      ddot = vec_$ddot_i(sx,incx,sy,incx,n)
      return
      end
_ENDIF
_ELSE
      function cpulft(i)
c..
c..    ipsc timer (both cputime,wallclock and reset)
c..
      implicit REAL (a-h,p-w),integer (i-n),logical  (o)
      implicit character *8 (z),character *1 (x)
      implicit character *4 (y)
      common/timez/timlim,timed(9),begin,elapl,isecs
      ak = dclock() - begin
      if (i.le.0) then
         cpulft=(timlim-ak)
      else
          cpulft=ak
      end if
c
      return
      end
      integer function dimcube(p)
      implicit REAL (a-h,o-z)
      integer p
c
c     dimension of a hypercube containing at least p nodes
c        = ceil(log2(p))
c
      dimcube = idint(1.44d0*dlog(dfloat(p)) + 0.99d0)
      return
      end
      subroutine ggop (type, x, n, op, work)
      integer type, n, root, dim
      character*1 op
      double precision x(n), work(n)
      common/nodinf/mpid,minode,mihost,dim,nnodes
c
c  global vector commutative operation using spanning tree.
c
c  all participating processes must have the same process id (pid).
c
c***  modified version : all nodes receive final result
c     use gdprod, gdsum, gdhigh and gdlow routines
c  input..
c
c    type      message type.  must be the same for all participating
c              processes.  there must be no other messages of this type
c              in the system.
c    x         the input vector to be used in the operation.
c    n         the length of the vector.
c    op        '+'  sum
c              '*'  product
c              'm'  maximum
c              'm'  minimum
c    root      node id of root process (which will get the final message
c              (if + or myhost(), then the smallest node number in the a
c              subcube acts as root and then forwards the message to the
c    dim       the size of the subcube participating.
c
c  output..
c
c    x         for the root process, x contains the desired result.
c              for all other processes, x contains the partial result
c              for their subtrees.
c
c  workspace
c
c    work      used to receive other contributions.
c
c  errors conditions
c
c        if called by a nonparticipating node, an error message is
c        syslogged and then the subroutine exits.
c
c        if a message longer than n elements is received, only the first
c        elements are saved, an error message is syslogged,
c        and then the computation continues with the truncated results.
c
c        if a message shorter than n elements is received, then an error
c        message is syslogged and the computation continues.
c
c  calls:  mynode, mypid, recvw, sendw, xor
c
      integer bit, bytes, diff, i, ignore, me, mynode,
     *   mypid, p, parent, pid, troot, xor
      REAL   tgoptm,tfndtm,tgettm,tputtm,dclock,dumtim
      common/nodtim/ tgoptm,topen(10),tfndtm(10),tgettm(10),tputtm(10)
c
      dumtim = dclock()
c
         if (op .eq. '+') then
            call gdsum(x,n,work)
         else if (op .eq. '*') then
            call gdprod(x,n,work)
         else if (op .eq. 'm') then
            call gdhigh(x,n,work)
         else if (op .eq. 'm') then
            call gdlow(x,n,work)
         else
            call caserr(' unrecognised operation in ggop')
         end if
c
      tgoptm = tgoptm + (dclock()-dumtim)
c
      return
      end
      subroutine ininod
c
c...  set few parameters needed in node proces
c
      common/nodinf/mpid,minode,mihost,ldim,nnodes,noddim
      REAL  tgoptm,tfndtm,tgettm,tputtm
      common/nodtim/ tgoptm,topen(10),tfndtm(10),tgettm(10),tputtm(10)
      parameter (nreal=8,nint=4,iroot=0)
      integer dimcube
      logical oroot
      common/iofile/ir,iw
c
      mpid = mypid()
      minode = mynode()
      mihost = 0
      nnodes = numnodes()
      noddim = nodedim()
      ldim = dimcube(nnodes)
      if (nnodes.ne.2**ldim.and.oroot()) then
         print *,ldim-nnodes,' nodes not in cube '
      end if
c
      tgoptm = 0.0d0
      do 100 loop=1,10
      topen (loop) = 0.0d0
      tfndtm(loop) = 0.0d0
      tgettm(loop) = 0.0d0
100   tputtm(loop) = 0.0d0
c
      return
      end
      subroutine initia
      implicit REAL (a-h,p-w),integer   (i-n),logical    (o)
      implicit character *8 (z),character *1 (x)
      implicit character *4 (y)
      character*20 fname
INCLUDE(../m4/common/utilc)
      common/iofile/iread,iwr
      common/timez/timlim(12),isec
      common/prints/oprntd(60)
c
c
c***   ***NODE-IPSC***
      common/nodinf/mpid,minode,mihost,ldim,nnodes,nodscr
c***   ***NODE-IPSC***
      opnode = .false.
      odumpm = .true.
      call ininod
      call setcpu
      iwr = 6
      iread = 5
      opkill=.true.
      oprntd(28)=.true.
c
c...  set iwr to 94 to seperate output of nodes
c
      if (.not.oroot()) then
         iwr = 94
c...      different numbers are not needed / different names are
c...      if no node output is requested send it to sink
         nn = 100+minode
         write(fname,'(a,i3)') 'out_mopac_',nn
c        if (opkill) oprnts(60) = .false.
         if (opnode) then
          open(iwr,form='formatted',file=fname,err=9998)
         else
          open(iwr,form='formatted',file='/dev/null',err=9998)
         endif
c
      end if
      return
9998  write(6,9997)
9997  format(/' *** failed to open output file *** '/)
      call pend
      return
      end
      subroutine pend
      implicit REAL (a-h,p-w),integer   (i-n),logical    (o)
      call exit
      stop
      end
      function oipsci()
      implicit REAL (a-h,o-z)
      logical oipsci
c
c...   decide  if we should process this integral batch
c...   called from jkin70 (integs) etc.
c
      common/nodinf/mpid,minode,mihost,ldim,nnodes
      common/nodin2/icount
c
       icount = icount + 1
       oipsci = mod(icount,nnodes).ne.minode
c
       return
       end
       function  iipsci()
c
c...   initialise
c
       common/nodin2/icount
c
       icount = 0
       iipsci = 0
c
       return
       end
      logical function oroot()
c...   tells me if i am the root
      common/nodinf/mpid,minode,mihost,ldim,nnodes
      oroot = minode.eq.0
c
      return
      end
      subroutine setcpu
c
c...   set start of clock to 0.0 **must** be called
c
      implicit REAL (a-h,p-w),integer (i-n),logical  (o)
      implicit character *8 (z),character *1 (x)
      implicit character *4 (y)
      integer ftimen
      common/timez/timlim,timed(9),begin,elapl,isecs
      begin = dclock()
      elapl = ftimen()
      return
      end
      subroutine mxm(a,nar,b,nac,c,nbc)
      implicit REAL (a-h,p-w),integer (i-n),logical  (o)
      implicit character *8 (z),character *1 (x)
      implicit character *4 (y)
      dimension a(nar,nac),b(nac,nbc),c(nar,nbc)
      call dgemm ( 'n' , 'n' , nar , nbc , nac , 1.0d0 , a , nar ,
     *                         b , nac , 0.0d0 , c , nar )
      return
      end
      subroutine caserr(log)
      implicit REAL (a-h,p-w),integer   (i-n),logical    (o)
      implicit character *8 (z),character *1 (x)
      implicit character *4 (y)
      character*(*) log
      character*80 ia
      common/iofile/iread,iwrite
c
      ia = log
      write(iwrite,30)ia
30    format(//65('*#')//50x,'error detected'/50x,'**************'/
     1/20x,a80//65('*#')//)
      call exit
      return
      end
_ENDIF
_ENDIF
      subroutine nonbet (u1x,u1y,u1z,u2x,u2y,u2z,
     1                   g1x,g1y,g1z,g2x,g2y,g2z)
c
c this routine calculates second harmonic generation in a
c noniterative way.
c
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      common /iofile/ mfgr,mfgw
c.....................................................................
c  calculate beta in a noniterative fashion
c.....................................................................
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),
     1                nlast(numatm),norbs,nelecs,nalpha,nbeta,nclose,
     2                nopen,ndumy,fract
      common /omval/ omega
      common /chanel/ ifiles(30)
      equivalence(iw,ifiles(6))
      dimension u1x(maxorb,maxorb),u1y(maxorb,maxorb),u1z(maxorb,maxorb)
      dimension u2x(maxorb,maxorb),u2y(maxorb,maxorb),u2z(maxorb,maxorb)
      dimension g1x(maxorb,maxorb),g1y(maxorb,maxorb),g1z(maxorb,maxorb)
      dimension g2x(maxorb,maxorb),g2y(maxorb,maxorb),g2z(maxorb,maxorb)
c
c get data from alpha calculations
c
      maxsq = norbs*norbs
      bavx = 0.0d+00
      bavy = 0.0d+00
      bavz = 0.0d+00
      call daread_mop (u1x,maxsq,8)
      call daread_mop (u1y,maxsq,9)
      call daread_mop (u1z,maxsq,10)
      call daread_mop (g1x,maxsq,11)
      call daread_mop (g1y,maxsq,12)
      call daread_mop (g1z,maxsq,13)
      call daread_mop (u2x,maxsq,14)
      call daread_mop (u2y,maxsq,15)
      call daread_mop (u2z,maxsq,16)
      call daread_mop (g2x,maxsq,17)
      call daread_mop (g2y,maxsq,18)
      call daread_mop (g2z,maxsq,19)
c xxx
      call betcom (u1x,g1x,u2x,g2x,nclose,norbs,bxxx)
      bavx = bavx +3.0d0 * bxxx
c yxx
      call betcom (u1x,g1x,u2y,g2y,nclose,norbs,byxx)
      bavy = bavy + byxx
c zxx
      call betcom (u1x,g1x,u2z,g2z,nclose,norbs,bzxx)
      bavz = bavz + bzxx
c xxy
      call betall (u2x,g2x,u1x,g1x,u1y,g1y,nclose,norbs,bxxy)
      bavy = bavy + bxxy
c yxy
      call betall (u2y,g2y,u1x,g1x,u1y,g1y,nclose,norbs,byxy)
      bavx = bavx + byxy
c zxy
      call betall (u2z,g2z,u1x,g1x,u1y,g1y,nclose,norbs,bzxy)
c xxz
      call betall (u2x,g2x,u1x,g1x,u1z,g1z,nclose,norbs,bxxz)
      bavz = bavz + bxxz
c yxz
      call betall (u2y,g2y,u1x,g1x,u1z,g1z,nclose,norbs,byxz)
c zxz
      call betall (u2z,g2z,u1x,g1x,u1z,g1z,nclose,norbs,bzxz)
      bavx = bavx + bzxz
c xyx
      call betall (u2x,g2x,u1y,g1y,u1x,g1x,nclose,norbs,bxyx)
      bavy = bavy + bxyx
c yyx
      call betall (u2y,g2y,u1y,g1y,u1x,g1x,nclose,norbs,byyx)
      bavx = bavx + byyx
c zyx
      call betall (u2z,g2z,u1y,g1y,u1x,g1x,nclose,norbs,bzyx)
c xyy
      call betcom (u1y,g1y,u2x,g2x,nclose,norbs,bxyy)
      bavx = bavx + bxyy
c yyy
      call betcom (u1y,g1y,u2y,g2y,nclose,norbs,byyy)
      bavy = bavy + 3.0d0*byyy
c zyy
      call betcom (u1y,g1y,u2z,g2z,nclose,norbs,bzyy)
      bavz = bavz + bzyy
c xyz
      call betall (u2x,g2x,u1y,g1y,u1z,g1z,nclose,norbs,bxyz)
c yyz
      call betall (u2y,g2y,u1y,g1y,u1z,g1z,nclose,norbs,byyz)
      bavz = bavz + byyz
c zyz
      call betall (u2z,g2z,u1y,g1y,u1z,g1z,nclose,norbs,bzyz)
      bavy = bavy + bzyz
c xzx
      call betall (u2x,g2x,u1z,g1z,u1x,g1x,nclose,norbs,bxzx)
      bavz = bavz + bxzx
c yzx
      call betall (u2y,g2y,u1z,g1z,u1x,g1x,nclose,norbs,byzx)
c zzx
      call betall (u2z,g2z,u1z,g1z,u1x,g1x,nclose,norbs,bzzx)
      bavx = bavx + bzzx
c xzy
      call betall (u2x,g2x,u1z,g1z,u1y,g1y,nclose,norbs,bxzy)
c yzy
      call betall (u2y,g2y,u1z,g1z,u1y,g1y,nclose,norbs,byzy)
      bavz = bavz + byzy
c zzy
      call betall (u2z,g2z,u1z,g1z,u1y,g1y,nclose,norbs,bzzy)
      bavy = bavy + bzzy
c xzz
      call betcom (u1z,g1z,u2x,g2x,nclose,norbs,bxzz)
      bavx = bavx + bxzz
c yzz
      call betcom (u1z,g1z,u2y,g2y,nclose,norbs,byzz)
      bavy = bavy + byzz
c zzz
      call betcom (u1z,g1z,u2z,g2z,nclose,norbs,bzzz)
      bavz = bavz + 3.0d0 * bzzz
c
      bavx = bavx/5.0d+00
      bavy = bavy/5.0d+00
      bavz = bavz/5.0d+00
c
      bvec = (bavx*bavx+bavy*bavy+bavz*bavz)**0.5d+00
      write(mfgw,10)
   10 format (//,   ' beta (second harmonic generation)'//)
      write(mfgw,20) bxxx,byxx,bzxx,bxxy,byxy,bzxy,
     1              bxxz,byxz,bzxz,bxyx,byyx,bzyx,
     2              bxyy,byyy,bzyy,bxyz,byyz,bzyz,
     3              bxzx,byzx,bzzx,bxzy,byzy,bzzy,
     4              bxzz,byzz,bzzz
   20 format (//,'  bxxx  ',d15.8,'  byxx ',d15.8,'  bzxx ',d15.8,/,
     1           '  bxxy  ',d15.8,'  byxy ',d15.8,'  bzxy ',d15.8,/,
     2           '  bxxz  ',d15.8,'  byxz ',d15.8,'  bzxz ',d15.8,/,
     3           '  bxyx  ',d15.8,'  byyx ',d15.8,'  bzyx ',d15.8,/,
     4           '  bxyy  ',d15.8,'  byyy ',d15.8,'  bzyy ',d15.8,/,
     5           '  bxyz  ',d15.8,'  byyz ',d15.8,'  bzyz ',d15.8,/,
     6           '  bxzx  ',d15.8,'  byzx ',d15.8,'  bzzx ',d15.8,/,
     7           '  bxzy  ',d15.8,'  byzy ',d15.8,'  bzzy ',d15.8,/,
     8           '  bxzz  ',d15.8,'  byzz ',d15.8,'  bzzz ',d15.8)
c
      write(mfgw,30) omega,bavx
   30 format (//, ' average betax(shg) value at',f10.5, 'ev = ',
     1         1f15.5 )
c
      write(mfgw,40) omega,bavy
   40 format (' average betay(shg) value at',f10.5, 'ev = ',
     1         1f15.5 )
c
      write(mfgw,50) omega,bavz
   50 format (' average betaz(shg) value at',f10.5, 'ev = ',
     1         1f15.5 ,//)
c
      write(mfgw,60) omega,bvec
   60 format (//, ' average beta (shg) value at',f10.5, 'ev = ',
     1         1f15.5 ,//)
      return
      end
      subroutine nonope (u0x,u1y,u1z,u1x,u0y,u0z,
     1                    g0x,g1y,g1z,g1x,g0y,g0z)
c
c this routine calculates electrooptic pockel's effect
c in a noniterative way.
c
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      common /iofile/ mfgr,mfgw
c.....................................................................
c  calculate beta in a noniterative fashion
c.....................................................................
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),
     1                nlast(numatm),norbs,nelecs,nalpha,nbeta,nclose,
     2                nopen,ndumy,fract
      common /omval/ omega
      common /chanel/ ifiles(30)
      equivalence(iw,ifiles(6))
      dimension u0x(maxorb,maxorb),u1y(maxorb,maxorb),u1z(maxorb,maxorb)
      dimension u1x(maxorb,maxorb),u0y(maxorb,maxorb),u0z(maxorb,maxorb)
      dimension g0x(maxorb,maxorb),g1y(maxorb,maxorb),g1z(maxorb,maxorb)
      dimension g1x(maxorb,maxorb),g0y(maxorb,maxorb),g0z(maxorb,maxorb)
c
      maxsq = norbs*norbs
c
c read data from alpha calculation
c
      bavx = 0.0d+00
      bavy = 0.0d+00
      bavz = 0.0d+00
c
      call daread_mop (u0x,maxsq,2)
      call daread_mop (u0y,maxsq,3)
      call daread_mop (u0z,maxsq,4)
      call daread_mop (g0x,maxsq,5)
      call daread_mop (g0y,maxsq,6)
      call daread_mop (g0z,maxsq,7)
      call daread_mop (u1x,maxsq,8)
      call daread_mop (u1y,maxsq,9)
      call daread_mop (u1z,maxsq,10)
      call daread_mop (g1x,maxsq,11)
      call daread_mop (g1y,maxsq,12)
      call daread_mop (g1z,maxsq,13)
c xxx
      call betall (u1x,g1x,u0x,g0x,u1x,g1x,nclose,norbs,bxxx)
      bavx = bavx + 3.0d0 * bxxx
c yxx
      call betall (u1y,g1y,u0x,g0x,u1x,g1x,nclose,norbs,byxx)
      bavy = bavy + byxx
c zxx
      call betall (u1z,g1z,u0x,g0x,u1x,g1x,nclose,norbs,bzxx)
      bavz = bavz + bzxx
c xxy
      call betall (u1x,g1x,u0x,g0x,u1y,g1y,nclose,norbs,bxxy)
      bavy = bavy + bxxy
c yxy
      call betall (u1y,g1y,u0x,g0x,u1y,g1y,nclose,norbs,byxy)
      bavx = bavx + byxy
c zxy
      call betall (u1z,g1z,u0x,g0x,u1y,g1y,nclose,norbs,bzxy)
c xxz
      call betall (u1x,g1x,u0x,g0x,u1z,g1z,nclose,norbs,bxxz)
      bavz = bavz + bxxz
c yxz
      call betall (u1y,g1y,u0x,g0x,u1z,g1z,nclose,norbs,byxz)
c zxz
      call betall (u1z,g1z,u0x,g0x,u1z,g1z,nclose,norbs,bzxz)
      bavx = bavx + bzxz
c xyx
      call betall (u1x,g1x,u0y,g0y,u1x,g1x,nclose,norbs,bxyx)
      bavy = bavy + bxyx
c yyx
      call betall (u1y,g1y,u0y,g0y,u1x,g1x,nclose,norbs,byyx)
      bavx = bavx + byyx
c zyx
      call betall (u1z,g1z,u0y,g0y,u1x,g1x,nclose,norbs,bzyx)
c xyy
      call betall (u1x,g1x,u0y,g0y,u1y,g1y,nclose,norbs,bxyy)
      bavx = bavx + bxyy
c yyy
      call betall (u1y,g1y,u0y,g0y,u1y,g1y,nclose,norbs,byyy)
      bavy = bavy + 3.0d0 * byyy
c zyy
      call betall (u1z,g1z,u0y,g0y,u1y,g1y,nclose,norbs,bzyy)
      bavz = bavz + bzyy
c xyz
      call betall (u1x,g1x,u0y,g0y,u1z,g1z,nclose,norbs,bxyz)
c yyz
      call betall (u1y,g1y,u0y,g0y,u1z,g1z,nclose,norbs,byyz)
      bavz = bavz + byyz
c zyz
      call betall (u1z,g1z,u0y,g0y,u1z,g1z,nclose,norbs,bzyz)
      bavy = bavy + bzyz
c xzx
      call betall (u1x,g1x,u0z,g0z,u1x,g1x,nclose,norbs,bxzx)
      bavz = bavz + bxzx
c yzx
      call betall (u1y,g1y,u0z,g0z,u1x,g1x,nclose,norbs,byzx)
c zzx
      call betall (u1z,g1z,u0z,g0z,u1x,g1x,nclose,norbs,bzzx)
      bavx = bavx + bzzx
c xzy
      call betall (u1x,g1x,u0z,g0z,u1y,g1y,nclose,norbs,bxzy)
c yzy
      call betall (u1y,g1y,u0z,g0z,u1y,g1y,nclose,norbs,byzy)
      bavz = bavz + byzy
c zzy
      call betall (u1z,g1z,u0z,g0z,u1y,g1y,nclose,norbs,bzzy)
      bavy = bavy + bzzy
c xzz
      call betall (u1x,g1x,u0z,g0z,u1z,g1z,nclose,norbs,bxzz)
      bavx = bavx + bxzz
c yzz
      call betall (u1y,g1y,u0z,g0z,u1z,g1z,nclose,norbs,byzz)
      bavy = bavy + byzz
c zzz
      call betall (u1z,g1z,u0z,g0z,u1z,g1z,nclose,norbs,bzzz)
      bavz = bavz + 3.0d0 * bzzz
c
      bavx = bavx/5.0d+00
      bavy = bavy/5.0d+00
      bavz = bavz/5.0d+00
c
      bvec = (bavx*bavx+bavy*bavy+bavz*bavz)**0.5d+00
      write(mfgw,*)   '  beta (electoptic pockels effect) '
      write(mfgw,10) bxxx,byxx,bzxx,bxxy,byxy,bzxy,
     1              bxxz,byxz,bzxz,bxyx,byyx,bzyx,
     2              bxyy,byyy,bzyy,bxyz,byyz,bzyz,
     3              bxzx,byzx,bzzx,bxzy,byzy,bzzy,
     4              bxzz,byzz,bzzz
   10 format (//,'  bxxx  ',d15.8,'  byxx ',d15.8,'  bzxx ',d15.8,/,
     1           '  bxxy  ',d15.8,'  byxy ',d15.8,'  bzxy ',d15.8,/,
     2           '  bxxz  ',d15.8,'  byxz ',d15.8,'  bzxz ',d15.8,/,
     3           '  bxyx  ',d15.8,'  byyx ',d15.8,'  bzyx ',d15.8,/,
     4           '  bxyy  ',d15.8,'  byyy ',d15.8,'  bzyy ',d15.8,/,
     5           '  bxyz  ',d15.8,'  byyz ',d15.8,'  bzyz ',d15.8,/,
     6           '  bxzx  ',d15.8,'  byzx ',d15.8,'  bzzx ',d15.8,/,
     7           '  bxzy  ',d15.8,'  byzy ',d15.8,'  bzzy ',d15.8,/,
     8           '  bxzz  ',d15.8,'  byzz ',d15.8,'  bzzz ',d15.8)
c
      write(mfgw,20) omega,bavx
   20 format(//,' average betax value at', f10.5, 'ev = ',
     1         1f15.5 )
c
      write(mfgw,30) omega,bavy
   30 format(' average betay value at', f10.5, 'ev = ',
     1         1f15.5 )
c
      write(mfgw,40) omega,bavz
   40 format(' average betaz value at', f10.5, 'ev = ',
     1         1f15.5 ,//)
c
      write(mfgw,50) omega,bvec
   50 format(//,' average beta(eope) value at', f10.5, 'ev = ',
     1         1f15.5 ,//)
      return
      end
      subroutine nonor (u0x,u1y,u1z,u1x,u0y,u0z,g0x,g1y,g1z,
     1                  g1x,g0y,g0z)
c
c this routine calculates optical rectification in a
c noniterative way
c
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      common /iofile/ mfgr,mfgw
c.....................................................................
c  calculate beta in a noniterative fashion
c.....................................................................
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),
     1                nlast(numatm),norbs,nelecs,nalpha,nbeta,nclose,
     2                nopen,ndumy,fract
      common /omval/ omega
      common /chanel/ ifiles(30)
      equivalence(iw,ifiles(6))
      dimension u0x(maxorb,maxorb),u1y(maxorb,maxorb),u1z(maxorb,maxorb)
      dimension u1x(maxorb,maxorb),u0y(maxorb,maxorb),u0z(maxorb,maxorb)
      dimension g0x(maxorb,maxorb),g1y(maxorb,maxorb),g1z(maxorb,maxorb)
      dimension g1x(maxorb,maxorb),g0y(maxorb,maxorb),g0z(maxorb,maxorb)
      maxsq = norbs*norbs
c
c read data from alpha calculation
c
      bavx = 0.0d+00
      bavy = 0.0d+00
      bavz = 0.0d+00
c
      call daread_mop (u0x,maxsq,2)
      call daread_mop (u0y,maxsq,3)
      call daread_mop (u0z,maxsq,4)
      call daread_mop (g0x,maxsq,5)
      call daread_mop (g0y,maxsq,6)
      call daread_mop (g0z,maxsq,7)
      call daread_mop (u1x,maxsq,8)
      call daread_mop (u1y,maxsq,9)
      call daread_mop (u1z,maxsq,10)
      call daread_mop (g1x,maxsq,11)
      call daread_mop (g1y,maxsq,12)
      call daread_mop (g1z,maxsq,13)
c
c noniterative beta calculation
c
c xxx
      call betal1 (u0x,g0x,u1x,g1x,u1x,g1x,nclose,norbs,bxxx)
      bavx = bavx + 3.0d0* bxxx
c yxx
      call betal1 (u0y,g0y,u1x,g1x,u1x,g1x,nclose,norbs,byxx)
      bavy = bavy + byxx
c zxx
      call betal1 (u0z,g0z,u1x,g1x,u1x,g1x,nclose,norbs,bzxx)
      bavz = bavz + bzxx
c xxy
      call betal1 (u0x,g0x,u1x,g1x,u1y,g1y,nclose,norbs,bxxy)
      bavy = bavy + bxxy
c yxy
      call betal1 (u0y,g0y,u1x,g1x,u1y,g1y,nclose,norbs,byxy)
      bavx = bavx + byxy
c zxy
      call betal1 (u0z,g0z,u1x,g1x,u1y,g1y,nclose,norbs,bzxy)
c xxz
      call betal1 (u0x,g0x,u1x,g1x,u1z,g1z,nclose,norbs,bxxz)
      bavz = bavz + bxxz
c yxz
      call betal1 (u0y,g0y,u1x,g1x,u1z,g1z,nclose,norbs,byxz)
c zxz
      call betal1 (u0z,g0z,u1x,g1x,u1z,g1z,nclose,norbs,bzxz)
      bavx = bavx + bzxz
c xyx
      call betal1 (u0x,g0x,u1y,g1y,u1x,g1x,nclose,norbs,bxyx)
      bavy = bavy + bxyx
c yyx
      call betal1 (u0y,g0y,u1y,g1y,u1x,g1x,nclose,norbs,byyx)
      bavx = bavx + byyx
c zyx
      call betal1 (u0z,g0z,u1y,g1y,u1x,g1x,nclose,norbs,bzyx)
c xyy
      call betal1 (u0x,g0x,u1y,g1y,u1y,g1y,nclose,norbs,bxyy)
      bavx = bavx + bxyy
c yyy
      call betal1 (u0y,g0y,u1y,g1y,u1y,g1y,nclose,norbs,byyy)
      bavy = bavy + 3.0d0 * byyy
c zyy
      call betal1 (u0z,g0z,u1y,g1y,u1y,g1y,nclose,norbs,bzyy)
      bavz = bavz + bzyy
c xyz
      call betal1 (u0x,g0x,u1y,g1y,u1z,g1z,nclose,norbs,bxyz)
c yyz
      call betal1 (u0y,g0y,u1y,g1y,u1z,g1z,nclose,norbs,byyz)
      bavz = bavz + byyz
c zyz
      call betal1 (u0z,g0z,u1y,g1y,u1z,g1z,nclose,norbs,bzyz)
      bavy = bavy + bzyz
c xzx
      call betal1 (u0x,g0x,u1z,g1z,u1x,g1x,nclose,norbs,bxzx)
      bavz = bavz + bxzx
c yzx
      call betal1 (u0y,g0y,u1z,g1z,u1x,g1x,nclose,norbs,byzx)
c zzx
      call betal1 (u0z,g0z,u1z,g1z,u1x,g1x,nclose,norbs,bzzx)
      bavx = bavx + bzzx
c xzy
      call betal1 (u0x,g0x,u1z,g1z,u1y,g1y,nclose,norbs,bxzy)
c yzy
      call betal1 (u0y,g0y,u1z,g1z,u1y,g1y,nclose,norbs,byzy)
      bavz = bavz + byzy
c zzy
      call betal1 (u0z,g0z,u1z,g1z,u1y,g1y,nclose,norbs,bzzy)
      bavy = bavy + bzzy
c xzz
      call betal1 (u0x,g0x,u1z,g1z,u1z,g1z,nclose,norbs,bxzz)
      bavx = bavx + bxzz
c yzz
      call betal1 (u0y,g0y,u1z,g1z,u1z,g1z,nclose,norbs,byzz)
      bavy = bavy + byzz
c zzz
      call betal1 (u0z,g0z,u1z,g1z,u1z,g1z,nclose,norbs,bzzz)
      bavz = bavz + 3.0d0 * bzzz
c
      bavx = bavx/5.0d+00
      bavy = bavy/5.0d+00
      bavz = bavz/5.0d+00
c
      bvec = (bavx*bavx+bavy*bavy+bavz*bavz)**0.5d+00
      write(mfgw,10)
   10 format  (//, ' beta (optical rectification) ')
      write(mfgw,20) bxxx,byxx,bzxx,bxxy,byxy,bzxy,
     1              bxxz,byxz,bzxz,bxyx,byyx,bzyx,
     2              bxyy,byyy,bzyy,bxyz,byyz,bzyz,
     3              bxzx,byzx,bzzx,bxzy,byzy,bzzy,
     4              bxzz,byzz,bzzz
   20 format (//,'  bxxx  ',d15.8,'  byxx ',d15.8,'  bzxx ',d15.8,/,
     1           '  bxxy  ',d15.8,'  byxy ',d15.8,'  bzxy ',d15.8,/,
     2           '  bxxz  ',d15.8,'  byxz ',d15.8,'  bzxz ',d15.8,/,
     3           '  bxyx  ',d15.8,'  byyx ',d15.8,'  bzyx ',d15.8,/,
     4           '  bxyy  ',d15.8,'  byyy ',d15.8,'  bzyy ',d15.8,/,
     5           '  bxyz  ',d15.8,'  byyz ',d15.8,'  bzyz ',d15.8,/,
     6           '  bxzx  ',d15.8,'  byzx ',d15.8,'  bzzx ',d15.8,/,
     7           '  bxzy  ',d15.8,'  byzy ',d15.8,'  bzzy ',d15.8,/,
     8           '  bxzz  ',d15.8,'  byzz ',d15.8,'  bzzz ',d15.8)
c
      write(mfgw,30) omega,bavx
   30 format(//,' average betax value at ',f10.5, 'ev = ',
     1        1f15.5 )
c
      write(mfgw,40) omega,bavy
   40 format(' average betay value at ',f10.5, 'ev = ',
     1        1f15.5 )
c
      write(mfgw,50) omega,bavz
   50 format(' average betaz value at ',f10.5, 'ev = ',
     1        1f15.5 ,//)
c
      write(mfgw,60) omega,bvec
   60 format(//,' average beta(or) value at ',f10.5, 'ev = ',
     1        1f15.5 ,//)
c
      return
      end
      subroutine mat33(a, b, c)
c  a subroutine that will multiply two 3 by 3 matricies in the following
c     fashion:    c = a(transpose) b a
c
      implicit REAL (a-h,o-z)
      dimension a(9), b(9), c(9), t(9)
c
c
      t(1) = b(1)*a(1) + b(2)*a(4) + b(3)*a(7)
      t(2) = b(1)*a(2) + b(2)*a(5) + b(3)*a(8)
      t(3) = b(1)*a(3) + b(2)*a(6) + b(3)*a(9)
      t(4) = b(4)*a(1) + b(5)*a(4) + b(6)*a(7)
      t(5) = b(4)*a(2) + b(5)*a(5) + b(6)*a(8)
      t(6) = b(4)*a(3) + b(5)*a(6) + b(6)*a(9)
      t(7) = b(7)*a(1) + b(8)*a(4) + b(9)*a(7)
      t(8) = b(7)*a(2) + b(8)*a(5) + b(9)*a(8)
      t(9) = b(7)*a(3) + b(8)*a(6) + b(9)*a(9)
c
      c(1) = a(1)*t(1) + a(4)*t(4) + a(7)*t(7)
      c(2) = a(1)*t(2) + a(4)*t(5) + a(7)*t(8)
      c(3) = a(1)*t(3) + a(4)*t(6) + a(7)*t(9)
      c(4) = a(2)*t(1) + a(5)*t(4) + a(8)*t(7)
      c(5) = a(2)*t(2) + a(5)*t(5) + a(8)*t(8)
      c(6) = a(2)*t(3) + a(5)*t(6) + a(8)*t(9)
      c(7) = a(3)*t(1) + a(6)*t(4) + a(9)*t(7)
      c(8) = a(3)*t(2) + a(6)*t(5) + a(9)*t(8)
      c(9) = a(3)*t(3) + a(6)*t(6) + a(9)*t(9)
c
      return
      end
      subroutine zerom(x,m)
      implicit REAL (a-h,o-z)
c
c  zerom zeros the matrix x
c
      dimension x(m,m)
      do 20 i = 1,m
         do 10 j = 1,m
            x(i,j) = 0.0d00
   10    continue
   20 continue
      return
      end
      REAL function dot(x,y,n)
      implicit REAL (a-h,o-z)
      dimension x(*), y(*)
************************************************************************
*
*   dot forms the scalar product of two vectors.
*
*   on input     x   =    first vector, of length n.
*                y   =    second vector, of length n.
*
*   on return    dot =    dot product of x and y.
*
************************************************************************
      dot = 0.0d0
      do 10 i=1,n
   10 dot = dot + x(i)*y(i)
      return
      end
      function dot1(a,b)
      implicit REAL (a-h,o-z)
      dimension a(3)
      dimension b(3)
      dot1 = a(1)*b(1) + a(2)*b(2) + a(3)*b(3)
      return
      end
      subroutine gethesm(xparam,igthes,nvar,iloop,totime) 
      implicit REAL (a-h,o-z)                                       
INCLUDE(common/sizes)                                                           
c     get the hessian. depending on igthes we get it from :                     
c                                                                               
c      0 : diagonal matrix, dghsx*i (default for min-search)                    
c      1 : calculate it numerically (default for ts-search)                     
c      2 : read in from ftn009                                                  
c      3 : calculate it by double numerical differentiation
c      4 : read in from ftn009 (during restart, partly or whole,                
c          already done at this point)                                          
      common /geovar/ ndum,loc(2,maxpar), idumy, xaram(maxpar)                  
      common /cmpg/ geo(3,numatm)                                             
      common /geosym/ ndep,locpar(maxpar),idepfn(maxpar),locdep(maxpar)         
      common /last/ last                                                      
      common /keywrd/ keywrd                                                    
      common /timex / time0                                                     
      common /gradnt/ grad(maxpar),gnfina                                       
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),          
     1                nlast(numatm), norbs, nelecs,nalpha,nbeta,                
     2                nclose,nopen,ndumy,fract                                  
      common /numcal/ numcal                                                    
      common /sigma2/ gnext1(maxpar), gmin1(maxpar)                             
      common /nllcom/ hess(maxpar,maxpar),bmat(maxpar,maxpar),                  
     *pmat(maxpar)                                                              
      common /scrach/ pvec                                                      
      common /timdmp/ tleft, tdump
      common/fmatrx/oldf(maxpar),d(maxpar),vmode(maxpar),
     $u(maxpar,maxpar),dd,rmin,rmax,omin,xlamd,xlamd0,skal,
     $mode,nstep,negreq,iprnt
      dimension ipow(9), eigval(maxpar),tvec(maxpar),svec(maxpar),              
     *fx(maxpar),hessc(maxhes),uc(maxpar**2)                                    
      common /iofile/ mfgr,mfgw
      dimension xparam(*),tmp(150,150)
      logical restrt,scf1,ldum 
      character*241 keywrd,line                                           
      character chdot*1,zero*1,nine*1,ch*1
      data chdot,zero,nine  /'.','0','9'/                     
      data  icalcn,zzero,one,two    /0,0.d0,1.d0,2.d0/                          
c
      data dghss,dghsa,dghsd /1000.d0,500.d0,200.d0/          
      data xinc /1.d-3/          
c     dghsx is hessian diagonal for igthes=0 (stretching, angle,
c     dihedral).  the values should be 'optimum' for cyclohexanone
c     xinc is stepsize for hessian calculation. tests shows that it should
c     be in the range 10(-2) to 10(-4). 10(-3) appears to be 
c     a reasonable compromise between accuracy and numerical problems
      if (igthes.eq.0) then
         write(mfgw,60)
   60    format(/,10x,'diagonal matrix used as start hessian',/)
         do 70 i=1,nvar
            do 70 j=1,nvar
               hess(i,j)=zzero
   70    continue
         ij=1
         do 80 j=1,numatm
            do 80 i=1,3
               if (loc(2,ij).eq.i.and.loc(1,ij).eq.j)then
                  if (i.eq.1)hess(ij,ij)=dghss
                  if (i.eq.2)hess(ij,ij)=dghsa
                  if (i.eq.3)hess(ij,ij)=dghsd
                  ij=ij+1
               endif
   80    continue
         ij=ij-1
         if(ij.ne.nvar)write(*,*)'error in igthes=0,ij,nvar',ij,nvar
      endif
c
      if (igthes.eq.2) then
         write(mfgw,100)
  100    format(/,10x,'hessian read from disk',/)
         ipow(9)=0
c        use dummy array for call except for hessian
c        temporary set nalpha = 0, then we can read hessian from rhf
c        run for use in say uhf runs
c        also save mode, to allow following a different mode than the one
c        currently on restart file
         nxxx=nalpha
         nalpha=0
         mtmp=mode
         call bkrsav(tdm,hess,fdmy,gnext1,gmin1,pmat,iidum,j,bmat,ipow)
         nalpha=nxxx
         mode=mtmp
         nstep=0
      endif
      if((igthes.eq.1).or.(igthes.eq.3).or.(igthes.eq.4))then
c       if igthes is .eq. 4, then this is a hessian restart.
c       use gnext1 and dummy for calls to compfg during hessian
c       calculation
         if (igthes.eq.1)write(mfgw,190)
  190    format(/,10x,'hessian calculated numerically',/)
         if (igthes.eq.3)write(mfgw,191)
  191    format(/,10x,'hessian calculated double numerically',/)
            if(iprnt.ge.5)write(mfgw,'(i3,12(8f9.4,/3x))')
     1    0,(grad(if),if=1,nvar)
         time1=secmop()
         tstore=time1
         do 210 i=iloop,nvar
            xparam(i)=xparam(i) + xinc
            call compfg(xparam, .true., dummy, .true., gnext1, .true.)
            if(iprnt.ge.5)write(mfgw,'(i3,12(8f9.4,/3x))')
     1    i,(gnext1(if),if=1,nvar)
            xparam(i)=xparam(i) - xinc
            if (igthes.eq.3) then
            xparam(i)=xparam(i) - xinc
            call compfg(xparam, .true., dummy, .true., gmin1, .true.)
            if(iprnt.ge.5)write(mfgw,'(i3,12(8f9.4,/3x))')
     1    -i,(gmin1(if),if=1,nvar)
            xparam(i)=xparam(i) + xinc
            do 199 j=1,nvar
  199       hess(i,j)= (gnext1(j)-gmin1(j))/(xinc+xinc)
            else
            do 200 j=1,nvar
  200       hess(i,j)= (gnext1(j)-grad(j))/xinc
            endif
            time2=secmop()
            tstep=time2-time1
            tleft=tleft-tstep
            time1=time2
            if( tleft .lt. tstep*two) then
c
c  store partial hessian patrix
c  store gradients for geometry and iloop as positive
               write(mfgw,'(a)')' not enough time to complete hessian'
               write(mfgw,'(a,i4)')
     +         ' stopping in hessian at coordinate:',i
               ipow(9)=1
               tt0=secmop()-time0
               call bkrsav(tt0,hess,funct,grad,xparam,pmat,i,nstep,bmat,
     1ipow)
_IF(ipsc,tools)
               call pend
_ELSE
               stop
_ENDIF
            endif
  210    continue
c     fix last entry in geo array, this is currently at value-xinc
         k=loc(1,nvar)
         l=loc(2,nvar)
         geo(l,k)=xparam(nvar)
         if(ndep.ne.0) call mopsym()
c        add all time used back to tleft, this will then be subtracted
c        again in main ef routine
         time2=secmop()
         tstep=time2-tstore
         tleft=tleft+tstep
      endif
c
c     symmetrize hessian
      do 220 i=1,nvar
c$dir no_recurrence
         do 220 j=1,i-1
            hess(i,j)=(hess(i,j)+hess(j,i))/two
            hess(j,i)=hess(i,j)
  220 continue
      return
      end
_IF()
      subroutine dcopy(n,x,ix,y,iy)
      implicit REAL (a-h,o-z)
c     copy vector x, step ix onto vector y, step iy, n elements.
c     simulate routine on cray (same name and calling sequence).
      dimension x(*),y(*)
      i=1
      do 10 j=1,iy*(n-1)+1,iy
         y(j)=x(i)
   10 i=i+ix
      return
      end
      REAL function ddot (n,x,ix,y,iy)
      implicit REAL (a-h,o-z)
      dimension x(*),y(*)
c     ddot=dot product of vector x, step ix, by vector y, step iy,
c     n elements.
c     simulate routine on cray (same name and calling sequence).
      j=1
      ddot=0.0d0
      do 10 i=1,(n-1)*ix+1,ix
         ddot=ddot+x(i)*y(j)
   10 j=j+iy
      return
      end
c*module blas1   *deck daxpy
      subroutine daxpy(n,da,dx,incx,dy,incy)
      implicit REAL (a-h,o-z)
      dimension dx(1),dy(1)
c
c     constant times a vector plus a vector.
c           dy(i) = dy(i) + da * dx(i)
c     uses unrolled loops for increments equal to one.
c     jack dongarra, linpack, 3/11/78.
c
      if(n.le.0)return
      if (da .eq. 0.0d+00) return
      if(incx.eq.1.and.incy.eq.1)go to 20
c
c        code for unequal increments or equal increments
c          not equal to 1
c
      ix = 1
      iy = 1
      if(incx.lt.0)ix = (-n+1)*incx + 1
      if(incy.lt.0)iy = (-n+1)*incy + 1
      do 10 i = 1,n
        dy(iy) = dy(iy) + da*dx(ix)
        ix = ix + incx
        iy = iy + incy
   10 continue
      return
c
c        code for both increments equal to 1
c
c
c        clean-up loop
c
   20 m = mod(n,4)
      if( m .eq. 0 ) go to 40
      do 30 i = 1,m
        dy(i) = dy(i) + da*dx(i)
   30 continue
      if( n .lt. 4 ) return
   40 mp1 = m + 1
      do 50 i = mp1,n,4
        dy(i) = dy(i) + da*dx(i)
        dy(i + 1) = dy(i + 1) + da*dx(i + 1)
        dy(i + 2) = dy(i + 2) + da*dx(i + 2)
        dy(i + 3) = dy(i + 3) + da*dx(i + 3)
   50 continue
      return
      end
c*module blas1   *deck dscal
      subroutine dscal(n,da,dx,incx)
      implicit REAL (a-h,o-z)
      dimension dx(1)
c
c     scales a vector by a constant.
c           dx(i) = da * dx(i)
c     uses unrolled loops for increment equal to one.
c     jack dongarra, linpack, 3/11/78.
c
      if(n.le.0)return
      if(incx.eq.1)go to 20
c
c        code for increment not equal to 1
c
      nincx = n*incx
      do 10 i = 1,nincx,incx
        dx(i) = da*dx(i)
   10 continue
      return
c
c        code for increment equal to 1
c
c
c        clean-up loop
c
   20 m = mod(n,5)
      if( m .eq. 0 ) go to 40
      do 30 i = 1,m
        dx(i) = da*dx(i)
   30 continue
      if( n .lt. 5 ) return
   40 mp1 = m + 1
      do 50 i = mp1,n,5
        dx(i) = da*dx(i)
        dx(i + 1) = da*dx(i + 1)
        dx(i + 2) = da*dx(i + 2)
        dx(i + 3) = da*dx(i + 3)
        dx(i + 4) = da*dx(i + 4)
   50 continue
      return
      end
c*module blas1   *deck dswap
      subroutine dswap (n,dx,incx,dy,incy)
      implicit REAL (a-h,o-z)
      dimension dx(1),dy(1)
c
c     interchanges two vectors.
c           dx(i) <==> dy(i)
c     uses unrolled loops for increments equal one.
c     jack dongarra, linpack, 3/11/78.
c
      if(n.le.0)return
      if(incx.eq.1.and.incy.eq.1)go to 20
c
c       code for unequal increments or equal increments not equal
c         to 1
c
      ix = 1
      iy = 1
      if(incx.lt.0)ix = (-n+1)*incx + 1
      if(incy.lt.0)iy = (-n+1)*incy + 1
      do 10 i = 1,n
        dtemp = dx(ix)
        dx(ix) = dy(iy)
        dy(iy) = dtemp
        ix = ix + incx
        iy = iy + incy
   10 continue
      return
c
c       code for both increments equal to 1
c
c
c       clean-up loop
c
   20 m = mod(n,3)
      if( m .eq. 0 ) go to 40
      do 30 i = 1,m
        dtemp = dx(i)
        dx(i) = dy(i)
        dy(i) = dtemp
   30 continue
      if( n .lt. 3 ) return
   40 mp1 = m + 1
      do 50 i = mp1,n,3
        dtemp = dx(i)
        dx(i) = dy(i)
        dy(i) = dtemp
        dtemp = dx(i + 1)
        dx(i + 1) = dy(i + 1)
        dy(i + 1) = dtemp
        dtemp = dx(i + 2)
        dx(i + 2) = dy(i + 2)
        dy(i + 2) = dtemp
   50 continue
      return
      end
c*module blas1   *deck idamax
      integer function idamax(n,dx,incx)
      implicit REAL (a-h,o-z)
      dimension dx(1)
c
c     finds the index of element having max. absolute value.
c     jack dongarra, linpack, 3/11/78.
c
      idamax = 0
      if( n .lt. 1 ) return
      idamax = 1
      if(n.eq.1)return
      if(incx.eq.1)go to 20
c
c        code for increment not equal to 1
c
      ix = 1
      rmax = dabs(dx(1))
      ix = ix + incx
      do 10 i = 2,n
         if(dabs(dx(ix)).le.rmax) go to 5
         idamax = i
         rmax = dabs(dx(ix))
    5    ix = ix + incx
   10 continue
      return
c
c        code for increment equal to 1
c
   20 rmax = dabs(dx(1))
      do 30 i = 2,n
         if(dabs(dx(i)).le.rmax) go to 30
         idamax = i
         rmax = dabs(dx(i))
   30 continue
      return
      end
_ENDIF()
_IF()
      subroutine dgemm ( transa, transb, m, n, k, alpha, a, lda, b, ldb,
     $                   beta, c, ldc )
*     .. scalar arguments ..
      character*1        transa, transb
      integer            m, n, k, lda, ldb, ldc
      REAL   alpha, beta
*     .. array arguments ..
      REAL   a( lda, * ), b( ldb, * ), c( ldc, * )
*     ..
*
*  purpose
*  =======
*
*  dgemm  performs one of the matrix-matrix operations
*
*     c := alpha*op( a )*op( b ) + beta*c,
*
*  where  op( x ) is one of
*
*     op( x ) = x   or   op( x ) = x',
*
*  alpha and beta are scalars, and a, b and c are matrices, with op( a )
*  an m by k matrix,  op( b )  a  k by n matrix and  c an m by n matrix.
*
*  parameters
*  ==========
*
*  transa - character*1.
*           on entry, transa specifies the form of op( a ) to be used in
*           the matrix multiplication as follows:
*
*              transa = 'n' or 'n',  op( a ) = a.
*
*              transa = 't' or 't',  op( a ) = a'.
*
*              transa = 'c' or 'c',  op( a ) = a'.
*
*           unchanged on exit.
*
*  transb - character*1.
*           on entry, transb specifies the form of op( b ) to be used in
*           the matrix multiplication as follows:
*
*              transb = 'n' or 'n',  op( b ) = b.
*
*              transb = 't' or 't',  op( b ) = b'.
*
*              transb = 'c' or 'c',  op( b ) = b'.
*
*           unchanged on exit.
*
*  m      - integer.
*           on entry,  m  specifies  the number  of rows  of the  matrix
*           op( a )  and of the  matrix  c.  m  must  be at least  zero.
*           unchanged on exit.
*
*  n      - integer.
*           on entry,  n  specifies the number  of columns of the matrix
*           op( b ) and the number of columns of the matrix c. n must be
*           at least zero.
*           unchanged on exit.
*
*  k      - integer.
*           on entry,  k  specifies  the number of columns of the matrix
*           op( a ) and the number of rows of the matrix op( b ). k must
*           be at least  zero.
*           unchanged on exit.
*
*  alpha  - double precision.
*           on entry, alpha specifies the scalar alpha.
*           unchanged on exit.
*
*  a      - double precision array of dimension ( lda, ka ), where ka is
*           k  when  transa = 'n' or 'n',  and is  m  otherwise.
*           before entry with  transa = 'n' or 'n',  the leading  m by k
*           part of the array  a  must contain the matrix  a,  otherwise
*           the leading  k by m  part of the array  a  must contain  the
*           matrix a.
*           unchanged on exit.
*
*  lda    - integer.
*           on entry, lda specifies the first dimension of a as declared
*           in the calling (sub) program. when  transa = 'n' or 'n' then
*           lda must be at least  max( 1, m ), otherwise  lda must be at
*           least  max( 1, k ).
*           unchanged on exit.
*
*  b      - double precision array of dimension ( ldb, kb ), where kb is
*           n  when  transb = 'n' or 'n',  and is  k  otherwise.
*           before entry with  transb = 'n' or 'n',  the leading  k by n
*           part of the array  b  must contain the matrix  b,  otherwise
*           the leading  n by k  part of the array  b  must contain  the
*           matrix b.
*           unchanged on exit.
*
*  ldb    - integer.
*           on entry, ldb specifies the first dimension of b as declared
*           in the calling (sub) program. when  transb = 'n' or 'n' then
*           ldb must be at least  max( 1, k ), otherwise  ldb must be at
*           least  max( 1, n ).
*           unchanged on exit.
*
*  beta   - double precision.
*           on entry,  beta  specifies the scalar  beta.  when  beta  is
*           supplied as zero then c need not be set on input.
*           unchanged on exit.
*
*  c      - double precision array of dimension ( ldc, n ).
*           before entry, the leading  m by n  part of the array  c must
*           contain the matrix  c,  except when  beta  is zero, in which
*           case c need not be set on entry.
*           on exit, the array  c  is overwritten by the  m by n  matrix
*           ( alpha*op( a )*op( b ) + beta*c ).
*
*  ldc    - integer.
*           on entry, ldc specifies the first dimension of c as declared
*           in  the  calling  (sub)  program.   ldc  must  be  at  least
*           max( 1, m ).
*           unchanged on exit.
*
*
*  level 3 blas routine.
*
*  -- written on 8-february-1989.
*     jack dongarra, argonne national laboratory.
*     iain duff, aere harwell.
*     jeremy du croz, numerical algorithms group ltd.
*     sven hammarling, numerical algorithms group ltd.
*
*
*     .. external functions ..
      logical            lsame
      external           lsame
*     .. external subroutines ..
      external           xerbla
*     .. intrinsic functions ..
      intrinsic          max
*     .. local scalars ..
      logical            nota, notb
      integer            i, info, j, l, ncola, nrowa, nrowb
      REAL   temp
*     .. parameters ..
      REAL   one         , zero
      parameter        ( one = 1.0d+0, zero = 0.0d+0 )
*     ..
*     .. executable statements ..
*
*     set  nota  and  notb  as  true if  a  and  b  respectively are not
*     transposed and set  nrowa, ncola and  nrowb  as the number of rows
*     and  columns of  a  and the  number of  rows  of  b  respectively.
*
      nota  = lsame( transa, 'n' )
      notb  = lsame( transb, 'n' )
      if( nota )then
         nrowa = m
         ncola = k
      else
         nrowa = k
         ncola = m
      end if
      if( notb )then
         nrowb = k
      else
         nrowb = n
      end if
*
*     test the input parameters.
*
      info = 0
      if(      ( .not.nota                 ).and.
     $         ( .not.lsame( transa, 'c' ) ).and.
     $         ( .not.lsame( transa, 't' ) )      )then
         info = 1
      else if( ( .not.notb                 ).and.
     $         ( .not.lsame( transb, 'c' ) ).and.
     $         ( .not.lsame( transb, 't' ) )      )then
         info = 2
      else if( m  .lt.0               )then
         info = 3
      else if( n  .lt.0               )then
         info = 4
      else if( k  .lt.0               )then
         info = 5
      else if( lda.lt.max( 1, nrowa ) )then
         info = 8
      else if( ldb.lt.max( 1, nrowb ) )then
         info = 10
      else if( ldc.lt.max( 1, m     ) )then
         info = 13
      end if
      if( info.ne.0 )then
         call xerbla( 'dgemm ', info )
         return
      end if
*
*     quick return if possible.
*
      if( ( m.eq.0 ).or.( n.eq.0 ).or.
     $    ( ( ( alpha.eq.zero ).or.( k.eq.0 ) ).and.( beta.eq.one ) ) )
     $   return
*
*     and if  alpha.eq.zero.
*
      if( alpha.eq.zero )then
         if( beta.eq.zero )then
            do 20, j = 1, n
               do 10, i = 1, m
                  c( i, j ) = zero
   10          continue
   20       continue
         else
            do 40, j = 1, n
               do 30, i = 1, m
                  c( i, j ) = beta*c( i, j )
   30          continue
   40       continue
         end if
         return
      end if
*
*     start the operations.
*
      if( notb )then
         if( nota )then
*
*           form  c := alpha*a*b + beta*c.
*
            do 90, j = 1, n
               if( beta.eq.zero )then
                  do 50, i = 1, m
                     c( i, j ) = zero
   50             continue
               else if( beta.ne.one )then
                  do 60, i = 1, m
                     c( i, j ) = beta*c( i, j )
   60             continue
               end if
               do 80, l = 1, k
                  if( b( l, j ).ne.zero )then
                     temp = alpha*b( l, j )
                     do 70, i = 1, m
                        c( i, j ) = c( i, j ) + temp*a( i, l )
   70                continue
                  end if
   80          continue
   90       continue
         else
*
*           form  c := alpha*a'*b + beta*c
*
            do 120, j = 1, n
               do 110, i = 1, m
                  temp = zero
                  do 100, l = 1, k
                     temp = temp + a( l, i )*b( l, j )
  100             continue
                  if( beta.eq.zero )then
                     c( i, j ) = alpha*temp
                  else
                     c( i, j ) = alpha*temp + beta*c( i, j )
                  end if
  110          continue
  120       continue
         end if
      else
         if( nota )then
*
*           form  c := alpha*a*b' + beta*c
*
            do 170, j = 1, n
               if( beta.eq.zero )then
                  do 130, i = 1, m
                     c( i, j ) = zero
  130             continue
               else if( beta.ne.one )then
                  do 140, i = 1, m
                     c( i, j ) = beta*c( i, j )
  140             continue
               end if
               do 160, l = 1, k
                  if( b( j, l ).ne.zero )then
                     temp = alpha*b( j, l )
                     do 150, i = 1, m
                        c( i, j ) = c( i, j ) + temp*a( i, l )
  150                continue
                  end if
  160          continue
  170       continue
         else
*
*           form  c := alpha*a'*b' + beta*c
*
            do 200, j = 1, n
               do 190, i = 1, m
                  temp = zero
                  do 180, l = 1, k
                     temp = temp + a( l, i )*b( j, l )
  180             continue
                  if( beta.eq.zero )then
                     c( i, j ) = alpha*temp
                  else
                     c( i, j ) = alpha*temp + beta*c( i, j )
                  end if
  190          continue
  200       continue
         end if
      end if
*
      return
*
*     end of dgemm .
*
      end
      subroutine dgemv ( trans, m, n, alpha, a, lda, x, incx,
     $                   beta, y, incy )
*     .. scalar arguments ..
      REAL   alpha, beta
      integer            incx, incy, lda, m, n
      character*1        trans
*     .. array arguments ..
      REAL   a( lda, * ), x( * ), y( * )
*     ..
*
*  purpose
*  =======
*
*  dgemv  performs one of the matrix-vector operations
*
*     y := alpha*a*x + beta*y,   or   y := alpha*a'*x + beta*y,
*
*  where alpha and beta are scalars, x and y are vectors and a is an
*  m by n matrix.
*
*  parameters
*  ==========
*
*  trans  - character*1.
*           on entry, trans specifies the operation to be performed as
*           follows:
*
*              trans = 'n' or 'n'   y := alpha*a*x + beta*y.
*
*              trans = 't' or 't'   y := alpha*a'*x + beta*y.
*
*              trans = 'c' or 'c'   y := alpha*a'*x + beta*y.
*
*           unchanged on exit.
*
*  m      - integer.
*           on entry, m specifies the number of rows of the matrix a.
*           m must be at least zero.
*           unchanged on exit.
*
*  n      - integer.
*           on entry, n specifies the number of columns of the matrix a.
*           n must be at least zero.
*           unchanged on exit.
*
*  alpha  - double precision.
*           on entry, alpha specifies the scalar alpha.
*           unchanged on exit.
*
*  a      - double precision array of dimension ( lda, n ).
*           before entry, the leading m by n part of the array a must
*           contain the matrix of coefficients.
*           unchanged on exit.
*
*  lda    - integer.
*           on entry, lda specifies the first dimension of a as declared
*           in the calling (sub) program. lda must be at least
*           max( 1, m ).
*           unchanged on exit.
*
*  x      - double precision array of dimension at least
*           ( 1 + ( n - 1 )*abs( incx ) ) when trans = 'n' or 'n'
*           and at least
*           ( 1 + ( m - 1 )*abs( incx ) ) otherwise.
*           before entry, the incremented array x must contain the
*           vector x.
*           unchanged on exit.
*
*  incx   - integer.
*           on entry, incx specifies the increment for the elements of
*           x. incx must not be zero.
*           unchanged on exit.
*
*  beta   - double precision.
*           on entry, beta specifies the scalar beta. when beta is
*           supplied as zero then y need not be set on input.
*           unchanged on exit.
*
*  y      - double precision array of dimension at least
*           ( 1 + ( m - 1 )*abs( incy ) ) when trans = 'n' or 'n'
*           and at least
*           ( 1 + ( n - 1 )*abs( incy ) ) otherwise.
*           before entry with beta non-zero, the incremented array y
*           must contain the vector y. on exit, y is overwritten by the
*           updated vector y.
*
*  incy   - integer.
*           on entry, incy specifies the increment for the elements of
*           y. incy must not be zero.
*           unchanged on exit.
*
*
*  level 2 blas routine.
*
*  -- written on 22-october-1986.
*     jack dongarra, argonne national lab.
*     jeremy du croz, nag central office.
*     sven hammarling, nag central office.
*     richard hanson, sandia national labs.
*
*
*     .. parameters ..
      REAL   one         , zero
      parameter        ( one = 1.0d+0, zero = 0.0d+0 )
*     .. local scalars ..
      REAL   temp
      integer            i, info, ix, iy, j, jx, jy, kx, ky, lenx, leny
*     .. external functions ..
      logical            lsame
      external           lsame
*     .. external subroutines ..
      external           xerbla
*     .. intrinsic functions ..
      intrinsic          max
*     ..
*     .. executable statements ..
*
*     test the input parameters.
*
      info = 0
      if     ( .not.lsame( trans, 'n' ).and.
     $         .not.lsame( trans, 't' ).and.
     $         .not.lsame( trans, 'c' )      )then
         info = 1
      else if( m.lt.0 )then
         info = 2
      else if( n.lt.0 )then
         info = 3
      else if( lda.lt.max( 1, m ) )then
         info = 6
      else if( incx.eq.0 )then
         info = 8
      else if( incy.eq.0 )then
         info = 11
      end if
      if( info.ne.0 )then
         call xerbla( 'dgemv ', info )
         return
      end if
*
*     quick return if possible.
*
      if( ( m.eq.0 ).or.( n.eq.0 ).or.
     $    ( ( alpha.eq.zero ).and.( beta.eq.one ) ) )
     $   return
*
*     set  lenx  and  leny, the lengths of the vectors x and y, and set
*     up the start points in  x  and  y.
*
      if( lsame( trans, 'n' ) )then
         lenx = n
         leny = m
      else
         lenx = m
         leny = n
      end if
      if( incx.gt.0 )then
         kx = 1
      else
         kx = 1 - ( lenx - 1 )*incx
      end if
      if( incy.gt.0 )then
         ky = 1
      else
         ky = 1 - ( leny - 1 )*incy
      end if
*
*     start the operations. in this version the elements of a are
*     accessed sequentially with one pass through a.
*
*     first form  y := beta*y.
*
      if( beta.ne.one )then
         if( incy.eq.1 )then
            if( beta.eq.zero )then
               do 10, i = 1, leny
                  y( i ) = zero
   10          continue
            else
               do 20, i = 1, leny
                  y( i ) = beta*y( i )
   20          continue
            end if
         else
            iy = ky
            if( beta.eq.zero )then
               do 30, i = 1, leny
                  y( iy ) = zero
                  iy      = iy   + incy
   30          continue
            else
               do 40, i = 1, leny
                  y( iy ) = beta*y( iy )
                  iy      = iy           + incy
   40          continue
            end if
         end if
      end if
      if( alpha.eq.zero )
     $   return
      if( lsame( trans, 'n' ) )then
*
*        form  y := alpha*a*x + y.
*
         jx = kx
         if( incy.eq.1 )then
            do 60, j = 1, n
               if( x( jx ).ne.zero )then
                  temp = alpha*x( jx )
                  do 50, i = 1, m
                     y( i ) = y( i ) + temp*a( i, j )
   50             continue
               end if
               jx = jx + incx
   60       continue
         else
            do 80, j = 1, n
               if( x( jx ).ne.zero )then
                  temp = alpha*x( jx )
                  iy   = ky
                  do 70, i = 1, m
                     y( iy ) = y( iy ) + temp*a( i, j )
                     iy      = iy      + incy
   70             continue
               end if
               jx = jx + incx
   80       continue
         end if
      else
*
*        form  y := alpha*a'*x + y.
*
         jy = ky
         if( incx.eq.1 )then
            do 100, j = 1, n
               temp = zero
               do 90, i = 1, m
                  temp = temp + a( i, j )*x( i )
   90          continue
               y( jy ) = y( jy ) + alpha*temp
               jy      = jy      + incy
  100       continue
         else
            do 120, j = 1, n
               temp = zero
               ix   = kx
               do 110, i = 1, m
                  temp = temp + a( i, j )*x( ix )
                  ix   = ix   + incx
  110          continue
               y( jy ) = y( jy ) + alpha*temp
               jy      = jy      + incy
  120       continue
         end if
      end if
*
      return
*
*     end of dgemv .
*
      end
      subroutine dger  ( m, n, alpha, x, incx, y, incy, a, lda )
*     .. scalar arguments ..
      REAL   alpha
      integer            incx, incy, lda, m, n
*     .. array arguments ..
      REAL   a( lda, * ), x( * ), y( * )
*     ..
*
*  purpose
*  =======
*
*  dger   performs the rank 1 operation
*
*     a := alpha*x*y' + a,
*
*  where alpha is a scalar, x is an m element vector, y is an n element
*  vector and a is an m by n matrix.
*
*  parameters
*  ==========
*
*  m      - integer.
*           on entry, m specifies the number of rows of the matrix a.
*           m must be at least zero.
*           unchanged on exit.
*
*  n      - integer.
*           on entry, n specifies the number of columns of the matrix a.
*           n must be at least zero.
*           unchanged on exit.
*
*  alpha  - double precision.
*           on entry, alpha specifies the scalar alpha.
*           unchanged on exit.
*
*  x      - double precision array of dimension at least
*           ( 1 + ( m - 1 )*abs( incx ) ).
*           before entry, the incremented array x must contain the m
*           element vector x.
*           unchanged on exit.
*
*  incx   - integer.
*           on entry, incx specifies the increment for the elements of
*           x. incx must not be zero.
*           unchanged on exit.
*
*  y      - double precision array of dimension at least
*           ( 1 + ( n - 1 )*abs( incy ) ).
*           before entry, the incremented array y must contain the n
*           element vector y.
*           unchanged on exit.
*
*  incy   - integer.
*           on entry, incy specifies the increment for the elements of
*           y. incy must not be zero.
*           unchanged on exit.
*
*  a      - double precision array of dimension ( lda, n ).
*           before entry, the leading m by n part of the array a must
*           contain the matrix of coefficients. on exit, a is
*           overwritten by the updated matrix.
*
*  lda    - integer.
*           on entry, lda specifies the first dimension of a as declared
*           in the calling (sub) program. lda must be at least
*           max( 1, m ).
*           unchanged on exit.
*
*
*  level 2 blas routine.
*
*  -- written on 22-october-1986.
*     jack dongarra, argonne national lab.
*     jeremy du croz, nag central office.
*     sven hammarling, nag central office.
*     richard hanson, sandia national labs.
*
*
*     .. parameters ..
      REAL   zero
      parameter        ( zero = 0.0d+0 )
*     .. local scalars ..
      REAL   temp
      integer            i, info, ix, j, jy, kx
*     .. external subroutines ..
      external           xerbla
*     .. intrinsic functions ..
      intrinsic          max
*     ..
*     .. executable statements ..
*
*     test the input parameters.
*
      info = 0
      if     ( m.lt.0 )then
         info = 1
      else if( n.lt.0 )then
         info = 2
      else if( incx.eq.0 )then
         info = 5
      else if( incy.eq.0 )then
         info = 7
      else if( lda.lt.max( 1, m ) )then
         info = 9
      end if
      if( info.ne.0 )then
         call xerbla( 'dger  ', info )
         return
      end if
*
*     quick return if possible.
*
      if( ( m.eq.0 ).or.( n.eq.0 ).or.( alpha.eq.zero ) )
     $   return
*
*     start the operations. in this version the elements of a are
*     accessed sequentially with one pass through a.
*
      if( incy.gt.0 )then
         jy = 1
      else
         jy = 1 - ( n - 1 )*incy
      end if
      if( incx.eq.1 )then
         do 20, j = 1, n
            if( y( jy ).ne.zero )then
               temp = alpha*y( jy )
               do 10, i = 1, m
                  a( i, j ) = a( i, j ) + x( i )*temp
   10          continue
            end if
            jy = jy + incy
   20    continue
      else
         if( incx.gt.0 )then
            kx = 1
         else
            kx = 1 - ( m - 1 )*incx
         end if
         do 40, j = 1, n
            if( y( jy ).ne.zero )then
               temp = alpha*y( jy )
               ix   = kx
               do 30, i = 1, m
                  a( i, j ) = a( i, j ) + x( ix )*temp
                  ix        = ix        + incx
   30          continue
            end if
            jy = jy + incy
   40    continue
      end if
*
      return
*
*     end of dger  .
*
      end
      subroutine dgetf2( m, n, a, lda, ipiv, info )
*
*  -- lapack routine (version 1.0b) --
*     univ. of tennessee, univ. of california berkeley, nag ltd.,
*     courant institute, argonne national lab, and rice university
*     june 30, 1992
*
*     .. scalar arguments ..
      integer            info, lda, m, n
*     ..
*     .. array arguments ..
      integer            ipiv( * )
      REAL   a( lda, * )
*     ..
*
*  purpose
*  =======
*
*  dgetf2 computes an lu factorization of a general m-by-n matrix a
*  using partial pivoting with row interchanges.
*
*  the factorization has the form
*     a = p * l * u
*  where p is a permutation matrix, l is lower triangular with unit
*  diagonal elements (lower trapezoidal if m > n), and u is upper
*  triangular (upper trapezoidal if m < n).
*
*  this is the right-looking level 2 blas version of the algorithm.
*
*  arguments
*  =========
*
*  m       (input) integer
*          the number of rows of the matrix a.  m >= 0.
*
*  n       (input) integer
*          the number of columns of the matrix a.  n >= 0.
*
*  a       (input/output) double precision array, dimension (lda,n)
*          on entry, the m by n matrix to be factored.
*          on exit, the factors l and u from the factorization
*          a = p*l*u; the unit diagonal elements of l are not stored.
*
*  lda     (input) integer
*          the leading dimension of the array a.  lda >= max(1,m).
*
*  ipiv    (output) integer array, dimension (min(m,n))
*          the pivot indices; for 1 <= i <= min(m,n), row i of the
*          matrix was interchanged with row ipiv(i).
*
*  info    (output) integer
*          = 0: successful exit
*          < 0: if info = -k, the k-th argument had an illegal value
*          > 0: if info = k, u(k,k) is exactly zero. the factorization
*               has been completed, but the factor u is exactly
*               singular, and division by zero will occur if it is used
*               to solve a system of equations.
*
*  =====================================================================
*
*     .. parameters ..
      double precision   one, zero
      parameter          ( one = 1.0d+0, zero = 0.0d+0 )
*     ..
*     .. local scalars ..
      integer            j, jp
*     ..
*     .. external functions ..
      integer            idamax
      external           idamax
*     ..
*     .. external subroutines ..
      external           dger, dscal, dswap, xerbla
*     ..
*     .. intrinsic functions ..
      intrinsic          max, min
*     ..
*     .. executable statements ..
*
*     test the input parameters.
*
      info = 0
      if( m.lt.0 ) then
         info = -1
      else if( n.lt.0 ) then
         info = -2
      else if( lda.lt.max( 1, m ) ) then
         info = -4
      end if
      if( info.ne.0 ) then
         call xerbla( 'dgetf2', -info )
         return
      end if
*
*     quick return if possible
*
      if( m.eq.0 .or. n.eq.0 )
     $   return
*
      do 10 j = 1, min( m, n )
*
*        find pivot and test for singularity.
*
         jp = j - 1 + idamax( m-j+1, a( j, j ), 1 )
         ipiv( j ) = jp
         if( a( jp, j ).ne.zero ) then
*
*           apply the interchange to columns 1:n.
*
            if( jp.ne.j )
     $         call dswap( n, a( j, 1 ), lda, a( jp, 1 ), lda )
*
*           compute elements j+1:m of j-th column.
*
            if( j.lt.m )
     $         call dscal( m-j, one / a( j, j ), a( j+1, j ), 1 )
*
         else if( info.eq.0 ) then
*
            info = j
         end if
*
         if( j.lt.min( m, n ) ) then
*
*           update trailing submatrix.
*
            call dger( m-j, n-j, -one, a( j+1, j ), 1, a( j, j+1 ), lda,
     $                 a( j+1, j+1 ), lda )
         end if
   10 continue
      return
*
*     end of dgetf2
*
      end
      subroutine dgetrf( m, n, a, lda, ipiv, info )
*
*  -- lapack routine (version 1.0b) --
*     univ. of tennessee, univ. of california berkeley, nag ltd.,
*     courant institute, argonne national lab, and rice university
*     february 29, 1992
*
*     .. scalar arguments ..
      integer            info, lda, m, n
*     ..
*     .. array arguments ..
      integer            ipiv( * )
      REAL   a( lda, * )
*     ..
*
*  purpose
*  =======
*
*  dgetrf computes an lu factorization of a general m-by-n matrix a
*  using partial pivoting with row interchanges.
*
*  the factorization has the form
*     a = p * l * u
*  where p is a permutation matrix, l is lower triangular with unit
*  diagonal elements (lower trapezoidal if m > n), and u is upper
*  triangular (upper trapezoidal if m < n).
*
*  this is the right-looking level 3 blas version of the algorithm.
*
*  arguments
*  =========
*
*  m       (input) integer
*          the number of rows of the matrix a.  m >= 0.
*
*  n       (input) integer
*          the number of columns of the matrix a.  n >= 0.
*
*  a       (input/output) double precision array, dimension (lda,n)
*          on entry, the m by n matrix to be factored.
*          on exit, the factors l and u from the factorization
*          a = p*l*u; the unit diagonal elements of l are not stored.
*
*  lda     (input) integer
*          the leading dimension of the array a.  lda >= max(1,m).
*
*  ipiv    (output) integer array, dimension (min(m,n))
*          the pivot indices; for 1 <= i <= min(m,n), row i of the
*          matrix was interchanged with row ipiv(i).
*
*  info    (output) integer
*          = 0: successful exit
*          < 0: if info = -k, the k-th argument had an illegal value
*          > 0: if info = k, u(k,k) is exactly zero. the factorization
*               has been completed, but the factor u is exactly
*               singular, and division by zero will occur if it is used
*               to solve a system of equations.
*
*  =====================================================================
*
*     .. parameters ..
      REAL   one
      parameter          ( one = 1.0d+0 )
*     ..
*     .. local scalars ..
      integer            i, iinfo, j, jb, nb
*     ..
*     .. external subroutines ..
      external           dgemm, dgetf2, dlaswp, dtrsm, xerbla
*     ..
*     .. external functions ..
      integer            ilaenv
      external           ilaenv
*     ..
*     .. intrinsic functions ..
      intrinsic          max, min
*     ..
*     .. executable statements ..
*
*     test the input parameters.
*
      info = 0
      if( m.lt.0 ) then
         info = -1
      else if( n.lt.0 ) then
         info = -2
      else if( lda.lt.max( 1, m ) ) then
         info = -4
      end if
      if( info.ne.0 ) then
         call xerbla( 'dgetrf', -info )
         return
      end if
*
*     quick return if possible
*
      if( m.eq.0 .or. n.eq.0 )
     $   return
*
*     determine the block size for this environment.
*
      nb = ilaenv( 1, 'dgetrf', ' ', m, n, -1, -1 )
      if( nb.le.1 .or. nb.ge.min( m, n ) ) then
*
*        use unblocked code.
*
         call dgetf2( m, n, a, lda, ipiv, info )
      else
*
*        use blocked code.
*
         do 20 j = 1, min( m, n ), nb
            jb = min( min( m, n )-j+1, nb )
*
*           factor diagonal and subdiagonal blocks and test for exact
*           singularity.
*
            call dgetf2( m-j+1, jb, a( j, j ), lda, ipiv( j ), iinfo )
*
*           adjust info and the pivot indices.
*
            if( info.eq.0 .and. iinfo.gt.0 )
     $         info = iinfo + j - 1
            do 10 i = j, min( m, j+jb-1 )
               ipiv( i ) = j - 1 + ipiv( i )
   10       continue
*
*           apply interchanges to columns 1:j-1.
*
            call dlaswp( j-1, a, lda, j, j+jb-1, ipiv, 1 )
*
            if( j+jb.le.n ) then
*
*              apply interchanges to columns j+jb:n.
*
               call dlaswp( n-j-jb+1, a( 1, j+jb ), lda, j, j+jb-1,
     $                      ipiv, 1 )
*
*              compute block row of u.
*
               call dtrsm( 'left', 'lower', 'no transpose', 'unit', jb,
     $                     n-j-jb+1, one, a( j, j ), lda, a( j, j+jb ),
     $                     lda )
               if( j+jb.le.m ) then
*
*                 update trailing submatrix.
*
                  call dgemm( 'no transpose', 'no transpose', m-j-jb+1,
     $                        n-j-jb+1, jb, -one, a( j+jb, j ), lda,
     $                        a( j, j+jb ), lda, one, a( j+jb, j+jb ),
     $                        lda )
               end if
            end if
   20    continue
      end if
      return
*
*     end of dgetrf
*
      end
      subroutine dgetri( n, a, lda, ipiv, work, lwork, info )
*
*  -- lapack routine (version 1.0b) --
*     univ. of tennessee, univ. of california berkeley, nag ltd.,
*     courant institute, argonne national lab, and rice university
*     june 30, 1992
*
*     .. scalar arguments ..
      integer            info, lda, lwork, n
*     ..
*     .. array arguments ..
      integer            ipiv( * )
      REAL   a( lda, * ), work( lwork )
*     ..
*
*  purpose
*  =======
*
*  dgetri computes the inverse of a matrix using the lu factorization
*  computed by dgetrf.
*
*  this method inverts u and then computes inv(a) by solving the system
*  inv(a)*l = inv(u) for inv(a).
*
*  arguments
*  =========
*
*  n       (input) integer
*          the order of the matrix a.  n >= 0.
*
*  a       (input/output) double precision array, dimension (lda,n)
*          on entry, the factors l and u from the factorization
*          a = p*l*u as computed by dgetrf.
*          on exit, if info = 0, the inverse of the original matrix a.
*
*  lda     (input) integer
*          the leading dimension of the array a.  lda >= max(1,n).
*
*  ipiv    (input) integer array, dimension (n)
*          the pivot indices from dgetrf; for 1<=i<=n, row i of the
*          matrix was interchanged with row ipiv(i).
*
*  work    (workspace) double precision array, dimension (lwork)
*          if info returns 0, then work(1) returns n*nb, the minimum
*          value of lwork required to use the optimal blocksize.
*
*  lwork   (input) integer
*          the dimension of the array work.  lwork >= max(1,n).
*          for optimal performance lwork should be at least n*nb,
*          where nb is the optimal blocksize returned by ilaenv.
*
*  info    (output) integer
*          = 0:  successful exit
*          < 0: if info = -k, the k-th argument had an illegal value
*          > 0: if info = k, u(k,k) is exactly zero; the matrix is
*               singular and its inverse could not be computed.
*
*  =====================================================================
*
*     .. parameters ..
      REAL   zero, one
      parameter          ( zero = 0.0d+0, one = 1.0d+0 )
*     ..
*     .. local scalars ..
      integer            i, iws, j, jb, jj, jp, ldwork, nb, nbmin, nn
*     ..
*     .. external functions ..
      integer            ilaenv
      external           ilaenv
*     ..
*     .. external subroutines ..
      external           dgemm, dgemv, dswap, dtrsm, dtrtri, xerbla
*     ..
*     .. intrinsic functions ..
      intrinsic          max, min
*     ..
*     .. executable statements ..
*
*     test the input parameters.
*
      info = 0
      work( 1 ) = max( n, 1 )
      if( n.lt.0 ) then
         info = -1
      else if( lda.lt.max( 1, n ) ) then
         info = -3
      else if( lwork.lt.max( 1, n ) ) then
         info = -6
      end if
      if( info.ne.0 ) then
         call xerbla( 'dgetri', -info )
         return
      end if
*
*     quick return if possible
*
      if( n.eq.0 )
     $   return
*
*     form inv(u).  if info > 0 from dtrtri, then u is singular,
*     and the inverse is not computed.
*
      call dtrtri( 'upper', 'non-unit', n, a, lda, info )
      if( info.gt.0 )
     $   return
*
*     determine the block size for this environment.
*
      nb = ilaenv( 1, 'dgetri', ' ', n, -1, -1, -1 )
      nbmin = 2
      ldwork = n
      if( nb.gt.1 .and. nb.lt.n ) then
         iws = max( ldwork*nb, 1 )
         if( lwork.lt.iws ) then
            nb = lwork / ldwork
            nbmin = max( 2, ilaenv( 2, 'dgetri', ' ', n, -1, -1, -1 ) )
         end if
      else
         iws = n
      end if
*
*     solve the equation inv(a)*l = inv(u) for inv(a).
*
      if( nb.lt.nbmin .or. nb.ge.n ) then
*
*        use unblocked code.
*
         do 20 j = n, 1, -1
*
*           copy current column of l to work and replace with zeros.
*
            do 10 i = j + 1, n
               work( i ) = a( i, j )
               a( i, j ) = zero
   10       continue
*
*           compute current column of inv(a).
*
            if( j.lt.n )
     $         call dgemv( 'no transpose', n, n-j, -one, a( 1, j+1 ),
     $                     lda, work( j+1 ), 1, one, a( 1, j ), 1 )
   20    continue
      else
*
*        use blocked code.
*
         nn = ( ( n-1 ) / nb )*nb + 1
         do 50 j = nn, 1, -nb
            jb = min( nb, n-j+1 )
*
*           copy current block column of l to work and replace with
*           zeros.
*
            do 40 jj = j, j + jb - 1
               do 30 i = jj + 1, n
                  work( i+( jj-j )*ldwork ) = a( i, jj )
                  a( i, jj ) = zero
   30          continue
   40       continue
*
*           compute current block column of inv(a).
*
            if( j+jb.le.n )
     $         call dgemm( 'no transpose', 'no transpose', n, jb,
     $                     n-j-jb+1, -one, a( 1, j+jb ), lda,
     $                     work( j+jb ), ldwork, one, a( 1, j ), lda )
            call dtrsm( 'right', 'lower', 'no transpose', 'unit', n, jb,
     $                  one, work( j ), ldwork, a( 1, j ), lda )
   50    continue
      end if
*
*     apply column interchanges.
*
      do 60 j = n - 1, 1, -1
         jp = ipiv( j )
         if( jp.ne.j )
     $      call dswap( n, a( 1, j ), 1, a( 1, jp ), 1 )
   60 continue
*
      work( 1 ) = iws
      return
*
*     end of dgetri
*
      subroutine dlaswp( n, a, lda, k1, k2, ipiv, incx )
*
*  -- lapack auxiliary routine (version 1.0b) --
*     univ. of tennessee, univ. of california berkeley, nag ltd.,
*     courant institute, argonne national lab, and rice university
*     october 31, 1992
*
*     .. scalar arguments ..
      integer            incx, k1, k2, lda, n
*     ..
*     .. array arguments ..
      integer            ipiv( * )
      double precision   a( lda, * )
*     ..
*
*  purpose
*  =======
*
*  dlaswp performs a series of row interchanges on the matrix a.
*  one row interchange is initiated for each of rows k1 through k2 of a.
*
*  arguments
*  =========
*
*  n       (input) integer
*          the number of columns of the matrix a.
*
*  a       (input/output) double precision array, dimension (lda,n)
*          on entry, the matrix of column dimension n to which the row
*          interchanges will be applied.
*          on exit, the permuted matrix.
*
*  lda     (input) integer
*          the leading dimension of the array a.
*
*  k1      (input) integer
*          the first element of ipiv for which a row interchange will
*          be done.
*
*  k2      (input) integer
*          the last element of ipiv for which a row interchange will
*          be done.
*
*  ipiv    (input) integer array, dimension (m*abs(incx))
*          the vector of pivot indices.  only the elements in positions
*          k1 through k2 of ipiv are accessed.
*          ipiv(k) = l implies rows k and l are to be interchanged.
*
*  incx    (input) integer
*          the increment between successive values of ipiv.  if ipiv
*          is negative, the pivots are applied in reverse order.
*
* =====================================================================
*
*     .. local scalars ..
      integer            i, ip, ix
*     ..
*     .. external subroutines ..
      external           dswap
*     ..
*     .. executable statements ..
*
*     interchange row i with row ipiv(i) for each of rows k1 through k2.
*
      if( incx.eq.0 )
     $   return
      if( incx.gt.0 ) then
         ix = k1
      else
         ix = 1 + ( 1-k2 )*incx
      end if
      if( incx.eq.1 ) then
         do 10 i = k1, k2
            ip = ipiv( i )
            if( ip.ne.i )
     $         call dswap( n, a( i, 1 ), lda, a( ip, 1 ), lda )
   10    continue
      else if( incx.gt.1 ) then
         do 20 i = k1, k2
            ip = ipiv( ix )
            if( ip.ne.i )
     $         call dswap( n, a( i, 1 ), lda, a( ip, 1 ), lda )
            ix = ix + incx
   20    continue
      else if( incx.lt.0 ) then
         do 30 i = k2, k1, -1
            ip = ipiv( ix )
            if( ip.ne.i )
     $         call dswap( n, a( i, 1 ), lda, a( ip, 1 ), lda )
            ix = ix + incx
   30    continue
      end if
*
      return
*
*     end of dlaswp
*
      end
      subroutine dtrmm ( side, uplo, transa, diag, m, n, alpha, a, lda,
     $                   b, ldb )
*     .. scalar arguments ..
      character*1        side, uplo, transa, diag
      integer            m, n, lda, ldb
      REAL   alpha
*     .. array arguments ..
      REAL   a( lda, * ), b( ldb, * )
*     ..
*
*  purpose
*  =======
*
*  dtrmm  performs one of the matrix-matrix operations
*
*     b := alpha*op( a )*b,   or   b := alpha*b*op( a ),
*
*  where  alpha  is a scalar,  b  is an m by n matrix,  a  is a unit, or
*  non-unit,  upper or lower triangular matrix  and  op( a )  is one  of
*
*     op( a ) = a   or   op( a ) = a'.
*
*  parameters
*  ==========
*
*  side   - character*1.
*           on entry,  side specifies whether  op( a ) multiplies b from
*           the left or right as follows:
*
*              side = 'l' or 'l'   b := alpha*op( a )*b.
*
*              side = 'r' or 'r'   b := alpha*b*op( a ).
*
*           unchanged on exit.
*
*  uplo   - character*1.
*           on entry, uplo specifies whether the matrix a is an upper or
*           lower triangular matrix as follows:
*
*              uplo = 'u' or 'u'   a is an upper triangular matrix.
*
*              uplo = 'l' or 'l'   a is a lower triangular matrix.
*
*           unchanged on exit.
*
*  transa - character*1.
*           on entry, transa specifies the form of op( a ) to be used in
*           the matrix multiplication as follows:
*
*              transa = 'n' or 'n'   op( a ) = a.
*
*              transa = 't' or 't'   op( a ) = a'.
*
*              transa = 'c' or 'c'   op( a ) = a'.
*
*           unchanged on exit.
*
*  diag   - character*1.
*           on entry, diag specifies whether or not a is unit triangular
*           as follows:
*
*              diag = 'u' or 'u'   a is assumed to be unit triangular.
*
*              diag = 'n' or 'n'   a is not assumed to be unit
*                                  triangular.
*
*           unchanged on exit.
*
*  m      - integer.
*           on entry, m specifies the number of rows of b. m must be at
*           least zero.
*           unchanged on exit.
*
*  n      - integer.
*           on entry, n specifies the number of columns of b.  n must be
*           at least zero.
*           unchanged on exit.
*
*  alpha  - double precision.
*           on entry,  alpha specifies the scalar  alpha. when  alpha is
*           zero then  a is not referenced and  b need not be set before
*           entry.
*           unchanged on exit.
*
*  a      - double precision array of dimension ( lda, k ), where k is m
*           when  side = 'l' or 'l'  and is  n  when  side = 'r' or 'r'.
*           before entry  with  uplo = 'u' or 'u',  the  leading  k by k
*           upper triangular part of the array  a must contain the upper
*           triangular matrix  and the strictly lower triangular part of
*           a is not referenced.
*           before entry  with  uplo = 'l' or 'l',  the  leading  k by k
*           lower triangular part of the array  a must contain the lower
*           triangular matrix  and the strictly upper triangular part of
*           a is not referenced.
*           note that when  diag = 'u' or 'u',  the diagonal elements of
*           a  are not referenced either,  but are assumed to be  unity.
*           unchanged on exit.
*
*  lda    - integer.
*           on entry, lda specifies the first dimension of a as declared
*           in the calling (sub) program.  when  side = 'l' or 'l'  then
*           lda  must be at least  max( 1, m ),  when  side = 'r' or 'r'
*           then lda must be at least max( 1, n ).
*           unchanged on exit.
*
*  b      - double precision array of dimension ( ldb, n ).
*           before entry,  the leading  m by n part of the array  b must
*           contain the matrix  b,  and  on exit  is overwritten  by the
*           transformed matrix.
*
*  ldb    - integer.
*           on entry, ldb specifies the first dimension of b as declared
*           in  the  calling  (sub)  program.   ldb  must  be  at  least
*           max( 1, m ).
*           unchanged on exit.
*
*
*  level 3 blas routine.
*
*  -- written on 8-february-1989.
*     jack dongarra, argonne national laboratory.
*     iain duff, aere harwell.
*     jeremy du croz, numerical algorithms group ltd.
*     sven hammarling, numerical algorithms group ltd.
*
*
*     .. external functions ..
      logical            lsame
      external           lsame
*     .. external subroutines ..
      external           xerbla
*     .. intrinsic functions ..
      intrinsic          max
*     .. local scalars ..
      logical            lside, nounit, upper
      integer            i, info, j, k, nrowa
      REAL   temp
*     .. parameters ..
      REAL   one         , zero
      parameter        ( one = 1.0d+0, zero = 0.0d+0 )
*     ..
*     .. executable statements ..
*
*     test the input parameters.
*
      lside  = lsame( side  , 'l' )
      if( lside )then
         nrowa = m
      else
         nrowa = n
      end if
      nounit = lsame( diag  , 'n' )
      upper  = lsame( uplo  , 'u' )
*
      info   = 0
      if(      ( .not.lside                ).and.
     $         ( .not.lsame( side  , 'r' ) )      )then
         info = 1
      else if( ( .not.upper                ).and.
     $         ( .not.lsame( uplo  , 'l' ) )      )then
         info = 2
      else if( ( .not.lsame( transa, 'n' ) ).and.
     $         ( .not.lsame( transa, 't' ) ).and.
     $         ( .not.lsame( transa, 'c' ) )      )then
         info = 3
      else if( ( .not.lsame( diag  , 'u' ) ).and.
     $         ( .not.lsame( diag  , 'n' ) )      )then
         info = 4
      else if( m  .lt.0               )then
         info = 5
      else if( n  .lt.0               )then
         info = 6
      else if( lda.lt.max( 1, nrowa ) )then
         info = 9
      else if( ldb.lt.max( 1, m     ) )then
         info = 11
      end if
      if( info.ne.0 )then
         call xerbla( 'dtrmm ', info )
         return
      end if
*
*     quick return if possible.
*
      if( n.eq.0 )
     $   return
*
*     and when  alpha.eq.zero.
*
      if( alpha.eq.zero )then
         do 20, j = 1, n
            do 10, i = 1, m
               b( i, j ) = zero
   10       continue
   20    continue
         return
      end if
*
*     start the operations.
*
      if( lside )then
         if( lsame( transa, 'n' ) )then
*
*           form  b := alpha*a*b.
*
            if( upper )then
               do 50, j = 1, n
                  do 40, k = 1, m
                     if( b( k, j ).ne.zero )then
                        temp = alpha*b( k, j )
                        do 30, i = 1, k - 1
                           b( i, j ) = b( i, j ) + temp*a( i, k )
   30                   continue
                        if( nounit )
     $                     temp = temp*a( k, k )
                        b( k, j ) = temp
                     end if
   40             continue
   50          continue
            else
               do 80, j = 1, n
                  do 70 k = m, 1, -1
                     if( b( k, j ).ne.zero )then
                        temp      = alpha*b( k, j )
                        b( k, j ) = temp
                        if( nounit )
     $                     b( k, j ) = b( k, j )*a( k, k )
                        do 60, i = k + 1, m
                           b( i, j ) = b( i, j ) + temp*a( i, k )
   60                   continue
                     end if
   70             continue
   80          continue
            end if
         else
*
*           form  b := alpha*b*a'.
*
            if( upper )then
               do 110, j = 1, n
                  do 100, i = m, 1, -1
                     temp = b( i, j )
                     if( nounit )
     $                  temp = temp*a( i, i )
                     do 90, k = 1, i - 1
                        temp = temp + a( k, i )*b( k, j )
   90                continue
                     b( i, j ) = alpha*temp
  100             continue
  110          continue
            else
               do 140, j = 1, n
                  do 130, i = 1, m
                     temp = b( i, j )
                     if( nounit )
     $                  temp = temp*a( i, i )
                     do 120, k = i + 1, m
                        temp = temp + a( k, i )*b( k, j )
  120                continue
                     b( i, j ) = alpha*temp
  130             continue
  140          continue
            end if
         end if
      else
         if( lsame( transa, 'n' ) )then
*
*           form  b := alpha*b*a.
*
            if( upper )then
               do 180, j = n, 1, -1
                  temp = alpha
                  if( nounit )
     $               temp = temp*a( j, j )
                  do 150, i = 1, m
                     b( i, j ) = temp*b( i, j )
  150             continue
                  do 170, k = 1, j - 1
                     if( a( k, j ).ne.zero )then
                        temp = alpha*a( k, j )
                        do 160, i = 1, m
                           b( i, j ) = b( i, j ) + temp*b( i, k )
  160                   continue
                     end if
  170             continue
  180          continue
            else
               do 220, j = 1, n
                  temp = alpha
                  if( nounit )
     $               temp = temp*a( j, j )
                  do 190, i = 1, m
                     b( i, j ) = temp*b( i, j )
  190             continue
                  do 210, k = j + 1, n
                     if( a( k, j ).ne.zero )then
                        temp = alpha*a( k, j )
                        do 200, i = 1, m
                           b( i, j ) = b( i, j ) + temp*b( i, k )
  200                   continue
                     end if
  210             continue
  220          continue
            end if
         else
*
*           form  b := alpha*b*a'.
*
            if( upper )then
               do 260, k = 1, n
                  do 240, j = 1, k - 1
                     if( a( j, k ).ne.zero )then
                        temp = alpha*a( j, k )
                        do 230, i = 1, m
                           b( i, j ) = b( i, j ) + temp*b( i, k )
  230                   continue
                     end if
  240             continue
                  temp = alpha
                  if( nounit )
     $               temp = temp*a( k, k )
                  if( temp.ne.one )then
                     do 250, i = 1, m
                        b( i, k ) = temp*b( i, k )
  250                continue
                  end if
  260          continue
            else
               do 300, k = n, 1, -1
                  do 280, j = k + 1, n
                     if( a( j, k ).ne.zero )then
                        temp = alpha*a( j, k )
                        do 270, i = 1, m
                           b( i, j ) = b( i, j ) + temp*b( i, k )
  270                   continue
                     end if
  280             continue
                  temp = alpha
                  if( nounit )
     $               temp = temp*a( k, k )
                  if( temp.ne.one )then
                     do 290, i = 1, m
                        b( i, k ) = temp*b( i, k )
  290                continue
                  end if
  300          continue
            end if
         end if
      end if
*
      return
*
*     end of dtrmm .
*
      end
      subroutine dtrmv ( uplo, trans, diag, n, a, lda, x, incx )
*     .. scalar arguments ..
      integer            incx, lda, n
      character*1        diag, trans, uplo
*     .. array arguments ..
      REAL   a( lda, * ), x( * )
*     ..
*
*  purpose
*  =======
*
*  dtrmv  performs one of the matrix-vector operations
*
*     x := a*x,   or   x := a'*x,
*
*  where x is an n element vector and  a is an n by n unit, or non-unit,
*  upper or lower triangular matrix.
*
*  parameters
*  ==========
*
*  uplo   - character*1.
*           on entry, uplo specifies whether the matrix is an upper or
*           lower triangular matrix as follows:
*
*              uplo = 'u' or 'u'   a is an upper triangular matrix.
*
*              uplo = 'l' or 'l'   a is a lower triangular matrix.
*
*           unchanged on exit.
*
*  trans  - character*1.
*           on entry, trans specifies the operation to be performed as
*           follows:
*
*              trans = 'n' or 'n'   x := a*x.
*
*              trans = 't' or 't'   x := a'*x.
*
*              trans = 'c' or 'c'   x := a'*x.
*
*           unchanged on exit.
*
*  diag   - character*1.
*           on entry, diag specifies whether or not a is unit
*           triangular as follows:
*
*              diag = 'u' or 'u'   a is assumed to be unit triangular.
*
*              diag = 'n' or 'n'   a is not assumed to be unit
*                                  triangular.
*
*           unchanged on exit.
*
*  n      - integer.
*           on entry, n specifies the order of the matrix a.
*           n must be at least zero.
*           unchanged on exit.
*
*  a      - double precision array of dimension ( lda, n ).
*           before entry with  uplo = 'u' or 'u', the leading n by n
*           upper triangular part of the array a must contain the upper
*           triangular matrix and the strictly lower triangular part of
*           a is not referenced.
*           before entry with uplo = 'l' or 'l', the leading n by n
*           lower triangular part of the array a must contain the lower
*           triangular matrix and the strictly upper triangular part of
*           a is not referenced.
*           note that when  diag = 'u' or 'u', the diagonal elements of
*           a are not referenced either, but are assumed to be unity.
*           unchanged on exit.
*
*  lda    - integer.
*           on entry, lda specifies the first dimension of a as declared
*           in the calling (sub) program. lda must be at least
*           max( 1, n ).
*           unchanged on exit.
*
*  x      - double precision array of dimension at least
*           ( 1 + ( n - 1 )*abs( incx ) ).
*           before entry, the incremented array x must contain the n
*           element vector x. on exit, x is overwritten with the
*           tranformed vector x.
*
*  incx   - integer.
*           on entry, incx specifies the increment for the elements of
*           x. incx must not be zero.
*           unchanged on exit.
*
*
*  level 2 blas routine.
*
*  -- written on 22-october-1986.
*     jack dongarra, argonne national lab.
*     jeremy du croz, nag central office.
*     sven hammarling, nag central office.
*     richard hanson, sandia national labs.
*
*
*     .. parameters ..
      REAL   zero
      parameter        ( zero = 0.0d+0 )
*     .. local scalars ..
      REAL   temp
      integer            i, info, ix, j, jx, kx
      logical            nounit
*     .. external functions ..
      logical            lsame
      external           lsame
*     .. external subroutines ..
      external           xerbla
*     .. intrinsic functions ..
      intrinsic          max
*     ..
*     .. executable statements ..
*
*     test the input parameters.
*
      info = 0
      if     ( .not.lsame( uplo , 'u' ).and.
     $         .not.lsame( uplo , 'l' )      )then
         info = 1
      else if( .not.lsame( trans, 'n' ).and.
     $         .not.lsame( trans, 't' ).and.
     $         .not.lsame( trans, 'c' )      )then
         info = 2
      else if( .not.lsame( diag , 'u' ).and.
     $         .not.lsame( diag , 'n' )      )then
         info = 3
      else if( n.lt.0 )then
         info = 4
      else if( lda.lt.max( 1, n ) )then
         info = 6
      else if( incx.eq.0 )then
         info = 8
      end if
      if( info.ne.0 )then
         call xerbla( 'dtrmv ', info )
         return
      end if
*
*     quick return if possible.
*
      if( n.eq.0 )
     $   return
*
      nounit = lsame( diag, 'n' )
*
*     set up the start point in x if the increment is not unity. this
*     will be  ( n - 1 )*incx  too small for descending loops.
*
      if( incx.le.0 )then
         kx = 1 - ( n - 1 )*incx
      else if( incx.ne.1 )then
         kx = 1
      end if
*
*     start the operations. in this version the elements of a are
*     accessed sequentially with one pass through a.
*
      if( lsame( trans, 'n' ) )then
*
*        form  x := a*x.
*
         if( lsame( uplo, 'u' ) )then
            if( incx.eq.1 )then
               do 20, j = 1, n
                  if( x( j ).ne.zero )then
                     temp = x( j )
                     do 10, i = 1, j - 1
                        x( i ) = x( i ) + temp*a( i, j )
   10                continue
                     if( nounit )
     $                  x( j ) = x( j )*a( j, j )
                  end if
   20          continue
            else
               jx = kx
               do 40, j = 1, n
                  if( x( jx ).ne.zero )then
                     temp = x( jx )
                     ix   = kx
                     do 30, i = 1, j - 1
                        x( ix ) = x( ix ) + temp*a( i, j )
                        ix      = ix      + incx
   30                continue
                     if( nounit )
     $                  x( jx ) = x( jx )*a( j, j )
                  end if
                  jx = jx + incx
   40          continue
            end if
         else
            if( incx.eq.1 )then
               do 60, j = n, 1, -1
                  if( x( j ).ne.zero )then
                     temp = x( j )
                     do 50, i = n, j + 1, -1
                        x( i ) = x( i ) + temp*a( i, j )
   50                continue
                     if( nounit )
     $                  x( j ) = x( j )*a( j, j )
                  end if
   60          continue
            else
               kx = kx + ( n - 1 )*incx
               jx = kx
               do 80, j = n, 1, -1
                  if( x( jx ).ne.zero )then
                     temp = x( jx )
                     ix   = kx
                     do 70, i = n, j + 1, -1
                        x( ix ) = x( ix ) + temp*a( i, j )
                        ix      = ix      - incx
   70                continue
                     if( nounit )
     $                  x( jx ) = x( jx )*a( j, j )
                  end if
                  jx = jx - incx
   80          continue
            end if
         end if
      else
*
*        form  x := a'*x.
*
         if( lsame( uplo, 'u' ) )then
            if( incx.eq.1 )then
               do 100, j = n, 1, -1
                  temp = x( j )
                  if( nounit )
     $               temp = temp*a( j, j )
                  do 90, i = j - 1, 1, -1
                     temp = temp + a( i, j )*x( i )
   90             continue
                  x( j ) = temp
  100          continue
            else
               jx = kx + ( n - 1 )*incx
               do 120, j = n, 1, -1
                  temp = x( jx )
                  ix   = jx
                  if( nounit )
     $               temp = temp*a( j, j )
                  do 110, i = j - 1, 1, -1
                     ix   = ix   - incx
                     temp = temp + a( i, j )*x( ix )
  110             continue
                  x( jx ) = temp
                  jx      = jx   - incx
  120          continue
            end if
         else
            if( incx.eq.1 )then
               do 140, j = 1, n
                  temp = x( j )
                  if( nounit )
     $               temp = temp*a( j, j )
                  do 130, i = j + 1, n
                     temp = temp + a( i, j )*x( i )
  130             continue
                  x( j ) = temp
  140          continue
            else
               jx = kx
               do 160, j = 1, n
                  temp = x( jx )
                  ix   = jx
                  if( nounit )
     $               temp = temp*a( j, j )
                  do 150, i = j + 1, n
                     ix   = ix   + incx
                     temp = temp + a( i, j )*x( ix )
  150             continue
                  x( jx ) = temp
                  jx      = jx   + incx
  160          continue
            end if
         end if
      end if
*
      return
*
*     end of dtrmv .
*
      end
      subroutine dtrsm ( side, uplo, transa, diag, m, n, alpha, a, lda,
     $                   b, ldb )
*     .. scalar arguments ..
      character*1        side, uplo, transa, diag
      integer            m, n, lda, ldb
      REAL   alpha
*     .. array arguments ..
      REAL   a( lda, * ), b( ldb, * )
*     ..
*
*  purpose
*  =======
*
*  dtrsm  solves one of the matrix equations
*
*     op( a )*x = alpha*b,   or   x*op( a ) = alpha*b,
*
*  where alpha is a scalar, x and b are m by n matrices, a is a unit, or
*  non-unit,  upper or lower triangular matrix  and  op( a )  is one  of
*
*     op( a ) = a   or   op( a ) = a'.
*
*  the matrix x is overwritten on b.
*
*  parameters
*  ==========
*
*  side   - character*1.
*           on entry, side specifies whether op( a ) appears on the left
*           or right of x as follows:
*
*              side = 'l' or 'l'   op( a )*x = alpha*b.
*
*              side = 'r' or 'r'   x*op( a ) = alpha*b.
*
*           unchanged on exit.
*
*  uplo   - character*1.
*           on entry, uplo specifies whether the matrix a is an upper or
*           lower triangular matrix as follows:
*
*              uplo = 'u' or 'u'   a is an upper triangular matrix.
*
*              uplo = 'l' or 'l'   a is a lower triangular matrix.
*
*           unchanged on exit.
*
*  transa - character*1.
*           on entry, transa specifies the form of op( a ) to be used in
*           the matrix multiplication as follows:
*
*              transa = 'n' or 'n'   op( a ) = a.
*
*              transa = 't' or 't'   op( a ) = a'.
*
*              transa = 'c' or 'c'   op( a ) = a'.
*
*           unchanged on exit.
*
*  diag   - character*1.
*           on entry, diag specifies whether or not a is unit triangular
*           as follows:
*
*              diag = 'u' or 'u'   a is assumed to be unit triangular.
*
*              diag = 'n' or 'n'   a is not assumed to be unit
*                                  triangular.
*
*           unchanged on exit.
*
*  m      - integer.
*           on entry, m specifies the number of rows of b. m must be at
*           least zero.
*           unchanged on exit.
*
*  n      - integer.
*           on entry, n specifies the number of columns of b.  n must be
*           at least zero.
*           unchanged on exit.
*
*  alpha  - double precision.
*           on entry,  alpha specifies the scalar  alpha. when  alpha is
*           zero then  a is not referenced and  b need not be set before
*           entry.
*           unchanged on exit.
*
*  a      - double precision array of dimension ( lda, k ), where k is m
*           when  side = 'l' or 'l'  and is  n  when  side = 'r' or 'r'.
*           before entry  with  uplo = 'u' or 'u',  the  leading  k by k
*           upper triangular part of the array  a must contain the upper
*           triangular matrix  and the strictly lower triangular part of
*           a is not referenced.
*           before entry  with  uplo = 'l' or 'l',  the  leading  k by k
*           lower triangular part of the array  a must contain the lower
*           triangular matrix  and the strictly upper triangular part of
*           a is not referenced.
*           note that when  diag = 'u' or 'u',  the diagonal elements of
*           a  are not referenced either,  but are assumed to be  unity.
*           unchanged on exit.
*
*  lda    - integer.
*           on entry, lda specifies the first dimension of a as declared
*           in the calling (sub) program.  when  side = 'l' or 'l'  then
*           lda  must be at least  max( 1, m ),  when  side = 'r' or 'r'
*           then lda must be at least max( 1, n ).
*           unchanged on exit.
*
*  b      - double precision array of dimension ( ldb, n ).
*           before entry,  the leading  m by n part of the array  b must
*           contain  the  right-hand  side  matrix  b,  and  on exit  is
*           overwritten by the solution matrix  x.
*
*  ldb    - integer.
*           on entry, ldb specifies the first dimension of b as declared
*           in  the  calling  (sub)  program.   ldb  must  be  at  least
*           max( 1, m ).
*           unchanged on exit.
*
*
*  level 3 blas routine.
*
*
*  -- written on 8-february-1989.
*     jack dongarra, argonne national laboratory.
*     iain duff, aere harwell.
*     jeremy du croz, numerical algorithms group ltd.
*     sven hammarling, numerical algorithms group ltd.
*
*
*     .. external functions ..
      logical            lsame
      external           lsame
*     .. external subroutines ..
      external           xerbla
*     .. intrinsic functions ..
      intrinsic          max
*     .. local scalars ..
      logical            lside, nounit, upper
      integer            i, info, j, k, nrowa
      REAL   temp
*     .. parameters ..
      REAL   one         , zero
      parameter        ( one = 1.0d+0, zero = 0.0d+0 )
*     ..
*     .. executable statements ..
*
*     test the input parameters.
*
      lside  = lsame( side  , 'l' )
      if( lside )then
         nrowa = m
      else
         nrowa = n
      end if
      nounit = lsame( diag  , 'n' )
      upper  = lsame( uplo  , 'u' )
*
      info   = 0
      if(      ( .not.lside                ).and.
     $         ( .not.lsame( side  , 'r' ) )      )then
         info = 1
      else if( ( .not.upper                ).and.
     $         ( .not.lsame( uplo  , 'l' ) )      )then
         info = 2
      else if( ( .not.lsame( transa, 'n' ) ).and.
     $         ( .not.lsame( transa, 't' ) ).and.
     $         ( .not.lsame( transa, 'c' ) )      )then
         info = 3
      else if( ( .not.lsame( diag  , 'u' ) ).and.
     $         ( .not.lsame( diag  , 'n' ) )      )then
         info = 4
      else if( m  .lt.0               )then
         info = 5
      else if( n  .lt.0               )then
         info = 6
      else if( lda.lt.max( 1, nrowa ) )then
         info = 9
      else if( ldb.lt.max( 1, m     ) )then
         info = 11
      end if
      if( info.ne.0 )then
         call xerbla( 'dtrsm ', info )
         return
      end if
*
*     quick return if possible.
*
      if( n.eq.0 )
     $   return
*
*     and when  alpha.eq.zero.
*
      if( alpha.eq.zero )then
         do 20, j = 1, n
            do 10, i = 1, m
               b( i, j ) = zero
   10       continue
   20    continue
         return
      end if
*
*     start the operations.
*
      if( lside )then
         if( lsame( transa, 'n' ) )then
*
*           form  b := alpha*inv( a )*b.
*
            if( upper )then
               do 60, j = 1, n
                  if( alpha.ne.one )then
                     do 30, i = 1, m
                        b( i, j ) = alpha*b( i, j )
   30                continue
                  end if
                  do 50, k = m, 1, -1
                     if( b( k, j ).ne.zero )then
                        if( nounit )
     $                     b( k, j ) = b( k, j )/a( k, k )
                        do 40, i = 1, k - 1
                           b( i, j ) = b( i, j ) - b( k, j )*a( i, k )
   40                   continue
                     end if
   50             continue
   60          continue
            else
               do 100, j = 1, n
                  if( alpha.ne.one )then
                     do 70, i = 1, m
                        b( i, j ) = alpha*b( i, j )
   70                continue
                  end if
                  do 90 k = 1, m
                     if( b( k, j ).ne.zero )then
                        if( nounit )
     $                     b( k, j ) = b( k, j )/a( k, k )
                        do 80, i = k + 1, m
                           b( i, j ) = b( i, j ) - b( k, j )*a( i, k )
   80                   continue
                     end if
   90             continue
  100          continue
            end if
         else
*
*           form  b := alpha*inv( a' )*b.
*
            if( upper )then
               do 130, j = 1, n
                  do 120, i = 1, m
                     temp = alpha*b( i, j )
                     do 110, k = 1, i - 1
                        temp = temp - a( k, i )*b( k, j )
  110                continue
                     if( nounit )
     $                  temp = temp/a( i, i )
                     b( i, j ) = temp
  120             continue
  130          continue
            else
               do 160, j = 1, n
                  do 150, i = m, 1, -1
                     temp = alpha*b( i, j )
                     do 140, k = i + 1, m
                        temp = temp - a( k, i )*b( k, j )
  140                continue
                     if( nounit )
     $                  temp = temp/a( i, i )
                     b( i, j ) = temp
  150             continue
  160          continue
            end if
         end if
      else
         if( lsame( transa, 'n' ) )then
*
*           form  b := alpha*b*inv( a ).
*
            if( upper )then
               do 210, j = 1, n
                  if( alpha.ne.one )then
                     do 170, i = 1, m
                        b( i, j ) = alpha*b( i, j )
  170                continue
                  end if
                  do 190, k = 1, j - 1
                     if( a( k, j ).ne.zero )then
                        do 180, i = 1, m
                           b( i, j ) = b( i, j ) - a( k, j )*b( i, k )
  180                   continue
                     end if
  190             continue
                  if( nounit )then
                     temp = one/a( j, j )
                     do 200, i = 1, m
                        b( i, j ) = temp*b( i, j )
  200                continue
                  end if
  210          continue
            else
               do 260, j = n, 1, -1
                  if( alpha.ne.one )then
                     do 220, i = 1, m
                        b( i, j ) = alpha*b( i, j )
  220                continue
                  end if
                  do 240, k = j + 1, n
                     if( a( k, j ).ne.zero )then
                        do 230, i = 1, m
                           b( i, j ) = b( i, j ) - a( k, j )*b( i, k )
  230                   continue
                     end if
  240             continue
                  if( nounit )then
                     temp = one/a( j, j )
                     do 250, i = 1, m
                       b( i, j ) = temp*b( i, j )
  250                continue
                  end if
  260          continue
            end if
         else
*
*           form  b := alpha*b*inv( a' ).
*
            if( upper )then
               do 310, k = n, 1, -1
                  if( nounit )then
                     temp = one/a( k, k )
                     do 270, i = 1, m
                        b( i, k ) = temp*b( i, k )
  270                continue
                  end if
                  do 290, j = 1, k - 1
                     if( a( j, k ).ne.zero )then
                        temp = a( j, k )
                        do 280, i = 1, m
                           b( i, j ) = b( i, j ) - temp*b( i, k )
  280                   continue
                     end if
  290             continue
                  if( alpha.ne.one )then
                     do 300, i = 1, m
                        b( i, k ) = alpha*b( i, k )
  300                continue
                  end if
  310          continue
            else
               do 360, k = 1, n
                  if( nounit )then
                     temp = one/a( k, k )
                     do 320, i = 1, m
                        b( i, k ) = temp*b( i, k )
  320                continue
                  end if
                  do 340, j = k + 1, n
                     if( a( j, k ).ne.zero )then
                        temp = a( j, k )
                        do 330, i = 1, m
                           b( i, j ) = b( i, j ) - temp*b( i, k )
  330                   continue
                     end if
  340             continue
                  if( alpha.ne.one )then
                     do 350, i = 1, m
                        b( i, k ) = alpha*b( i, k )
  350                continue
                  end if
  360          continue
            end if
         end if
      end if
*
      return
*
*     end of dtrsm .
*
      end
      subroutine dtrti2( uplo, diag, n, a, lda, info )
*
*  -- lapack routine (version 1.0b) --
*     univ. of tennessee, univ. of california berkeley, nag ltd.,
*     courant institute, argonne national lab, and rice university
*     february 29, 1992
*
*     .. scalar arguments ..
      character          diag, uplo
      integer            info, lda, n
*     ..
*     .. array arguments ..
      REAL   a( lda, * )
*     ..
*
*  purpose
*  =======
*
*  dtrti2 computes the inverse of a real upper or lower triangular
*  matrix.
*
*  this is the level 2 blas version of the algorithm.
*
*  arguments
*  =========
*
*  uplo    (input) character*1
*          specifies whether the matrix a is upper or lower triangular.
*          = 'u':  upper triangular
*          = 'l':  lower triangular
*
*  diag    (input) character*1
*          specifies whether or not the matrix a is unit triangular.
*          = 'n':  non-unit triangular
*          = 'u':  unit triangular
*
*  n       (input) integer
*          the order of the matrix a.  n >= 0.
*
*  a       (input/output) double precision array, dimension (lda,n)
*          on entry, the triangular matrix a.  if uplo = 'u', the
*          leading n by n upper triangular part of the array a contains
*          the upper triangular matrix, and the strictly lower
*          triangular part of a is not referenced.  if uplo = 'l', the
*          leading n by n lower triangular part of the array a contains
*          the lower triangular matrix, and the strictly upper
*          triangular part of a is not referenced.  if diag = 'u', the
*          diagonal elements of a are also not referenced and are
*          assumed to be 1.
*
*          on exit, the (triangular) inverse of the original matrix, in
*          the same storage format.
*
*  lda     (input) integer
*          the leading dimension of the array a.  lda >= max(1,n).
*
*  info    (output) integer
*          = 0: successful exit
*          < 0: if info = -k, the k-th argument had an illegal value
*
*  =====================================================================
*
*     .. parameters ..
      REAL   one
      parameter          ( one = 1.0d+0 )
*     ..
*     .. local scalars ..
      logical            nounit, upper
      integer            j
      REAL   ajj
*     ..
*     .. external functions ..
      logical            lsame
      external           lsame
*     ..
*     .. external subroutines ..
      external           dscal, dtrmv, xerbla
*     ..
*     .. intrinsic functions ..
      intrinsic          max
*     ..
*     .. executable statements ..
*
*     test the input parameters.
*
      info = 0
      upper = lsame( uplo, 'u' )
      nounit = lsame( diag, 'n' )
      if( .not.upper .and. .not.lsame( uplo, 'l' ) ) then
         info = -1
      else if( .not.nounit .and. .not.lsame( diag, 'u' ) ) then
         info = -2
      else if( n.lt.0 ) then
         info = -3
      else if( lda.lt.max( 1, n ) ) then
         info = -5
      end if
      if( info.ne.0 ) then
         call xerbla( 'dtrti2', -info )
         return
      end if
*
      if( upper ) then
*
*        compute inverse of upper triangular matrix.
*
         do 10 j = 1, n
            if( nounit ) then
               a( j, j ) = one / a( j, j )
               ajj = -a( j, j )
            else
               ajj = -one
            end if
*
*           compute elements 1:j-1 of j-th column.
*
            call dtrmv( 'upper', 'no transpose', diag, j-1, a, lda,
     $                  a( 1, j ), 1 )
            call dscal( j-1, ajj, a( 1, j ), 1 )
   10    continue
      else
*
*        compute inverse of lower triangular matrix.
*
         do 20 j = n, 1, -1
            if( nounit ) then
               a( j, j ) = one / a( j, j )
               ajj = -a( j, j )
            else
               ajj = -one
            end if
            if( j.lt.n ) then
*
*              compute elements j+1:n of j-th column.
*
               call dtrmv( 'lower', 'no transpose', diag, n-j,
     $                     a( j+1, j+1 ), lda, a( j+1, j ), 1 )
               call dscal( n-j, ajj, a( j+1, j ), 1 )
            end if
   20    continue
      end if
*
      return
*
*     end of dtrti2
*
      end
      subroutine dtrtri( uplo, diag, n, a, lda, info )
*
*  -- lapack routine (version 1.0b) --
*     univ. of tennessee, univ. of california berkeley, nag ltd.,
*     courant institute, argonne national lab, and rice university
*     february 29, 1992
*
*     .. scalar arguments ..
      character          diag, uplo
      integer            info, lda, n
*     ..
*     .. array arguments ..
      REAL   a( lda, * )
*     ..
*
*  purpose
*  =======
*
*  dtrtri computes the inverse of a real upper or lower triangular
*  matrix a.
*
*  this is the level 3 blas version of the algorithm.
*
*  arguments
*  =========
*
*  uplo    (input) character*1
*          specifies whether the matrix a is upper or lower triangular.
*          = 'u':  upper triangular
*          = 'l':  lower triangular
*
*  diag    (input) character*1
*          specifies whether or not the matrix a is unit triangular.
*          = 'n':  non-unit triangular
*          = 'u':  unit triangular
*
*  n       (input) integer
*          the order of the matrix a.  n >= 0.
*
*  a       (input/output) double precision array, dimension (lda,n)
*
*          on entry, the triangular matrix a.  if uplo = 'u', the
*          leading n by n upper triangular part of the array a contains
*          the upper triangular matrix, and the strictly lower
*          triangular part of a is not referenced.  if uplo = 'l', the
*          leading n by n lower triangular part of the array a contains
*          the lower triangular matrix, and the strictly upper
*          triangular part of a is not referenced.  if diag = 'u', the
*          diagonal elements of a are also not referenced and are
*          assumed to be 1.
*
*          on exit, the (triangular) inverse of the original matrix, in
*          the same storage format.
*
*  lda     (input) integer
*          the leading dimension of the array a.  lda >= max(1,n).
*
*  info    (output) integer
*          = 0: successful exit
*          > 0: if info = k, a(k,k) is exactly zero.  the triangular
*               matrix is singular and its inverse can not be computed.
*          < 0: if info = -k, the k-th argument had an illegal value
*
*  =====================================================================
*
*     .. parameters ..
      REAL   one, zero
      parameter          ( one = 1.0d+0, zero = 0.0d+0 )
*     ..
*     .. local scalars ..
      logical            nounit, upper
      integer            j, jb, nb, nn
*     ..
*     .. external functions ..
      logical            lsame
      integer            ilaenv
      external           lsame, ilaenv
*     ..
*     .. external subroutines ..
      external           dtrmm, dtrsm, dtrti2, xerbla
*     ..
*     .. intrinsic functions ..
      intrinsic          max, min
*     ..
*     .. executable statements ..
*
*     test the input parameters.
*
      info = 0
      upper = lsame( uplo, 'u' )
      nounit = lsame( diag, 'n' )
      if( .not.upper .and. .not.lsame( uplo, 'l' ) ) then
         info = -1
      else if( .not.nounit .and. .not.lsame( diag, 'u' ) ) then
         info = -2
      else if( n.lt.0 ) then
         info = -3
      else if( lda.lt.max( 1, n ) ) then
         info = -5
      end if
      if( info.ne.0 ) then
         call xerbla( 'dtrtri', -info )
         return
      end if
*
*     quick return if possible
*
      if( n.eq.0 )
     $   return
*
*     check for singularity if non-unit.
*
      if( nounit ) then
         do 10 info = 1, n
            if( a( info, info ).eq.zero )
     $         return
   10    continue
         info = 0
      end if
*
*     determine the block size for this environment.
*
      nb = ilaenv( 1, 'dtrtri', uplo // diag, n, -1, -1, -1 )
      if( nb.le.1 .or. nb.ge.n ) then
*
*        use unblocked code
*
         call dtrti2( uplo, diag, n, a, lda, info )
      else
*
*        use blocked code
*
         if( upper ) then
*
*           compute inverse of upper triangular matrix
*
            do 20 j = 1, n, nb
               jb = min( nb, n-j+1 )
*
*              compute rows 1:j-1 of current block column
*
               call dtrmm( 'left', 'upper', 'no transpose', diag, j-1,
     $                     jb, one, a, lda, a( 1, j ), lda )
               call dtrsm( 'right', 'upper', 'no transpose', diag, j-1,
     $                     jb, -one, a( j, j ), lda, a( 1, j ), lda )
*
*              compute inverse of current diagonal block
*
               call dtrti2( 'upper', diag, jb, a( j, j ), lda, info )
   20       continue
         else
*
*           compute inverse of lower triangular matrix
*
            nn = ( ( n-1 ) / nb )*nb + 1
            do 30 j = nn, 1, -nb
               jb = min( nb, n-j+1 )
               if( j+jb.le.n ) then
*
*                 compute rows j+jb:n of current block column
*
                  call dtrmm( 'left', 'lower', 'no transpose', diag,
     $                        n-j-jb+1, jb, one, a( j+jb, j+jb ), lda,
     $                        a( j+jb, j ), lda )
                  call dtrsm( 'right', 'lower', 'no transpose', diag,
     $                        n-j-jb+1, jb, -one, a( j, j ), lda,
     $                        a( j+jb, j ), lda )
               end if
*
*              compute inverse of current diagonal block
*
               call dtrti2( 'lower', diag, jb, a( j, j ), lda, info )
   30       continue
         end if
      end if
*
      return
*
*     end of dtrtri
*
      end
      integer function ilaenv( ispec, name, opts, n1, n2, n3, n4)
*
*  -- lapack auxiliary routine (preliminary version) --
*     univ. of tennessee, univ. of california berkeley, nag ltd.,
*     courant institute, argonne national lab, and rice university
*     february 20, 1992
*
*     .. scalar arguments ..
      character*( * )    name, opts
      integer            ispec, n1, n2, n3, n4
*     ..
*
*  purpose
*  =======
*
*  ilaenv is called from the lapack routines to choose problem-dependent
*  parameters for the local environment.  see ispec for a description of
*  the parameters.
*
*  this version provides a set of parameters which should give good,
*  but not optimal, performance on many of the currently available
*  computers.  users are encouraged to modify this routine to set
*  the tuning parameters for their particular machine using the option
*  and problem size information in the arguments.
*
*  this routine will not function correctly if it is converted to all
*  lower case.  converting it to all upper case is allowed.
*
*  arguments
*  =========
*
*  ispec   (input) integer
*          specifies the parameter to be returned as the value of
*          ilaenv.
*          = 1: the optimal blocksize; if this value is 1, an unblocked
*               algorithm will give the best performance.
*          = 2: the minimum block size for which the block routine
*               should be used; if the usable block size is less than
*               this value, an unblocked routine should be used.
*          = 3: the crossover point (in a block routine, for n less
*               than this value, an unblocked routine should be used)
*          = 4: the number of shifts, used in the nonsymmetric
*               eigenvalue routines
*          = 5: the minimum column dimension for blocking to be used;
*               rectangular blocks must have dimension at least k by m,
*               where k is given by ilaenv(2,...) and m by ilaenv(5,...)
*          = 6: the crossover point for the svd (when reducing an m by n
*               matrix to bidiagonal form, if max(m,n)/min(m,n) exceeds
*               this value, a qr factorization is used first to reduce
*               the matrix to a triangular form.)
*          = 7: the number of processors
*          = 8: the crossover point for the multishift qr and qz methods
*               for nonsymmetric eigenvalue problems.
*
*  name    (input) character*(*)
*          the name of the calling subroutine, in either upper case or
*          lower case.
*
*  opts    (input) character*(*)
*          the character options to the subroutine name, concatenated
*          into a single character string.  for example, uplo = 'u',
*          trans = 't', and diag = 'n' for a triangular routine would
*          be specified as opts = 'utn'.
*
*  n1      (input) integer
*  n2      (input) integer
*  n3      (input) integer
*  n4      (input) integer
*          problem dimensions for the subroutine name; these may not all
*          be required.
*
* (ilaenv) (output) integer
*          >= 0: the value of the parameter specified by ispec
*          < 0:  if ilaenv = -k, the k-th argument had an illegal value.
*
*  further details
*  ===============
*
*  the following conventions have been used when calling ilaenv from the
*  lapack routines:
*  1)  opts is a concatenation of all of the character options to
*      subroutine name, in the same order that they appear in the
*      argument list for name, even if they are not used in determining
*      the value of the parameter specified by ispec.
*  2)  the problem dimensions n1, n2, n3, n4 are specified in the order
*      that they appear in the argument list for name.  n1 is used
*      first, n2 second, and so on, and unused problem dimensions are
*      passed a value of -1.
*  3)  the parameter value returned by ilaenv is checked for validity in
*      the calling subroutine.  for example, ilaenv is used to retrieve
*      the optimal blocksize for strtri as follows:
*
*      nb = ilaenv( 1, 'strtri', uplo // diag, n, -1, -1, -1 )
*      if( nb.le.1 ) nb = max( 1, n )
*
*  =====================================================================
*
*     .. local scalars ..
      logical            cname, sname
      character*1        c1
      character*2        c2, c4
      character*3        c3
      character*6        subnam
      integer            i, ic, iz, nb, nbmin, nx
*     ..
*     .. intrinsic functions ..
      intrinsic          char, ichar, int, min, real
*     ..
*     .. executable statements ..
*
      go to ( 100, 100, 100, 400, 500, 600, 700, 800 ) ispec
*
*     invalid value for ispec
*
      ilaenv = -1
      return
*
  100 continue
*
*     convert name to upper case if the first character is lower case.
*
      ilaenv = 1
      subnam = name
      ic = ichar( subnam( 1:1 ) )
      iz = ichar( 'z' )
      if( iz.eq.90 .or. iz.eq.122 ) then
*
*        ascii character set
*
         if( ic.ge.97 .and. ic.le.122 ) then
            subnam( 1:1 ) = char( ic-32 )
            do 10 i = 2, 6
               ic = ichar( subnam( i:i ) )
               if( ic.ge.97 .and. ic.le.122 )
     $            subnam( i:i ) = char( ic-32 )
   10       continue
         end if
*
      else if( iz.eq.233 .or. iz.eq.169 ) then
*
*        ebcdic character set
*
         if( ( ic.ge.129 .and. ic.le.137 ) .or.
     $       ( ic.ge.145 .and. ic.le.153 ) .or.
     $       ( ic.ge.162 .and. ic.le.169 ) ) then
            subnam( 1:1 ) = char( ic+64 )
            do 20 i = 2, 6
               ic = ichar( subnam( i:i ) )
               if( ( ic.ge.129 .and. ic.le.137 ) .or.
     $             ( ic.ge.145 .and. ic.le.153 ) .or.
     $             ( ic.ge.162 .and. ic.le.169 ) )
     $            subnam( i:i ) = char( ic+64 )
   20       continue
         end if
*
      else if( iz.eq.218 .or. iz.eq.250 ) then
*
*        prime machines:  ascii+128
*
         if( ic.ge.225 .and. ic.le.250 ) then
            subnam( 1:1 ) = char( ic-32 )
            do 30 i = 2, 6
               ic = ichar( subnam( i:i ) )
               if( ic.ge.225 .and. ic.le.250 )
     $            subnam( i:i ) = char( ic-32 )
   30       continue
         end if
      end if
*
      c1 = subnam( 1:1 )
      sname = c1.eq.'s' .or. c1.eq.'d'
      cname = c1.eq.'c' .or. c1.eq.'z'
      if( .not.( cname .or. sname ) )
     $   return
      c2 = subnam( 2:3 )
      c3 = subnam( 4:6 )
      c4 = c3( 2:3 )
*
      go to ( 110, 200, 300 ) ispec
*
  110 continue
*
*     ispec = 1:  block size
*
*     in these examples, separate code is provided for setting nb for
*     real and complex.  we assume that nb will take the same value in
*     single or double precision.
*
      nb = 1
*
      if( c2.eq.'ge' ) then
         if( c3.eq.'trf' ) then
            if( sname ) then
               nb = 64
            else
               nb = 64
            end if
         else if( c3.eq.'qrf' .or. c3.eq.'rqf' .or. c3.eq.'lqf' .or.
     $            c3.eq.'qlf' ) then
            if( sname ) then
               nb = 32
            else
               nb = 32
            end if
         else if( c3.eq.'hrd' ) then
            if( sname ) then
               nb = 32
            else
               nb = 32
            end if
         else if( c3.eq.'brd' ) then
            if( sname ) then
               nb = 32
            else
               nb = 32
            end if
         else if( c3.eq.'tri' ) then
            if( sname ) then
               nb = 64
            else
               nb = 64
            end if
         end if
      else if( c2.eq.'po' ) then
         if( c3.eq.'trf' ) then
            if( sname ) then
               nb = 64
            else
               nb = 64
            end if
         end if
      else if( c2.eq.'sy' ) then
         if( c3.eq.'trf' ) then
            if( sname ) then
               nb = 64
            else
               nb = 64
            end if
         else if( sname .and. c3.eq.'trd' ) then
            nb = 1
         else if( sname .and. c3.eq.'gst' ) then
            nb = 64
         end if
      else if( cname .and. c2.eq.'he' ) then
         if( c3.eq.'trf' ) then
            nb = 64
         else if( c3.eq.'trd' ) then
            nb = 1
         else if( c3.eq.'gst' ) then
            nb = 64
         end if
      else if( sname .and. c2.eq.'or' ) then
         if( c3( 1:1 ).eq.'g' ) then
            if( c4.eq.'qr' .or. c4.eq.'rq' .or. c4.eq.'lq' .or.
     $          c4.eq.'ql' .or. c4.eq.'hr' .or. c4.eq.'tr' .or.
     $          c4.eq.'br' ) then
               nb = 32
            end if
         else if( c3( 1:1 ).eq.'m' ) then
            if( c4.eq.'qr' .or. c4.eq.'rq' .or. c4.eq.'lq' .or.
     $          c4.eq.'ql' .or. c4.eq.'hr' .or. c4.eq.'tr' .or.
     $          c4.eq.'br' ) then
               nb = 32
            end if
         end if
      else if( cname .and. c2.eq.'un' ) then
         if( c3( 1:1 ).eq.'g' ) then
            if( c4.eq.'qr' .or. c4.eq.'rq' .or. c4.eq.'lq' .or.
     $          c4.eq.'ql' .or. c4.eq.'hr' .or. c4.eq.'tr' .or.
     $          c4.eq.'br' ) then
               nb = 32
            end if
         else if( c3( 1:1 ).eq.'m' ) then
            if( c4.eq.'qr' .or. c4.eq.'rq' .or. c4.eq.'lq' .or.
     $          c4.eq.'ql' .or. c4.eq.'hr' .or. c4.eq.'tr' .or.
     $          c4.eq.'br' ) then
               nb = 32
            end if
         end if
      else if( c2.eq.'gb' ) then
         if( c3.eq.'trf' ) then
            if( sname ) then
               if( n4.le.64 ) then
                  nb = 1
               else
                  nb = 32
               end if
            else
               if( n4.le.64 ) then
                  nb = 1
               else
                  nb = 32
               end if
            end if
         end if
      else if( c2.eq.'pb' ) then
         if( c3.eq.'trf' ) then
            if( sname ) then
               if( n2.le.64 ) then
                  nb = 1
               else
                  nb = 32
               end if
            else
               if( n2.le.64 ) then
                  nb = 1
               else
                  nb = 32
               end if
            end if
         end if
      else if( c2.eq.'tr' ) then
         if( c3.eq.'tri' ) then
            if( sname ) then
               nb = 64
            else
               nb = 64
            end if
         end if
      else if( c2.eq.'la' ) then
         if( c3.eq.'uum' ) then
            if( sname ) then
               nb = 64
            else
               nb = 64
            end if
         end if
      else if( sname .and. c2.eq.'st' ) then
         if( c3.eq.'ebz' ) then
            nb = 1
         end if
      end if
      ilaenv = nb
      return
*
  200 continue
*
*     ispec = 2:  minimum block size
*
      nbmin = 2
      if( c2.eq.'ge' ) then
         if( c3.eq.'qrf' .or. c3.eq.'rqf' .or. c3.eq.'lqf' .or.
     $       c3.eq.'qlf' ) then
            if( sname ) then
               nbmin = 2
            else
               nbmin = 2
            end if
         else if( c3.eq.'hrd' ) then
            if( sname ) then
               nbmin = 2
            else
               nbmin = 2
            end if
         else if( c3.eq.'brd' ) then
            if( sname ) then
               nbmin = 2
            else
               nbmin = 2
            end if
         else if( c3.eq.'tri' ) then
            if( sname ) then
               nbmin = 2
            else
               nbmin = 2
            end if
         end if
      else if( c2.eq.'sy' ) then
         if( c3.eq.'trf' ) then
            if( sname ) then
               nbmin = 2
            else
               nbmin = 2
            end if
         else if( sname .and. c3.eq.'trd' ) then
            nbmin = 2
         end if
      else if( cname .and. c2.eq.'he' ) then
         if( c3.eq.'trd' ) then
            nbmin = 2
         end if
      else if( sname .and. c2.eq.'or' ) then
         if( c3( 1:1 ).eq.'g' ) then
            if( c4.eq.'qr' .or. c4.eq.'rq' .or. c4.eq.'lq' .or.
     $          c4.eq.'ql' .or. c4.eq.'hr' .or. c4.eq.'tr' .or.
     $          c4.eq.'br' ) then
               nbmin = 2
            end if
         else if( c3( 1:1 ).eq.'m' ) then
            if( c4.eq.'qr' .or. c4.eq.'rq' .or. c4.eq.'lq' .or.
     $          c4.eq.'ql' .or. c4.eq.'hr' .or. c4.eq.'tr' .or.
     $          c4.eq.'br' ) then
               nbmin = 2
            end if
         end if
      else if( cname .and. c2.eq.'un' ) then
         if( c3( 1:1 ).eq.'g' ) then
            if( c4.eq.'qr' .or. c4.eq.'rq' .or. c4.eq.'lq' .or.
     $          c4.eq.'ql' .or. c4.eq.'hr' .or. c4.eq.'tr' .or.
     $          c4.eq.'br' ) then
               nbmin = 2
            end if
         else if( c3( 1:1 ).eq.'m' ) then
            if( c4.eq.'qr' .or. c4.eq.'rq' .or. c4.eq.'lq' .or.
     $          c4.eq.'ql' .or. c4.eq.'hr' .or. c4.eq.'tr' .or.
     $          c4.eq.'br' ) then
               nbmin = 2
            end if
         end if
      end if
      ilaenv = nbmin
      return
*
  300 continue
*
*     ispec = 3:  crossover point
*
      nx = 0
      if( c2.eq.'ge' ) then
         if( c3.eq.'qrf' .or. c3.eq.'rqf' .or. c3.eq.'lqf' .or.
     $       c3.eq.'qlf' ) then
            if( sname ) then
               nx = 128
            else
               nx = 128
            end if
         else if( c3.eq.'hrd' ) then
            if( sname ) then
               nx = 128
            else
               nx = 128
            end if
         else if( c3.eq.'brd' ) then
            if( sname ) then
               nx = 128
            else
               nx = 128
            end if
         end if
      else if( c2.eq.'sy' ) then
         if( sname .and. c3.eq.'trd' ) then
            nx = 1
         end if
      else if( cname .and. c2.eq.'he' ) then
         if( c3.eq.'trd' ) then
            nx = 1
         end if
      else if( sname .and. c2.eq.'or' ) then
         if( c3( 1:1 ).eq.'g' ) then
            if( c4.eq.'qr' .or. c4.eq.'rq' .or. c4.eq.'lq' .or.
     $          c4.eq.'ql' .or. c4.eq.'hr' .or. c4.eq.'tr' .or.
     $          c4.eq.'br' ) then
               nx = 128
            end if
         end if
      else if( cname .and. c2.eq.'un' ) then
         if( c3( 1:1 ).eq.'g' ) then
            if( c4.eq.'qr' .or. c4.eq.'rq' .or. c4.eq.'lq' .or.
     $          c4.eq.'ql' .or. c4.eq.'hr' .or. c4.eq.'tr' .or.
     $          c4.eq.'br' ) then
               nx = 128
            end if
         end if
      end if
      ilaenv = nx
      return
*
  400 continue
*
*     ispec = 4:  number of shifts (used by xhseqr)
*
      ilaenv = 6
      return
*
  500 continue
*
*     ispec = 5:  minimum column dimension (not used)
*
      ilaenv = 2
      return
*
  600 continue 
*
*     ispec = 6:  crossover point for svd (used by xgelss and xgesvd)
*
      ilaenv = int( real( min( n1, n2 ) )*1.6e0 )
      return
*
  700 continue
*
*     ispec = 7:  number of processors (not used)
*
      ilaenv = 1
      return
*
  800 continue
*
*     ispec = 8:  crossover point for multishift (used by xhseqr)
*
      ilaenv = 50
      return
*
*     end of ilaenv
*
      end
      logical function lsame( ca, cb )
*
*  -- lapack auxiliary routine (version 1.0) --
*     univ. of tennessee, univ. of california berkeley, nag ltd.,
*     courant institute, argonne national lab, and rice university
*     february 29, 1992
*
*     .. scalar arguments ..
      character          ca, cb
*     ..
*
*  purpose
*  =======
*
*  lsame returns .true. if ca is the same letter as cb regardless of
*  case.
*
*  arguments
*  =========
*
*  ca      (input) character*1
*  cb      (input) character*1
*          ca and cb specify the single characters to be compared.
*
*     .. intrinsic functions ..
      intrinsic          ichar
*     ..
*     .. local scalars ..
      integer            inta, intb, zcode
*     ..
*     .. executable statements ..
*
*     test if the characters are equal
*
      lsame = ca.eq.cb
      if( lsame )
     $   return
*
*     now test for equivalence if both characters are alphabetic.
*
      zcode = ichar( 'z' )
*
*     use 'z' rather than 'a' so that ascii can be detected on prime
*     machines, on which ichar returns a value with bit 8 set.
*     ichar('a') on prime machines returns 193 which is the same as
*     ichar('a') on an ebcdic machine.
*
      inta = ichar( ca )
      intb = ichar( cb )
*
      if( zcode.eq.90 .or. zcode.eq.122 ) then
*
*        ascii is assumed - zcode is the ascii code of either lower or
*        upper case 'z'.
*
         if( inta.ge.97 .and. inta.le.122 ) inta = inta - 32
         if( intb.ge.97 .and. intb.le.122 ) intb = intb - 32
*
      else if( zcode.eq.233 .or. zcode.eq.169 ) then
*
*        ebcdic is assumed - zcode is the ebcdic code of either lower or
*        upper case 'z'.
*
         if( inta.ge.129 .and. inta.le.137 .or.
     $       inta.ge.145 .and. inta.le.153 .or.
     $       inta.ge.162 .and. inta.le.169 ) inta = inta + 64
         if( intb.ge.129 .and. intb.le.137 .or.
     $       intb.ge.145 .and. intb.le.153 .or.
     $       intb.ge.162 .and. intb.le.169 ) intb = intb + 64
*
      else if( zcode.eq.218 .or. zcode.eq.250 ) then
*
*        ascii is assumed, on prime machines - zcode is the ascii code
*        plus 128 of either lower or upper case 'z'.
*
         if( inta.ge.225 .and. inta.le.250 ) inta = inta - 32
         if( intb.ge.225 .and. intb.le.250 ) intb = intb - 32
      end if
      lsame = inta.eq.intb
*
*     return
*
*     end of lsame
*
      end
      subroutine xerbla( srname, info )
*
*  -- lapack auxiliary routine (version 1.0b) --
*     univ. of tennessee, univ. of california berkeley, nag ltd.,
*     courant institute, argonne national lab, and rice university
*     february 29, 1992
*
*     .. scalar arguments ..
      character*6        srname
      integer            info
c mopac change
      common /chanel/ ifiles(30)
      equivalence(iw,ifiles(6))
c end of mopac change
*     ..
*
*  purpose
*  =======
*
*  xerbla  is an error handler for the lapack routines.
*  it is called by an lapack routine if an input parameter has an
*  invalid value.  a message is printed and execution stops.
*
*  installers may consider modifying the stop statement in order to
*  call system-specific exception-handling facilities.
*
*  arguments
*  =========
*
*  srname  (input) character*6
*          the name of the routine which called xerbla.
*
*  info    (input) integer
*          the position of the invalid parameter in the parameter list
*          of the calling routine.
*
*     .. executable statements ..
*
c mopac change
c     write( *, fmt = 9999 )srname, info
      write( iw, fmt = 9999 )srname, info
c end of mopac change
*
      stop
*
 9999 format( ' ** on entry to ', a6, ' parameter number ', i2, ' had ',
     $      'an illegal value' )
*
*     end of xerbla
*
      end
_ENDIF
      subroutine openda_mop(irest)
c
c     - - - - open master dictionary file 10 - - - -
c
      implicit REAL (a-h,o-z)
c
c
      common /iodaf/ idaf,irecln,irecst,ifilen(145),ioda(145)
      common /jobnam/ jobnam
      common /chanel/ ifiles(30)
      character*80 jobnam
      equivalence(iw,ifiles(6))
c
      idaf = 17
*vax  irecln = 512
      irecln = 1023
c
c             get open parameters from input (optional)
c
c           obtain dictnry file name from run command line
c
*vax      open (unit=idaf, file='dictnry', status='unknown',
*vax     *      access='direct', form='unformatted', recl=2*irecln)
c
      i=index(jobnam,' ')-1
      open(unit=idaf, file=jobnam(:i)//'.pol', status='unknown',
     1      access='direct', form='unformatted', recl=8*irecln)
c
c     ----- is this a new or old daf file -----
c
      if (irest .ne. 0) go to 20
c
c        ----- mark the new daf records as empty -----
c
      irecst = 1
      do 10 i = 1,145
         ioda(i) = -1
   10 continue
      irecst = irecst + 1
      write(unit=idaf, rec=1) irecst,ioda,ifilen,is,ipk
      return
c
c     ----- load the old daf directory -----
c
   20 continue
      read(unit=idaf, rec=1) irecst,ioda,ifilen,is,ipk
      return
      end
      subroutine daread_mop_1(v,len,idaf,ns)
      implicit REAL (a-h,o-z)
      dimension v(len)
c
c       read a physical record from the daf
c
      read(unit=idaf, rec=ns) v
      return
      end
      subroutine daread_mop(v,len,nrec)
      implicit REAL (a-h,o-z)
      dimension v(len)
c
      common /iodaf/ idaf,irecln,irecst,ifilen(145),ioda(145)
      common /chanel/ ifiles(30)
      common /iofile/ mfgr,mfgw
      equivalence(iw,ifiles(6))
c
c         read a logical record from the daf dictionary file
c         a logical record may span several physical records.
c
      n = ioda(nrec)
      if(n.eq.-1) go to 20
      is = -irecln + 1
      ns = n
      lent = len
   10 continue
      is = is + irecln
      if = is + lent - 1
      if ((if-is+1) .gt. irecln) if = is + irecln - 1
      nsp = ns
      lenw = if - is + 1
      call daread_mop_1(v(is),lenw,idaf,nsp)
      lent = lent - irecln
      ns = ns + 1
      n = ns
      if (lent .ge. 1) go to 10
      return
c
   20 continue
      write(mfgw,30) nrec,len
      stop
c
   30 format(1x,'*** error ***, attempt to read a daf record',
     1         ' that was never written. nrec,len=',i5,i10)
      end
      subroutine dawrit_mop(v,len,nrec)
      implicit REAL (a-h,o-z)
c
      logical newrec
c
      dimension v(len)
c
      common /iodaf/ idaf,irecln,irecst,ifilen(145),ioda(145)
      common /chanel/ ifiles(30)
            common /iofile/ mfgr,mfgw
      equivalence(iw,ifiles(6))
c
c         write a logical record on the daf dictionary file
c         a logical record may span several physical records
c
      n = ioda(nrec)
      if (n .gt. 0 .and. len .ne. ifilen(nrec)) go to 30
      newrec = .false.
      if (n .gt. 0) go to 10
      ioda(nrec) = irecst
      ifilen(nrec) = len
      newrec = .true.
      irecst = irecst + (len-1)/irecln + 1
      n = ioda(nrec)
   10 continue
      ist = -irecln + 1
      ns = n
      lent = len
   20 continue
      ist = ist + irecln
      if = ist + lent - 1
      if ((if-ist+1) .gt. irecln) if = ist+irecln-1
      nsp = ns
      lenw = if - ist + 1
      call dawrt1(v(ist),lenw,idaf,nsp)
      lent = lent - irecln
      ns = ns + 1
      n = ns
      if (lent .ge. 1) go to 20
      if (newrec) write(unit=idaf, rec=1) irecst,ioda,ifilen,is,ipk
c
c     the cray/ctss system has a bug in it!  this call to dawrit_mop
c     does not always succeed in tranferring data to the disk,
c     leaving the data only in the buffer.  subsequent calls
c     to daread_mop for other logical records will destroy the
c     buffer resident data, and the data will be lost forever.
c     the following call quarantees the buffer is flushed
c     to disk.  it should be removed if this bug is ever fixed.
c
*cts  call empty(idaf)
      return
c
   30 continue
      write(mfgw,40) nrec,len,ifilen(nrec)
      stop
c
   40 format(1x,'dawrit has requested a record with length',
     1       1x,'different than before - abort forced.'/
     2       1x,'daf record ',i5,' new length =',i5,' old length =',i5)
      end
c*module iolib   *deck dawrt1
      subroutine dawrt1(v,len,idaf,ns)
      implicit REAL (a-h,o-z)
      dimension v(len)
c
c     ----- write a physical record on the daf -----
c
      write(unit=idaf, rec=ns) v
      return
      end
_IF()
      character*80 function getnam(namein)
c
c    this function is designed for use on a vms and on a unix
c    system.  if your system is vms, comment out the line
c    "      call getenv(namein, nameout)", further on in this function.
c    if your system is unix, make sure the line is not
c    commented out.
c    on a unix system, getenv will consult the environment
c    for the current alias of the character string contained in
c    'namein'.  the alias, if it exists, or the original name in namein
c    will be returned.
c
      character*(*) namein
      character*(80) nameout
      nameout=' '
      call getenv(namein, nameout)
      if (nameout.eq.'  ') nameout=namein
      getnam = nameout
      return
      end
_ENDIF
c
c=====================================================================
c
      subroutine asumd(p,ndis)
      implicit REAL (a-h,o-z)
*****************************************************************
*  calculation  "ai" values for green's function method         *
*  subroutine written by dr. david danovich, department of      *
*  of chemistry, technion-israel institute of technology,       *
*  haifa, 32000, israel.       version: 2.09.90                 *
*****************************************************************
INCLUDE(common/sizes)
      dimension p(*)
      common /dod/ itl(200),it(200)
      common /vector /c(morb2),eig(maxorb),dumy(morb2+maxorb)
      common /perem /nyr,iy,iggv,iggw
      common /asma/ as1,as2,as3,as4,as5,as6
      kyr2=nyr+iggv
      kyr1=nyr+1
      myr1=nyr-iggw
      as1=0.d0
      as2=0.d0
      as3=0.d0
      as4=0.d0
      as5=0.d0
      as6=0.d0
      do 200 m=kyr1,kyr2
         do 200 n=kyr1,kyr2
            do 200 i=myr1,nyr
               do 200 j=myr1,nyr
                  do 200 k=myr1,nyr
                     iyr=iy
                     kk=k
                     jj=j
                     if(kk.ge.jj) go to 10
                     lt=kk
                     kk=jj
                     jj=lt
   10                if(iyr.gt.nyr) go to 20
                     if(iyr.ge.kk) go to 20
                     numb=itl(kk)+it(kk)*jj+it(jj)+it(iyr)+iyr
                     go to 30
   20                numb=itl(iyr)+it(iyr)*iyr+it(iyr)+it(kk)+jj
   30                iyr=iy
                     kk=k
                     jj=j
                     if(iyr.le.nyr) go to 50
                     if(jj.ge.kk) go to 40
                     lt=jj
                     jj=kk
                     kk=lt
   40                numb1=itl(iyr)+it(iyr)*jj+it(jj)+it(iyr)+kk
                     go to 100
   50                if(iyr.ge.jj.and.iyr.ge.kk) go to 60
                     if(iyr.lt.jj.and.iyr.lt.kk) go to 70
                     if(iyr.ge.jj.and.iyr.lt.kk) go to 90
                     numb1=itl(jj)+it(jj)*iyr+it(iyr)+it(iyr)+kk
                     go to 100
   60                if(jj.ge.kk) go to 40
                     lt=jj
                     jj=kk
                     kk=lt
                     go to 40
   70                if(jj.ge.kk) go to 80
                     lt=jj
                     jj=kk
                     kk=lt
   80                numb1=itl(jj)+it(jj)*iyr+it(iyr)+it(kk)+iyr
                     go to 100
   90                numb1=itl(kk)+it(kk)*iyr+it(iyr)+it(iyr)+jj
  100                jj=j
                     ii=i
                     mm=m
                     nn=n
                     if(mm.gt.nn) go to 110
                     if(mm.eq.nn) go to 120
                     numb2=itl(nn)+it(nn)*ii+it(ii)+it(mm)+jj
                     go to 130
  110                numb2=itl(mm)+it(mm)*jj+it(jj)+it(nn)+ii
                     go to 130
  120                if(jj.ge.ii) go to 110
                     lt=jj
                     jj=ii
                     ii=lt
                     go to 110
  130                jj=j
                     nn=n
                     ii=i
                     mm=m
                     if(nn.gt.mm) go to 140
                     if(nn.eq.mm) go to 150
                     numb3=itl(mm)+it(mm)*ii+it(ii)+it(nn)+jj
                     go to 160
  140                numb3=itl(nn)+it(nn)*jj+it(jj)+it(mm)+ii
                     go to 160
  150                if(jj.ge.ii) go to 140
                     lt=jj
                     jj=ii
                     ii=lt
                     go to 140
  160                mm=m
                     kk=k
                     nn=n
                     ii=i
                     if(mm.gt.nn) go to 170
                     if(mm.eq.nn) go to 180
                     numb4=itl(nn)+it(nn)*ii+it(ii)+it(mm)+kk
                     go to 190
  170                numb4=itl(mm)+it(mm)*kk+it(kk)+it(nn)+ii
                     go to 190
  180                if(kk.ge.ii) go to 170
                     lt=kk
                     kk=ii
                     ii=lt
                     go to 170
  190                as1=as1+(2.d0*p(numb)-p(numb1))*
     1(2.d0*p(numb2)-p(numb3))*p(numb4)/
     2((eig(j)+eig(i)-eig(m)-eig(n))*(eig(k)+eig(i)-eig(mm)-eig(n)))
  200 continue
      as1=-as1
      do 400 m=kyr1,kyr2
         do 400 n=kyr1,kyr2
            do 400 l=kyr1,kyr2
               do 400 i=myr1,nyr
                  do 400 j=myr1,nyr
                     iyr=iy
                     nn=n
                     ll=l
                     if(ll.ge.nn) go to 210
                     lt=ll
                     ll=nn
                     nn=lt
  210                if(iyr.le.nyr) go to 220
                     if(iyr.lt.ll) go to 220
                     numb=itl(iyr)+it(iyr)*iyr+it(iyr)+it(ll)+nn
                     go to 230
  220                numb=itl(ll)+it(ll)*nn+it(nn)+it(iyr)+iyr
  230                iyr=iy
                     nn=n
                     ll=l
                     if(iyr.gt.nyr) go to 250
                     if(nn.ge.ll) go to 240
                     lt=nn
                     nn=ll
                     ll=lt
  240                numb1=itl(nn)+it(nn)*iyr+it(iyr)+it(ll)+iyr
                     go to 300
  250                if(iyr.ge.nn.and.iyr.ge.ll) go to 260
                     if(iyr.lt.nn.and.iyr.lt.ll) go to 280
                     if(iyr.ge.nn.and.iyr.lt.ll) go to 290
                     numb1=itl(nn)+it(nn)*iyr+it(iyr)+it(iyr)+ll
                     go to 300
  260                if(nn.ge.ll) go to 270
                     lt=nn
                     nn=ll
                     ll=lt
  270                numb1=itl(iyr)+it(iyr)*nn+it(nn)+it(iyr)+ll
                     go to 300
  280                if(nn.ge.ll) go to 240
                     lt=nn
                     nn=ll
                     ll=lt
                     go to 240
  290                numb1=itl(ll)+it(ll)*iyr+it(iyr)+it(iyr)+nn
  300                jj=j
                     mm=m
                     ii=i
                     nn=n
                     if(mm.gt.nn) go to 310
                     if(mm.eq.nn) go to 320
                     numb2=itl(nn)+it(nn)*ii+it(ii)+it(mm)+jj
                     go to 330
  310                numb2=itl(mm)+it(mm)*jj+it(jj)+it(nn)+ii
                     go to 330
  320                if(jj.ge.ii) go to 310
                     lt=jj
                     jj=ii
                     ii=lt
                     go to 310
  330                jj=j
                     nn=n
                     ii=i
                     mm=m
                     if(nn.gt.mm) go to 340
                     if(nn.eq.mm) go to 350
                     numb3=itl(mm)+it(mm)*ii+it(ii)+it(nn)+jj
                     go to 360
  340                numb3=itl(nn)+it(nn)*jj+it(jj)+it(mm)+ii
                     go to 360
  350                if(jj.ge.ii) go to 340
                     lt=jj
                     jj=ii
                     ii=lt
                     go to 340
  360                jj=j
                     ll=l
                     ii=i
                     mm=m
                     if(ll.gt.mm) go to 370
                     if(ll.eq.mm) go to 380
                     numb4=itl(mm)+it(mm)*jj+it(jj)+it(ll)+ii
                     go to 390
  370                numb4=itl(ll)+it(ll)*ii+it(ii)+it(mm)+jj
                     go to 390
  380                if(ii.ge.jj) go to 370
                     lt=ii
                     ii=jj
                     jj=lt
                     go to 370
  390                as2=as2+(2.d0*p(numb)-p(numb1))*
     1(2.d0*p(numb2)-p(numb3))*p(numb4)/
     2((eig(j)+eig(i)-eig(m)-eig(n))*(eig(j)+eig(i)-eig(m)-eig(l)))
  400 continue
      do 560 m=kyr1,kyr2
         do 560 n=kyr1,kyr2
            do 560 l=kyr1,kyr2
               do 560 i=myr1,nyr
                  do 560 j=myr1,nyr
                     iyr=iy
                     ll=l
                     jj=j
                     if(iyr.ge.ll) go to 410
                     numb=itl(ll)+it(ll)*jj+it(jj)+it(iyr)+iyr
                     go to 420
  410                numb=itl(iyr)+it(iyr)*iyr+it(iyr)+it(ll)+jj
  420                iyr=iy
                     jj=j
                     ll=l
                     if(iyr.gt.nyr) go to 440
                     if(iyr.ge.jj) go to 430
                     numb1=itl(ll)+it(ll)*iyr+it(iyr)+it(jj)+iyr
                     go to 460
  430                numb1=itl(ll)+it(ll)*iyr+it(iyr)+it(iyr)+jj
                     go to 460
  440                if(iyr.lt.ll) go to 430
                     if(iyr.gt.ll) go to 450
                     numb1=itl(iyr)+it(iyr)*iyr+it(iyr)+it(ll)+jj
                     go to 460
  450                numb1=itl(iyr)+it(iyr)*ll+it(ll)+it(iyr)+jj
  460                jj=j
                     mm=m
                     ii=i
                     nn=n
                     if(mm.gt.nn) go to 470
                     if(mm.eq.nn) go to 480
                     numb2=itl(nn)+it(nn)*ii+it(ii)+it(mm)+jj
                     go to 490
  470                numb2=itl(mm)+it(mm)*jj+it(jj)+it(nn)+ii
                     go to 490
  480                if(jj.ge.ii) go to 470
                     lt=jj
                     jj=ii
                     ii=lt
                     go to 470
  490                jj=j
                     nn=n
                     ii=i
                     mm=m
                     if(nn.gt.mm) go to 500
                     if(nn.eq.mm) go to 510
                     numb3=itl(mm)+it(mm)*ii+it(ii)+it(nn)+jj
                     go to 520
  500                numb3=itl(nn)+it(nn)*jj+it(jj)+it(mm)+ii
                     go to 520
  510                if(jj.ge.ii) go to 500
                     lt=jj
                     jj=ii
                     ii=lt
                     go to 500
  520                mm=m
                     ll=l
                     ii=i
                     nn=n
                     if(mm.ge.ll) go to 530
                     lt=mm
                     mm=ll
                     ll=lt
  530                if(mm.ge.nn) go to 540
                     numb4=itl(nn)+it(nn)*ii+it(ii)+it(mm)+ll
                     go to 550
  540                numb4=itl(mm)+it(mm)*ll+it(ll)+it(nn)+ii
  550                as3=as3+(2.d0*p(numb)-p(numb1))*
     1(2.d0*p(numb2)-p(numb3))*p(numb4)/
     2((eig(j)+eig(i)-eig(m)-eig(n))*(eig(j)-eig(l)))
  560 continue
      as4=as3
      do 700 m=kyr1,kyr2
         do 700 n=kyr1,kyr2
            do 700 i=myr1,nyr
               do 700 j=myr1,nyr
                  do 700 k=myr1,nyr
                     iyr=iy
                     nn=n
                     kk=k
                     if(iyr.ge.nn) go to 570
                     numb=itl(nn)+it(nn)*kk+it(kk)+it(iyr)+iyr
                     go to 580
  570                numb=itl(iyr)+it(iyr)*iyr+it(iyr)+it(nn)+kk
  580                iyr=iy
                     kk=k
                     nn=n
                     if(iyr.gt.nyr) go to 600
                     if(iyr.ge.kk) go to 590
                     numb1=itl(nn)+it(nn)*iyr+it(iyr)+it(kk)+iyr
                     go to 620
  590                numb1=itl(nn)+it(nn)*iyr+it(iyr)+it(iyr)+kk
                     go to 620
  600                if(iyr.lt.nn) go to 590
                     if(iyr.gt.nn) go to 610
                     numb1=itl(iyr)+it(iyr)*iyr+it(iyr)+it(nn)+kk
                     go to 620
  610                numb1=itl(iyr)+it(iyr)*nn+it(nn)+it(iyr)+kk
  620                jj=j
                     mm=m
                     ii=i
                     nn=n
                     if(mm.gt.nn) go to 630
                     if(mm.eq.nn) go to 640
                     numb2=itl(nn)+it(nn)*ii+it(ii)+it(mm)+jj
                     go to 650
  630                numb2=itl(mm)+it(mm)*jj+it(jj)+it(nn)+ii
                     go to 650
  640                if(jj.ge.ii) go to 630
                     lt=jj
                     jj=ii
                     ii=lt
                     go to 630
  650                jj=j
                     nn=n
                     ii=i
                     mm=m
                     if(nn.gt.mm) go to 660
                     if(nn.eq.mm) go to 670
                     numb3=itl(mm)+it(mm)*ii+it(ii)+it(nn)+jj
                     go to 680
  660                numb3=itl(nn)+it(nn)*jj+it(jj)+it(mm)+ii
                     go to 680
  670                if(jj.ge.ii) go to 660
                     lt=jj
                     jj=ii
                     ii=lt
                     go to 660
  680                ii=i
                     kk=k
                     jj=j
                     mm=m
                     if(ii.ge.kk) go to 690
                     lt=ii
                     ii=kk
                     kk=lt
  690                numb4=itl(mm)+it(mm)*jj+it(jj)+it(ii)+kk
                     as5=as5+(2.d0*p(numb)-p(numb1))*
     1(2.d0*p(numb2)-p(numb3))*p(numb4)/
     2((eig(j)+eig(i)-eig(m)-eig(n))*(eig(k)-eig(n)))
  700 continue
      as5=-as5
      as6=as5
      return
      end
c
c=================================================================
c
      subroutine csumd(p,ndis,ep)
      implicit REAL (a-h,o-z)
************************************************************
*  calculation 'ci' values for green's function method     *
*  subroutine written by dr. david danovich, department of *
*  chemistry, technion-israel institute of technology,     *
*  haifa, 32000, israel.      version:  2.09.90            *
************************************************************
INCLUDE(common/sizes)
      dimension p(*)
      common/dod/itl(200),it(200)
      common/vector/c(morb2),eig(maxorb)
      common/perem/nyr,iy,iggv,iggw
      common/csuc/cs1,cs2,cs3,cs4,cs5,cs6
      kyr2=nyr+iggv
      kyr1=nyr+1
      myr1=nyr-iggw
      cs1=0.d0
      cs2=0.d0
      cs3=0.d0
      cs4=0.d0
      cs5=0.d0
      cs6=0.d0
      do 1 m=kyr1,kyr2
      do 1 n=kyr1,kyr2
      do 1 l=kyr1,kyr2
      do 1 k=kyr1,kyr2
      do 1 i=myr1,nyr
      iyr=iy
      mm=m
      ii=i
      nn=n
      if(iyr.ge.mm) go to 2
      lt=iyr
      iyr=mm
      mm=lt
   2  if(iyr.gt.nn) go to 3
      if(iyr.eq.nn) go to 4
      lt=iyr
      iyr=nn
      nn=lt
      lt=mm
      mm=ii
      ii=lt
      go to 3
   4  if(mm.ge.ii) go to 3
      lt=mm
      mm=ii
      ii=lt
  3   numb=itl(iyr)+it(iyr)*mm+it(mm)+it(nn)+ii
      iyr=iy
      nn=n
      ii=i
      mm=m
      if(iyr.ge.nn) go to 5
      lt=iyr
      iyr=nn
      nn=lt
   5  if(iyr.gt.mm) go to 6
      if(iyr.eq.mm) go to 7
      lt=iyr
      iyr=mm
      mm=lt
      lt=nn
      nn=ii
      ii=lt
      go to 6
   7  if(nn.ge.ii) go to 6
      lt=nn
      nn=ii
      ii=lt
   6  numb1=itl(iyr)+it(iyr)*nn+it(nn)+it(mm)+ii
      kk=k
      ll=l
      mm=m
      nn=n
      if(mm.ge.ll) go to 8
      lt=mm
      mm=ll
      ll=lt
   8  if(nn.ge.kk) go to 9
      lt=nn
      nn=kk
      kk=lt
   9  if(mm.gt.nn) go to 10
      if(mm.eq.nn) go to 11
      lt=mm
      mm=nn
      nn=lt
      lt=ll
      ll=kk
      kk=lt
      go to 10
   11 if(ll.ge.kk) go to 10
      lt=ll
      ll=kk
      kk=lt
  10  numb2=itl(mm)+it(mm)*ll+it(ll)+it(nn)+kk
      iyr=iy
      ll=l
      ii=i
      kk=k
      if(iyr.ge.ll) go to 12
      lt=iyr
      iyr=ll
      ll=lt
  12  if(iyr.gt.kk) go to 13
      if(iyr.eq.kk) go to 14
      lt=iyr
      iyr=kk
      kk=lt
      lt=ll
      ll=ii
      ii=lt
      go to 13
  14  if(ll.ge.ii) go to 13
      lt=ll
      ll=ii
      ii=lt
   13 numb3=itl(iyr)+it(iyr)*ll+it(ll)+it(kk)+ii
      cs1=cs1+(2.d0*p(numb)-p(numb1))*p(numb2)*p(numb3)/((ep+eig(i)-
     *eig(m)-eig(n))*(ep+eig(i)-eig(l)-eig(k)))
   1  continue
      do 21 m=kyr1,kyr2
      do 21 n=kyr1,kyr2
      do 21 i=myr1,nyr
      do 21 j=myr1,nyr
      do 21 k=myr1,nyr
      iyr=iy
      mm=m
      ii=i
      nn=n
      if(iyr.ge.mm) go to 22
      lt=iyr
      iyr=mm
      mm=lt
   22 if(iyr.gt.nn) go to 23
      if(iyr.eq.nn) go to 24
      lt=iyr
      iyr=nn
      nn=lt
      lt=mm
      mm=ii
      ii=lt
      go to 23
   24 if(mm.ge.ii) go to 23
      lt=mm
      mm=ii
      ii=lt
  23  numb=itl(iyr)+it(iyr)*mm+it(mm)+it(nn)+ii
      iyr=iy
      nn=n
      ii=i
      mm=m
      if(iyr.ge.nn) go to 25
      lt=iyr
      iyr=nn
      nn=lt
  25  if(iyr.gt.mm) go to 26
      if(iyr.eq.mm) go to 27
      lt=iyr
      iyr=mm
      mm=lt
      lt=nn
      nn=ii
      ii=lt
      go to 26
   27 if(nn.ge.ii) go to 26
      lt=nn
      nn=ii
      ii=lt
   26 numb1=itl(iyr)+it(iyr)*nn+it(nn)+it(mm)+ii
      mm=m
      jj=j
      nn=n
      kk=k
      if(mm.gt.nn) go to 28
      if(mm.eq.nn) go to 29
      lt=mm
      mm=nn
      nn=lt
      lt=jj
      jj=kk
      kk=lt
      go to 28
   29 if(jj.ge.kk) go to 28
      lt=jj
      jj=kk
      kk=lt
  28  numb2=itl(mm)+it(mm)*jj+it(jj)+it(nn)+kk
      iyr=iy
      jj=j
      ii=i
      kk=k
      if(iyr.ge.jj) go to 30
      lt=iyr
      iyr=jj
      jj=lt
  30  if(ii.ge.kk) go to 31
      lt=ii
      ii=kk
      kk=lt
  31  if(iyr.gt.ii) go to 32
      if(iyr.eq.ii) go to 33
      lt=iyr
      iyr=ii
      ii=lt
      lt=jj
      jj=kk
      kk=lt
      go to 32
  33  if(jj.ge.kk) go to 32
      lt=jj
      jj=kk
      kk=lt
   32 numb3=itl(iyr)+it(iyr)*jj+it(jj)+it(ii)+kk
      cs2=cs2+(2.d0*p(numb)-p(numb1))*p(numb2)*p(numb3)/((ep+eig(i)-
     *eig(m)-eig(n))*(eig(j)+eig(k)-eig(m)-eig(n)))
  21  continue
      cs3=cs2
      do 41 m=kyr1,kyr2
      do 41 n=kyr1,kyr2
      do 41 l=kyr1,kyr2
      do 41 i=myr1,nyr
      do 41 j=myr1,nyr
      iyr=iy
      mm=m
      ii=i
      jj=j
      if(iyr.ge.ii) go to 42
      lt=iyr
      iyr=ii
      ii=lt
   42 if(iyr.gt.mm) go to 43
      if(iyr.eq.mm) go to 44
      lt=iyr
      iyr=mm
      mm=lt
      lt=ii
      ii=jj
      jj=lt
      go to 43
   44 if(ii.ge.jj) go to 43
      lt=ii
      ii=jj
      jj=lt
  43  numb=itl(iyr)+it(iyr)*ii+it(ii)+it(mm)+jj
      iyr=iy
      jj=j
      ii=i
      mm=m
      if(iyr.ge.jj) go to 45
      lt=iyr
      iyr=jj
      jj=lt
   45 if(iyr.gt.mm) go to 46
      if(iyr.eq.mm) go to 47
      lt=iyr
      iyr=mm
      mm=lt
      lt=jj
      jj=ii
      ii=lt
      go to 46
   47 if(jj.ge.ii) go to 46
      lt=jj
      jj=ii
      ii=lt
   46 numb1=itl(iyr)+it(iyr)*jj+it(jj)+it(mm)+ii
      ii=i
      jj=j
      nn=n
      ll=l
      if(nn.gt.ll) go to 48
      if(nn.eq.ll) go to 49
      lt=nn
      nn=ll
      ll=lt
      lt=ii
      ii=jj
      jj=lt
      go to 48
   49 if(ii.ge.jj) go to 48
      lt=ii
      ii=jj
      jj=lt
  48  numb2=itl(nn)+it(nn)*ii+it(ii)+it(ll)+jj
      iyr=iy
      nn=n
      mm=m
      ll=l
      if(iyr.ge.nn) go to 50
      lt=iyr
      iyr=nn
      nn=lt
  50  if(mm.ge.ll) go to 51
      lt=mm
      mm=ll
      ll=lt
  51  if(iyr.gt.mm) go to 52
      if(iyr.eq.mm) go to 53
      lt=iyr
      iyr=mm
      mm=lt
      lt=nn
      nn=ll
      ll=lt
      go to 52
  53  if(nn.ge.ll) go to 52
      lt=nn
      nn=ll
      ll=lt
   52 numb3=itl(iyr)+it(iyr)*nn+it(nn)+it(mm)+ll
      cs4=cs4+(2.d0*p(numb)-p(numb1))*p(numb2)*p(numb3)/((ep+eig(m)-
     *eig(i)-eig(j))*(eig(i)+eig(j)-eig(n)-eig(l)))
  41  continue
      cs5=cs4
      do 61 m=kyr1,kyr2
      do 61 i=myr1,nyr
      do 61 j=myr1,nyr
      do 61 k=myr1,nyr
      do 61 l=myr1,nyr
      iyr=iy
      mm=m
      kk=k
      ll=l
      if(iyr.ge.kk) go to 62
      lt=iyr
      iyr=kk
      kk=lt
   62 if(iyr.gt.mm) go to 63
      if(iyr.eq.mm) go to 64
      lt=iyr
      iyr=mm
      mm=lt
      lt=kk
      kk=ll
      ll=lt
      go to 63
   64 if(kk.ge.ll) go to 63
      lt=kk
      kk=ll
      ll=lt
  63  numb=itl(iyr)+it(iyr)*kk+it(kk)+it(mm)+ll
      iyr=iy
      ll=l
      kk=k
      mm=m
      if(iyr.ge.ll) go to 65
      lt=iyr
      iyr=ll
      ll=lt
   65 if(iyr.gt.mm) go to 66
      if(iyr.eq.mm) go to 67
      lt=iyr
      iyr=mm
      mm=lt
      lt=ll
      ll=kk
      kk=lt
      go to 66
   67 if(ll.ge.kk) go to 66
      lt=ll
      ll=kk
      kk=lt
   66 numb1=itl(iyr)+it(iyr)*ll+it(ll)+it(mm)+kk
      kk=k
      ii=i
      ll=l
      jj=j
      if(kk.ge.ii) go to 68
      lt=kk
      kk=ii
      ii=lt
  68  if(ll.ge.jj) go to 69
      lt=ll
      ll=jj
      jj=lt
   69 if(kk.gt.ll) go to 70
      if(kk.eq.ll) go to 71
      lt=kk
      kk=ll
      ll=lt
      lt=ii
      ii=jj
      jj=lt
      go to 70
   71 if(ii.ge.jj) go to 70
      lt=ii
      ii=jj
      jj=lt
  70  numb2=itl(kk)+it(kk)*ii+it(ii)+it(ll)+jj
      iyr=iy
      ii=i
      mm=m
      jj=j
      if(iyr.ge.ii) go to 72
      lt=iyr
      iyr=ii
      ii=lt
  72  if(iyr.gt.mm) go to 73
      if(iyr.eq.mm) go to 74
      lt=iyr
      iyr=mm
      mm=lt
      lt=ii
      ii=jj
      jj=lt
      go to 73
  74  if(ii.ge.jj) go to 73
      lt=ii
      ii=jj
      jj=lt
   73 numb3=itl(iyr)+it(iyr)*ii+it(ii)+it(mm)+jj
      cs6=cs6+(2.d0*p(numb)-p(numb1))*p(numb2)*p(numb3)/((ep+eig(m)-
     *eig(i)-eig(j))*(ep+eig(m)-eig(k)-eig(l)))
  61  continue
      cs6=-cs6
      return
      end
c
c===================================================================
c
      subroutine dsumd(p,ndis,ep)
      implicit REAL (a-h,o-z)
**************************************************************
*  calculation 'di' values for green's function method       *
*  subroutine written by dr. david danovich, department of   *
*  chemistry, technion-israel institute of technology,       *
*  haifa, 32000, israel.            version: 2.09.90         *
**************************************************************
INCLUDE(common/sizes)
      dimension p(*)
      common/dod/itl(200),it(200)
      common/vector/c(morb2),eig(maxorb),dumy(morb2+maxorb)
      common/perem/nyr,iy,iggv,iggw
      common/dsmd/ds1,ds2,ds3,ds4,ds5,ds6
      kyr2=nyr+iggv
      kyr1=nyr+1
      myr1=nyr-iggw
      ds1=0.d0
      ds2=0.d0
      ds3=0.d0
      ds4=0.d0
      ds5=0.d0
      ds6=0.d0
      do 170 m=kyr1,kyr2
         do 170 n=kyr1,kyr2
            do 170 l=kyr1,kyr2
               do 170 i=myr1,nyr
                  do 170 j=myr1,nyr
                     iyr=iy
                     mm=m
                     ii=i
                     nn=n
                     if(iyr.ge.mm) go to 10
                     lt=iyr
                     iyr=mm
                     mm=lt
   10                if(iyr.gt.nn) go to 30
                     if(iyr.eq.nn) go to 20
                     lt=iyr
                     iyr=nn
                     nn=lt
                     lt=mm
                     mm=ii
                     ii=lt
                     go to 30
   20                if(mm.ge.ii) go to 30
                     lt=mm
                     mm=ii
                     ii=lt
   30                numb=itl(iyr)+it(iyr)*mm+it(mm)+it(nn)+ii
                     mm=m
                     ii=i
                     jj=j
                     ll=l
                     if(mm.gt.ll) go to 50
                     if(mm.eq.ll) go to 40
                     lt=mm
                     mm=ll
                     ll=lt
                     lt=ii
                     ii=jj
                     jj=lt
                     go to 50
   40                if(ii.ge.jj) go to 50
                     lt=ii
                     ii=jj
                     jj=lt
   50                numb1=itl(mm)+it(mm)*ii+it(ii)+it(ll)+jj
                     iyr=iy
                     ll=l
                     jj=j
                     nn=n
                     if(iyr.ge.ll) go to 60
                     lt=iyr
                     iyr=ll
                     ll=lt
   60                if(iyr.gt.nn) go to 80
                     if(iyr.eq.nn) go to 70
                     lt=iyr
                     iyr=nn
                     nn=lt
                     lt=ll
                     ll=jj
                     jj=lt
                     go to 80
   70                if(ll.ge.jj) go to 80
                     lt=ll
                     ll=jj
                     jj=lt
   80                numb2=itl(iyr)+it(iyr)*ll+it(ll)+it(nn)+jj
                     iyr=iy
                     ll=l
                     nn=n
                     jj=j
                     if(iyr.ge.nn) go to 90
                     lt=iyr
                     iyr=nn
                     nn=lt
   90                if(iyr.gt.ll) go to 110
                     if(iyr.eq.ll) go to 100
                     lt=iyr
                     iyr=ll
                     ll=lt
                     lt=nn
                     nn=jj
                     jj=lt
                     go to 110
  100                if(nn.ge.jj) go to 110
                     lt=nn
                     nn=jj
                     jj=lt
  110                numb3=itl(iyr)+it(iyr)*nn+it(nn)+it(ll)+jj
                     mm=m
                     ll=l
                     jj=j
                     ii=i
                     if(mm.ge.ll) go to 120
                     lt=mm
                     mm=ll
                     ll=lt
  120                if(jj.ge.ii) go to 130
                     lt=jj
                     jj=ii
                     ii=lt
  130                numb4=itl(mm)+it(mm)*ll+it(ll)+it(jj)+ii
                     iyr=iy
                     nn=n
                     ii=i
                     mm=m
                     if(iyr.ge.nn) go to 140
                     lt=iyr
                     iyr=nn
                     nn=lt
  140                if(iyr.gt.mm) go to 160
                     if(iyr.eq.mm) go to 150
                     lt=iyr
                     iyr=mm
                     mm=lt
                     lt=nn
                     nn=ii
                     ii=lt
                     go to 160
  150                if(nn.ge.ii) go to 160
                     lt=nn
                     nn=ii
                     ii=lt
  160                numb6=itl(iyr)+it(iyr)*nn+it(nn)+it(mm)+ii
                     ds1=ds1+(p(numb)*(p(numb1)*
     1(p(numb2)-2.d0*p(numb3))+p(numb4)*(p(numb3)-2.d0*p(numb2)))/
     2((ep+eig(i)-eig(m)-eig(n))*(ep+eig(j)-eig(n)-eig(l)))+
     3p(numb6)*(p(numb1)*(4.d0*p(numb3)-2.d0*p(numb2))+
     4p(numb4)*(p(numb2)-2.d0*p(numb3)))/
     5((ep+eig(i)-eig(m)-eig(n))*(ep+eig(j)-eig(n)-eig(l))))
  170 continue
      do 350 m=kyr1,kyr2
         do 350 n=kyr1,kyr2
            do 350 l=kyr1,kyr2
               do 350 i=myr1,nyr
                  do 350 j=myr1,nyr
                     iyr=iy
                     mm=m
                     ii=i
                     ll=l
                     if(iyr.ge.ll) go to 180
                     lt=iyr
                     iyr=ll
                     ll=lt
  180                if(iyr.gt.mm) go to 200
                     if(iyr.eq.mm) go to 190
                     lt=iyr
                     iyr=mm
                     mm=lt
                     lt=ll
                     ll=ii
                     ii=lt
                     go to 200
  190                if(ll.ge.ii) go to 200
                     lt=ll
                     ll=ii
                     ii=lt
  200                numb=itl(iyr)+it(iyr)*ll+it(ll)+it(mm)+ii
                     mm=m
                     ii=i
                     jj=j
                     nn=n
                     if(mm.gt.nn) go to 220
                     if(mm.eq.nn) go to 210
                     lt=mm
                     mm=nn
                     nn=lt
                     lt=ii
                     ii=jj
                     jj=lt
                     go to 220
  210                if(ii.ge.jj) go to 220
                     lt=ii
                     ii=jj
                     jj=lt
  220                numb1=itl(mm)+it(mm)*ii+it(ii)+it(nn)+jj
                     iyr=iy
                     ll=l
                     jj=j
                     nn=n
                     if(iyr.ge.ll) go to 230
                     lt=iyr
                     iyr=ll
                     ll=lt
  230                if(iyr.gt.nn) go to 250
                     if(iyr.eq.nn) go to 240
                     lt=iyr
                     iyr=nn
                     nn=lt
                     lt=ll
                     ll=jj
                     jj=lt
                     go to 250
  240                if(ll.ge.jj) go to 250
                     lt=ll
                     ll=jj
                     jj=lt
  250                numb2=itl(iyr)+it(iyr)*ll+it(ll)+it(nn)+jj
                     iyr=iy
                     ll=l
                     nn=n
                     jj=j
                     if(iyr.ge.jj) go to 260
                     lt=iyr
                     iyr=jj
                     jj=lt
  260                if(nn.ge.ll) go to 270
                     lt=nn
                     nn=ll
                     ll=lt
  270                if(iyr.gt.nn) go to 290
                     if(iyr.eq.nn) go to 280
                     lt=iyr
                     iyr=nn
                     nn=lt
                     lt=jj
                     jj=ll
                     ll=lt
                     go to 290
  280                if(jj.ge.ll) go to 290
                     lt=jj
                     jj=ll
                     ll=lt
  290                numb3=itl(iyr)+it(iyr)*jj+it(jj)+it(nn)+ll
                     mm=m
                     nn=n
                     jj=j
                     ii=i
                     if(mm.gt.nn) go to 310
                     if(mm.eq.nn) go to 300
                     lt=mm
                     mm=nn
                     nn=lt
                     lt=jj
                     jj=ii
                     ii=lt
                     go to 310
  300                if(jj.ge.ii) go to 310
                     lt=jj
                     jj=ii
                     ii=lt
  310                numb4=itl(mm)+it(mm)*jj+it(jj)+it(nn)+ii
                     iyr=iy
                     ll=l
                     ii=i
                     mm=m
                     if(iyr.ge.mm) go to 320
                     lt=iyr
                     iyr=mm
                     mm=lt
  320                if(iyr.gt.ll) go to 340
                     if(iyr.eq.ll) go to 330
                     lt=iyr
                     iyr=ll
                     ll=lt
                     lt=mm
                     mm=ii
                     ii=lt
                     go to 340
  330                if(mm.ge.ii) go to 340
                     lt=mm
                     mm=ii
                     ii=lt
  340                numb5=itl(iyr)+it(iyr)*mm+it(mm)+it(ll)+ii
                     ds2=ds2+(p(numb)*(p(numb1)*(4.d0*p(numb2)-
     12.d0*p(numb3))+p(numb4)*(p(numb3)-2.d0*p(numb2)))/
     2((ep+eig(i)-eig(m)-eig(l))*(eig(i)+eig(j)-eig(m)-eig(n)))+
     3p(numb5)*(p(numb1)*(p(numb3)-2.d0*p(numb2))+
     4p(numb4)*(p(numb2)-2.d0*p(numb3)))/
     5((ep+eig(i)-eig(m)-eig(l))*(eig(i)+eig(j)-eig(m)-eig(n))))
  350 continue
      ds3=ds2
      do 530 m=kyr1,kyr2
         do 530 n=kyr1,kyr2
            do 530 i=myr1,nyr
               do 530 j=myr1,nyr
                  do 530 k=myr1,nyr
                     iyr=iy
                     mm=m
                     kk=k
                     jj=j
                     if(iyr.ge.kk) go to 360
                     lt=iyr
                     iyr=kk
                     kk=lt
  360                if(iyr.gt.mm) go to 380
                     if(iyr.eq.mm) go to 370
                     lt=iyr
                     iyr=mm
                     mm=lt
                     lt=kk
                     kk=jj
                     jj=lt
                     go to 380
  370                if(kk.ge.jj) go to 380
                     lt=kk
                     kk=jj
                     jj=lt
  380                numb=itl(iyr)+it(iyr)*kk+it(kk)+it(mm)+jj
                     mm=m
                     ii=i
                     jj=j
                     nn=n
                     if(mm.gt.nn) go to 400
                     if(mm.eq.nn) go to 390
                     lt=mm
                     mm=nn
                     nn=lt
                     lt=jj
                     jj=ii
                     ii=lt
                     go to 400
  390                if(jj.ge.ii) go to 400
                     lt=jj
                     jj=ii
                     ii=lt
  400                numb1=itl(mm)+it(mm)*jj+it(jj)+it(nn)+ii
                     iyr=iy
                     kk=k
                     ii=i
                     nn=n
                     if(iyr.ge.kk) go to 410
                     lt=iyr
                     iyr=kk
                     kk=lt
  410                if(iyr.gt.nn) go to 430
                     if(iyr.eq.nn) go to 420
                     lt=iyr
                     iyr=nn
                     nn=lt
                     lt=kk
                     kk=ii
                     ii=lt
                     go to 430
  420                if(kk.ge.ii) go to 430
                     lt=kk
                     kk=ii
                     ii=lt
  430                numb2=itl(iyr)+it(iyr)*kk+it(kk)+it(nn)+ii
                     iyr=iy
                     ii=i
                     nn=n
                     kk=k
                     if(iyr.ge.nn) go to 440
                     lt=iyr
                     iyr=nn
                     nn=lt
  440                if(ii.ge.kk) go to 450
                     lt=ii
                     ii=kk
                     kk=lt
  450                if(iyr.gt.ii) go to 470
                     if(iyr.eq.ii) go to 460
                     lt=iyr
                     iyr=ii
                     ii=lt
                     lt=nn
                     nn=kk
                     kk=lt
                     go to 470
  460                if(nn.ge.kk) go to 470
                     lt=nn
                     nn=kk
                     kk=lt
  470                numb3=itl(iyr)+it(iyr)*nn+it(nn)+it(ii)+kk
                     mm=m
                     nn=n
                     jj=j
                     ii=i
                     if(nn.gt.mm) go to 490
                     if(nn.eq.mm) go to 480
                     lt=nn
                     nn=mm
                     mm=lt
                     lt=jj
                     jj=ii
                     ii=lt
                     go to 490
  480                if(jj.ge.ii) go to 490
                     lt=jj
                     jj=ii
                     ii=lt
  490                numb4=itl(nn)+it(nn)*jj+it(jj)+it(mm)+ii
                     iyr=iy
                     jj=j
                     kk=k
                     mm=m
                     if(iyr.ge.jj) go to 500
                     lt=iyr
                     iyr=jj
                     jj=lt
  500                if(iyr.gt.mm) go to 520
                     if(iyr.eq.mm) go to 510
                     lt=iyr
                     iyr=mm
                     mm=lt
                     lt=jj
                     jj=kk
                     kk=lt
                     go to 520
  510                if(jj.ge.kk) go to 520
                     lt=jj
                     jj=kk
                     kk=lt
  520                numb5=itl(iyr)+it(iyr)*jj+it(jj)+it(mm)+kk
                     ds4=ds4+(p(numb)*(p(numb1)*(4.d0*p(numb2)-
     12.d0*p(numb3))+p(numb4)*(p(numb3)-2.d0*p(numb2)))/
     2((ep+eig(m)-eig(j)-eig(k))*(eig(i)+eig(j)-eig(m)-eig(n)))+
     3p(numb5)*(p(numb1)*(p(numb3)-2.d0*p(numb2))+
     4p(numb4)*(p(numb2)-2*p(numb3)))/
     5((ep+eig(m)-eig(j)-eig(k))*(eig(i)+eig(j)-eig(m)-eig(n))))
  530 continue
      ds5=ds4
      do 720 m=kyr1,kyr2
         do 720 n=kyr1,kyr2
            do 720 i=myr1,nyr
               do 720 j=myr1,nyr
                  do 720 k=myr1,nyr
                     iyr=iy
                     mm=m
                     kk=k
                     ii=i
                     if(iyr.ge.kk) go to 540
                     lt=iyr
                     iyr=kk
                     kk=lt
  540                if(iyr.gt.mm) go to 560
                     if(iyr.eq.mm) go to 550
                     lt=iyr
                     iyr=mm
                     mm=lt
                     lt=kk
                     kk=ii
                     ii=lt
                     go to 560
  550                if(kk.ge.ii) go to 560
                     lt=kk
                     kk=ii
                     ii=lt
  560                numb=itl(iyr)+it(iyr)*kk+it(kk)+it(mm)+ii
                     mm=m
                     ii=i
                     jj=j
                     nn=n
                     if(mm.gt.nn) go to 580
                     if(mm.eq.nn) go to 570
                     lt=mm
                     mm=nn
                     nn=lt
                     lt=ii
                     ii=jj
                     jj=lt
                     go to 580
  570                if(ii.ge.jj) go to 580
                     lt=ii
                     ii=jj
                     jj=lt
  580                numb1=itl(mm)+it(mm)*ii+it(ii)+it(nn)+jj
                     iyr=iy
                     kk=k
                     jj=j
                     nn=n
                     if(iyr.ge.kk) go to 590
                     lt=iyr
                     iyr=kk
                     kk=lt
  590                if(iyr.gt.nn) go to 610
                     if(iyr.eq.nn) go to 600
                     lt=iyr
                     iyr=nn
                     nn=lt
                     lt=kk
                     kk=jj
                     jj=lt
                     go to 610
  600                if(kk.ge.jj) go to 610
                     lt=kk
                     kk=jj
                     jj=lt
  610                numb2=itl(iyr)+it(iyr)*kk+it(kk)+it(nn)+jj
                     iyr=iy
                     jj=j
                     nn=n
                     kk=k
                     if(iyr.ge.jj) go to 620
                     lt=iyr
                     iyr=jj
                     jj=lt
  620                if(iyr.gt.nn) go to 640
                     if(iyr.eq.nn) go to 630
                     lt=iyr
                     iyr=nn
                     nn=lt
                     lt=jj
                     jj=kk
                     kk=lt
                     go to 640
  630                if(jj.ge.kk) go to 640
                     lt=jj
                     jj=kk
                     kk=lt
  640                numb3=itl(iyr)+it(iyr)*jj+it(jj)+it(nn)+kk
                     mm=m
                     nn=n
                     jj=j
                     ii=i
                     if(ii.ge.jj) go to 650
                     lt=ii
                     ii=jj
                     jj=lt
  650                if(nn.ge.mm) go to 660
                     lt=nn
                     nn=mm
                     mm=lt
  660                if(ii.gt.nn) go to 680
                     if(ii.eq.nn) go to 670
                     lt=ii
                     ii=nn
                     nn=lt
                     lt=jj
                     jj=mm
                     mm=lt
                     go to 680
  670                if(jj.ge.mm) go to 680
                     lt=jj
                     jj=mm
                     mm=lt
  680                numb4=itl(ii)+it(ii)*jj+it(jj)+it(nn)+mm
                     iyr=iy
                     ii=i
                     kk=k
                     mm=m
                     if(iyr.ge.ii) go to 690
                     lt=iyr
                     iyr=ii
                     ii=lt
  690                if(iyr.gt.mm) go to 710
                     if(iyr.eq.mm) go to 700
                     lt=iyr
                     iyr=mm
                     mm=lt
                     lt=ii
                     ii=kk
                     kk=lt
                     go to 710
  700                if(ii.ge.kk) go to 710
                     lt=ii
                     ii=kk
                     kk=lt
  710                numb5=itl(iyr)+it(iyr)*ii+it(ii)+it(mm)+kk
                     ds6=ds6+(p(numb)*(p(numb1)*(4.d0*p(numb2)-
     12.d0*p(numb3))+p(numb4)*(p(numb3)-2.d0*p(numb2)))/
     2((ep+eig(m)-eig(i)-eig(k))*(ep+eig(n)-eig(j)-eig(k)))+
     3p(numb5)*(p(numb1)*(p(numb3)-2.d0*p(numb2))+
     4p(numb4)*(p(numb2)-2.d0*p(numb3)))/
     5((ep+eig(m)-eig(i)-eig(k))*(ep+eig(n)-eig(j)-eig(k))))
  720 continue
      ds6=-ds6
      return
      end
c
c====================================================================
c
      subroutine fcnpp(p,ndis)
*****************************************************************
*     main program for green's function calculations            *
*     subroutine written by dr. d.danovich, computation         *
*     chemistry centre, department of chemistry, technion-      *
*     israel institute of technology, haifa, 32000, israel      *
*     version   2.09.90                                         *
*****************************************************************
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      common / readme / ird
      common /iofile/ mfgr,iw
      dimension p(*),eg2(20),eg23(20),ega(20),ig2(20),ig23(20),
     .iga(20),rir(20),prir(20)
      common/molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),
     * nlast(numatm),norbs,nelecs,nalpha,nbeta,nclose,nopen,ndumy,
     * fract
      common/dod/itl(200),it(200)
      common/davi/intso
      common/perem/nyr,iyr,iggv,iggw
      common/csuc/cs1,cs2,cs3,cs4,cs5,cs6
      common/asma/as1,as2,as3,as4,as5,as6
      common/dsmd/ds1,ds2,ds3,ds4,ds5,ds6
      common/suma/su2r,eps,sum1,sum2
      common/vector/c(morb2),eig(maxorb),cbeta(morb2),eigb(maxorb)
      dimension value(10)
      character line*80
      write(iw,1) intso,norbs
   1  format(//5x,'number of nonzero integrals =',i10,5x,
     *'total number of mo  =',i4)
      write(iw,2)
   2  format(//35x,'  orbital energy ')
      if(norbs.gt.200) stop
      write(iw,3) (i,i=1,norbs)
   3  format(/5x,10i7)
      write(iw,4) (eig(i),i=1,norbs)
  4   format(//5x,10f7.3)
      numb=nelecs/2
      write(iw,5) numb
   5  format(//5x,' higher occupied mo  is  ',i4,'  mo ')
      do 2000 i=1,20
      eg2(i)=0.d0
      eg23(i)=0.d0
      ega(i)=0.d0
      rir(i)=0.d0
      prir(i)=0.d0
      ig2(i)=0
      ig23(i)=0
 2000 iga(i)=0
      read(ird,'(a)') line
      call nuchar(line,value,nvalue)
      iggww=value(1)
      iggv=value(2)
      niz=value(3)
      iver=value(4)
      ieps=value(5)
      iter2=value(6)
      iter3=value(7)
      ifulit=value(8)
      iprint=value(9)
      it23=value(10)
      eps=10.d0**(-ieps)
      iggw=iggww-1
      write(iw,120) iggww,iggv,niz,iver,eps,iter2,iter3,ifulit,
     *iprint,it23
 120  format(///5x,'total number of occupied orbitals involved in the'/
     *5x,' ovgf calculation =',i3/5x,'total number of unoccupied ',
     *'orbitals involved in the'/5x,' ovgf calculation =',i3/5x,
     *'the number of first occupied mo for which ovgf correction '/5x,
     *'must be started =',i3/5x,
     *'the number of last occupied mo for which ovgf correction '/5x,
     *'must be  finished =',i3/5x,
     *'tolerance factor = ',f12.8/5x,
     *'second-order contribution = ',i3/5x,
     *'third-order contribution = ',i3/5x,
     *'full expression = ',i3/5x,
     *'print factor = ',i3/5x,
     *'only second-order contribution = ',i3)
      nyr=numb
      numh=niz
      numv=iver
      if(iter2.ne.0) go to 16
      iii=0
      if(numh.le.0) numh=1
      do 10 iyr=numh,numv
      ep=eig(iyr)
      if(iprint.ne.0) print 122, ep
      call suma2(p,ndis,ep)
      ir=0
      w=ep+su2r
  11  ir=ir+1
      call suma2(p,ndis,w)
      w1=ep+su2r
      if(dabs(w1-w).lt.eps) go to 12
      w=w1
      go to 11
  12  iii=iii+1
      eg2(iii)=w1
      ig2(iii)=ir
      if(iprint.ne.0) write(iw,154) w1,ir
  10  continue
   16 numh=niz
      numv=iver
      if(it23.ne.0) go to 1000
      if(iter3.ne.0) go to 17
      iii=0
      if(numh.le.0) numh=1
      do 18 iyr=numh,numv
      ep=eig(iyr)
      if(iprint.ne.0) write(iw,122) ep
      call suma2(p,ndis,ep)
      call asumd(p,ndis)
      call csumd(p,ndis,ep)
      call dsumd(p,ndis,ep)
      ir=0
      su3r=as1+cs1+ds1+as2+cs2+ds2+as3+cs3+ds3+as4+cs4+ds4+as5+cs5+
     *ds5+as6+cs6+ds6
      w=ep+su2r+su3r
  19  ir=ir+1
      call suma2(p,ndis,w)
      call csumd(p,ndis,w)
      call dsumd(p,ndis,w)
      su3r=as1+cs1+ds1+as2+cs2+ds2+as3+cs3+ds3+as4+cs4+ds4+as5+cs5+
     *ds5+as6+cs6+ds6
      w1=ep+su2r+su3r
      if(dabs(w1-w).lt.eps) go to 20
      w=w1
      go to 19
   20 iii=iii+1
      eg23(iii)=w1
      ig23(iii)=ir
      if(iprint.ne.0) write(iw,154) w1,ir
   18 continue
   17 numh=niz
      numv=iver
      if(numh.le.0) numh=1
      write(iw,121) numh,numv
 121  format(/5x,'numh =',i4,5x,'numv =',i4)
      if(ifulit.gt.0) go to 23
      if(ifulit.lt.0) go to 24
      iii=0
      do 25 iyr=numh,numv
      ep=eig(iyr)
      if(iprint.ne.0) write(iw,122) ep
 122  format(/5x,'ep =',f18.8)
      call suma2(p,ndis,ep)
      call asumd(p,ndis)
      call csumd(p,ndis,ep)
      call dsumd(p,ndis,ep)
      ir=0
      su3r=as1+cs1+ds1+as2+cs2+ds2+as3+cs3+ds3+as4+cs4+ds4+as5+cs5+ds5+
     *as6+cs6+ds6
      if(su2r.eq.0.d0) go to 26
      faca=-(cs2+cs3+cs4+cs5+ds2+ds3+ds4+ds5)/su2r
      go to 27
   26 write(iw,28)
   28 format(/5x,' su2r=0 on 0  step ')
      faca=0.d0
   27 w=ep+su2r+(1+faca)**(-1)*su3r
   29 ir=ir+1
      call suma2(p,ndis,w)
      call csumd(p,ndis,w)
      call dsumd(p,ndis,w)
      su3r=as1+cs1+ds1+as2+cs2+ds2+as3+cs3+ds3+as4+cs4+ds4+as5+cs5+ds5+
     *as6+cs6+ds6
      if(su2r.eq.0.d0) go to 30
      faca=-(cs2+cs3+cs4+cs5+ds2+ds3+ds4+ds5)/su2r
      go to 31
   30 write(iw,32) ir
  32  format(/5x,' su2r =0 on ',i5,' step ')
      faca=0.d0
  31  w1=ep+su2r+(1+faca)**(-1)*su3r
      if(dabs(w1-w).lt.eps) go to 33
      w=w1
      go to 29
  33  iii=iii+1
      ega(iii)=w1
      iga(iii)=ir
      if(iprint.ne.0) write(iw,154) w1,ir
 154  format(/5x,' w1 = ',f12.8,5x,' ir = ',i5)
  25  continue
      go to 1000
  23  iii=0
      do 127 iyr=numh,numv
      ep=eig(iyr)
      if(iprint.ne.0) write(iw,122) ep
      call suma2(p,ndis,ep)
      call asumd(p,ndis)
      call csumd(p,ndis,ep)
      call dsumd(p,ndis,ep)
      ir=0
      if(sum1.eq.0.d0) go to 34
      g1=-(cs4+cs5+ds4+ds5)/sum1
      go to 35
  34  write(iw,36)
  36  format(/5x,'sum1=0 on 0  step  ')
      g1=0.d0
   35 if(sum2.eq.0.d0) go to 37
      g2=-(cs2+cs3+ds2+ds3)/sum2
      go to 38
   37 write(iw,39)
   39 format(/5x,' sum2 = 0 on 0  step ')
      g2=0.d0
   38 w=ep+su2r+(1+g1)**(-1)*(cs4+cs5+cs6+ds4+ds5+ds6)+(1+g2)**(-1)*
     *(cs1+cs2+cs3+ds1+ds2+ds3)+(as1+as2+as3+as4+as5+as6)
  40  ir=ir+1
      call suma2(p,ndis,w)
      call csumd(p,ndis,w)
      call dsumd(p,ndis,w)
      if(sum1.eq.0.d0) go to 41
      g1=-(cs4+cs5+ds4+ds5)/sum1
      go to 42
  41  write(iw,43) ir
  43  format(/5x,'sum1=0 on',i5,' step  ')
      g1=0.d0
   42 if(sum2.eq.0.d0) go to 44
      g2=-(cs2+cs3+ds2+ds3)/sum2
      go to 45
   44 write(iw,46) ir
   46 format(/5x,' sum2 = 0 on',i5,'  step ')
      g2=0.d0
   45 w1=ep+su2r+(1+g1)**(-1)*(cs4+cs5+cs6+ds4+ds5+ds6)+(1+g2)**(-1)*
     *(cs1+cs2+cs3+ds1+ds2+ds3)+(as1+as2+as3+as4+as5+as6)
      if(dabs(w1-w).lt.eps) go to 47
      w=w1
      go to 40
   47 iii=iii+1
      ega(iii)=w1
      iga(iii)=ir
      if(iprint.ne.0) write(iw,154) w1,ir
 127  continue
      go to 1000
   24 iii=0
      do 48 iyr=numh,numv
      ep=eig(iyr)
      if(iprint.ne.0) write(iw,122) ep
      call suma2(p,ndis,ep)
      call asumd(p,ndis)
      call csumd(p,ndis,ep)
      call dsumd(p,ndis,ep)
      ir=0
      if(sum1.eq.0.d0) go to 49
      g1=-(cs4+cs5+ds4+ds5)/sum1
      go to 50
  49  write(iw,51)
  51  format(/5x,'sum1 b 3 =0 on 0  step  ')
      g1=0.d0
   50 if(sum2.eq.0.d0) go to 52
      g2=-(cs2+cs3+ds2+ds3)/sum2
      go to 53
   52 write(iw,54)
   54 format(/5x,' sum2 b 3 = 0 on 0  step ')
      g2=0.d0
   53 szam=cs1+ds1+cs2+ds2+cs3+ds3+cs4+ds4+cs5+ds5+cs6+ds6
      if(szam.ne.0.d0) go to 55
      write(iw,56)
  56  format(/5x,' szam 0 on 0  step ')
      a=0.d0
      go to 57
  55  a=(g1*(cs4+cs5+cs6+ds4+ds5+ds6)+g2*(cs1+cs2+cs3+ds1+ds2+ds3))/szam
  57  su3r=as1+cs1+ds1+as2+cs2+ds2+as3+cs3+ds3+as4+cs4+ds4+as5+cs5+ds5+
     *as6+cs6+ds6
      w=ep+su2r+(1+a)**(-1)*su3r
  58  ir=ir+1
      call suma2(p,ndis,w)
      call csumd(p,ndis,w)
      call dsumd(p,ndis,w)
      if(sum1.eq.0.d0) go to 59
      g1=-(cs4+cs5+ds4+ds5)/sum1
      go to 60
  59  write(iw,61) ir
  61  format(/5x,'sum1=0 on',i5,'  step ')
      g1=0.d0
   60 if(sum2.eq.0.d0) go to 62
      g2=-(cs2+cs3+ds2+ds3)/sum2
      go to 63
   62 write(iw,64) ir
   64 format(/5x,' sum2 = 0 on',i5,'  step ')
      g2=0.d0
   63 szam=cs1+ds1+cs2+ds2+cs3+ds3+cs4+ds4+cs5+ds5+cs6+ds6
      if(szam.ne.0.d0) go to 65
      write(iw,66) ir
  66  format(/5x,' szam 0 on',i5,'  step ')
      a=0.d0
      go to 67
  65  a=(g1*(cs4+cs5+cs6+ds4+ds5+ds6)+g2*(cs1+cs2+cs3+ds1+ds2+ds3))/szam
  67  su3r=as1+cs1+ds1+as2+cs2+ds2+as3+cs3+ds3+as4+cs4+ds4+as5+cs5+ds5+
     *as6+cs6+ds6
      w1=ep+su2r+(1+a)**(-1)*su3r
      if(dabs(w1-w).lt.eps) go to 68
      w=w1
      go to 58
   68 iii=iii+1
      ega(iii)=w1
      iga(iii)=ir
      if(iprint.ne.0) write(iw,154) w1,ir
  48  continue
 1000 write(iw,13)
   13 format(///5x,' results of calculation pes  ')
      write(iw,14)
  14  format(/1x,'level ',3x,' 2   ',2x,' ir ',3x,' 3   ',2x,
     *' ir ',3x,' final ',2x,' ir ',3x,' scf')
      do 81 ii=1,iii
      write(iw,82) numh,eg2(ii),ig2(ii),eg23(ii),ig23(ii),ega(ii),
     *iga(ii),eig(numh)
      numh=numh+1
  81  continue
  82  format(/i3,5x,f7.3,3x,i2,2x,f7.3,3x,i2,2x,f7.3,4x,i2,4x,
     *f7.3)
      write(iw,83) iggww,iggv,eps,ifulit
  83  format(//5x,' in calculated used ',i5,' homo  and ',
     *i5,' lumo '/5x,' accuracy selfconsistent  = ',f12.8/5x,
     *' final result calculated by ',i3,'  method ')
      write(iw,84)
   84 format(//6x,'final=0, calculated by  formula w=ep+sum2+(1+a)',
     1'**(-1)*su3r'/6x,
     *'final=1, calculated by formula w=ep+sum2+(1+g1)**-1)'/3x,
     1'*(cs4+cs5+cs6+ds4+ds5+ds6)+(1+g2)**(-1)*(cs1+cs2+cs3+ds1'/3x,
     2'+ds2+ds3)+aa'/6x,
     *'final= -1, calculated by formula w=ep+sum2+(1+a)**(-1)*sum3')
      numh=niz
      numv=iver
      num1=numb-iggw
      num2=numb+iggv
      kil=0
      do 350 i=numh,numv
      zsuma=0.d0
      namb=numb+1
      do 301 j=num1,numb
      do 301 l=namb,num2
      jj=j
      ll=l
      ii=i
      if(jj.ge.ll) go to 302
      lt=jj
      jj=ll
      ll=lt
 302  if(jj.gt.ii) go to 303
      if(jj.eq.ii) go to 304
 306  nymb=itl(ii)+it(ii)*ii+it(ii)+it(jj)+ll
      go to 305
 304  if(ll.ge.ii) go to 303
      go to 306
 303  nymb=itl(jj)+it(jj)*ll+it(ll)+it(ii)+ii
 305  jj=j
      ll=l
      ii=i
      if(jj.ge.ii.and.ii.ge.ll) go to 307
      if(jj.ge.ii.and.ll.ge.ii.and.jj.ge.ll) go to 308
      if(jj.ge.ii.and.ll.ge.ii.and.ll.ge.jj) go to 309
      if(ii.ge.jj.and.ii.ge.ll.and.jj.ge.ll) go to 310
      if(ii.ge.jj.and.ii.ge.ll.and.ll.ge.jj) go to 311
      if(ii.ge.jj.and.ll.ge.ii) go to 312
      write(iw,320) jj,ii,ll
 320  format(5x,'jj=',i5,5x,'ii=',i5,5x,'ll=',i5)
      stop
 307  nymb1=itl(jj)+it(jj)*ii+it(ii)+it(ii)+ll
      go to 313
 308  nymb1=itl(jj)+it(jj)*ii+it(ii)+it(ll)+ii
      go to 313
 309  nymb1=itl(ll)+it(ll)*ii+it(ii)+it(jj)+ii
      go to 313
 310  nymb1=itl(ii)+it(ii)*jj+it(jj)+it(ii)+ll
      go to 313
 311  nymb1=itl(ii)+it(ii)*ll+it(ll)+it(ii)+jj
      go to 313
 312  nymb1=itl(ll)+it(ll)*ii+it(ii)+it(ii)+jj
 313  zverx=(p(nymb)-0.5d0*p(nymb1))**2
      zniz=eig(l)-eig(j)
      ps=zverx/zniz
      zsuma=zsuma+ps
 301  continue
      kil=kil+1
      rir(kil)=2.d0*zsuma
 350  continue
      write(iw,355)
 355  format(//5x,' calculation relaxation effects only  ')
      do 356 i=1,iii
      prir(i)=-eig(numh)-rir(i)
      numh=numh+1
 356  continue
      numh=niz
      write(iw,359)
 359  format(/3x,'level',2x,'r.effect',3x,'energy scf',5x,'energy')
      do 357 i=1,iii
      write(iw,358) numh,rir(i),eig(numh),prir(i)
      numh=numh+1
 357  continue
 358  format(/3x,i3,2x,f10.6,3x,f8.4,8x,f8.4)
      return
      end
      subroutine greenf
      implicit REAL (a-h,o-z)
*******************************************************************
*                                                                 *
*     subroutine need for green function calculation              *
*******************************************************************
INCLUDE(common/sizes)
      common/molkst/numat,nat(numatm),nfirst(numatm),nmidle(numatm),
     1 nlast(numatm),norbs,nelecs,nalpha,nbeta,nclose,nopen,ndumy,
     2 fract
      common/dod/itl(200),it(200)
      common/dod1/nmux,lm6,lm7
c     common /chanel/ ifiles(30)
c     equivalence(iw,ifiles(6))
      common /iofile/ mfgr,iw
c     iw=6
      write(iw,10)
   10 format(///)
      write(iw,20)
   20 format(10x,'************************************************'/
     1       10x,'*                                              *'/
     2       10x,'*   semiempirical green function calculation   *'/
     3       10x,'*                                              *'/
     4       10x,'*  this package was written by dr. d.danovich  *'/
     5       10x,'*            chemistry department              *'/
     6       10x,'*    technion-israel institute of technology   *'/
     7       10x,'*      technion city, haifa  32000, israel     *'/
     8       10x,'*                                              *'/
     9       10x,'************************************************')
      k=0
      do 30 i=1,200
         it(i)=k
   30 k=k+i
      do 40 i=1,200
         n=it(i)
   40 itl(i)=n*(n-1)/2
      mmm=norbs
      nmux=itl(mmm)+it(mmm)*mmm+it(mmm)+it(mmm)+mmm
      lm6=0
      do 50 i=1,numat
         iao=nlast(i)-nfirst(i)+1
   50 lm6=lm6+(iao*(iao+1))/2
      lm7=lm6*lm6
      memory=nmux+2*lm6+lm7+8
      call insymc
      call mo(memory)
      return
      end
c
c==================================================================
c
      subroutine gstore(ii,jj,kk,ll,wert,pgr,nmux)
************************************************************
*                                                          *
*     store two-electron mo integrals on file ntp3.        *
*     subroutine written by dr.david danovich,             *
*     computational chemistry centre, chemistry department *
*     technion-israel institute of technology, haifa,      *
*     32000, israel,          version     02.09.90         *
************************************************************
      implicit REAL (a-h,o-z)
      dimension pgr(*)
      common/dod/itl(200),it(200)
      iii=ii
      jjj=jj
      kkk=kk
      lll=ll
      if(iii.ge.jjj) go to 10
      lt=iii
      iii=jjj
      jjj=lt
   10 if(kkk.ge.lll) go to 20
      lt=kkk
      kkk=lll
      lll=lt
   20 if(iii.gt.kkk) go to 40
      if(iii.eq.kkk) go to 30
      lt=iii
      iii=kkk
      kkk=lt
      lt=jjj
      jjj=lll
      lll=lt
      go to 40
   30 if(jjj.ge.lll) go to 40
      lt=jjj
      jjj=lll
      lll=lt
   40 nnnn=itl(iii)+it(iii)*jjj+it(jjj)+it(kkk)+lll
      pgr(nnnn)=wert
      return
      end
c
c==============================================================
c
      subroutine mo(memory)
      implicit REAL (a-h,o-z)
*******************************************************************
*                                                                 *
*     subroutine need for green function calculations             *
*******************************************************************
INCLUDE(common/sizes)
      common/molkst/numat,nat(numatm),nfirst(numatm),nmidle(numatm),
     1 nlast(numatm),norbs,nelecs,nalpha,nbeta,nclose,nopen,ndumy,
     2 fract
      common/dod/itl(200),it(200)
      common/vector/c(morb2),eig(maxorb),cbeta(morb2),eigb(maxorb)
      common/wmatrc/w(n2elec),wk(n2elec)
      common/ciparm/ici1,ici2,iout2
      common/dod1/nmux,lm6,lm7
      parameter (igreen=600000)
      common/fmcom/x(600000)
c     common /chanel/ ifiles(30)
c     equivalence(iw,ifiles(6))
      common /iofile/ mfgr,iw
      if(memory.gt.igreen)then
         write(iw,'(a)')' available memory in '//
     1'greens function calculation'
         write(iw,'(a,i8,a,i8)')' too small.  available:'
     1,igreen,' needed:',memory
         write(iw,'(a)')' to run this job, modify igreen in subroutine'
     1//' mo (called by greenf) and recompile'
      stop
      endif
      loadfm=0
      i10=1+loadfm
      nnmm=i10+nmux
      nnnn1=nnmm+lm7
      nnmm1=nnnn1+lm6
      last=nnmm1+lm6
      need=last-i10
      call worder(x(nnmm),lm7,iout2)
      call moint(c,x(i10),x(nnmm),x(nnnn1),x(nnmm1),norbs,norbs,lm7,lm6,
     1 nmux)
      call fcnpp(x(i10),nmux)
      return
      end
      subroutine moint(c,pgr,cc,w,c12,norbs,lm2,lm8,kmax,nmux)
********************************************************************
*     transformation of two-electron integrals from ao to mo basis *
*     subroutine written by dr.david danovich, computational       *
*     chemistry centre, department of chemistry, technion -        *
*     israel institute of technology, haifa, 32000, israel         *
*     version     02.09.90                                         *
*     subroutine need for green function calculations              *
********************************************************************
      implicit REAL (a-h,o-z)
      dimension pgr(*)
      common/cimos /imoci(200)
      common/ciparm/ici1,ici2,iout2
      common/davi/nintg
c     common /chanel/ ifiles(30)
c     equivalence(iw,ifiles(6))
      common /iofile/ mfgr,iw
      dimension c(lm2,norbs),cc(*),w(*),c12(*)
      data off/1.0d-8/,zero/0.0d0/
c     set control variables.
c     lmax   = storage capacity of cc(lm8)
      lmax   = lm8/kmax
c     compute (ij,kl) integrals
      iend=ici1+ici2
      nintg=0
c     outer ij-loop
      do 10 i=1,iend
         ii = imoci(i)
         do 10 j=1,i
            ij = imoci(j)
c     compute set of (ij,ab) integrals
            call ccprod(c(1,ii),c(1,ij),c12,lm2,kmax)
            call wwstep(c12,cc,w,lm8,kmax,lmax)
c     inner kl-loop
            do 10 k=1,i
               ik = imoci(k)
               do 10  l=1,k
                  if(i.eq.k.and.j.lt.l) go to 10
                  il = imoci(l)
                  wnn = zero
c     compute the integral
                  nintg = nintg+1
                  call ccprod(c(1,ik),c(1,il),c12,lm2,kmax)
                  wnn = sisms(c12,w,kmax)
                  if(dabs(wnn).lt.off) wnn=zero
                  call gstore(ii,ij,ik,il,wnn,pgr,nmux)
   10 continue
      if(iout2.gt.-5) write(iw,20) nintg
   20 format(///1x,'there are',i12,' nonzero integrals.'/)
      return
      end
c
c===================================================================
c
      subroutine suma2(p,ndis,ep)
********************************************************************
*     calculation second-order contribution in the self-energy     *
*     function                                                     *
*     subroutine written by dr. david danovich, computational      *
*     chemistry centre, department of chemistry, technion -        *
*     israel institute of technology, haifa, 32000, israel         *
*     version    02.09.90                                          *
********************************************************************
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      dimension p(*)
      common/dod/itl(200),it(200)
      common/vector/c(morb2),eig(maxorb),cbeta(morb2),eigb(maxorb)
      common/perem/nyr,iy,iggv,iggw
      common/suma/su2r,eps,sum1,sum2
      kyr2=nyr+iggv
      kyr1=nyr+1
      myr=nyr-iggw
      sum1=0.d0
      sum2=0.d0
      do 70 m=kyr1,kyr2
         do 70 i=myr,nyr
            do 70 j=myr,nyr
               iyr=iy
               ii=i
               mm=m
               jj=j
               if(iyr.ge.ii) go to 10
               lt=iyr
               iyr=ii
               ii=lt
   10          if(iyr.gt.mm) go to 30
               if(iyr.eq.mm) go to 20
               lt=iyr
               iyr=mm
               mm=lt
               lt=ii
               ii=jj
               jj=lt
               go to 30
   20          if(ii.ge.jj) go to 30
               lt=ii
               ii=jj
               jj=lt
   30          numb=itl(iyr)+it(iyr)*ii+it(ii)+it(mm)+jj
               iyr=iy
               jj=j
               mm=m
               ii=i
               if(iyr.ge.jj) go to 40
               lt=iyr
               iyr=jj
               jj=lt
   40          if(iyr.gt.mm) go to 60
               if(iyr.eq.mm) go to 50
               lt=iyr
               iyr=mm
               mm=lt
               lt=jj
               jj=ii
               ii=lt
               go to 60
   50          if(jj.ge.ii) go to 60
               lt=jj
               jj=ii
               ii=lt
   60          numb1=itl(iyr)+it(iyr)*jj+it(jj)+it(mm)+ii
               sum1=sum1+(2.d0*p(numb)-p(numb1))*p(numb)/
     1(ep+eig(m)-eig(i)-eig(j))
   70 continue
      do 140 m=kyr1,kyr2
         do 140 n=kyr1,kyr2
            do 140 i=myr,nyr
               iyr=iy
               ii=i
               mm=m
               nn=n
               if(iyr.ge.mm) go to 80
               lt=iyr
               iyr=mm
               mm=lt
   80          if(iyr.gt.nn) go to 100
               if(iyr.eq.nn) go to 90
               lt=iyr
               iyr=nn
               nn=lt
               lt=mm
               mm=ii
               ii=lt
               go to 100
   90          if(mm.ge.ii) go to 100
               lt=mm
               mm=ii
               ii=lt
  100          numb=itl(iyr)+it(iyr)*mm+it(mm)+it(nn)+ii
               iyr=iy
               nn=n
               mm=m
               ii=i
               if(iyr.ge.nn) go to 110
               lt=iyr
               iyr=nn
               nn=lt
  110          if(iyr.gt.mm) go to 130
               if(iyr.eq.mm) go to 120
               lt=iyr
               iyr=mm
               mm=lt
               lt=nn
               nn=ii
               ii=lt
               go to 130
  120          if(nn.ge.ii) go to 130
               lt=nn
               nn=ii
               ii=lt
  130          numb1=itl(iyr)+it(iyr)*nn+it(nn)+it(mm)+ii
               sum2=sum2+(2.d0*p(numb)-p(numb1))*p(numb)/
     1(ep+eig(i)-eig(m)-eig(n))
  140 continue
      su2r=sum1+sum2
      return
      end
c
c================================================================
c
      subroutine syman1(num1,num2,array,linear,jump,idim)
      implicit REAL (a-h,o-z)
c***************************************************************
c                                                              *
c     symmetry package from umndo program of peter bischof     *
c     was rewritten by david danovich for mopac system         *
c                                                              *
c***************************************************************
INCLUDE(common/sizes)
      parameter (mxdim=maxpar+numatm)
      dimension linear(numatm),nuss(mxdim),icount(12),array(3,numatm)
      common /iofile/ mfgr,iw
      common /s00001/t(12,12),jx(7,12),lina,i1,j1,j2
      common /s00002/ numat,norbs,nadim,ncdim,iqual,ndorbs,ierror
      common /s00020/ nimm(2,mxdim),nocc(2)
      common/symres/ trans,rtr,sig,name,namo(mxdim),index(mxdim),ista(2)
      character*4  ifra, name, ista, namo, nimm
      common /syminf/ ibase(2,12),nbase,ivibro(2,12),ivib
      data ifra / '????'  /
      if(num1.lt.2) goto 12
      if(num2.lt.2) goto 12
      if(num1.gt.mxdim) goto 12
c **  molecular symmetry
 1    ierror=0
      lcall=0
      ivib=0
      nbase=0
      numat=num1
      name=ifra
      ista(1)=' '
      ista(2)=ifra
      do 2 i=1,mxdim
 2    namo(i)=ifra
      call r00001(linear,array)
      if(ierror.lt.1) call r00009(linear,array)
      if(ierror.lt.1) call r00016
      do 3 i=1,numat
 3    index(i)=linear(i)
      return
 12   ierror=1
      write(iw,600)num1,num2
      return
 600  format(' illegal syma - arguments: num1 = ',i10,' num2 = ',i10)
      end
c
c======================================================================
c
      subroutine syman2(num1,num2,array,linear,jump,idim)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      parameter (mxdim=maxpar+numatm)
      dimension nuss(mxdim),icount(12),array(num1,num1)
      common /s00001/ t(12,12),jx(7,12),lina,i1,j1,j2
      common /s00002/ numat,norbs,nadim,ncdim,iqual,ndorbs,ierror
      common /s00020/ nimm(2,mxdim),nocc(2)
      common/symres/ trans,rtr,sig,name,namo(mxdim),index(mxdim),ista(2)
      character*4  ifra, name, ista, namo, nimm
      common /syminf/ ibase(2,12),nbase,ivibro(2,12),ivib
      common /iofile/ mfgr,iw
      data ifra / '????'  /
      if(num1.lt.2) goto 12
      if(num2.lt.2) goto 12
      if(num1.gt.mxdim) goto 12
c **  orbital symmetry
      if(ierror.gt.0) then
        return
      endif
      lcall=0
      if(linear.gt.0) goto 6
      if(lcall.gt.0) goto 8
      korb=0
      nqz=1
      do 5 i=1,numat
      jj=1
      if(index(i).gt.1) jj=4
      do 5 j=1,jj
      korb=korb+1
      nuss(korb)=100*i+10*nqz+j-1
 5    continue
      goto 8
 6    do 7 i=1,num1
 7    nuss(i)=linear
 8    norbs=num1
      ncdim=num2
      ncdum=num2
      call r00010(array,nuss,icount,num1)
      if(ierror.gt.0) return
      nbase=0
      do 9 i=1,i1
      if(icount(i).lt.1) goto 9
      nbase=nbase+1
      ibase(1,nbase)=icount(i)
      ibase(2,nbase)=jx(1,i)
 9    continue
      lcall=lcall+1
      if(lcall.gt.2) lcall=1
      do 10 i=1,norbs
      nimm(lcall,i)=namo(i)
 10   nimm(2,i)=namo(i)
      return
 12   ierror=1
      write(iw,600)num1,num2
      return
 600  format(' illegal syma - arguments: num1 = ',i10,' num2 = ',i10)
      end
c
c==========================================================================
c
      subroutine r00001(nat,coord)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      parameter (mxdim=maxpar+numatm)
      character*4 name,namo,ista
      common /s00002/ numat,norbs,ncdim,iqual,ndorbs,ierror
      common /s00003/ ielem(20),elem(3,3,20),cub(3,3),jelem(20,numatm)
      common /s00004/ shift(3),r(3,3),vect(2,mxdim)
      common/symres/ trans,rtr,sig,name,namo(mxdim),index(mxdim),ista(2)
      common  /atmass/  atmass(numatm)
      logical planar,linear,cubic,axis
      dimension nat(numatm),coord(3,numatm),f(6),ew(3),help(3)
      dimension rhelp(3,3)
      dimension icyc(6)
      data toler,big/ 0.1d0,1.d35 /
      do 2 i=1,3
      do 1 j=1,3
 1    cub(i,j)=0.d0
 2    cub(i,i)=1.d0
      do 3 i=1,20
      call r00006(i,i)
 3    ielem(i)=0
      do 4 i=1,3
 4    shift(i)=0.d0
      wmol=0.0d0
      do 5 i=1,numat
      wmol=wmol+atmass(i)
      do 5 k=1,3
 5    shift(k)=shift(k)+atmass(i)*coord(k,i)
      ij=0
      do 7 i=1,3
      shift(i)=shift(i)/wmol
      do 6 k=1,numat
 6    coord(i,k)=coord(i,k)-shift(i)
      do 7 j=1,i
      ij=ij+1
      f(ij)=0.d0
      do 7 k=1,numat
      term=atmass(k)*coord(i,k)*coord(j,k)
 7    f(ij)=f(ij)+term
      trans=25.98160821d0 + 2.97975d0*dlog(wmol)
      call r00015(f,r,ew)
      r(1,3)=r(2,1)*r(3,2)-r(3,1)*r(2,2)
      r(2,3)=r(3,1)*r(1,2)-r(1,1)*r(3,2)
      r(3,3)=r(1,1)*r(2,2)-r(2,1)*r(1,2)
      planar=(ew(1).lt.toler)
      linear=(ew(2).lt.toler)
      cubic=((ew(3)-ew(1)).lt.toler)
      if(.not.linear) goto 8
      call r00005(coord,1)
      ielem(20)=1
      goto 22
 8    if(cubic.or.((ew(3)-ew(2)).gt.toler)) goto 10
      do 9 i=1,3
      buff=-r(i,1)
      r(i,1)=r(i,3)
 9    r(i,3)=buff
      buff=ew(1)
      ew(1)=ew(3)
      ew(3)=buff
 10   axis=(dabs(ew(1)-ew(2)).lt.toler)
      call r00005(coord,1)
      if(cubic) call r00003(nat,coord,1)
      if(.not.axis) goto 16
      iturn=7
      do 11 i=8,18
      call r00007(nat,coord,i)
      if((ielem(i).eq.1).and.(i.lt.14)) iturn=i
 11   continue
      iturn=iturn-5
      do 13 i=1,numat
      dist=coord(1,i)**2+coord(2,i)**2
      if(dist.lt.toler) goto 13
      buff1=big
      jndex=0
      iplus=i+1
      do 12 j=iplus,numat
      buff=coord(1,j)**2+coord(2,j)**2
      if(dabs(buff-dist).gt.toler) goto 12
      buff=(coord(1,i)-coord(1,j))**2+(coord(2,i)-coord(2,j))**2
      if(buff.gt.buff1) goto 12
      jndex=j
      buff1=buff
 12   continue
      goto 14
 13   continue
 14   if(jndex.lt.1) ierror=1
      if(ierror.gt.0) goto 25
      help(1)=coord(1,i)+coord(1,jndex)
      help(2)=coord(2,i)+coord(2,jndex)
      dist=dsqrt(help(1)**2+help(2)**2)
      sina=help(2)/dist
      cosa=help(1)/dist
      call r00002(coord,sina,cosa,1,2)
      call r00007(nat,coord,5)
      if(ielem(5).eq.1) goto 16
      call r00007(nat,coord,1)
      if(ielem(1).eq.0) goto 16
      dist=1.5707963268d0/dfloat(iturn)
      sina=dsin(dist)
      cosa=dcos(dist)
      icheck=0
 15   call r00002(coord,sina,cosa,1,2)
      if(icheck.gt.0) goto 16
      call r00007(nat,coord,5)
      if(ielem(5).gt.0) goto 16
      icheck=1
      sina=-sina
      goto 15
 16   if(cubic) call r00003(nat,coord,2)
      if(axis) goto 22
      do 17 i=1,6
      call r00007(nat,coord,i)
 17   icyc(i)=(1+iqual)*ielem(i)
      naxes=ielem(1)+ielem(2)+ielem(3)
      if(naxes.gt.1) goto 18
      iz=1
      if(ielem(1).eq.1) goto 19
      iz=2
      if(ielem(2).eq.1) goto 19
      iz=3
      if(ielem(3).eq.1) goto 19
      if(icyc(5).gt.icyc(4)) iz=2
      if(icyc(6).gt.icyc(7-iz)) iz=1
      goto 19
 18   iz=1
      if(icyc(2).gt.icyc(1)) iz=2
      if(icyc(3).gt.icyc(iz)) iz=3
 19   icyc(7-iz)=-1
      ix=1
      if(icyc(5).gt.icyc(6)) ix=2
      if(icyc(4).gt.icyc(7-ix)) ix=3
      iy=6-ix-iz
      do 20 i=1,3
      rhelp(i,1)=r(i,ix)
 20   rhelp(i,2)=r(i,iy)
      rhelp(1,3)=r(2,ix)*r(3,iy)-r(3,ix)*r(2,iy)
      rhelp(2,3)=r(3,ix)*r(1,iy)-r(1,ix)*r(3,iy)
      rhelp(3,3)=r(1,ix)*r(2,iy)-r(2,ix)*r(1,iy)
      call r00005(coord,-1)
      do 21 i=1,3
      do 21 j=1,3
 21   r(i,j)=rhelp(i,j)
      call r00005(coord,1)
 22   do 23 i=1,7
      call r00007(nat,coord,i)
 23   continue
      ncode=0
      j=1
      do 24 i=1,20
      ncode=ncode+ielem(i)*j
 24   j=2*j
 25   call r00005(coord,-1)
      total=ew(1)+ew(2)+ew(3)
      do 26 i=1,3
      ew(i)=total-ew(i)
      do 26 j=1,numat
 26   coord(i,j)=coord(i,j)+shift(i)
      call r00008(jgroup,ncode)
      if(jgroup.lt.1) ierror=2
      total=ew(1)*ew(2)*ew(3)/(sig*sig)
      if(linear) rtr= 6.970686d0 + 1.9865d0*dlog(ew(1)/sig)
      if(.not.linear) rtr=11.592852d0 + 0.98325d0*dlog(total)
      return
      end
c
c==================================================================
c
      subroutine r00002(coord,sina,cosa,i,j)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      parameter (mxdim=maxpar+numatm)
      common /s00002/ numat,norbs,ncdim,iqual,ndorbs,ierror
      common /s00004/ shift(3),r(3,3),vect(2,mxdim)
      dimension coord(3,numatm)
      call r00005(coord,-1)
      do 1 k=1,3
      buff=-sina*r(k,i)+cosa*r(k,j)
      r(k,i)=cosa*r(k,i)+sina*r(k,j)
 1    r(k,j)=buff
      call r00005(coord,1)
      return
      end
c
c====================================================================
c
      subroutine r00003(nat,coord,jump)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      parameter (mxdim=maxpar+numatm)
      common /s00002/ numat,norbs,ncdim,iqual,ndorbs,ierror
      common /s00003/ ielem(20),elem(3,3,20),cub(3,3),jelem(20,numatm)
      common /s00004/ shift(3),r(3,3),vect(2,mxdim)
      dimension coord(3,numatm),nat(numatm),wink(2)
      data big,toler / 1.d35,0.1/
      data wink(1),wink(2)/ 0.955316618125d0, 0.6523581398d0  /
      goto (1,5),jump
 1    ielem(19)=1
      index=0
      xmin=big
      do 2 i=1,numat
      dist=coord(1,i)**2+coord(2,i)**2+coord(3,i)**2
      if(dist.lt.toler) goto 2
      if(dist.gt.xmin) goto 2
      index=i
      xmin=dist
 2    continue
      dist=dsqrt(xmin)
      call r00005(coord,-1)
      r(1,3)=coord(1,index)/dist
      r(2,3)=coord(2,index)/dist
      r(3,3)=coord(3,index)/dist
      buff=dsqrt(r(1,3)**2+r(2,3)**2)
      buff1=dsqrt(r(1,3)**2+r(3,3)**2)
      if(buff.gt.buff1) goto 3
      r(1,1)= r(3,3)/buff1
      r(2,1)=0.0d0
      r(3,1)=-r(1,3)/buff1
      goto 4
 3    r(1,1)= r(2,3)/buff
      r(2,1)=-r(1,3)/buff
      r(3,1)=0.0d0
 4    r(1,2)= r(2,3)*r(3,1)-r(2,1)*r(3,3)
      r(2,2)= r(3,3)*r(1,1)-r(3,1)*r(1,3)
      r(3,2)= r(1,3)*r(2,1)-r(1,1)*r(2,3)
      call r00005(coord,1)
      return
 5    wink2=0.d0
      if(ielem(8).lt.1) goto 8
      do 6 i=1,2
      jota=18-4*i
      wink2=wink(i)
      sina=dsin(wink2)
      cosa=dcos(wink2)
      call r00002(coord,sina,cosa,1,3)
      call r00007(nat,coord,jota)
      if(ielem(jota).gt.0) goto 7
      wink2=-wink2
      sinb=dsin(2.d0*wink2)
      cosb=dcos(2.d0*wink2)
      call r00002(coord,sinb,cosb,1,3)
      call r00007(nat,coord,jota)
      if(ielem(jota).gt.0) goto 7
      call r00002(coord,sina,cosa,1,3)
 6    continue
 7    call r00007(nat,coord,9)
      if(ielem(10).gt.0) call r00007(nat,coord,17)
      goto 10
 8    wink2=-wink(1)
      if(ielem(10).gt.0) wink2=-wink(2)
      sina=-dsin(wink2)
      cosa=dcos(wink2)
      call r00002(coord,sina,cosa,1,3)
      call r00007(nat,coord,8)
      call r00002(coord,-sina,cosa,1,3)
      if(ielem(8).gt.0) goto 10
      if(ielem(9).gt.0) goto 9
      wink2=-wink2
      goto 10
 9    call r00002(coord,0.707106781186d0,0.707106781186d0,
     +            1,2)
 10   cub(1,1)=dcos(wink2)
      cub(3,3)=cub(1,1)
      cub(1,3)=dsin(wink2)
      cub(3,1)=-cub(1,3)
      call r00004(cub,8)
      call r00004(cub,15)
      call r00007(nat,coord,8)
      call r00007(nat,coord,15)
      return
      end
c
c=====================================================================
c
      subroutine r00004(fmat,iplace)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      common /s00003/ ielem(20),elem(3,3,20),cub(3,3),jelem(20,numatm)
      dimension help(3,3),fmat(3,3)
      do 1 i=1,3
      do 1 j=1,3
      help(i,j)=0.d0
      do 1 k=1,3
      do 1 l=1,3
 1    help(i,j)=help(i,j)+fmat(i,l)*fmat(j,k)*elem(l,k,iplace)
      do 2 i=1,3
      do 2 j=1,3
 2    elem(i,j,iplace)=help(i,j)
      return
      end
c
c==========================================================================
c
      subroutine r00005(coord,jump)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      parameter (mxdim=maxpar+numatm)
      common /s00002/ numat,norbs,ncdim,iqual,ndorbs,ierror
      common /s00004/ shift(3),r(3,3),vect(2,mxdim)
      dimension coord(3,numatm),help(3)
      if(jump.lt.0) goto 3
      do 2 i=1,numat
      do 1 j=1,3
 1    help(j)=coord(j,i)
      do 2 j=1,3
      coord(j,i)=0.d0
      do 2 k=1,3
 2    coord(j,i)=coord(j,i)+r(k,j)*help(k)
      return
 3    do 5 i=1,numat
      do 4 j=1,3
 4    help(j)=coord(j,i)
      do 5 j=1,3
      coord(j,i)=0.d0
      do 5 k=1,3
 5    coord(j,i)=coord(j,i)+r(j,k)*help(k)
      return
      end
c
c========================================================================
c
      subroutine r00006(ioper,iplace)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      common /s00003/ ielem(20),elem(3,3,20),cub(3,3),jelem(20,numatm)
      dimension j(3,20)
      data j(1, 1),j(2, 1),j(3, 1) /       1   ,   -1   ,   -1     /
      data j(1, 2),j(2, 2),j(3, 2) /      -1   ,    1   ,   -1     /
      data j(1, 3),j(2, 3),j(3, 3) /      -1   ,   -1   ,    1     /
      data j(1, 4),j(2, 4),j(3, 4) /       1   ,    1   ,   -1     /
      data j(1, 5),j(2, 5),j(3, 5) /       1   ,   -1   ,    1     /
      data j(1, 6),j(2, 6),j(3, 6) /      -1   ,    1   ,    1     /
      data j(1, 7),j(2, 7),j(3, 7) /      -1   ,   -1   ,   -1     /
      data j(1, 8),j(2, 8),j(3, 8) /       3   ,    0   ,    1     /
      data j(1, 9),j(2, 9),j(3, 9) /       4   ,    0   ,    1     /
      data j(1,10),j(2,10),j(3,10) /       5   ,    0   ,    1     /
      data j(1,11),j(2,11),j(3,11) /       6   ,    0   ,    1     /
      data j(1,12),j(2,12),j(3,12) /       7   ,    0   ,    1     /
      data j(1,13),j(2,13),j(3,13) /       8   ,    0   ,    1     /
      data j(1,14),j(2,14),j(3,14) /       4   ,    0   ,   -1     /
      data j(1,15),j(2,15),j(3,15) /       6   ,    0   ,   -1     /
      data j(1,16),j(2,16),j(3,16) /       8   ,    0   ,   -1     /
      data j(1,17),j(2,17),j(3,17) /      10   ,    0   ,   -1     /
      data j(1,18),j(2,18),j(3,18) /      12   ,    0   ,   -1     /
      data j(1,19),j(2,19),j(3,19) /       5   ,    0   ,   -1     /
      data j(1,20),j(2,20),j(3,20) /       0   ,    0   ,   -1     /
      data twopi / 6.283185308d0 /
      do 2 i=1,3
      do 1 k=1,3
 1    elem(i,k,iplace)=0.d0
 2    elem(i,i,iplace)=j(i,ioper)
      if(ioper.eq.20) goto 4
      if(j(1,ioper).lt.2) goto 3
      angle=twopi/dfloat(j(1,ioper))
      elem(1,1,iplace)=dcos(angle)
      elem(2,2,iplace)=elem(1,1,iplace)
      elem(2,1,iplace)=dsin(angle)
      elem(1,2,iplace)=-elem(2,1,iplace)
 3    if((ioper.eq.8).or.(ioper.eq.15)) call r00004(cub,iplace)
      return
 4    elem(1,2,iplace)=1.0d0
      elem(2,1,iplace)=1.0d0
      return
      end
c
c======================================================================
c
      subroutine r00007(nat,coord,ioper)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      dimension nat(numatm),coord(3,numatm),help(3),e(3,3)
      common /s00002/ numat,norbs,ncdim,iqual,ndorbs,ierror
      common /s00003/ ielem(20),elem(3,3,20),cub(3,3),jelem(20,numatm)
      data toler / 0.01 d0/
      iresul=1
      iqual=0
      do 2 i=1,numat
      help(1)=coord(1,i)*elem(1,1,ioper)+coord(2,i)*elem(1,2,ioper)
     .                                  +coord(3,i)*elem(1,3,ioper)
      help(2)=coord(1,i)*elem(2,1,ioper)+coord(2,i)*elem(2,2,ioper)
     .                                  +coord(3,i)*elem(2,3,ioper)
      help(3)=coord(1,i)*elem(3,1,ioper)+coord(2,i)*elem(3,2,ioper)
     .                                  +coord(3,i)*elem(3,3,ioper)
      do 1 j=1,numat
      if(nat(i).ne.nat(j)) goto 1
      if(dabs(coord(1,j)-help(1)).gt.toler) goto 1
      if(dabs(coord(2,j)-help(2)).gt.toler) goto 1
      if(dabs(coord(3,j)-help(3)).gt.toler) goto 1
      jelem(ioper,i)=j
      if(i.eq.j) iqual=iqual+1
      goto 2
 1    continue
      iresul=0
 2    continue
      ielem(ioper)=iresul
      return
      end
c
c=====================================================================
c
      subroutine r00008(igroup,ncode)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      parameter (mxdim=maxpar+numatm)
      common /s00001/         t(12,12),jx(7,12),lina,i1,j1,j2
      common /s00003/ ielem(20),elem(3,3,20),cub(3,3),jelem(20,numatm)
      common/symres/trans,rtr,sig,name,namo(mxdim),index(mxdim),ista(2)
      integer c1(3),cs(7),ci(7),c2(7),c3(9),c4(16),c5(19),c6(29),
     .       c7(33),c8(46),d2(21),d3(13),d4(31),d5(21),d6(43),
     .       c2v(21),c3v(13),c4v(31),c5v(21),c6v(43),
     .       c2h(21),c3h(29),c4h(55),c5h(67),c6h(105),
     .       d2h(73),d3h(43),d4h(111),d5h(73),d6h(157),
     .       d2d(31),d3d(43),d4d(57),d5d(73),d6d(91),
     .       s4(16),s6(29),s8(46),
     .       td(31),oh(111),ih(111),cv(10),dh(25)
      dimension j(43),jtab(1844),isigma(43)
      equivalence (jtab(   1),c1(1)),(jtab(   4),cs(1))
      equivalence (jtab(  11),ci(1)),(jtab(  18),c2(1))
      equivalence (jtab(  25),c3(1)),(jtab(  34),c4(1))
      equivalence (jtab(  50),c5(1)),(jtab(  69),c6(1))
      equivalence (jtab(  98),c7(1)),(jtab( 131),c8(1))
      equivalence (jtab( 177),d2(1)),(jtab( 198),d3(1))
      equivalence (jtab( 211),d4(1)),(jtab( 242),d5(1))
      equivalence (jtab( 263),d6(1)),(jtab( 306),c2v(1))
      equivalence (jtab( 327),c3v(1)),(jtab( 340),c4v(1))
      equivalence (jtab( 371),c5v(1)),(jtab( 392),c6v(1))
      equivalence (jtab( 435),c2h(1)),(jtab( 456),c3h(1))
      equivalence (jtab( 485),c4h(1)),(jtab( 540),c5h(1))
      equivalence (jtab( 607),c6h(1)),(jtab( 712),d2h(1))
      equivalence (jtab( 785),d3h(1)),(jtab( 828),d4h(1))
      equivalence (jtab( 939),d5h(1)),(jtab(1012),d6h(1))
      equivalence (jtab(1169),d2d(1)),(jtab(1200),d3d(1))
      equivalence (jtab(1243),d4d(1)),(jtab(1300),d5d(1))
      equivalence (jtab(1373),d6d(1)),(jtab(1464),s4(1))
      equivalence (jtab(1480),s6(1)),(jtab(1509),s8(1))
      equivalence (jtab(1555),td(1)),(jtab(1586),oh(1))
      equivalence (jtab(1697),ih(1))
      equivalence (jtab(1808),cv(1)),(jtab(1818),dh(1))
      data j( 1),j( 2),j( 3),j( 4)/ 1010001, 2020004, 2020011, 2020018 /
      data j( 5),j( 6),j( 7),j( 8)/ 3020025, 4030034, 5030050, 6040069 /
      data j( 9),j(10),j(11),j(12)/ 7040098, 8050131, 4040177, 3030198 /
      data j(13),j(14),j(15),j(16)/ 5050211, 4040242, 6060263, 4040306 /
      data j(17),j(18),j(19),j(20)/ 3030327, 5050340, 4040371, 6060392 /
      data j(21),j(22),j(23),j(24)/ 4040435, 6040456, 8060485,10060540 /
      data j(25),j(26),j(27),j(28)/12080607, 8080712, 6060785,10100828 /
      data j(29),j(30),j(31),j(32)/ 8080939,12121012, 5051169, 6061200 /
      data j(33),j(34),j(35),j(36)/ 7071243, 8081300, 9091373, 4031464 /
      data j(37),j(38),j(39),j(40)/ 6041480, 8051509, 5051555,10101586 /
      data j(41),j(42),j(43)      /10101697, 2031808, 3061818          /
      data isigma / 1,1,1,2,3,4,5,6,7,8,4,6,8,10,12,2,3,4,5,6,2,3,4,5,6,
     .              4,6,8,10,12,4,6,8,10,12,2,3,4,12,24,60,1,2         /
      data c1
     ./                         2hc1,
     .4ha     ,                  0                                     /
      data cs
     ./                         2hcs,
     .4ha'    ,          8      ,      20104                           ,
     .4ha"    ,          1      ,       -1                             /
      data ci
     ./                         2hci,
     .4hag    ,         64      ,      10107                           ,
     .4hau    ,          1      ,       -1                             /
      data c2
     ./                         2hc2,
     .4ha     ,          4      ,    2140103                           ,
     .4hb     ,          1      ,       -1                             /
      data c3
     ./                         2hc3,
     .4ha     ,     128      , 3140108  , 3240122                      ,
     .4he     ,       2      ,   -1     ,    -1                        /
      data c4
     ./                         2hc4,
     .4ha     ,      260  ,4140109  ,2140103  ,4340123                 ,
     .4hb     ,      1    ,   -1    ,    1    ,   -1                   ,
     .4he     ,      2    ,    0    ,   -2    ,    0                   /
      data c5
     ./                         2hc5,
     .2ha  ,     512  , 5140110  ,      5240122   , 5340123    ,5440124,
     .2he1 ,     2    ,    51    ,    52     ,   52      ,  51         ,
     .2he2 ,     2    ,    52     ,   51     ,   51      ,  52         /
      data c6
     ./                         2hc6,
     .2ha  ,  1156  ,6140111  ,3140108  ,2140103  ,3240133  ,6540125   ,
     .2hb  ,   1    ,   -1    ,    1    ,   -1    ,    1    ,   -1     ,
     .2he1 ,   2    ,    1    ,   -1    ,   -2    ,   -1    ,    1     ,
     .2he2 ,   2    ,   -1    ,   -1    ,    2    ,   -1    ,   -1     /
      data c7
     ./                         2hc7,
     .2ha ,2048,7140112,7240122,7340123,7440124,7540125,7640126,
     .2he1 ,   2   ,  71   ,  72   ,  73    ,  73   ,  72   ,  71    ,
     .2he2 ,   2   ,  72   ,  73   ,  71    ,  71   ,  73   ,  72    ,
     .2he3 ,   2   ,  73   ,  71   ,  72    ,  72   ,  71   ,  73    /
      data c8
     ./                         2hc8,
     .2ha ,4356,8140113,4140109,2140103,4340134,8340123,8540124,8740125,
     .2hb  , 1  ,  -1  ,   1  ,   1  ,   1  ,  -1   ,  -1   ,  -1    ,
     .2he1 , 2  ,  81  ,   0  ,  -2  ,   0  ,  83   ,  83   ,  81    ,
     .2he2 , 2  ,   0  ,  -2  ,   2  ,  -2  ,   0   ,   0   ,   0    ,
     .2he3 , 2  ,  83  ,   0  ,  -2  ,   0  ,  81   ,  81   ,  83    /
      data d2
     ./                         2hd2,
     .4ha     ,      7    ,2140103  ,2140102  ,2140101                 ,
     .4hb1    ,      1    ,    1    ,   -1    ,   -1                   ,
     .4hb2    ,      1    ,   -1    ,    1    ,   -1                   ,
     .4hb3    ,      1    ,   -1    ,   -1    ,    1                   /
      data d3
     ./                         2hd3,
     .4ha1    ,      129    ,   3140208      , 2140301                 ,
     .4ha2    ,      1      ,       1        ,    -1                   ,
     .4he     ,      2      ,      -1        ,     0                   /
      data d4
     ./                         2hd4,
     .2ha1 ,     263  , 4140209  , 2140103   ,2140201    ,2140220      ,
     .2ha2 ,     1    ,     1    ,     1     ,   -1      ,  -1         ,
     .2hb1 ,     1    ,    -1    ,     1     ,    1      ,  -1         ,
     .2hb2 ,     1    ,    -1    ,     1     ,   -1      ,   1         ,
     .2he  ,     2    ,     0    ,    -2     ,    0      ,   0         /
      data d5
     ./                         2hd5,
     .4ha1    ,      513  ,5140210    ,5240222    ,  2140501           ,
     .4ha2    ,      1    ,    1      ,    1      ,     -1             ,
     .4he1    ,      2    ,   51      ,   52      ,      0             ,
     .4he2    ,      2    ,   52      ,   51      ,      0             /
      data d6
     ./                         2hd6,
     .2ha1 ,  1159  ,6140211  ,3140208  ,2140103  ,2140301  ,2140302   ,
     .2ha2 ,   1    ,    1    ,    1    ,    1    ,   -1    ,   -1     ,
     .2hb1 ,   1    ,   -1    ,    1    ,   -1    ,    1    ,   -1     ,
     .2hb2 ,   1    ,   -1    ,    1    ,   -1    ,   -1    ,    1     ,
     .2he1 ,   2    ,    1    ,   -1    ,   -2    ,    0    ,    0     ,
     .2he2 ,   2    ,   -1    ,   -1    ,    2    ,    0    ,    0     /
      data c2v
     ./                         3hc2v,
     .4ha1    ,     52    ,2140103  ,  20105  ,  20106                 ,
     .4ha2    ,      1    ,    1    ,   -1    ,   -1                   ,
     .4hb1    ,      1    ,   -1    ,    1    ,   -1                   ,
     .4hb2    ,      1    ,   -1    ,   -1    ,    1                   /
      data c3v
     ./                         3hc3v,
     .4ha1    ,      144     ,3140208   ,   20305                      ,
     .4ha2    ,       1      ,    1     ,    -1                        ,
     .4he     ,       2      ,   -1     ,     0                        /
      data c4v
     ./                         3hc4v,
     .2ha1 ,    308   ,4140209   ,2140103    , 20205     ,20224        ,
     .2ha2 ,     1    ,     1    ,     1     ,   -1      ,  -1         ,
     .2hb1 ,     1    ,    -1    ,     1     ,    1      ,  -1         ,
     .2hb2 ,     1    ,    -1    ,     1     ,   -1      ,   1         ,
     .2he  ,     2    ,     0    ,    -2     ,    0      ,   0         /
      data c5v
     ./                         3hc5v,
     .4ha1    ,     528     , 5140210     , 5240222     , 20505        ,
     .4ha2    ,      1      ,      1      ,      1      ,   -1         ,
     .4he1    ,      2      ,     51      ,     52      ,    0         ,
     .4he2    ,      2      ,     52      ,     51      ,    0         /
      data c6v
     ./                         3hc6v,
     .2ha1 , 1204   ,  6140211,  3140208,2140103  , 20305   ,  20306   ,
     .2ha2 ,   1    ,    1    ,    1    ,    1    ,   -1    ,   -1     ,
     .2hb1 ,   1    ,   -1    ,    1    ,   -1    ,    1    ,   -1     ,
     .2hb2 ,   1    ,   -1    ,    1    ,   -1    ,   -1    ,    1     ,
     .2he1 ,   2    ,    1    ,   -1    ,   -2    ,    0    ,    0     ,
     .2he2 ,   2    ,   -1    ,   -1    ,    2    ,    0    ,    0     /
      data c2h
     ./                         3hc2h,
     .4hag    ,     76    ,2140103  , 10107   , 20104                  ,
     .4hbg    ,      1    ,   -1    ,    1    ,   -1                   ,
     .4hau    ,      1    ,    1    ,   -1    ,   -1                   ,
     .4hbu    ,      1    ,   -1    ,   -1    ,    1                   /
      data c3h
     ./                         3hc3h,
     .2ha' ,  136   ,  3140108,  3240122,    20104,  3130124,3530143   ,
     .2he' ,   2    ,   -1    ,   -1    ,    2    ,   -1    ,   -1     ,
     .2ha" ,   1    ,    1    ,    1    ,   -1    ,   -1    ,   -1     ,
     .2he" ,   2    ,   -1    ,   -1    ,   -2    ,    1    ,    1     /
      data c4h
     ./                         3hc4h,
     .2hag,8524,4140109,2140103,4340123,10107,4330152,20104,4130114,
     .2hbg ,   1  ,  -1  ,   1  ,  -1  ,   1  ,  -1  ,   1  ,  -1      ,
     .2heg ,   2  ,   0  ,  -2  ,   0  ,   2  ,   0  ,  -2  ,   0      ,
     .2hau ,   1  ,   1  ,   1  ,   1  ,  -1  ,  -1  ,  -1  ,  -1      ,
     .2hbu ,   1  ,  -1  ,   1  ,  -1  ,  -1  ,   1  ,  -1  ,   1      ,
     .2heu ,   2  ,   0  ,  -2  ,   0  ,  -2  ,   0  ,   2  ,   0      /
      data c5h
     ./                         3hc5h,
     .2ha',520,5140110,5240122,5340123,5440124,20104,5130119,5730163,
     .                                               5330164,5930165,
     .3he1' ,  2  , 51  , 52  ,52  , 51  ,  2  , 51  , 52  , 52  , 51  ,
     .3he2' ,  2  , 52  , 51  ,51  , 52  ,  2  , 52  , 51  , 51  , 52  ,
     .2ha"  ,  1  ,  1  ,  1  , 1  ,  1  , -1  , -1  , -1  , -1  , -1  ,
     .3he1" ,  2  , 51  , 52  ,52  , 51  , -2  ,103  ,101  ,101  ,103  ,
     .3he2" ,  2  , 52  , 51  ,51  , 52  , -2  ,101  ,103  ,103  ,101  /
      data c6h
     ./                         3hc6h,
     .2hag,17612,6140111,3140108,2140103,3240133,6540125,10107,20104,
     .                                  3530127,6530137,6130115,3130183,
     .3hbg ,  1 , -1 ,  1 , -1 ,  1 , -1 ,  1 , -1 , -1 ,  1 ,  1 , -1 ,
     .3he1g,  2 ,  1 , -1 , -2 , -1 ,  1 ,  2 , -2 ,  1 , -1 , -1 ,  1 ,
     .3he2g,  2 , -1 , -1 ,  2 , -1 , -1 ,  2 ,  2 , -1 , -1 , -1 , -1 ,
     .3hau ,  1 ,  1 ,  1 ,  1 ,  1 ,  1 , -1 , -1 , -1 , -1 , -1 , -1 ,
     .3hbu ,  1 , -1 ,  1 , -1 ,  1 , -1 , -1 ,  1 ,  1 , -1 , -1 ,  1 ,
     .3he1u,  2 ,  1 , -1 , -2 , -1 ,  1 , -2 ,  2 , -1 ,  1 ,  1 , -1 ,
     .3he2u,  2 , -1 , -1 ,  2 , -1 , -1 , -2 , -2 ,  1 ,  1 ,  1 ,  1 /
      data d2h
     ./                         3hd2h,
     .2hag,     127,2140103,2140102,2140101,  10107,  20104,20105,20106,
     .3hb1g,   1   ,   1   ,  -1   ,  -1   ,   1   ,   1   ,  -1   , -1,
     .3hb2g,   1   ,  -1   ,   1   ,  -1   ,   1   ,  -1   ,   1   , -1,
     .3hb3g,   1   ,  -1   ,  -1   ,   1   ,   1   ,  -1   ,  -1   ,  1,
     .3hau ,   1   ,   1   ,   1   ,   1   ,  -1   ,  -1   ,  -1   , -1,
     .3hb1u,   1   ,   1   ,  -1   ,  -1   ,  -1   ,  -1   ,   1   ,  1,
     .3hb2u,   1   ,  -1   ,   1   ,  -1   ,  -1   ,   1   ,  -1   ,  1,
     .3hb3u,   1   ,  -1   ,  -1   ,   1   ,  -1   ,   1   ,   1   , -1/
      data d3h
     ./                         3hd3h,
     .3ha1',  153  ,3140208   ,2140301  , 20104  ,3130224   , 20305    ,
     .3ha2',   1    ,    1    ,   -1    ,    1    ,    1    ,   -1     ,
     .3he' ,   2    ,   -1    ,    0    ,    2    ,   -1    ,    0     ,
     .3ha1",   1    ,    1    ,    1    ,   -1    ,   -1    ,   -1     ,
     .3ha2",   1    ,    1    ,   -1    ,   -1    ,   -1    ,    1     ,
     .3he" ,   2    ,   -1    ,    0    ,   -2    ,    1    ,    0     /
      data d4h
     ./                         3hd4h,
     .3ha1g,8575,4140209,2140103,2140201,2140220,10107,4130214,20104,
     .                                                      20205,20229,
     .3ha2g ,  1 ,  1 ,  1 , -1 , -1 ,  1 ,  1 ,  1 , -1 , -1 ,
     .3hb1g ,  1 , -1 ,  1 ,  1 , -1 ,  1 , -1 ,  1 ,  1 , -1 ,
     .3hb2g ,  1 , -1 ,  1 , -1 ,  1 ,  1 , -1 ,  1 , -1 ,  1 ,
     .3heg  ,  2 ,  0 , -2 ,  0 ,  0 ,  2 ,  0 , -2 ,  0 ,  0 ,
     .3ha1u ,  1 ,  1 ,  1 ,  1 ,  1 , -1 , -1 , -1 , -1 , -1 ,
     .3ha2u ,  1 ,  1 ,  1 , -1 , -1 , -1 , -1 , -1 ,  1 ,  1 ,
     .3hb1u ,  1 , -1 ,  1 ,  1 , -1 , -1 ,  1 , -1 , -1 ,  1 ,
     .3hb2u ,  1 , -1 ,  1 , -1 ,  1 , -1 ,  1 , -1 ,  1 , -1 ,
     .3heu  ,  2 ,  0 , -2 ,  0 ,  0 , -2 ,  0 ,  2 ,  0 ,  0 /
      data d5h
     ./                         3hd5h,
     .3ha1',537, 5140210, 5240222,2140501,20104,5130219,  5330263,20505,
     .3ha2',  1  ,  1   ,    1   , -1  ,   1  ,   1    ,    1    , -1  ,
     .3he1',  2  , 51   ,   52   ,  0  ,   2  ,  51    ,   52    ,  0  ,
     .3he2',  2  , 52   ,   51   ,  0  ,   2  ,  52    ,   51    ,  0  ,
     .3ha1",  1  ,  1   ,    1   ,  1  ,  -1  ,  -1    ,   -1    , -1  ,
     .3ha2",  1  ,  1   ,    1   , -1  ,  -1  ,  -1    ,   -1    ,  1  ,
     .3he1",  2  , 51   ,   52   ,  0  ,  -2  , 103    ,  101    ,  0  ,
     .3he2",  2  , 52   ,   51   ,  0  ,  -2  , 101    ,  103    ,  0  /
      data d6h
     ./                         3hd6h,
     .3ha1g,17663,6140211,3140208,2140103,2140301,2140302,10107,20104,
     .                                      6130215,3130238,20306,20305,
     .3ha2g ,   1,  1,  1,  1, -1, -1,  1,  1,  1,  1, -1, -1,
     .3hb1g ,   1, -1,  1, -1,  1, -1,  1, -1,  1, -1,  1, -1,
     .3hb2g ,   1, -1,  1, -1, -1,  1,  1, -1,  1, -1, -1,  1,
     .3he1g ,   2,  1, -1, -2,  0,  0,  2, -2, -1,  1,  0,  0,
     .3he2g ,   2, -1, -1,  2,  0,  0,  2,  2, -1, -1,  0,  0,
     .3ha1u ,   1,  1,  1,  1,  1,  1, -1, -1, -1, -1, -1, -1,
     .3ha2u ,   1,  1,  1,  1, -1, -1, -1, -1, -1, -1,  1,  1,
     .3hb1u ,   1, -1,  1, -1,  1, -1, -1,  1, -1,  1, -1,  1,
     .3hb2u ,   1, -1,  1, -1, -1,  1, -1,  1, -1,  1,  1, -1,
     .3he1u ,   2,  1, -1, -2,  0,  0, -2,  2,  1, -1,  0,  0,
     .3he2u ,   2, -1, -1,  2,  0,  0, -2, -2,  1,  1,  0,  0/
      data d2d
     ./                         3hd2d,
     .2ha1 ,   8244   ,4130214   , 2140103   ,2140220    ,20205        ,
     .2ha2 ,     1    ,     1    ,     1     ,   -1      ,  -1         ,
     .2hb1 ,     1    ,    -1    ,     1     ,    1      ,  -1         ,
     .2hb2 ,     1    ,    -1    ,     1     ,   -1      ,   1         ,
     .2he  ,     2    ,     0    ,    -2     ,    0      ,   0         /
      data d3d
     ./                         3hd3d,
     .3ha1g,16594   ,3140208  ,2140302  , 10107   ,6130215  , 20305    ,
     .3ha2g,   1    ,    1    ,   -1    ,    1    ,    1    ,   -1     ,
     .3heg ,   2    ,   -1    ,    0    ,    2    ,   -1    ,    0     ,
     .3ha1u,   1    ,    1    ,    1    ,   -1    ,   -1    ,   -1     ,
     .3ha2u,   1    ,    1    ,   -1    ,   -1    ,   -1    ,    1     ,
     .3heu ,   2    ,   -1    ,    0    ,   -2    ,    1    ,    0     /
      data d4d
     ./                         3hd4d,
     .3ha1  ,33076,8130216    ,4140209, 8330223,2140103,20405,2140426,
     .3ha2  , 1 ,     1     ,  1 ,     1     ,  1 , -1 , -1 ,
     .3hb1  , 1 ,    -1     ,  1 ,    -1     ,  1 , -1 ,  1 ,
     .3hb2  , 1 ,    -1     ,  1 ,    -1     ,  1 ,  1 , -1 ,
     .3he1  , 2 ,    81     ,  0 ,    83     , -2 ,  0 ,  0 ,
     .3he2  , 2 ,     0     , -2 ,     0     ,  2 ,  0 ,  0 ,
     .3he3  , 2 ,    83     ,  0 ,    81     , -2 ,  0 ,  0 /
      data d5d
     ./                         3hd5d,
     .3ha1g,66130,5140210,5240222,2140502,10107,10130217,
     .                                                  10330226,20505,
     .3ha2g ,   1  ,   1  ,   1  ,  -1  ,   1  ,   1  ,   1  ,  -1  ,
     .3he1g ,   2  ,  51  ,  52  ,   0  ,   2  ,  52  ,  51  ,   0  ,
     .3he2g ,   2  ,  52  ,  51  ,   0  ,   2  ,  51  ,  52  ,   0  ,
     .3ha1u ,   1  ,   1  ,   1  ,   1  ,  -1  ,  -1  ,  -1  ,  -1  ,
     .3ha2u ,   1  ,   1  ,   1  ,  -1  ,  -1  ,  -1  ,  -1  ,   1  ,
     .3he1u ,   2  ,  51  ,  52  ,   0  ,  -2  , 101  , 103  ,   0  ,
     .3he2u ,   2  ,  52  ,  51  ,   0  ,  -2  , 103  , 101  ,   0  /
      data d6d
     ./                         3hd6d,
     .2ha1,140468,12130218,6140211,4130214,3140208,12530225,2140103,
     .                                                    20605,2140620,
     .3ha2  , 1 ,    1  , 1 , 1 , 1 ,   1  , 1 ,-1 ,-1 ,
     .3hb1  , 1 ,   -1  , 1 ,-1 , 1 ,  -1  , 1 ,-1 , 1 ,
     .3hb2  , 1 ,   -1  , 1 ,-1 , 1 ,  -1  , 1 , 1 ,-1 ,
     .3he1  , 2 ,  121  , 1 , 0 ,-1 , 125  ,-2 , 0 , 0 ,
     .3he2  , 2 ,    1  ,-1 ,-2 ,-1 ,   1  , 2 , 0 , 0 ,
     .3he3  , 2 ,    0  ,-2 , 0 , 2 ,   0  ,-2 , 0 , 0 ,
     .3he4  , 2 ,   -1  ,-1 , 2 ,-1 ,  -1  , 2 , 0 , 0 ,
     .3he5  , 2 ,  125  , 1 , 0 ,-1 , 121  ,-2 , 0 , 0 /
      data s4
     ./                         3hs4 ,
     .4ha     ,   8196    ,  4130114,   2140103,  4330123              ,
     .4hb     ,      1    ,   -1    ,    1    ,   -1                   ,
     .4he     ,      2    ,    0    ,   -2    ,    0                   /
      data s6
     ./                         3hs6 ,
     .3hag ,16576   ,3140108  ,3240122  , 10107 , 6530124 , 6130115    ,
     .3heg ,   2    ,   -1    ,   -1    ,    2    ,   -1    ,   -1     ,
     .3hau ,   1    ,    1    ,    1    ,   -1    ,   -1    ,   -1     ,
     .3heu ,   2    ,   -1    ,   -1    ,   -2    ,    1    ,    1     /
      data s8
     ./                         3hs8 ,
     .3ha  ,33028,8130116,4140109,8330123,2140103,8530125,4340135,
     .                                                          8730127,
     .3hb  , 1,    -1     , 1,    -1     , 1,    -1     , 1,    -1     ,
     .3he1 , 2,    81     , 0,    83     ,-2,    83     , 0,    81     ,
     .3he2 , 2,     0     ,-2,     0     , 2,     0     ,-2,     0     ,
     .3he3 , 2,    83     , 0,    81     ,-2,    81     , 0,    83     /
      data td
     ./                         3htd ,
     .2ha1 ,270516    ,   3140808,    2140303,    4130614, 20605       ,
     .2ha2 ,     1    ,     1    ,     1     ,   -1      ,  -1         ,
     .2he  ,     2    ,    -1    ,     2     ,    0      ,   0         ,
     .2ht1 ,     3    ,     0    ,    -1     ,    1      ,  -1         ,
     .2ht2 ,     3    ,     0    ,    -1     ,   -1      ,   1         /
      data oh
     ./                         3hoh ,
     .3ha1g,287231,3140808,2140601,4140609,2140303,10107,4130614,
     .                                              6130815,20304,20605,
     .3ha2g ,  1 ,  1 , -1 , -1 ,  1 ,  1 , -1 ,  1 ,  1 , -1 ,
     .3heg  ,  2 , -1 ,  0 ,  0 ,  2 ,  2 ,  0 , -1 ,  2 ,  0 ,
     .3ht1g ,  3 ,  0 , -1 ,  1 , -1 ,  3 ,  1 ,  0 , -1 , -1 ,
     .3ht2g ,  3 ,  0 ,  1 , -1 , -1 ,  3 , -1 ,  0 , -1 ,  1 ,
     .3ha1u ,  1 ,  1 ,  1 ,  1 ,  1 , -1 , -1 , -1 , -1 , -1 ,
     .3ha2u ,  1 ,  1 , -1 , -1 ,  1 , -1 ,  1 , -1 , -1 ,  1 ,
     .3heu  ,  2 , -1 ,  0 ,  0 ,  2 , -2 ,  0 ,  1 , -2 ,  0 ,
     .3ht1u ,  3 ,  0 , -1 ,  1 , -1 , -3 , -1 ,  0 ,  1 ,  1 ,
     .3ht2u ,  3 ,  0 ,  1 , -1 , -1 , -3 ,  1 ,  0 ,  1 , -1 /
      data ih
     ./                         3hih ,
     .3hag ,344786,5141210,5241222,3142008,2141502,10107,10131217,
     .                                       10331227,6132015,21505,
     .3ht1g,3,  101    ,  103    , 0,-1, 3,  103    ,  101    , 0 ,-1 ,
     .3ht2g,3,  103    ,  101    , 0,-1, 3,  101    ,  103    , 0 ,-1 ,
     .3hgg ,4,   -1    ,   -1    , 1, 0, 4,   -1    ,   -1    , 1 , 0 ,
     .3hhg ,5,    0    ,    0    ,-1, 1, 5,    0    ,    0    ,-1 , 1 ,
     .3hau ,1,    1    ,    1    , 1, 1,-1,   -1    ,   -1    ,-1 ,-1 ,
     .3ht1u,3,  101    ,  103    , 0,-1,-3,   51    ,   52    , 0 , 1 ,
     .3ht2u,3,  103    ,  101    , 0,-1,-3,   52    ,   51    , 0 , 1 ,
     .3hgu ,4,   -1    ,   -1    , 1, 0,-4,    1    ,    1    ,-1 , 0 ,
     .3hhu ,5,    0    ,    0    ,-1, 1,-5,    0    ,    0    , 1 ,-1 /
      data cv
     ./                         3hc*v,
     .3hsi  ,     524340           ,     4140109          ,
     .3hpi  ,         2            ,           0          ,
     .3hde  ,         2            ,          -2          /
      data dh
     ./                         3hd*h,
     .3hsig ,     524415       ,    4140109       ,      10107         ,
     .3hpig ,         2        ,         0        ,         2          ,
     .3hdeg ,         2        ,        -2        ,         2          ,
     .3hsiu ,         1        ,         1        ,        -1          ,
     .3hpiu ,         2        ,         0        ,        -2          ,
     .3hdeu ,         2        ,        -2        ,        -2          /
      sig=1.0d0
      i=igroup
      if(ncode.lt.0) goto 2
      igroup=0
      do 1 i=1,43
      icheck=j(i)/10000
      icheck=j(i)-10000*icheck+2
      icheck=jtab(icheck)
      if(icheck.eq.ncode) goto 2
 1    continue
      return
 2    igroup=i
      jgroup=j(igroup)
      j1=jgroup/1000000
      kdim=jgroup-1000000*j1
      i1=kdim/10000
      jgroup=kdim-10000*i1
      name=jtab(jgroup)
      sig=isigma(igroup)
      j2=0
      do 4 i=1,i1
      jgroup=jgroup+1
      jx(1,i)=jtab(jgroup)
      do 4 k=1,j1
      jgroup=jgroup+1
      buff=jtab(jgroup)
      if(i.gt.1) goto 3
      jx(2,k)=jtab(jgroup)/100
      jx(3,k)=jtab(jgroup)-100*jx(2,k)
      jx(4,k)=jx(2,k)/100
      jx(5,k)=jx(2,k)-100*jx(4,k)
      jx(2,k)=jx(5,k)
      jx(5,k)=jx(4,k)/10
      jx(4,k)=jx(4,k)-10*jx(5,k)
      jx(2,1)=1
      jx(3,1)=0
      j2=j2+jx(2,k)
      buff=1.0d0
 3    if(buff.lt.10.) goto 4
      nzz=jtab(jgroup)
      nz=nzz/10
      fz=nz
      fn=nzz-10*nz
      buff=2.0d0*dcos(6.283185307179d0*fn/fz)
 4    t(i,k)=buff
      lina=igroup-41
      return
      end
c
c================================================================
c
      subroutine r00009(nat,coord)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      parameter (mxdim=maxpar+numatm)
      common /s00001/         t(12,12),jx(7,12),lina,i1,j1,j2
      common /s00002/ numat,norbs,ncdim,iqual,ndorbs,ierror
      common /s00003/ ielem(20),elem(3,3,20),cub(3,3),jelem(20,numatm)
      common /s00004/ shift(3),r(3,3),vect(2,mxdim)
      dimension help(3,3),nat(numatm),coord(3,numatm)
      do 1 i=1,3
      do 1 j=1,numat
 1    coord(i,j)=coord(i,j)-shift(i)
      call r00005(coord,1)
      if(j1.lt.2) return
      do 5 i=2,j1
      jota=jx(3,i)
      jot=1
      if(jota.le.20) goto 2
      jotb=jota/10
      jot=jota-10*jotb
      jota=jx(3,jotb)
 2    call r00006(jota,i)
      if(jot.eq.1) goto 5
      do 3 j=1,3
      do 3 k=1,3
      help(j,k)=0.0d0
      do 3 l=1,3
 3    help(j,k)=help(j,k)+elem(j,l,jot)*elem(l,k,i)
      do 4 j=1,3
      do 4 k=1,3
 4    elem(j,k,i)=help(j,k)
 5    continue
      do 6 i=2,j1
      call r00007(nat,coord,i)
      jx(6,i)=iqual
      if(ielem(i).lt.1) ierror=5
 6    continue
      call r00005(coord,-1)
      do 7 i=1,3
      do 7 j=1,numat
 7    coord(i,j)=coord(i,j)+shift(i)
      return
      end
c
c===================================================================
c
      subroutine r00010(coeff,ntype,icount,ncdum)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      parameter (mxdim=maxpar+numatm)
      character*4  name,ifra,names, jx, namo, ista
      common /s00001/         t(12,12),jx(7,12),lina,i1,j1,j2
      common /s00002/ numat,norbs,ncdim,iqual,ndorbs,ierror
      common /s00003/ ielem(20),elem(3,3,20),cub(3,3),jelem(20,numatm)
      common /s00004/ shift(3),r(3,3),vect(2,mxdim)
      common/symres/trans,rtr,sig,name,namo(mxdim),index(mxdim),ista(2)
      dimension ntype(mxdim),coeff(ncdum,ncdum)
      dimension char(12),icount(12)
      data toler,ifra /  0.1d0, '????'/
c
      ndorbs=0
      do 1 i=1,i1
 1    icount(i)=0
      names=ifra
      if(j1.eq.1) names=jx(1,1)
      do 2 i=1,norbs
      index(i)=i
 2    namo(i)=names
      if(j1.eq.1) return
      if(ierror.gt.0) return
      ifound=0
      i=0
 3    ik=i+1
      do 4 j=1,j1
 4    char(j)=0.0d0
 5    i=i+1
      if(i.gt.norbs) goto 10
      do 6 j=1,j1
      char(j)=char(j)+r00011(coeff,ntype,i,j,ncdum)
      if(char(j).gt.10.) goto 3
 6    continue
      do 9 k=1,i1
      do 7 j=1,j1
      check=dabs(char(j)-t(k,j))
      if(check.gt.toler) goto 9
 7    continue
      icount(k)=icount(k)+1
      do 8 j=ik,i
      ifound=ifound+1
      index(j)=icount(k)
 8    namo(j)=jx(1,k)
      goto 3
 9    continue
      goto 5
 10   if(ifound.ne.norbs) ierror=99
      return
      end
c
c======================================================================
c
      function r00011(coeff,ntype,jorb,ioper,ncdum)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      parameter (mxdim=maxpar+numatm)
      common /s00002/ numat,norbs,ncdim,iqual,ndorbs,ierror
      common /s00003/ ielem(20),elem(3,3,20),cub(3,3),jelem(20,numatm)
      common /s00004/ shift(3),r(3,3),vect(2,mxdim)
      dimension ntype(mxdim),coeff(ncdum,ncdum),e(3,3,20)
      dimension h(5),p(3),d(5),ip(2,3),id(2,5),loc(2,50)
      equivalence (elem(1,1,1),e(1,1,1))
      r00011=1.d0
      if(ioper.eq.1) return
      do 1 i=1,norbs
      vect(1,i)=0.0d0
 1    vect(2,i)=0.0d0
      do 13 iatom=1,numat
      jatom=jelem(ioper,iatom)
      ki=0
      kj=0
      do 3 i=1,norbs
      icheck=ntype(i)/100
      if(icheck.ne.iatom) goto 2
      ki=ki+1
      loc(1,ki)=i
 2    if(icheck.ne.jatom) goto 3
      kj=kj+1
      loc(2,kj)=i
 3    continue
      ibase=ki
      do 4 i=1,ibase
      icheck=loc(1,i)
      itest=ntype(icheck)-10*(ntype(icheck)/10)
      if(itest.gt.0) goto 4
      jcheck=loc(2,i)
      loc(1,i)=0
      ki=ki-1
      vect(1,icheck)=coeff(icheck,jorb)
      vect(2,jcheck)=coeff(icheck,jorb)
 4    continue
      minus=100*iatom
 5    if(ki.lt.3) goto 13
      do 6 i=1,3
      ip(1,i)=0
 6    id(1,i)=0
      id(1,4)=0
      id(1,5)=0
      nqzp=-1
      nqzd=-1
      do 9 i=1,ibase
      if(loc(1,i).lt.1) goto 9
      icheck=loc(1,i)
      itest=ntype(icheck)
      inqz=(itest-minus)/10
      ilqz=itest-10*(itest/10)
      if(ilqz.gt.8) goto 8
      if(ilqz.gt.3) goto 7
      if(nqzp.lt.0) nqzp=inqz
      if(inqz.ne.nqzp) goto 9
      p(ilqz)=coeff(icheck,jorb)
      ip(1,ilqz)=loc(1,i)
      ip(2,ilqz)=loc(2,i)
      goto 8
 7    if(nqzd.lt.0) nqzd=inqz
      if(inqz.ne.nqzd) goto 9
      ilqz=ilqz-3
      d(ilqz)=coeff(icheck,jorb)
      id(1,ilqz)=loc(1,i)
      id(2,ilqz)=loc(2,i)
 8    loc(1,i)=0
      ki=ki-1
 9    continue
      if(nqzp.lt.0) goto 11
      h(1)=r(1,1)*p(1)+r(2,1)*p(2)+r(3,1)*p(3)
      h(2)=r(1,2)*p(1)+r(2,2)*p(2)+r(3,2)*p(3)
      h(3)=r(1,3)*p(1)+r(2,3)*p(2)+r(3,3)*p(3)
      p(1)=e(1,1,ioper)*h(1)+e(1,2,ioper)*h(2)+e(1,3,ioper)*h(3)
      p(2)=e(2,1,ioper)*h(1)+e(2,2,ioper)*h(2)+e(2,3,ioper)*h(3)
      p(3)=e(3,1,ioper)*h(1)+e(3,2,ioper)*h(2)+e(3,3,ioper)*h(3)
      do 10 i=1,3
      if(ip(1,i).lt.1) goto 16
      ii=ip(1,i)
      jj=ip(2,i)
      vect(1,ii)=h(i)
 10   vect(2,jj)=p(i)
 11   if(nqzd.lt.0) goto 5
      call r00012(d,h,ioper)
      do 12 i=1,5
      if(id(1,i).lt.1) goto 16
      ii=id(1,i)
      jj=id(2,i)
      vect(1,ii)=h(i)
 12   vect(2,jj)=d(i)
      ki=ki-5
      goto 5
 13   continue
      c1=0.0d0
      c2=0.0d0
      do 14 i=1,norbs
      c1=c1+vect(1,i)*vect(1,i)
 14   c2=c2+vect(1,i)*vect(2,i)
      if(dabs(c1).lt.1.d-5) goto 15
      r00011=c2/c1
      return
 15   r00011=100.d0
      return
 16   ierror=98
      return
      end
c
c=======================================================================
c
      subroutine r00012(d,h,ioper)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      parameter (mxdim=maxpar+numatm)
      common /s00001/         t(12,12),jx(7,12),lina,i1,j1,j2
      common /s00002/ numat,norbs,ncdim,iqual,ndorbs,ierror
      common /s00003/ ielem(20),elem(3,3,20),cub(3,3),jelem(20,numatm)
      common /s00004/ shift(3),r(3,3),vect(2,mxdim)
      dimension d(5),h(5),t1(5,5,12),s(3,3)
      if(ndorbs.gt.0) goto 4
      ndorbs=1
      do 1 i=1,3
      do 1 j=1,3
 1    s(i,j)=r(i,j)
      call r00013(s,t1,1)
      do 3 k=2,j1
      do 2 i=1,3
      do 2 j=1,3
 2    s(i,j)=elem(i,j,k)
      call r00013(s,t1,k)
 3    continue
 4    do 5 i=1,5
      h(i)=0.0d0
      do 5 j=1,5
 5    h(i)=h(i)+t1(i,j,1)*d(j)
      do 6 i=1,5
      d(i)=0.0d0
      do 6 j=1,5
 6    d(i)=d(i)+t1(i,j,ioper)*h(j)
      return
      end
c
c=================================================================
c
      subroutine r00013(r,t,ioper)
      implicit REAL (a-h,o-z)
      dimension r(3,3),t(5,5,12),f(2,4)
      logical right
      data pi,tol,s12 /3.14159265360d0,0.001d0,3.46410161513d0/
      data s3,one     / 1.73205080756d0, 1.d0/
      r1=r(2,1)*r(3,2)-r(3,1)*r(2,2)
      r2=r(3,1)*r(1,2)-r(1,1)*r(3,2)
      r3=r(1,1)*r(2,2)-r(2,1)*r(1,2)
      check=r1*r(1,3)+r2*r(2,3)+r3*r(3,3)
      right=check.gt.0.0d0
      r(1,3)=r1
      r(2,3)=r2
      r(3,3)=r3
      arg=r3
      if(dabs(arg).gt.one) arg=dsign(one,arg)
      b= dacos(arg)
      sina=dsqrt(1.d0-arg*arg)
      if(sina.lt.tol) goto 1
      arg=r(3,2)/sina
      if(dabs(arg).gt.one) arg=dsign(one,arg)
      g= dasin(arg)
      arg=r(2,3)/sina
      if(dabs(arg).gt.one) arg=dsign(one,arg)
      a= dasin(arg)
      goto 2
 1    arg=r(1,2)
      if(dabs(arg).gt.one) arg=dsign(one,arg)
      g= dasin(arg)
      a=0.d0
 2    f(1,1)=a
      f(1,2)=a
      f(1,3)=pi-a
      f(1,4)=pi-a
      f(2,1)=g
      f(2,3)=g
      f(2,2)=pi-g
      f(2,4)=pi-g
      do 3 i=1,4
      a=f(1,i)
      g=f(2,i)
      check=dabs(sin(b)*dcos(a)+r(1,3))
      if(check.gt.tol) goto 3
      check=-dsin(g)*dcos(b)*dsin(a)+dcos(g)*dcos(a)
      if(dabs(check-r(2,2)).gt.tol) goto 3
      check=dsin(a)*dcos(g)+dcos(a)*dcos(b)*dsin(g)
      if(dabs(check-r(1,2)).le.tol) goto 4
 3    continue
 4    g=-g
      a=-a
      b=-b
      e1=dcos(b*0.5d0)
      x1=-dsin(b*0.5d0)
      e2=e1*e1
      e3=e1*e2
      e4=e2*e2
      x2=x1*x1
      x3=x1*x2
      x4=x2*x2
      ta=2.0d0*a
      tg=2.0d0*g
      t(1,1,ioper)=e4*dcos(ta+tg)+x4*dcos(ta-tg)
      t(1,2,ioper)=2.d0*e3*x1*dcos(a+tg)-2.d0*e1*x3*dcos(a-tg)
      t(1,3,ioper)=2.d0*s3*e2*x2*dcos(tg)
      t(1,4,ioper)=2.d0*e3*x1*dsin(a+tg)-2.d0*e1*x3*dsin(a-tg)
      t(1,5,ioper)=e4*dsin(ta+tg)+x4*dsin(ta-tg)
      t(2,1,ioper)=2.d0*e1*x3*dcos(ta-g)-2.d0*e3*x1*dcos(ta+g)
      t(2,2,ioper)=(e4-3.0d0*e2*x2)*dcos(a+g)-(3.d0*e2*x2-x4)*dcos(a-g)
      t(2,3,ioper)=2.d0*s3*(e3*x1-e1*x3)*dcos(g)
      t(2,4,ioper)=(e4-3.0d0*e2*x2)*dsin(a+g)-(3.d0*e2*x2-x4)*dsin(a-g)
      t(2,5,ioper)=-2.d0*e3*x1*dsin(ta+g)+2.d0*e1*x3*dsin(ta-g)
      t(3,1,ioper)=s12*e2*x2*dcos(ta)
      t(3,2,ioper)=-s12*(e3*x1-e1*x3)*dcos(a)
      t(3,3,ioper)=e4-4.0d0*e2*x2+x4
      t(3,4,ioper)=-s12*(e3*x1-e1*x3)*dsin(a)
      t(3,5,ioper)=s12*e2*x2*dsin(ta)
      t(4,1,ioper)=2.d0*e1*x3*dsin(ta-g)+2.d0*e3*x1*dsin(ta+g)
      t(4,2,ioper)=-(e4-3.0d0*e2*x2)*dsin(a+g)-(3.d0*e2*x2-x4)*dsin(a-g)
      t(4,3,ioper)=-2.d0*s3*(e3*x1-e1*x3)*dsin(g)
      t(4,4,ioper)=(e4-3.0d0*e2*x2)*dcos(a+g)+(3.d0*e2*x2-x4)*dcos(a-g)
      t(4,5,ioper)=-2.d0*e3*x1*dcos(ta+g)-2.d0*e1*x3*dcos(ta-g)
      t(5,1,ioper)=-e4*dsin(ta+tg)+x4*dsin(ta-tg)
      t(5,2,ioper)=-2.d0*e3*x1*dsin(a+tg)-2.d0*e1*x3*dsin(a-tg)
      t(5,3,ioper)=-2.d0*s3*e2*x2*dsin(tg)
      t(5,4,ioper)=2.d0*e3*x1*dcos(a+tg)+2.d0*e1*x3*dcos(a-tg)
      t(5,5,ioper)=e4*dcos(ta+tg)-x4*dcos(ta-tg)
      if(right) return
      do 5 i=1,5
      t(2,i,ioper)=-t(2,i,ioper)
 5    t(4,i,ioper)=-t(4,i,ioper)
      return
      end
c
c======================================================================
c
      subroutine r00015(f,v,ew)
      implicit REAL (a-h,o-z)
      dimension f(6),a(3,3),v(3,3),ew(3)
      data toler /1.e-6 /
      n=3
      ij=0
      do 2 j=1,n
      do 1 i=1,j
      ij=ij+1
      a(i,j)=f(ij)
      a(j,i)=f(ij)
      v(i,j)=0.d0
 1    v(j,i)=0.d0
 2    v(j,j)=1.d0
      n1=n-1
      zeta=10.0d0
 3    ss=0.0d0
      do 4 j=1,n1
      do 4 i=j,n1
      irg=i+1
 4    ss=ss+dabs(a(irg,j))
      if(ss-toler) 21,21,5
 5    tau=0.0d0
      do 20 i=1,n
      i1=i+1
      if(n-i1) 20,6,6
 6    do 19 j=i1,n
      if(dabs(a(j,i)).lt.1.d-30) goto 19
      theta=0.5d0*(a(j,j)-a(i,i))/a(j,i)
      if(dabs(theta)-zeta) 7,7,19
 7    t=1.d0
      if(theta) 8,9,9
 8    t=-1.d0
 9    t=1.d0/(theta+t*dsqrt(1.d0+theta*theta))
      c=1.d0/dsqrt(1.0d0+t*t)
      s=c*t
      h=2.d0*a(j,i)
      hc=s*h*(s*theta-c)
      a(i,i)=a(i,i)+hc
      a(j,j)=a(j,j)-hc
      a(j,i)=-h*c*(s*theta-0.5d0*(c-s*s/c))
      tau=tau+1.0d0
      if(i.lt.2) goto 11
      do 10 ig=2,i
      irs=ig-1
      h=c*a(i,irs)-s*a(j,irs)
      a(j,irs)=s*a(i,irs)+c*a(j,irs)
 10   a(i,irs)=h
 11   l=j-1
      if(l-i1) 14,12,12
 12   do 13 ig=i1,l
      h=c*a(ig,i)-s*a(j,ig)
      a(j,ig)=s*a(ig,i)+c*a(j,ig)
 13   a(ig,i)=h
 14   if(n1-j) 17,15,15
 15   do 16 ig=j,n1
      ilg=ig+1
      h=c*a(ilg,i)-s*a(ilg,j)
      a(ilg,j)=s*a(ilg,i)+c*a(ilg,j)
 16   a(ilg,i)=h
 17   do 18 ig=1,n
      h=c*v(ig,i)-s*v(ig,j)
      v(ig,j)=s*v(ig,i)+c*v(ig,j)
 18   v(ig,i)=h
 19   continue
 20   continue
      h=0.5d0*dfloat(n*(n-1))
      zeta=zeta**(2.5d0-tau/h)
      goto 3
 21   do 22 j=1,n
 22   ew(j)=a(j,j)
      n1=n-1
 23   nt=0
      do 26 j=1,n1
      jrg=j+1
      if(ew(j)-ew(jrg)) 26,26,24
 24   buffer=ew(j)
      ew(j)=ew(jrg)
      ew(jrg)=buffer
      do 25 i=1,n
      buffer=v(i,jrg)
      v(i,jrg)=v(i,j)
 25   v(i,j)=buffer
      nt=1
 26   continue
      n1=n1-1
      if(nt) 23,27,23
 27   return
      end
c
c===================================================================
c
      subroutine r00016
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      parameter (mxdim=maxpar+numatm)
      character*4 name,namo,ista
      common /s00001/         t(12,12),jx(7,12),lina,i1,j1,j2
      common /s00002/ numat,norbs,ncdim,iqual,ndorbs,ierror
      common /syminf/ ibase(2,12),nbase,ivibro(2,12),ivib
      common/symres/trans,rtr,sig,name,namo(mxdim),index(mxdim),ista(2)
      dimension char(12),coeff(12)
      ivibra=3*numat-6
      if(lina.gt.0) goto 8
      char(1)=ivibra
      ivib=0
      if(j1.lt.2) return
      do 5 i=2,j1
      jump=jx(4,i)
      goto (1,2,3,4),jump
 1    char(i)=-3*jx(6,i)
      goto 5
 2    char(i)=jx(6,i)
      goto 5
 3    jp=jx(5,i)/10
      jk=jx(5,i)-10*jp
      angle=2.0d0*dcos(6.283185308d0*dfloat(jk)/dfloat(jp))
      char(i)=dfloat(jx(6,i))*(angle-1.0d0)
      goto 5
 4    jp=jx(5,i)/10
      jk=jx(5,i)-10*jp
      angle=2.d0*dcos(6.283185308d0*dfloat(jk)/dfloat(jp))
      char(i)=dfloat(jx(6,i)-2)*(angle+1.0d0)
 5    char(i)=char(i)*dfloat(jx(2,i))
      order=dfloat(j2)
      do 7 i=1,i1
      coeff(i)=0.1d0
      do 6 j=1,j1
 6    coeff(i)=coeff(i)+char(j)*t(i,j)/order
      if(coeff(i).lt.1.) goto 7
      idegen=     t(i,1)+0.1d0
      ivib=ivib+1
      ivibro(1,ivib)=  coeff(i)
      if(i1.ne.j1) ivibro(1,ivib)= coeff(i) /idegen
      ivibro(2,ivib)=jx(1,i)
 7    continue
      return
 8    ivibra=ivibra+1
      goto(9,10),lina
 9    ivibro(1,1)=numat-1
      ivibro(2,1)=jx(1,1)
      ivibro(1,2)=numat-2
      ivibro(2,2)=jx(1,2)
      ivib=2
      if(numat.lt.3) ivib=1
      return
 10   icent=jx(6,3)
      ivibro(1,1)=(numat-icent)/2
      ivibro(2,1)=jx(1,1)
      ivib=2
      ivibro(1,2)=(numat-2-icent)/2
      ivibro(2,2)=jx(1,2)
      if(ivibro(1,2).gt.0) ivib=3
      ivibro(1,ivib)=(numat-2+icent)/2
      ivibro(2,ivib)=jx(1,4)
      if(ivibro(1,ivib).gt.0) ivib=ivib+1
      ivibro(1,ivib)=(numat-2+icent)/2
      ivibro(2,ivib)=jx(1,5)
      if(ivibro(1,ivib).lt.1) ivib=ivib-1
      return
      end
c
c=======================================================================
c
      subroutine worder(cc,lm7,iout2)
*********************************************************
*                                                       *
*     ordering of ao repulsion integrals.               *
*     subroutine need for green function calculation    *
*********************************************************
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      common/twoele/gss(107),gsp(107),gpp(107),gp2(107),hsp(107),
     1 gsd(107),gpd(107),gdd(107)
      common/molkst/numat,nat(numatm),nfirst(numatm),nmidle(numatm),
     1nlast(numatm),norbs,nelecs,nalpha,nbeta,nclose,nopen,ndumy,
     2 fract
      common/wmatrc/w(n2elec),wk(n2elec)
c     common /chanel/ ifiles(30)
c     equivalence(iw,ifiles(6))
      common /iofile/ mfgr,iw
      dimension cc(*)
      dimension indx(numatm),indy(numatm)
      data zero/0.0d0/
      kk=1
      do 10 i=1,numat
         indx(i)=kk
         kk=kk+1
         if(nat(i).gt.2) kk=kk+9
         indy(i)=kk-1
   10 continue
c     storage control.
      kmax=kk-1
      lmax=lm7/kmax
      ktot=kmax*kmax
      if(kmax.gt.lmax) ktot=kmax*lmax
c     sorting of integrals for mndo
c     number of records.
      lrec=1+(kmax-1)/lmax
      do 190 l=1,lrec
         la=lmax*(l-1)+1
         lb=lmax*l
         kp=kmax*(la-1)
c     initialize integrals.
         do 20 kk=1,ktot
   20    cc(kk)=zero
c     loop over one-center integrals.
         do 90 ii=1,numat
            ia=indx(ii)
            if(ia.gt.lb) go to 100
            ib=indy(ii)
            if(ib.lt.la) go to 90
            ni=nat(ii)
            if(ni.gt.2) go to 30
c     hydrogen.
            kk=kmax*(ia-1)+ia-kp
            cc(kk)=gss(ni)
            go to 90
c     heavy atom.
   30       do 80 i=ia,ib
               if(i.lt.la.or.i.gt.lb) go to 80
               ks =kmax*(i-1)+ia-1-kp
               kgo=i-ia+1
               kk =ks+kgo
               go to (40,50,60,50,70,60,50,70,70,60),kgo
   40          cc(kk   )=gss(ni)
               cc(ks+3 )=gsp(ni)
               cc(ks+6 )=gsp(ni)
               cc(ks+10)=gsp(ni)
               go to 80
   50          cc(kk   )=hsp(ni)
               go to 80
   60          cc(ks+1 )=gsp(ni)
               cc(ks+3 )=gp2(ni)
               cc(ks+6 )=gp2(ni)
               cc(ks+10)=gp2(ni)
               cc(kk   )=gpp(ni)
               go to 80
   70          cc(kk   )=0.5d0*(gpp(ni)-gp2(ni))
   80       continue
   90    continue
c     loop over two-center integrals, mndo.
  100    if(numat.eq.1) go to 180
         na=0
         do 170 ii=2,numat
            ia=indx(ii)
            ib=indy(ii)
            iw1=ib-ia+1
            iminus=ii-1
            do 170 jj=1,iminus
               ja=indx(jj)
               jb=indy(jj)
               jw=jb-ja+1
               no=iw1*jw
c     case ii.gt.jj.
               if(ia.gt.lb.or.ib.lt.la) go to 130
               do 120 i=ia,ib
                  if(i.lt.la.or.i.gt.lb) go to 120
                  ks=kmax*(i-1)+ja-1-kp
                  ns=na+jw*(i-ia)
                  do 110 j=1,jw
                     kk=ks+j
                     nn=ns+j
  110             cc(kk)=w(nn)
  120          continue
c     case ii.lt.jj.
  130          if(ja.gt.lb.or.jb.lt.la) go to 160
               do 150 j=ja,jb
                  if(j.lt.la.or.j.gt.lb) go to 150
                  ks=kmax*(j-1)+ia-1-kp
                  ns=na+j-ja+1-jw
                  do 140 i=1,iw1
                     kk=ks+i
                     nn=ns+jw*i
  140             cc(kk)=w(nn)
  150          continue
  160          na=na+no
  170    continue
  180    continue
  190 continue
c     debug print.
      if(iout2.lt.1) return
      write(iw,220)
      write(iw,230) kmax
      if(lrec.gt.1) write(iw,240) lrec,lmax,ktot
      if(iout2.lt.4) return
      imax=kmax
      if(lrec.eq.1) go to 200
      imax=lmax
  200 write(iw,250)
      kk=1
      do 210 i=1,imax
         ka=kk
         kb=ka+kmax-1
         write(iw,260) (cc(k),k=ka,kb)
  210 kk=ka+kmax
      return
  220 format(1h1,//1x,'ao integrals in new order.'/)
  230 format(//1x,'the ao integrals are stored in a matrix with',i4,
     1  ' rows and columns.')
  240 format(  1x,'there are',i4,' records each of which contains',i4/2x
     1  ,' columns and',i6,' integrals.')
  250 format(//1x,'integrals in the first record.'/)
  260 format(  1x,10f7.3)
      end
c
c=======================================================================
c
      subroutine wwstep(c12,cc,ww,lm7,kmax,lmax)
*********************************************************
*                                                       *
*     calculation of a set of (ij,ab) integrals.        *
*     subroutine need for green function calculation    *
*********************************************************
      implicit REAL (a-h,o-z)
      dimension c12(*),cc(*),ww(*)
      if(kmax.gt.lmax) go to 20
c     ao integrals in cc(lm7).
      kk=1-kmax
      do 10 nn=1,kmax
         kk=kk+kmax
   10 ww(nn) = sisms(c12,cc(kk),kmax)
      return
   20 continue
      kk=1-kmax
      ll=0
      do 40 nn=1,kmax
         ll=ll+1
         if(ll.le.lmax) go to 30
         kk=1-kmax
         ll=1
   30    kk=kk+kmax
   40 ww(nn) = sisms(c12,cc(kk),kmax)
      return
      end
      subroutine addfck (f,p,numat,nat,nfirst,nlast)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      dimension nat(*),nfirst(*), nlast(*)
      common /solv/ fepsi,rds,disex2,nspa,nps,nps2,nden,
     1              cosurf(3,lenabc), srad(numatm),abcmat(lenab2),
     2              tm(3,3,numatm),qden(maxden),dirtm(3,nppa),
     3              bh(lenabc)
      common /solvi/ iatsp(lenabc+1),nar(lenabc)
      common /dirvec/ dirvec(3,nppa), nn(3,numatm)
c      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),
c     1                nlast(numatm), norbs, nelecs,nalpha,nbeta,
c     2                nclose,nopen,ndumy,fract
      dimension f(*),p(*)
      i0=nps2+nden*nps
      iden=0
      do 60 i=1,numat
         ia=nfirst(i)
         idel=nlast(i)-ia
         im=(ia*(ia+1))/2-1
         do 50 ic=0,idel
            do 40 id=0,ic
               im=im+1
               iden=iden+1
               fim=0.d0
               jden=0
               do 30 j=1,numat
                  ja=nfirst(j)
                  jdel=nlast(j)-ja
                  jm=(ja*(ja+1))/2-1
                  do 20 jc=0,jdel
                     do 10 jd=0,jc
                        jm=jm+1
                        jden=jden+1
                        kden=max(iden,jden)
                        i1=(kden*(kden-3))/2+iden+jden+i0
                        fim = fim + abcmat(i1) * p(jm)
   10                continue
                     jm=jm+ja-1
   20             continue
   30          continue
               f(im)=f(im)+2*fim
   40       continue
            f(im)=f(im)+2*fim
            im=im+ia-1
   50    continue
   60 continue
      return
      end
      subroutine addhcr (h)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      common /solv/ fepsi,rds,disex2,nspa,nps,nps2,nden,
     1              cosurf(3,lenabc), srad(numatm),abcmat(lenab2),
     2              tm(3,3,numatm),qden(maxden),dirtm(3,nppa),
     3              bh(lenabc)
      common /solvi/ iatsp(lenabc+1),nar(lenabc)
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),
     1                nlast(numatm), norbs, nelecs,nalpha,nbeta,
     2                nclose,nopen,ndumy,fract
      common /corec/ core(107)
      dimension h(*)
      iden=0
      i0=nps2+nden*nps
      do 40 i=1,numat
         ia=nfirst(i)
         idel=nlast(i)-ia
         im=(ia*(ia+1))/2-1
         do 30 ic=0,idel
            do 20 id=0,ic
               im=im+1
               iden=iden+1
               him=0.d0
               jden=1
               do 10 j=1,numat
                  ja=nfirst(j)
                  jdel=nlast(j)-ja
c#              jden=jden+1
                  kden=max(iden,jden)
                  i1=(kden*(kden-3))/2+iden+jden+i0
                  him = him - abcmat(i1) * core(nat(j))
                  jden=jden+jdel**2+1
   10          continue
               h(im) = h(im) + him
   20       continue
            h(im) = h(im) + him
            im=im+ia-1
   30    continue
   40 continue
      return
      end
      subroutine addnuc (enuclr)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      common /solv/ fepsi,rds,disex2,nspa,nps,nps2,nden,
     1              cosurf(3,lenabc), srad(numatm),abcmat(lenab2),
     2              tm(3,3,numatm),qden(maxden),dirtm(3,nppa),
     3              bh(lenabc)
      common /solvi/ iatsp(lenabc+1),nar(lenabc)
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),
     1                nlast(numatm), norbs, nelecs,nalpha,nbeta,
     2                nclose,nopen,ndumy,fract
      common /corec/ core(107)
      enclr=0.d0
      i0=nps2+nden*nps
      iden=0
      do 20 i=1,numat
         ia=nfirst(i)
         idel=nlast(i)-ia
         i1=i0+(iden*(iden+1))/2
         corei = core(nat(i))
         do 10 j=1,i-1
            ja=nfirst(j)
            jdel=nlast(j)-ja
            i1=i1+1
            enclr = enclr + 2 * corei * abcmat(i1) * core(nat(j))
            i1=i1+jdel**2
   10    continue
         i1=i1+1
         enclr = enclr + corei * abcmat(i1) * corei
         iden=iden+1+idel**2
   20 continue
      enuclr = enuclr+enclr
      return
      end
      subroutine alphaf (iwfla,atol,maxita,u,f,g,uold,h1,d,da)
c
c  subroutine for the calculation of the frequency dependent first-order
c  responce matricies ua and densities da.
c  used to compute the frequency dependent polarizability and for
c  solving the second-order problem.
c
      implicit REAL (a-h,o-z)
      logical last
INCLUDE(common/sizes)
c
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),
     1                nlast(numatm),norbs,nelecs,nalpha,nbeta,
     2                nclose,nopen,ndumy,fract
      common /vector/ c(morb2),eigs(maxorb),ca(morb2),dumy(maxorb)
      common /wmatrc/ w(n2elec*2)
      common /cmpg/ geo(3,numatm), coord(3,numatm)
      common /omval/ omega
      common /keywrd/ keywrd
      character*241 keywrd
c     common /chanel/ ifiles(30)
c     equivalence(iw,ifiles(6))
      common /iofile/ mfgr,iw
c
      dimension u(maxorb,maxorb), f(maxorb,maxorb), g(maxorb,maxorb)
      dimension uold(maxorb,maxorb), h1(maxorb,maxorb),
     1          d(maxorb,maxorb),da(maxorb,maxorb), allalp(3,3)
      character*1 alab
      dimension alab(3)
      save alab
      data alab/'x','y','z'/
c
      nsqr = norbs*norbs
      alpavg = 0.0d00
c compute offsets for u and g matrices
      iposu = 1 + 6*iwfla
      iposg = 4 + 6*iwfla
      write(iw,10) omega
   10 format (/,' +++++ alpha at ',1f13.5,' ev.')
c
c  choose a  component
c  x: id=1   y: id=2   z: id=3
c
      do 70 id = 1,3
         cmptim = secmop()
         last = .false.
c
c  calculate the dipole matrix.
c
         call hmuf (h1,id,coord,nfirst,nlast,nat,norbs,numat)
         call copym (h1,f,norbs)
c
c  initialize uold to zero
c
         call zerom (uold,norbs)
c.................................................................
c  loop starts here
c.................................................................
         icount = 0
         alpold = 0.0d00
   20    continue
         icount = icount + 1
         if (icount.gt.maxita) last = .true.
c
c  create g matrix.
c
         call tranfgc(f,g,c,norbs)
c
c  form u matrix
c
         call makeuf (u,uold,g,eigs,last,norbs,nnorb,nclose,diff,atol)
c
c  form new density matrix
c
         call densf (u,c,ca,d,da,norbs,nclose)
c
c compute test alpha to be used for a convergence test
c
         alphaw = aval(h1,d,norbs)
         dela = dabs(alpold-alphaw)
         alpold = alphaw
c.      write(iw,1500) alphaw
c. 1500 format ('  test alpha = ',d12.5)
c
c  create new fock matrix
c
         call zerom (f,norbs)
         call ffreq2 (f,d,w,numat,nfirst,nlast,norbs)
         call ffreq1 (f,d,da,da,norbs)
         call hplusf (f,h1,norbs)
c..............................................................
         if (.not.last) go to 20
         cmptim = secmop() - cmptim
         write(iw,30) icount,cmptim,diff,dela
   30    format (/' converged in',i4,' iterations in',f10.2,' seconds',
     1         /'           density converg. to ',1pd12.5,
     2         /'             alpha converg. to ',1pd12.5,/)
c
c compute alpha
c
         alphaw = aval(h1,d,norbs)
         allalp(id,id)=alphaw
         write(iw,40) alab(id),alab(id),alphaw
   40    format ('      alpha(',a1,',',a1,') = ',1pd14.7)
         alpavg = alpavg + alphaw
c
c  write out u and g for future use
c
         call dawrit_mop (u,nsqr,iposu+id)
         call dawrit_mop (g,nsqr,iposg+id)
c
c  compute other components
c
         do 60 ic = 1,3
            if (ic.ne.id) then
               call hmuf (h1,ic,coord,nfirst,nlast,nat,norbs,numat)
               alphaw = aval(h1,d,norbs)
               allalp(ic,id)=alphaw
               write(iw,50) alab(ic),alab(id),alphaw
   50          format ('      alpha(',a1,',',a1,') = ',1pd14.7)
            endif
   60    continue
   70 continue
      alpavg = alpavg/3.0d00
      write(iw,80) alpavg
   80 format (/,'  isotropic average alpha = ',1f13.5,' a.u.')
c
      return
      end
      function anorm_mop(a)
      implicit REAL (a-h,o-z)
      dimension a(3)
      anorm_mop = dsqrt(a(1)**2 + a(2)**2 + a(3)**2)
      return
      end
      function aval (h,d,norbs)
      implicit REAL (a-h,o-z)
c.................................................................
c  compute polarizability as trace of h*d
c.................................................................
      dimension h(norbs,norbs),d(norbs,norbs)
      sum = 0.0d00
      do 20 i = 1,norbs
         do 10 j = 1,norbs
            sum = sum + h(i,j)*d(j,i)
   10    continue
   20 continue
      aval = -sum
      return
      end
      subroutine bdensf (ua,ub,uab,c,d,da,norbs,nclose,iwflb)
      implicit REAL (a-h,o-z)
c     common /chanel/ ifiles(30)
c     equivalence(iw,ifiles(6))
      common /iofile/ mfgr,iw
c
c  this subroutine is used to compute the first-order density
c
      dimension c(norbs,norbs),d(norbs,norbs),ua(norbs,norbs),
     1       ub(norbs,norbs),da(norbs,norbs),uab(norbs,norbs)
c
c form density matrix
c
c
      call zerom(d,norbs)
c
c calculate
c
      do 100 i = 1,norbs
         do 90 j = 1,norbs
            s1 = 0.0d00
            s2 = 0.0d00
            s3 = 0.0d00
            s4 = 0.0d00
            do 20 k = 1,norbs
               do 10 l = 1,nclose
                  s1 = s1+c(i,k)*uab(k,l)*c(j,l)
                  s2 = s2+c(i,l)*uab(l,k)*c(j,k)
   10          continue
   20       continue
c
            do 50 k = 1,nclose
               do 40 l= nclose+1,norbs
                  do 30 m = 1,nclose
                     s3 = s3+c(i,k)*(ua(k,l)*ub(l,m)+ub(k,l)*ua(l,m))*
     1c(j,m)
   30             continue
   40          continue
   50       continue
c
            do 80 k = nclose+1,norbs
               do 70 l = 1,nclose
                  do 60 m = nclose+1, norbs
                     s4 = s4+c(i,k)*(ua(k,l)*ub(l,m)+ub(k,l)*ua(l,m))*
     1c(j,m)
   60             continue
   70          continue
   80       continue
            d(i,j) =  2.0d00*(s1-s2+s3-s4)
   90    continue
  100 continue
c      write(iw,*) 'initial density matrix final form'
c      call matout(d,eigs,norbs,norbs,norbs)
c
c create da
c
      do 120 i = 1,norbs
         do 110 j = 1,norbs
            da(i,j) = d(i,j)/2.0d00
  110    continue
  120 continue
c
      return
      end
      function collid1(cw,rw,cnbr,rnbr,
     +        mnbr,nnbr,ishape,jnbr,knbr)
      implicit REAL (a-h,o-z)
      logical collid1
c
c     ----- collision check of probe with neighboring atoms ---
c
      dimension cw(3)
      dimension cnbr(3,200)
      dimension rnbr(200)
      logical mnbr(200)
      if (nnbr .le. 0) go to 20
c
c     ---- check whether probe is too close to any neighbor ----
c
      do 10 i = 1, nnbr
         if (ishape .gt. 1 .and. i .eq. jnbr) go to 10
         if (ishape .eq. 3 .and. (i .eq. knbr .or. .not. mnbr(i)))
     1go to 10
         sumrad = rw + rnbr(i)
         vect1 = dabs(cw(1) - cnbr(1,i))
         if (vect1 .ge. sumrad) go to 10
         vect2 = dabs(cw(2) - cnbr(2,i))
         if (vect2 .ge. sumrad) go to 10
         vect3 = dabs(cw(3) - cnbr(3,i))
         if (vect3 .ge. sumrad) go to 10
         sr2 = sumrad ** 2
         dd2 = vect1 ** 2 + vect2 ** 2 + vect3 ** 2
         if (dd2 .lt. sr2) go to 30
   10 continue
   20 continue
      collid1 = .false.
      go to 40
   30 continue
      collid1 = .true.
   40 continue
      return
      end
c****************************************************************
      function collids(cw,rw,cnbr,rnbr,mnbr,nnbr,
     +        ishape,jnbr,knbr)
c****************************************************************
c     collision check of probe with neighboring atoms
c     for connolly surface only.
c****************************************************************
      implicit REAL (a-h,o-z)
      logical collids
      dimension cw(3), cnbr(3,200), rnbr(200)
      logical mnbr(200)
c
      collids = .false.
      if (nnbr .le. 0) return
c                 check whether probe is too close to any neighbor
      do 10 i = 1, nnbr
         if (ishape .gt. 1 .and. i .eq. jnbr) go to 10
         if (ishape .eq. 3 .and. (i .eq. knbr .or. .not. mnbr(i)))
     1   go to 10
         sumrad = rw + rnbr(i)
         vect1 = dabs(cw(1) - cnbr(1,i))
         if (vect1 .ge. sumrad) go to 10
         vect2 = dabs(cw(2) - cnbr(2,i))
         if (vect2 .ge. sumrad) go to 10
         vect3 = dabs(cw(3) - cnbr(3,i))
         if (vect3 .ge. sumrad) go to 10
         sr2 = sumrad ** 2
         dd2 = vect1 ** 2 + vect2 ** 2 + vect3 ** 2
         if (dd2 .lt. sr2) go to 30
   10 continue
      return
   30 collids = .true.
      return
      end
      subroutine densf(u,c,ca,d,da,norbs,nclose)
      implicit REAL (a-h,o-z)
c
c  this subroutine is used to compute the first-order density
c  from ca = c*u
c
      dimension c(norbs,norbs),ca(norbs,norbs),d(norbs,norbs)
      dimension u(norbs,norbs),da(norbs,norbs)
c
c  form density matrix      ca*n*c+ + c*n*ca+
c
      do 40 i = 1,norbs
         do 30 j = 1,norbs
            sum = 0.0d00
            do 20 k = 1,norbs
               sk1 = 0.0d00
               sk2 = 0.0d00
               do 10 l = 1,nclose
                  sk1 = sk1 + u(k,l)*c(j,l)
                  sk2 = sk2 + c(i,l)*u(l,k)
   10          continue
               sum = sum + c(i,k)*sk1 - sk2*c(j,k)
   20       continue
            d(i,j) = 2.0d00*sum
            da(i,j) = sum
   30    continue
   40 continue
c
      return
      end
      subroutine beopor(iwflb,maxitu,btol,ua,ub,f,ga,gb,t,h1,
     1                   d,da,uab,uold1,g,x)
c
c this subroutine calculates iterative beta values for
c the electrooptic pockels effect and optical rectification
c
      implicit REAL (a-h,o-z)
      REAL maxu
      logical last
INCLUDE(common/sizes)
c
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),
     1                nlast(numatm),norbs,nelecs,nalpha,nbeta,
     2                nclose,nopen,ndumy,fract
      common /vector/ c(morb2),eigs(maxorb),ca(morb2),dumy(maxorb)
      common /wmatrc/ w(n2elec*2)
      common /coord/ geo(3,numatm), coord(3,numatm)
      common /omval/ omega
c     common /chanel/ ifiles(30)
c     equivalence(iw,ifiles(6))
      common /iofile/ mfgr,iw
c
      dimension ua(maxorb,maxorb),ub(maxorb,maxorb),f(maxorb,maxorb),
     1          ga(maxorb,maxorb),gb(maxorb,maxorb),
     2          t(maxorb,maxorb), h1(maxorb,maxorb),
     3          d(maxorb,maxorb),da(maxorb,maxorb),
     4          uab(maxorb,maxorb),uold1(maxorb,maxorb),
     5          g(maxorb,maxorb),x(maxorb,maxorb)
      character*1 alab
      dimension alab(3),ida(9),idb(9)
      save alab, ida, idb
      data alab/'x','y','z'/
      data ida /1,1,1,2,2,2,3,3,3/
      data idb /1,2,3,1,2,3,1,2,3/
      one=1.0d00
      betold = 0.0d00
      maxsq = norbs*norbs
      if (iwflb .eq. 2) then
         iposu = 73
      else
         iposu = 109
      endif
      iposg = iposu + 9
      ipose = iposg + 9
      iposum = ipose + 9
      if (iwflb .eq. 0) then
         write(iw,10) omega
   10    format(/,' +++++ beta (static) at ',1f15.5 ,' ev.'/)
      elseif (iwflb .eq. 2) then
         write(iw,20) omega
   20    format(/,' +++++ beta',
     1          ' (electrooptic pockels effect) at ',1f15.5 ,' ev.'/)
      else
         write(iw,30) omega
   30    format(/,' +++++ beta',
     1          ' (optical rectification) at ',1f15.5 ,' ev.'/)
      endif
c
c  loop over components
c
      bavx = 0.0d+00
      bavy = 0.0d+00
      bavz = 0.0d+00
      do 90 id = 1,9
         cmptim = secmop()
         ia=ida(id)
         ib=idb(id)
         last = .false.
c
c  calculate the dipole matrix.
c
         call hmuf(h1,ia,coord,nfirst,nlast,nat,norbs,numat)
c
c  initialize zero arrays
c
         call zerom(uold1,norbs)
         call zerom(uab,norbs)
         call zerom(f,norbs)
c
c  input u and ga from alpha calculations
c
         if ((iwflb .eq. 2) .or. (iwflb .eq. 0)) then
c  ua contains ua(0)
            jpu = 1 + ia
            call daread_mop(ua,maxsq,jpu)
c  ga contains ga(0)
            jpg = 4 + ia
            call daread_mop(ga,maxsq,jpg)
         else
c  ua contains ua(w)
            jpu = 7 + ia
            call daread_mop(ua,maxsq,jpu)
c  ga contains ga(w)
            jpg = 10 + ia
            call daread_mop(ga,maxsq,jpg)
         endif
c
c read values for (w,-w) calculation  :  or
c
         if (iwflb .eq. 3) then
c  ub contains ub(-w) = -ub+(w)
            jpu = 7 + ib
            call daread_mop(x,maxsq,jpu)
            call fhpatn(ub,x,norbs,2,-one)
c  gb contains gb(-w) = gb+(w)
            jpg = 10 + ib
            call daread_mop(x,maxsq,jpg)
            call fhpatn(gb,x,norbs,2,one)
c
c read values for (0,w) calculation  :  oke
c
         elseif (iwflb .eq. 0) then
c  ub contains ub(0)
            jpu = 1 + ib
            call daread_mop(ub,maxsq,jpu)
c  gb contains gb(0)
            jpg = 4 + ib
            call daread_mop(gb,maxsq,jpg)
         else
c  ub contains ub(w)
            jpu = 7 + ib
            call daread_mop(ub,maxsq,jpu)
c  gb contains gb(w)
            jpg = 10 + ib
            call daread_mop(gb,maxsq,jpg)
         endif
c
c  construct t-matrix one time
c
         call tf(ua,ga,ub,gb,t,norbs,nclose,iwflb)
c
c  calculate initial density and beta value
c
         call bdensf(ua,ub,uab,c,d,da,norbs,nclose,iwflb)
         betaw = aval(h1,d,norbs)
         dela = dabs(betold-betaw)
         betold = betaw
c
c initialize fock matrix
c
         call ffreq2(f,d,w,numat,nfirst,nlast,norbs)
         call ffreq1(f,d,da,da,norbs)
         call zerom(da,norbs)
         call hplusf(f,da,norbs)
c.................................................................
c  loop starts here
c.................................................................
         icount = 0
   40    continue
         icount = icount + 1
         if (icount .ge. maxitu) last = .true.
c
c  create g matrix.
c
         call tranfgc(f,g,c,norbs)
c
c  form u matrix
c
         call bmakuf(ua,ub,uab,t,uold1,g,eigs,last,norbs,
     1              nclose,diff,iwflb,maxu,btol)
c
c  form new density matrix
c
         call bdensf(ua,ub,uab,c,d,da,norbs,nclose,iwflb)
c...
c compute test beta
c
         betaw = aval(h1,d,norbs)
         dela = dabs(betold-betaw)
         betold = betaw
c         if (last.or.(icount.gt.(maxitu-5))) then
c             write(iw,1500) icount,dela,maxu,diff
c 1500        format(' ',i4,'  delta beta = ', d12.5,
c     x       ' maxu = ', d12.5, '  udiff = ', d12.5)
c         endif
c
c  create new fock matrix
c
         call zerom(f,norbs)
         call ffreq2(f,d,w,numat,nfirst,nlast,norbs)
         call ffreq1(f,d,da,da,norbs)
         call zerom(da,norbs)
         call hplusf(f,da,norbs)
c..............................................................
         if (.not.last) go to 40
         cmptim = secmop() - cmptim
         write(iw,50) icount,cmptim
   50    format(/' converged in',i4,' iterations in',f10.2,
     1            ' seconds')
         write(iw,60) maxu,diff
   60    format(' maximum uab element =',1f15.5 ,
     1           ',  maximum difference =',1f15.5 ,/)
c
c  compute other components
c
         do 80 ic = 1,3
            call hmuf(h1,ic,coord,nfirst,nlast,nat,norbs,numat)
            betaw = aval(h1,d,norbs)
            write(iw,70) alab(ic),alab(ia),alab(ib),betaw
   70       format('      beta(',a1,',',a1,',',a1,') = ',1f15.5 )
c calculates the average value of beta
c
            if ((id .eq. 1) .and. (ic .eq. 1)) then
               bavx = bavx + 3.0d0*betaw
            elseif (((id.eq.5).or.(id.eq.9)).and. (ic .eq. 1)) then
               bavx = bavx + betaw
            elseif (((id.eq.2).or.(id .eq. 4)) .and. (ic .eq. 2)) then
               bavx = bavx + betaw
            elseif (((id.eq.3).or.(id .eq. 7)) .and. (ic .eq. 3)) then
               bavx = bavx + betaw
            endif
c calculates average beta in y-direction
c
            if ((id .eq. 5) .and. (ic .eq. 2)) then
               bavy = bavy + 3.0d0*betaw
            elseif (((id.eq.2).or.(id .eq. 4)) .and. (ic .eq. 1)) then
               bavy = bavy + betaw
            elseif (((id.eq.1).or.(id .eq. 9)) .and. (ic .eq. 2)) then
               bavy = bavy + betaw
            elseif (((id.eq.6).or.(id .eq. 8)) .and. (ic .eq. 3)) then
               bavy = bavy + betaw
            endif
c calculates average beta in the z-direction
c
            if ((id .eq. 9) .and. (ic .eq. 3)) then
               bavz = bavz + 3.0d0 * betaw
            elseif (((id.eq.3).or.(id .eq. 7)) .and. (ic .eq. 1)) then
               bavz = bavz + betaw
            elseif (((id.eq.6).or.(id .eq. 8)) .and. (ic .eq. 2)) then
               bavz = bavz + betaw
            elseif (((id.eq.1).or.(id .eq. 5)) .and. (ic .eq. 3)) then
               bavz = bavz + betaw
            endif
   80    continue
c
c call subroutine to calculate epsilon and uminus omega,omega
c  epsilon in h1 and uminus in da
         call epsab(h1,eigs,g,ga,gb,ua,ub,uab,da,norbs,nclose,iwflb)
         call dawrit_mop(uab,maxsq,iposu+id)
         call dawrit_mop(g,maxsq,iposg+id)
         call dawrit_mop(h1,maxsq,ipose+id)
         call dawrit_mop(da,maxsq,iposum+id)
   90 continue
      bavx = bavx/5.0d+00
      bavy = bavy/5.0d+00
      bavz = bavz/5.0d+00
      bvec = (bavx*bavx+bavy*bavy+bavz*bavz)**0.5d+00
c
      write(iw,100) omega,bavx
  100 format(//,' average betax value at ',f10.5,' ev = ',
     1   1f15.5 )
      write(iw,110) omega,bavy
  110 format(' average betay value at ',f10.5,' ev = ',
     1   1f15.5 )
      write(iw,120) omega,bavz
  120 format(' average betaz value at ',f10.5,' ev = ',
     1   1f15.5 )
      write(iw,130) omega,bvec
  130 format(//,'  average beta value at ',f10.5,' ev = ',
     1   1f15.5 ,//)
c
      return
      end
      subroutine betaf(iwflb,maxitu,btol,ua,ub,f,ga,gb,t,h1,d,da,
     1                  uab,uold1,g,x)
c
c this subroutine calculates iterative beta values for second harmonic
c generation.
c
      implicit REAL (a-h,o-z)
      REAL maxu
      logical last
INCLUDE(common/sizes)
c
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),
     1                nlast(numatm),norbs,nelecs,nalpha,nbeta,
     2                nclose,nopen,ndumy,fract
      common /vector/ c(morb2),eigs(maxorb),ca(morb2),dumy(maxorb)
      common /wmatrc/ w(n2elec*2)
      common /cmpg/ geo(3,numatm), coord(3,numatm)
      common /omval/ omega
      common /keywrd/ keywrd
c     common /chanel/ ifiles(30)
c     equivalence(iw,ifiles(6))
      common /iofile/ mfgr,iw
      character*241 keywrd
c
      dimension ua(maxorb,maxorb),ub(maxorb,maxorb),f(maxorb,maxorb),
     1          ga(maxorb,maxorb),gb(maxorb,maxorb),
     2          t(maxorb,maxorb), h1(maxorb,maxorb),
     3          d(maxorb,maxorb),da(maxorb,maxorb),
     4          uab(maxorb,maxorb),uold1(maxorb,maxorb),
     5          g(maxorb,maxorb),x(maxorb,maxorb)
      dimension allbet(3,3,3)
      character*1 alab
      dimension alab(3),ida(6),idb(6)
      save alab, ida, idb
      data alab/'x','y','z'/
      data ida /1,1,1,2,2,3/
      data idb /1,2,3,2,3,3/
c
      one=1.0d00
      betold = 0.0d00
      maxsq = norbs*norbs
      iposu = 25 + 24*iwflb
      iposg = iposu + 6
      ipose = iposg + 6
      iposum = ipose + 6
c
      if (iwflb .eq. 0) then
         write(iw,10) omega
   10    format(/,' +++++ beta (static) at ',1f15.5 ,' ev.'/)
      else
         write(iw,20) omega
   20    format(/,' +++++ beta',
     1           ' (second harmonic generation) at ',1f13.5,' ev.'/)
      endif
c
c  choose a  component
c  x: id=1   y: id=2   z: id=3
c
      bavx = 0.0d+00
      bavy = 0.0d+00
      bavz = 0.0d+00
      do 80 id = 1,6
         cmptim = secmop()
         ia=ida(id)
         ib=idb(id)
         last = .false.
c
c  calculate the dipole matrix.
c
         call hmuf(h1,ia,coord,nfirst,nlast,nat,norbs,numat)
c
c  initialize zero arrays
c
         call zerom(uold1,norbs)
         call zerom(uab,norbs)
         call zerom(f,norbs)
c
c  input u and ga from alpha calculations
c
         if ((iwflb .eq. 2) .or. (iwflb .eq. 0)) then
            jpu = 1 + ia
            call daread_mop(ua,maxsq,jpu)
            jpg = 4 + ia
            call daread_mop(ga,maxsq,jpg)
         else
            jpu = 7 + ia
            call daread_mop(ua,maxsq,jpu)
            jpg = 10 + ia
            call daread_mop(ga,maxsq,jpg)
         endif
c read values for (w,-w)
         if (iwflb .eq. 3) then
            jpu = 7 + ib
            call daread_mop(x,maxsq,jpu)
            call fhpatn(ub,x,norbs,2,-one)
            jpg = 10 + ib
            call daread_mop(x,maxsq,jpg)
            call fhpatn(gb,x,norbs,2,one)
c read values for oke
c
         elseif (iwflb .eq. 0) then
            jpu = 1 + ib
            call daread_mop(ub,maxsq,jpu)
            jpg = 4 + ib
            call daread_mop(gb,maxsq,jpg)
         else
            jpu = 7 + ib
            call daread_mop(ub,maxsq,jpu)
            jpg = 10 + ib
            call daread_mop(gb,maxsq,jpg)
         endif
c
c  construct t-matrix one time
c
         call tf(ua,ga,ub,gb,t,norbs,nclose,iwflb)
c
c  calculate initial density and beta value
c
         call bdensf(ua,ub,uab,c,d,da,norbs,nclose,iwflb)
         betaw = aval(h1,d,norbs)
         dela = dabs(betold-betaw)
         betold = betaw
c
c initialize fock matrix
c
         call ffreq2(f,d,w,numat,nfirst,nlast,norbs)
         call ffreq1(f,d,da,da,norbs)
         call zerom(da,norbs)
         call hplusf(f,da,norbs)
c.................................................................
c  loop starts here
c.................................................................
         icount = 0
   30    continue
         icount = icount + 1
         if (icount .ge. maxitu) last = .true.
c
c  create g matrix.
c
         call tranfgc(f,g,c,norbs)
c
c  form u matrix
c
         call bmakuf(ua,ub,uab,t,uold1,g,eigs,last,norbs,
     1              nclose,diff,iwflb,maxu,btol)
c
c  form new density matrix
c
         call bdensf(ua,ub,uab,c,d,da,norbs,nclose,iwflb)
c...
c compute test beta
c
         betaw = aval(h1,d,norbs)
         dela = dabs(betold-betaw)
         betold = betaw
c         if (last.or.(icount.gt.(maxitu-5))) then
c             write(iw,1500) icount,dela,maxu,diff
c 1500        format(' ',i4,'  delta beta = ', d12.5,
c     x       ' maxu = ', d12.5, '  udiff = ', d12.5)
c         endif
c
c  create new fock matrix
c
         call zerom(f,norbs)
         call ffreq2(f,d,w,numat,nfirst,nlast,norbs)
         call ffreq1(f,d,da,da,norbs)
         call zerom(da,norbs)
         call hplusf(f,da,norbs)
c..............................................................
         if (.not.last) go to 30
         cmptim = secmop() - cmptim
         write(iw,40) icount,cmptim
   40    format(/' converged in',i4,' iterations in',f10.2,
     1            ' seconds')
         write(iw,50) maxu,diff
   50    format(' maximum uab element =',1f15.5 ,
     1           ',  maximum difference =',1f15.5 ,/)
c
c compute beta
c
c        call hmuf(h1,id,coord,nfirst,nlast,nat,norbs,numat)
c        betaw = aval(h1,d,norbs)
c        write(iw,2000) alab(id),alab(id),alab(id),betaw
c2000    format('beta(',a1,',',a1,','a1,') = ',d12.5)
c
c  compute other components
c
         do 70 ic = 1,3
            call hmuf(h1,ic,coord,nfirst,nlast,nat,norbs,numat)
            betaw = aval(h1,d,norbs)
            allbet(ic,ia,ib)=betaw
            write(iw,60) alab(ic),alab(ia),alab(ib),betaw
   60       format('      beta(',a1,',',a1,',',a1,') = ',1f15.5 )
c
c calculate average beta in the x-direction
c
            if ((id .eq. 1) .and. (ic .eq. 1)) then
               bavx = bavx + 3.0d0 * betaw
            elseif ((id .eq. 2) .and. (ic .eq. 2)) then
               bavx = bavx + 2.0d0 * betaw
            elseif ((id .eq. 3) .and. (ic .eq. 3)) then
               bavx = bavx + 2.0d0 * betaw
            elseif (((id.eq.4).or.(id .eq. 6)) .and. (ic .eq. 1)) then
               bavx = bavx + betaw
            endif
c calculates average beta in the y-direction
            if ((id .eq. 4) .and. (ic .eq. 2)) then
               bavy = bavy + 3.0d0 * betaw
            elseif ((id .eq. 2) .and. (ic .eq. 1)) then
               bavy = bavy + 2.0d0 * betaw
            elseif ((id .eq. 5) .and. (ic .eq. 3)) then
               bavy = bavy + 2.0d0 * betaw
            elseif (((id.eq.1).or.(id .eq. 6)) .and. (ic .eq. 2)) then
               bavy = bavy + betaw
            endif
c calculates average beta in the z-direction
            if ((id .eq. 6) .and. (ic .eq. 3)) then
               bavz = bavz + 3.0d0 * betaw
            elseif ((id .eq. 3) .and. (ic .eq. 1)) then
               bavz = bavz + 2.0d0 * betaw
            elseif ((id .eq. 5) .and. (ic .eq. 2)) then
               bavz = bavz + 2.0d0 * betaw
            elseif (((id.eq.4) .or. (id.eq.1)) .and. (ic .eq. 3)) then
               bavz = bavz + betaw
            endif
   70    continue
c
c
c call subroutine to calculate epsilon and uminus omega,omega
c  epsilon in h1 and uminus in da
         call epsab(h1,eigs,g,ga,gb,ua,ub,uab,da,norbs,nclose,iwflb)
         call dawrit_mop(uab,maxsq,iposu+id)
         call dawrit_mop(g,maxsq,iposg+id)
         call dawrit_mop(h1,maxsq,ipose+id)
         call dawrit_mop(da,maxsq,iposum+id)
   80 continue
c
      bavx = bavx/5.0d+00
      bavy = bavy/5.0d+00
      bavz = bavz/5.0d+00
c calculates average beta
      bvec = (bavx*bavx+bavy*bavy+bavz*bavz)**0.5d+00
c
      write(iw,90) omega,bavx
   90 format(//,' average betax(shg) value at',f10.5, ' ev = ',
     1   1f11.5 )
      write(iw,100) omega,bavy
  100 format(' average betay(shg) value at',f10.5, ' ev = ',
     1   1f11.5 )
      write(iw,110) omega,bavz
  110 format(' average betaz(shg) value at',f10.5, ' ev = ',
     1   1f11.5)
c
      write(iw,120) omega,bvec
  120 format(//,' average beta (shg) value at',f10.5, ' ev = ',
     1   1f11.5 ,//)
      return
      end
      subroutine betal1(u0a,g0a,u1b,g1b,u1c,g1c,nclose,norbs,term)
c
c this subroutine calculates the trace of ugu matrices
c
      implicit REAL (a-h,o-z)
      dimension u0a(norbs,norbs),u1b(norbs,norbs),u1c(norbs,norbs),
     1          g0a(norbs,norbs),g1b(norbs,norbs),g1c(norbs,norbs)
      t1a = trugud(u0a,g1b,u1c,nclose,norbs,norbs)
      t2a = trudgu(u1c,g1b,u0a,nclose,norbs,norbs)
      t3a = trugdu(u1b,g1c,u0a,nclose,norbs,norbs)
      t4a = trugdu(u0a,g1c,u1b,nclose,norbs,norbs)
      t5a = trudgu(u1c,g0a,u1b,nclose,norbs,norbs)
      t6a = trugud(u1b,g0a,u1c,nclose,norbs,norbs)
      t1b = trugud(u0a,g1b,u1c,norbs,nclose,norbs)
      t2b = trudgu(u1c,g1b,u0a,norbs,nclose,norbs)
      t3b = trugdu(u1b,g1c,u0a,norbs,nclose,norbs)
      t4b = trugdu(u0a,g1c,u1b,norbs,nclose,norbs)
      t5b = trudgu(u1c,g0a,u1b,norbs,nclose,norbs)
      t6b = trugud(u1b,g0a,u1c,norbs,nclose,norbs)
      term = t1b-t1a+t2b-t2a+t3a-t3b+t4a-t4b+t5b-t5a+t6b-t6a
      return
      end
      subroutine betall(u2a,g2a,u1b,g1b,u1c,g1c,nclose,norbs,term)
c
c this subroutine calculates trace of ugu matrices
c when a,b,c directions are different
c
      implicit REAL (a-h,o-z)
      dimension u2a(norbs,norbs),u1b(norbs,norbs),u1c(norbs,norbs),
     1          g2a(norbs,norbs),g1b(norbs,norbs),g1c(norbs,norbs)
      t1a = trudgu(u2a,g1b,u1c,nclose,norbs,norbs)
      t2a = trugud(u1c,g1b,u2a,nclose,norbs,norbs)
      t3a = trugud(u1b,g1c,u2a,nclose,norbs,norbs)
      t4a = trudgu(u2a,g1c,u1b,nclose,norbs,norbs)
      t5a = trugdu(u1c,g2a,u1b,nclose,norbs,norbs)
      t6a = trugdu(u1b,g2a,u1c,nclose,norbs,norbs)
      t1b = trudgu(u2a,g1b,u1c,norbs,nclose,norbs)
      t2b = trugud(u1c,g1b,u2a,norbs,nclose,norbs)
      t3b = trugud(u1b,g1c,u2a,norbs,nclose,norbs)
      t4b = trudgu(u2a,g1c,u1b,norbs,nclose,norbs)
      t5b = trugdu(u1c,g2a,u1b,norbs,nclose,norbs)
      t6b = trugdu(u1b,g2a,u1c,norbs,nclose,norbs)
      term = t1b-t1a+t2b-t2a+t3b-t3a+t4b-t4a+t5a-t5b+t6a-t6b
      return
      end
      subroutine betcom(u1,g1,u2,g2,nclose,norbs,term)
c
c this subroutine calculates trace of ugu matrices
c
      implicit REAL (a-h,o-z)
      dimension u1(norbs,norbs),u2(norbs,norbs),
     1          g1(norbs,norbs),g2(norbs,norbs)
      t1a = trudgu(u2,g1,u1,nclose,norbs,norbs)
      t2a = trugud(u1,g1,u2,nclose,norbs,norbs)
      t3a = trugdu(u1,g2,u1,nclose,norbs,norbs)
      t1b = trudgu(u2,g1,u1,norbs,nclose,norbs)
      t2b = trugud(u1,g1,u2,norbs,nclose,norbs)
      t3b = trugdu(u1,g2,u1,norbs,nclose,norbs)
      term = 2.0d0*(t1b-t1a+t2b-t2a+t3a-t3b)
      return
      end
      subroutine bmakuf(ua,ub,uab,t,uold1,gab,eigs,last,norbs,
     1                    nclose,diff,iwflb,maxu,btol)
      implicit REAL (a-h,o-z)
      REAL maxu
      logical last
c
c  this subroutine creates the new transformation matrix u
c  and then checks for convergence
c
      dimension ua(norbs,norbs),uold1(norbs,norbs),t(norbs,norbs),
     1          eigs(norbs),gab(norbs,norbs),uab(norbs,norbs),
     2          ub(norbs,norbs)
      common /omval/ omega
c
c  zero matrix initially
c      call zerom(uab,norbs)
c
c  create diagonal blocks (occ,occ) and (unocc,unocc)
c
      do 30 i = 1,norbs
         do 20 j = 1,i
            sum = 0.0d00
            if (i.le.nclose) then
               kll=nclose+1
               kul=norbs
            elseif ((i.gt.nclose).and.(j.gt.nclose)) then
               kll=1
               kul=nclose
            endif
            do 10 k =kll,kul
               sum = sum+ua(i,k)*ub(k,j)+ub(i,k)*ua(k,j)
   10       continue
            uab(i,j) = sum*0.5d00
            uab(j,i) = sum*0.5d00
   20    continue
   30 continue
c
c  create off-diagonal blocks
c
      do 80 k = nclose+1,norbs
         do 70 l = 1,nclose
            go to (40,50,60), iwflb
c calculate for (w,w) values
c
   40       uab(k,l) = 27.2113961d0*((gab(k,l)+t(k,l))/
     1                 ((eigs(l)-eigs(k))-2.0d00*omega))
            uab(l,k) = 27.2113961d0*((gab(l,k)+t(l,k))/
     1                 ((eigs(k)-eigs(l))-2.0d00*omega))
            go to 70
c calculate for (0,w) values
c
   50       uab(k,l) = 27.2113961d0*((gab(k,l)+t(k,l))/
     1                 ((eigs(l)-eigs(k))-omega))
            uab(l,k) = 27.2113961d0*((gab(l,k)+t(l,k))/
     1                 ((eigs(k)-eigs(l))-omega))
            go to 70
c calculate for (w,-w) values
c
   60       uab(k,l) = 27.2113961d0*((gab(k,l)+t(k,l))/
     1                (eigs(l)-eigs(k)))
            uab(l,k) = 27.2113961d0*((gab(l,k)+t(l,k))/
     1                 (eigs(k)-eigs(l)))
   70    continue
   80 continue
c
c  check for convergence
c
      diff = 0.0d00
      maxu = -1000.00d0
      do 100 i = 1,norbs
         do 90 j = 1,norbs
            udif = uab(i,j)-uold1(i,j)
            if (diff.lt.dabs(udif)) diff = dabs(udif)
            if (maxu.lt.uab(i,j)) maxu = uab(i,j)
   90    continue
  100 continue
      if (diff.lt.btol) then
         last = .true.
      endif
c
      do 120 i = 1,norbs
         do 110 j = 1,norbs
            uold1(i,j) = uab(i,j)
  110    continue
  120 continue
c
      return
      end
      subroutine bprint
      implicit REAL (a-h,o-z)
      character*6      iao2s,iao2p,iao3s,iao3p
      integer shella,shelln,shellt,shellc,aos,shladf
c
c     common/datbas/ntybas,numg,ntypol,ntygd,ntyspd,nbamod
      common /b/ exx(360),c1(360),c2(360),c3(360),x(90),y(90),z(90),
     1         jan(90),shella(90),shelln(90),shellt(90),shellc(90),
     2         aos(90),nshell,maxtyp
      common /bx/ aon(90)
      common /chanel/ ifiles(30)
      dimension shladf(90),c4(90)
      equivalence(c4(1),c3(91)),(shladf(1),c3(181))
      equivalence (itab,ifiles(18))
      character*10 iatom(37), ap*1, pst*1, aon*6, skip1*1, star*1,
     1 skip2*1, star2*1
      common /jobnam/ jobnam
      character*80 jobnam
c
c     common/io/in,iout,ipunch
c
      common /scale/ scale(90)
c     common/ifbp/ifbp
c
      dimension incr(4,3)
c
      data iao2s/'    2s'/,iao2p/'    2p'/
      data iao3s/'    3s'/,iao3p/'    3p'/
      data thr1/1.0d-08/
      data incr/4*0,0,1,4,10,2*0,4,10/
      data iatom/
     1'  hydrogen','    helium','   lithium',' beryllium','     boron',
     2'    carbon','  nitrogen','    oxygen','  fluorine','      neon',
     3'    sodium',' magnesium',' aluminium','   silicon','phosphorus',
     4'    sulfur','  chlorine','     argon',' potassium','   calcium',
     5'  scandium','  titanium','  vanadium','  chromium',' manganese',
     6'      iron','    cobalt','    nickel','    copper','      zinc',
     7'   gallium',' germanium','   arsenic','  selenium','   bromine',
     8'   krypton','    banquo'/
      data zero/0.0d0/,ap/' '/,pst/'*'/
c
   10 format(2h *,129(1h-),1h*)
   20 format(2h *,a10,3f9.5,92x,1h*)
   30 format(2a1,45x,i3,3x,a6,5x,f5.2,62x,a1)
   40 format(2a1,41x,i3,1h-,i3,3x,a6,5x,f5.2,62x,a1)
   50 format(2a1,69x,5e12.6,a1)
   60 format(1x,131(1h*))
   70 format(2h *,13x,13hatomic center,13x,1h*,8x,14hatomic orbital,
     1 7x,1h*,21x,18hgaussian functions,20x,1h*)
   80 format(2h *,39x,1h*,1x,8hfunction,4x,5hshell,4x,5hscale,2x,1h*,59x
     1,1h*)
   90 format(2h *,4x,4hatom,3x,7hx-coord,2x,7hy-coord,2x,7hz-coord,
     1 3x,1h*,2x,6hnumber,5x,4htype,5x,6hfactor,1x,1h*,2x,8hexponent,
     2 4x,6hs-coef,6x,6hp-coef,6x,6hd-coef,6x,6hf-coef,3x,1h*)
  100 format(2h *,129x,1h*)
  110 format(11h0there are ,i4,21h primitive gaussians./)
c
c     test for printing of b-table.
c     if( (kop.eq.2)
c    $  .or. (kop.eq.0.and.ifbp.eq.0) )
c    $  go to 140
               i=index(jobnam,' ')-1
               open(unit=itab,file=jobnam(:i)//'.tab',
     1        status='unknown')
      rewind itab
      write(itab,60)
      write(itab,70)
      write(itab,60)
      write(itab,80)
      write(itab,90)
      write(itab,60)
c
      nprims=0
c
c     commence loop over shells.
      do 270 ishell=1,nshell
c
c     test for first pass through loop.  in the first pass,
c     we must process the first atom.
         if(ishell-1)120,130,120
c
c     not first pass, compute diff and test for step to new atom.
  120    diff= dabs(x1-x(ishell))+ dabs(x2-y(ishell))+ 
     +         dabs(x3-z(ishell))
         if(diff-thr1)190,190,130
c
c     step to new atom.
c     obtain atomic number and test for banquo atom.
  130    ia=jan(ishell)
c     if (ntybas.lt.5.or.ntybas.ge.7) goto 27
         if (aon(ishell).eq.iao2s) ia=jan(ishell)+2
         if (aon(ishell).eq.iao2p) ia=jan(ishell)+2
         if (aon(ishell).eq.iao3s) ia=jan(ishell)+10
         if (aon(ishell).eq.iao3p) ia=jan(ishell)+10
  140    if(ia)160,150,160
  150    ia=37
c     obtain coordinates.
  160    x1=x(ishell)
         x2=y(ishell)
         x3=z(ishell)
c     do not print minus line if ishell=1.
         if(ishell-1)180,180,170
  170    write(itab,10)
c     print atom name and coordinates.
  180    write(itab,20)iatom(ia),x1,x2,x3
c     set skip1 to suppress line skipping later on.
         skip1=ap
         star=pst
         iskip=0
c
c     processing for shell information line.
c     obtain indices for nstart increment.
  190    i=shellt(ishell)+1
         j=shellc(ishell)+1
         ip=shellt(ishell+1)+1
         jp=shellc(ishell+1)+1
c
c     obtain nstart and nend.
c     note that nstart is incremented according to the shell type and
c     shell constraint.
         nstart=aos(ishell)+incr(i,j)
         nend=aos(ishell+1)-1+incr(ip,jp)
         ndiff=nend-nstart+1
c     print of shell information line depends on whether
c     nstart=nend.
         scalei=scale(ishell)
         if(nstart-nend)210,200,210
  200    write(itab,30)skip1,star,nstart,aon(ishell),scalei,star
         go to 220
  210    write(itab,40)skip1,star,nstart,nend,aon(ishell),scalei,star
  220    skip1=ap
         star=pst
         iskip=1
c
c     output the gaussian function information.
         ngauss=shelln(ishell)
         i=shella(ishell)-1
         j=shladf(ishell)
         do 260 igauss=1,ngauss
            skip2=ap
            star2=pst
            if(igauss-1)240,230,240
  230       skip2=ap
            star2=pst
c     correct printed exponent.
  240       exxi=exx(igauss+i)/(scalei**2)
            c3a=zero
            c4a=zero
            if(j)260,260,250
  250       c3a=c3(j)
            c4a=c4(j)
            j=j+1
  260    write(itab,50)skip2,star2,exxi,c1(igauss+i),c2(igauss+i),c3a,
     1 c4a,star2
c
  270 nprims=nprims+ndiff*ngauss
      write(itab,60)
      write(itab,110) nprims
      write(itab,60)
c     go to 160
c
c     in no-print mode, merely determine the number of primitive
c     gaussians.
c 140 nprims=0
c     do 150 ishell=1,nshell
c     i=shellt(ishell)+1
c     j=shellc(ishell)+1
c     ip=shellt(ishell+1)+1
c     jp=shellc(ishell+1)+1
c 150 nprims=nprims+((aos(ishell+1)-1+incr(ip,jp))
c    $             -(aos(ishell)+incr(i,j))+1)*shelln(ishell)
c
  280 return
      end
      subroutine btoc (coord)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      dimension xx(3),xa(3),coord(3,*)
      common /solv/ fepsi,rds,disex2,nspa,nps,nps2,nden,
     1              cosurf(3,lenabc), srad(numatm),abcmat(lenab2),
     2              tm(3,3,numatm),qden(maxden),dirtm(3,nppa),
     3              bh(lenabc)
      common /solvi/ iatsp(lenabc+1),nar(lenabc)
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),
     1                nlast(numatm), norbs, nelecs,nalpha,nbeta,
     2                nclose,nopen,ndumy,fract
      common /multip/ dd(107),qq(107),am(107),ad(107),aq(107)
      do 10 i=1,nps
         j=iatsp(i)
         ri=srad(j)-rds
         do 10 ix=1,3
   10 cosurf(ix,i)=cosurf(ix,i)*ri+coord(ix,j)
c filling b-matrix
      i0=nps2-nden
      iden=0
      do 50 i=1,numat
         ia=nfirst(i)
         idel=nlast(i)-ia
         nati=nat(i)
         ddi=dd(nati)*2*.529177d0
         qqi2=(.529177d0*qq(nati))**2
         do 20 ix=1,3
            xx(ix)=coord(ix,i)
   20    continue
         do 40 ips=1,nps
            i1=i0+ips*nden
            dist=0.0d0
            do 30 ix=1,3
               xa(ix)=cosurf(ix,ips)-xx(ix)
               dist=dist+xa(ix)**2
   30       continue
            rm1=1.d0/dsqrt(dist)
            abcmat(iden+1+i1)=rm1
            if (idel .eq. 0) go to 40
            rm3=rm1**3
            rm5=rm1**5
            abcmat(iden+3+i1)=rm1+3*xa(1)**2*qqi2*rm5-qqi2*rm3
            abcmat(iden+6+i1)=rm1+3*xa(2)**2*qqi2*rm5-qqi2*rm3
            abcmat(iden+10+i1)=rm1+3*xa(3)**2*qqi2*rm5-qqi2*rm3
            abcmat(iden+2+i1)=xa(1)*ddi*rm3
            abcmat(iden+4+i1)=xa(2)*ddi*rm3
            abcmat(iden+7+i1)=xa(3)*ddi*rm3
            abcmat(iden+5+i1)=6*xa(1)*xa(2)*qqi2*rm5
            abcmat(iden+8+i1)=6*xa(1)*xa(3)*qqi2*rm5
            abcmat(iden+9+i1)=6*xa(3)*xa(2)*qqi2*rm5
   40    continue
   50 iden=iden+1+idel**2
      i1=nps2+nden*nps
c  filling c-matrix
      fact=-.50d0*2.00d0*13.6058d0*.5292d0*fepsi
      do 110 i=1,nden
         do 80 k=1,nps
            bhk=0.0d0
            kk2=(k*(k-1))/2
            do 60 l=1,k
   60       bhk=bhk+abcmat(i+l*nden+i0)*abcmat(kk2+l)
            do 70 l=k+1,nps
   70       bhk=bhk+abcmat(i+l*nden+i0)*abcmat((l*(l-1))/2+k)
            bh(k)=bhk
   80    continue
         do 100 j=1,i
            cij=0.0d0
            do 90 k=1,nps
   90       cij=cij+bh(k)*abcmat(j+k*nden+i0)
            i1=i1+1
            abcmat(i1)=fact*cij
  100    continue
  110 continue
***** this line 2 errors - should be nps2 and nps
***** i1=nsp2+nden*nsp
      i1=nps2+nden*nps
      do 120 i=1,nden
  120 i1=i1+i
      do 130 i=1,nps
         j=iatsp(i)
         rm=srad(j)-rds
         do 130 ix=1,3
  130 cosurf(ix,i)=(cosurf(ix,i)-coord(ix,j))/rm
c      call dielen(edie)
      return
      end
      subroutine cadima
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      integer shella,shelln,shellt,shellc,shladf,aos
      integer scona,sconb
      integer ubound,ulpure
      integer shellx
      character*214 keywrd
      common /keywrd/ keywrd
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),
     1  nlast(numatm),norbs,nelecs,nalpha,nbeta,nclose,nopen
      common /vector/ c(morb2),eigs(maxorb),vecs(morb2),eigb(maxorb)
      common /scrach/ rxyz(mpack)
      common /hmatrx/ h(mpack)
      common /fokmat/ f(mpack)
      common cxyz(numatm,3),natoms,icharg,multip,ian(numatm),nae,nbe,ne,
     1nbasis
      common/b/exx(360),c1(360),c2(360),c3(360),x(90),y(90),z(90),
     1         jan(90),shella(90),shelln(90),shellt(90),shellc(90),
     2         aos(90),nshell,maxtyp
      common/commax/lamax,lbmax,lpmax
      common/limit/imj,istart,jstart,iend,jend,irange,jrange,lentq
      common/type/itype,jtype
      common/ia/lind(151)
      common/const/zero
c      common/const/zero,half,one,onept5,two,three,four,ten,f42
      common/twop/twopt2,epi
      common/cfact/pt5,r3ov2,root3,root5,root15,r1,r2,r4,z1,z2,z3
      common/contr/ca(20),cb(20)
      common/twoc/twocx(9),twocy(9),twocz(9)
      common/threec/xip(16),yip(16),zip(16),sx(36),sy(36),sz(36)
      common/intk/zero1,xint(12)
      common/new/inew,jnew
      common/mopord/nordr(20),n6ord(10),n5ord(9),n10ord(10),
     +              n7ord(7),lbound(4,3),ubound(4),ulpure(4)
      common/block/ss(100),eek(100),eep(200)
      common/ipure/ipurd,ipurf
      common/rys/iop1,iop2
      common/t2w21e/lent(4),lindt(4),iadr(4),s(4),
     1ycut(4),t2(1030),w2(1030)
      common/intcon/f6i,f20i,f100
      common/cc/ccx(112),ccy(112),ccz(112)
      common/css/css(396)
      common/a/a(49)
      common/sdim/idim,inc
      common/pdim/incp,idim2c,idimaa
      common/xyz/xv(55,65),yv(55,65),zv(55,65)
      common/bb/valv(55,65),npp,ny,ipr
      common/deort/shellx(90)
c
      dimension shladf(90),c4(90)
      dimension tp(4),wp(4),foc(150)
      dimension indix(20),indiy(20),indiz(20),indjx(20),indjy(20),
     1          indjz(20)
      dimension indsx(20),indsy(20),indsz(20)
      dimension ifprt(8)
      dimension da(11325),d(150,150),v(150,150)
c
      equivalence(c4(1),c3(91)),(shladf(1),c3(181))
      equivalence (da(1),d(1,1))
c
      data cut1/-100.0d0/
      data indjx/1,2,1,1,3,1,1,2,2,1,4,1,1,2,3,3,2,1,1,2/
      data indjy/1,1,2,1,1,3,1,2,1,2,1,4,1,3,2,1,1,2,3,2/
      data indjz/1,1,1,2,1,1,3,1,2,2,1,1,4,1,1,2,3,3,2,2/
      data f15/15.0d0/
      data ifprt/0,1,2,0,0,1,1,2/
c
c     assign values to several variables
c
      ipurd=0
      ipurf=0
      ccx(1)=1.d0
      ccy(1)=1.d0
      ccz(1)=1.d0
      zero1=0.d0
      incp=0
      idim2c=7
      idimaa=49
      idim=6
      inc=2
      zero=0.d0
      onept5=1.5d0
      two=2.d0
      three=3.d0
      ten=10.d0
      f42=42.d0
      four=4.d0
      do 10 i=1,12
   10 xint(i)=dfloat(i)
      f100=100.d0
      f20=20.d0
      pt5=0.5d0
      if (ipr.gt.1) goto 70
c
c     the density matrix is built up
c
      nmo=ne/2
      do 20 i=1,nmo
   20 foc(i)=two
c
c     eigenvectors are deorthogonalized and stored in array v
c     depending on ht method used to compute the mep
c
      call mullik (c,h,f,norbs,vecs,rxyz)
      do 30 i=1,nmo
         do 30 j=1,norbs
            if (index(keywrd,'ort').ne.0) then
               v(j,i)=c(j+norbs*i-norbs)
            else
               v(j,i)=vecs(j+norbs*i-norbs)
            end if
   30 continue
      do 50 i=1,nbasis
         do 50 j=1,i
            d(i,j)=zero
            do 40 k=1,nmo
   40       d(i,j)=d(i,j)+foc(k)*v(i,k)*v(j,k)
            if(i.ne.j)d(i,j)=two*d(i,j)
   50 d(j,i)=d(i,j)
c
c     places symmetric square array in linear form
c
c
      k=1
      do 60 j=1,nbasis
         do 60 i=1,j
            da(k)=d(i,j)
   60 k=k+1
   70 continue
c
c    *******************************************************************
c     initialize this overlay.
c    *******************************************************************
c
      kop1=6
      kop2=0
      iop1=kop1
      iop2=kop2
      s(1)=0.25d0
      s(2)=0.367006838d0
      s(3)=0.180984215d0
      s(4)=0.116432928d0
      pi=four* datan(1.0d0)
      twopi=pi+pi
      rootpi= dsqrt(pi)
      pi3haf=pi*rootpi
c     /intcon/ variables to rpola.
      f6i=1.d0/xint(6)
      f20i=1.d0/f20
c
      ntt=nbasis*(nbasis+1)/2
c
c     initialize /cfact/.
      root3= dsqrt(xint(3))
      r3ov2=0.5d0*root3
      root5= dsqrt(xint(5))
      root15= dsqrt(f15)
      r1=pt5* dsqrt(xint(5)/xint(2))
      r2=xint(3)/(xint(2)*root5)
      r4=pt5* dsqrt(xint(3)/xint(2))
      z1=xint(4)/root5
      z2=xint(1)/root5
      z3=xint(3)/root5
c
c     fill inds and indi.
      do 80 i=1,20
         indix(i)=4*(indjx(i)-1)
         indiy(i)=4*(indjy(i)-1)
         indiz(i)=4*(indjz(i)-1)
         indsx(i)=6*(indjx(i)-1)
         indsy(i)=6*(indjy(i)-1)
         indsz(i)=6*(indjz(i)-1)
   80 continue
c
c     clear /twoc/.
      do 90 i=1,9
         twocz(i)=zero
         twocy(i)=zero
   90 twocx(i)=zero
c
c     clear /a/.
      do 100 i=1,49
  100 a(i)=zero
c
c     clear /css/.
      zero2=zero
      css(1)=1.d0
      do 110 i=2,396
  110 css(i)=zero
c
c     clear /threec/.
      do 120 i=1,16
         zip(i)=zero
         yip(i)=zero
  120 xip(i)=zero
      do 130 i=1,36
         sx(i)=zero
         sy(i)=zero
  130 sz(i)=zero
c
c     clear /cc/.
      word=zero
      do 140 i=1,112
         ccz(i)=zero
         ccy(i)=zero
  140 ccx(i)=zero
      ccx(1)=1.d0
      ccy(1)=1.d0
      ccz(1)=1.d0
c
c     clear /contr/.
      do 150 i=1,20
         ca(i)=zero
  150 cb(i)=zero
c
c     fill common /mopord/
c
      ubound(1)=1
      ubound(2)=4
      ubound(3)=10
      ubound(4)=20
      ulpure(1)=1
      ulpure(2)=4
      ulpure(3)=9
      ulpure(4)=17
      lbound(1,1)=1
      lbound(2,1)=1
      lbound(3,1)=1
      lbound(4,1)=1
      lbound(1,2)=1
      lbound(2,2)=2
      lbound(3,2)=5
      lbound(4,2)=11
      lbound(1,3)=1
      lbound(2,3)=1
      lbound(3,3)=5
      lbound(4,3)=11
      do 160 i=1,10
  160 n6ord(i)=i
      do 170 i=1,9
  170 n5ord(i)=i
      do 180 i=1,10
  180 n10ord(i)=i+10
      do 190 i=1,7
  190 n7ord(i)=i+10
c
c     initialize the ordering variables used by filmat.
c     this piece of code may look redundant, but hang on to it.
c     one can use this logic to alter the order of the basis functions.
c     (ie. change the order of the six d-functiones, etc.)
      if(ipurd)220,200,220
  200 do 210 i=1,9
  210 nordr(i)=n5ord(i)
      go to 240
  220 do 230 i=1,10
  230 nordr(i)=n6ord(i)
  240 if(ipurf)270,250,270
  250 do 260 i=1,7
  260 nordr(i+10)=n7ord(i)
      go to 290
  270 do 280 i=1,10
  280 nordr(i+10)=n10ord(i)
  290 continue
c
c     fill indexing array for filmat and linout.
c
      nbasp=nbasis+1
      do 300 i=1,nbasp
  300 lind(i)=(i*(i-1))/2
c
c    *******************************************************************
c     loop over shells.
c    *******************************************************************
c
c     loop over ishell
c
      do 390 ishell=1,nshell
         inew=ishell
         xa=x(ishell)
         ya=y(ishell)
         za=z(ishell)
         igbegn=shella(ishell)
         igend=igbegn+shelln(ishell)-1
         na=shelln(ishell)
         itype=shellt(ishell)
         lamax=itype+1
         scona=shellc(ishell)
         iend=ubound(lamax)
         istart=lbound(lamax,scona+1)
         irange=iend-istart+1
         igdf=shladf(inew)
c
c     loop over jshell.
c
         do 390 jshell=1,ishell
            jnew=jshell
            xb=x(jshell)
            yb=y(jshell)
            zb=z(jshell)
            jgbegn=shella(jshell)
            jgend=jgbegn+shelln(jshell)-1
            nb=shelln(jshell)
            jtype=shellt(jshell)
            lbmax=jtype+1
            sconb=shellc(jshell)
            jstart=lbound(lbmax,sconb+1)
            jend=ubound(lbmax)
            jrange=jend-jstart+1
            jgdf=shladf(jnew)
c
c     option to compute mep following reynolds's method
c
            if(index(keywrd,'ort').ne.0) then
               if(shellx(ishell).ne.shellx(jshell)) goto 390
            end if
c
            lpmax=lamax+lbmax-1
            lentq=irange*jrange
            lim1=lentq+100
            imj=iabs(ishell-jshell)
            nzero=(itype+jtype)/2+1
            abx=xb-xa
            aby=yb-ya
            abz=zb-za
            rabsq=abx*abx+aby*aby+abz*abz
  310       continue
c
c    *******************************************************************
c     loop over primitive gaussians.
c    *******************************************************************
c
            do 380 iret=1,npp
               do 380 jret=1,ny
                  do 320 i=1,lentq
  320             eep(i)=zero
                  do 370 igauss=igbegn,igend
                     as=exx(igauss)
                     asxa=as*xa
                     asya=as*ya
                     asza=as*za
                     arabsq=as*rabsq
                     call fillc(itype,igbegn,igauss,igdf,ca)
c
                     do 370 jgauss=jgbegn,jgend
                        bs=exx(jgauss)
                        call fillc(jtype,jgbegn,jgauss,jgdf,cb)
c
                        ep=as+bs
                        epi=1.d0/ep
                        twop=ep+ep
                        arg=-bs*arabsq*epi
                        pexp=zero
                        if(arg.gt.cut1) pexp=dexp(arg)
                        ztemp=twopi*epi*pexp
                        px=(asxa+bs*xb)*epi
                        py=(asya+bs*yb)*epi
                        pz=(asza+bs*zb)*epi
c
                        xap=px-xa
                        xbp=px-xb
                        yap=py-ya
                        ybp=py-yb
                        zap=pz-za
                        zbp=pz-zb
c
                        call getcc1(ccx,xap,xbp)
                        call getcc1(ccy,yap,ybp)
                        call getcc1(ccz,zap,zbp)
c
c     zero accumulation area.
c
                        do 330 i=100,lim1
  330                   eep(i)=zero
c
c    *******************************************************************
c     loop over atoms.
c    *******************************************************************
c
c
                        xc=xv(iret,jret)
                        yc=yv(iret,jret)
                        zc=zv(iret,jret)
                        cia= 1.d0
                        zt=ztemp*cia
                        pcx=xc-px
                        pcy=yc-py
                        pcz=zc-pz
                        rpcsq=pcx*pcx+pcy*pcy+pcz*pcz
                        arg=ep*rpcsq
                        call rpol1(nzero,arg,tp,wp)
                        call geta1(a)
c
c    *******************************************************************
c     loop over zeroes of rys polynomial.
c    *******************************************************************
c
                        do 350 izero=1,nzero
c
                           twopt2=twop*tp(izero)
                           zconst=zt*wp(izero)
c
                           call get2c(twocx,pcx,1.d0,a)
                           call get2c(twocy,pcy,1.d0,a)
                           call get2c(twocz,pcz,zconst,a)
c
                           call get3c(xip,twocx,ccx)
                           call get3c(yip,twocy,ccy)
                           call get3c(zip,twocz,ccz)
c
c    *******************************************************************
c     loop over atomic orbitals.
c    *******************************************************************
c
                           intc=100
                           do 340 i=istart,iend
c
                              ix=indix(i)
                              iy=indiy(i)
                              iz=indiz(i)
c
                              do 340 j=jstart,jend
                                 jx=indjx(j)
                                 jy=indjy(j)
                                 jz=indjz(j)
c
                                 intc=intc+1
                                 eep(intc)=eep(intc)+xip(ix+jx)*yip(iy+j
     1y)*zip(iz+jz)
c
  340                      continue
c     ... end of ao loop.
c
  350                   continue
c     ... end of loop over rys zeroes.
c
                        intc=0
                        do 360 i=istart,iend
                           ix=indsx(i)
                           iy=indsy(i)
                           iz=indsz(i)
                           do 360 j=jstart,jend
                              jx=indjx(j)
                              jy=indjy(j)
                              jz=indjz(j)
                              intc=intc+1
c
                              coef=ca(i)*cb(j)
  360                   eep(intc)=eep(intc)+eep(intc+100)*coef
c
  370             continue
c     ... end of loop over gaussians.
c
c     filmat takes the integrals in eep, eek, and ss, and stores them
c     in the proper places in s, t, and v.
c
                  call filmat(eep,da)
  380       valv(iret,jret)=valv(iret,jret)-eep(1)
  390 continue
c........ end of loop over shells.
      return
      end
c
c=====================================================================
c
      subroutine ccprod(c1,c2,c12,lm2,lm6)
**********************************************************
*     products of coefficients.                          *
*     subroutine from qcpe 438,  mndoc                   *
*     written by w.thiel                                 *
*     subroutine need for green function calculations    *
*     subroutine rewritten by d.danovich                 *
**********************************************************
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      common/molkst/numat,nat(numatm),nfirst(numatm),nmidle(numatm),
     1 nlast(numatm),norbs,nelecs,nalpha,nbeta,nclose,nopen,ndumy,
     2 fract
      dimension c1(lm2),c2(lm2),c12(*)
      kk=0
      do 10 ii=1,numat
         ia=nfirst(ii)
         ib=nlast(ii)
         kk=kk+1
         c12(kk)=c1(ia)*c2(ia)
         if(ia.eq.ib) go to 10
         cs1  = c1(ia)
         cpx1 = c1(ia+1)
         cpy1 = c1(ia+2)
         cpz1 = c1(ia+3)
         cs2  = c2(ia)
         cpx2 = c2(ia+1)
         cpy2 = c2(ia+2)
         cpz2 = c2(ia+3)
         c12(kk+1) = cpx1*cs2  + cpx2*cs1
         c12(kk+2) = cpx1*cpx2
         c12(kk+3) = cpy1*cs2  + cpy2*cs1
         c12(kk+4) = cpy1*cpx2 + cpy2*cpx1
         c12(kk+5) = cpy1*cpy2
         c12(kk+6) = cpz1*cs2  + cpz2*cs1
         c12(kk+7) = cpz1*cpx2 + cpz2*cpx1
         c12(kk+8) = cpz1*cpy2 + cpz2*cpy1
         c12(kk+9) = cpz1*cpz2
         kk = kk+9
   10 continue
      return
      end
      subroutine consts (coord)
c this routine constructs or updates the solvent-accessible
c surface (sas)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      dimension xx(3),xa(3),xi(3),xj(3),xsp(3,lenabc),coord(3,*)
      dimension nset(nppa*numatm/2),nsetf(lenabc), n0(2)
      logical din(nppa),isup
      common /solv/   fepsi,rds,disex2,nspa,nps,nps2,nden,
     1                cosurf(3,lenabc), srad(numatm),abcmat(lenab2),
     2                tm(3,3,numatm),qden(maxden),dirtm(3,nppa),
     3                bh(lenabc)
      common /solvi/ iatsp(lenabc+1),nar(lenabc)
      common /dirvec/ dirvec(3,nppa), nn(3,numatm)
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),
     1                nlast(numatm), norbs, nelecs,nalpha,nbeta,
     2                nclose,nopen,ndumy,fract
      dimension ipiv(lenabc)
      common /areavd/ area
      common /chanel/ ifiles(30)
      equivalence(iw,ifiles(6))
      equivalence (abcmat(lenabc*lenabc+1),xsp)
      isup=(nps.gt.0)
      n0(1)=nps2
      n0(2)=-nps
      maxnps=dsqrt(2*lenab2+.251d0)-nden-.5d0
      maxnps=min(maxnps,lenabc)
      if (maxnps .lt. 3*numat) then
         write(iw,*)' parameter lenabc must be increased for this system
     1'
         stop       ' parameter lenabc must be increased for this system
     1'
      endif
      if (isup) then
         nps3=lenabc-nps
         do 10 i=nps,1,-1
            iatsp(nps3+i)=iatsp(i)
            do 10 ix=1,3
               cosurf(ix,nps3+i)=cosurf(ix,i)
   10    continue
         nps3=nps3+1
      end if
      sdis=0.0d0
      fdiag=1.05d0*dsqrt(nppa+0.d0)
      inset=1
      iatsp(lenabc+1)=0
      nps = 0
      do 340 i=1,numat
         ds=dsqrt(4.d0/nspa)
         if (nat(i) .eq. 1) ds=2*ds
         c2ds=dcos(2.d0*ds)
         area=0.0d0
         r=srad(i)
         ri=r-rds
         do 20 ix=1,3
   20    xa(ix)=coord(ix,i)
         nps0=nps+1
         if(isup) then
            if (nps .ge. nps3) stop 'nps .gt. nps3'
            nps2=nps3
            if (iatsp(nps0) .ne. i) go to 340
            do 30 ips=nps2,lenabc+1
   30       if(iatsp(ips) .ne. i) go to 40
   40       nps3=ips
c transform cosurf according to tm(inv)
            do 50 j=nps2,nps3-1
               xx(1)=cosurf(1,j)
               xx(2)=cosurf(2,j)
               xx(3)=cosurf(3,j)
               cosurf(1,j)=xx(1)*tm(1,1,i)+xx(2)*tm(1,2,i)+xx(3)*tm(1,3,
     1i)
               cosurf(2,j)=xx(1)*tm(2,1,i)+xx(2)*tm(2,2,i)+xx(3)*tm(2,3,
     1i)
               cosurf(3,j)=xx(1)*tm(3,1,i)+xx(2)*tm(3,2,i)+xx(3)*tm(3,3,
     1i)
   50       continue
            nn1=nn(1,i)
            nn2=nn(2,i)
            nn3=nn(3,i)
         else
c search for 3 nearest neighbor atoms
            dist1=1.d20
            dist2=1.d20
            dist3=1.d20
            nn1=0
            nn2=0
            nn3=0
            do 70 j=1,numat
               if (j.eq. i) go to 70
               dist=0.0d0
               do 60 ix=1,3
   60          dist=dist+(xa(ix)-coord(ix,j))**2
               if (dist+0.05d0 .lt. dist3) then
                  dist3=dist
                  nn3=j
               end if
               if (dist3+0.05d0 .lt. dist2) then
                  dist=dist2
                  dist2=dist3
                  dist3=dist
                  nn3=nn2
                  nn2=j
               end if
               if (dist2+0.05d0 .lt. dist1) then
                  dist=dist1
                  dist1=dist2
                  dist2=dist
                  nn2=nn1
                  nn1=j
               end if
   70       continue
            nn(1,i)=nn1
            nn(2,i)=nn2
            nn(3,i)=nn3
         endif
c build new transformation matrix
         if (nn1 .eq. 0) then
            tm(1,1,i)=1.d0
            tm(1,2,i)=0.0d0
            tm(1,3,i)=0.0d0
         else
            dist1=0.0d0
            do 80 ix=1,3
   80       dist1=dist1+(xa(ix)-coord(ix,nn1))**2
            dist=1.0d0/dsqrt(dist1)
            tm(1,1,i)=(coord(1,nn1)-xa(1))*dist
            tm(1,2,i)=(coord(2,nn1)-xa(2))*dist
            tm(1,3,i)=(coord(3,nn1)-xa(3))*dist
         end if
   90    if (nn2 .eq. 0) then
            dist=dsqrt(tm(1,2,i)**2+tm(1,1,i)**2)
            tm(2,1,i)=-tm(1,2,i)/dist
            tm(2,2,i)=tm(1,1,i)/dist
            tm(2,3,i)=0.0d0
         else
            dist2=0.0d0
            do 100 ix=1,3
  100       dist2=dist2+(xa(ix)-coord(ix,nn2))**2
            dist=1.0d0/dsqrt(dist2)
            xx(1)=(coord(1,nn2)-xa(1))*dist
            xx(2)=(coord(2,nn2)-xa(2))*dist
            xx(3)=(coord(3,nn2)-xa(3))*dist
            sp=xx(1)*tm(1,1,i)+xx(2)*tm(1,2,i)+xx(3)*tm(1,3,i)
            if (sp*sp .gt. 0.99d0) then
               nn2=nn3
               nn3=0
               dist2=dist3
               go to 90
            end if
            sininv=1.d0/dsqrt(1.d0-sp*sp)
            tm(2,1,i)=(xx(1)-sp*tm(1,1,i))*sininv
            tm(2,2,i)=(xx(2)-sp*tm(1,2,i))*sininv
            tm(2,3,i)=(xx(3)-sp*tm(1,3,i))*sininv
         end if
         tm(3,1,i)=tm(1,2,i)*tm(2,3,i)-tm(2,2,i)*tm(1,3,i)
         tm(3,2,i)=tm(1,3,i)*tm(2,1,i)-tm(2,3,i)*tm(1,1,i)
         tm(3,3,i)=tm(1,1,i)*tm(2,2,i)-tm(2,1,i)*tm(1,2,i)
c transform dirvec according to tm
         do 110 j=1,nppa
            xx(1)=dirvec(1,j)
            xx(2)=dirvec(2,j)
            xx(3)=dirvec(3,j)
            do 110 ix=1,3
               x=xx(1)*tm(1,ix,i)+xx(2)*tm(2,ix,i)+xx(3)*tm(3,ix,i)
               dirtm(ix,j)=x
  110    continue
         if (isup) then
            do 120 j=nps2,nps3-1
               nps=nps+1
               iatsp(nps)=i
               xx(1)=cosurf(1,j)
               xx(2)=cosurf(2,j)
               xx(3)=cosurf(3,j)
               cosurf(1,nps)=xx(1)*tm(1,1,i)+xx(2)*tm(2,1,i)+xx(3)*tm(3,
     11,i)
               cosurf(2,nps)=xx(1)*tm(1,2,i)+xx(2)*tm(2,2,i)+xx(3)*tm(3,
     12,i)
               cosurf(3,nps)=xx(1)*tm(1,3,i)+xx(2)*tm(2,3,i)+xx(3)*tm(3,
     13,i)
  120       continue
         else
         i0=2-1/nat(i)
         jmax=n0(i0)
         i0=3*(i0-1)*nppa-3
         do 45 j=1,jmax
         nps=nps+1
         iatsp(nps)=i
         xx(1)=abcmat(i0+j*3+1)
         xx(2)=abcmat(i0+j*3+2)
         xx(3)=abcmat(i0+j*3+3)
         cosurf(1,nps)=xx(1)*tm(1,1,i)+xx(2)*tm(2,1,i)+xx(3)*tm(3,1,i)
         cosurf(2,nps)=xx(1)*tm(1,2,i)+xx(2)*tm(2,2,i)+xx(3)*tm(3,2,i)
         cosurf(3,nps)=xx(1)*tm(1,3,i)+xx(2)*tm(2,3,i)+xx(3)*tm(3,3,i)
  45     continue
         endif
c find the points of the basic grid on the sas
         narea=0
         do 160 j = 1,nppa
            din(j)=.false.
            do 130 ix=1,3
               xx(ix) = xa(ix) + dirtm(ix,j)* r
  130       continue
            do 150 k = 1, numat
               if (k . eq. i) go to 150
               dist=0.0d0
               do 140 ix=1,3
                  dist = dist + (xx(ix) - coord(ix,k))**2
  140          continue
               dist=dsqrt(dist)-srad(k)
               if (dist .lt. 0) go to 160
  150       continue
            narea=narea+1
            din(j)=.true.
  160    continue
         area=area+narea*ri*ri
  200    sdis0=sdis
         do 210 ips=nps0,nps
            nar(ips)=0
            xsp(1,ips)=0.0d0
            xsp(2,ips)=0.0d0
            xsp(3,ips)=0.0d0
  210    continue
         do 250 j=1,nppa
            if (.not. din(j)) go to 250
            spm=-1.d0
            x1=dirtm(1,j)
            x2=dirtm(2,j)
            x3=dirtm(3,j)
            do 220 ips=nps0,nps
               sp=x1*cosurf(1,ips)+x2*cosurf(2,ips)+x3*cosurf(3,ips)
               if (sp .lt. spm) go to 220
               spm=sp
               ipm=ips
  220       continue
            if (spm .lt. c2ds) then
               nps=nps+1
               if (nps .gt. maxnps) then
                  write(iw,*) 'nps is greater than maxnps-use smaller ns
     1pa'
                  stop 'nps greater than maxnps'
               end if
               do 230 ix=1,3
  230          cosurf(ix,nps)=dirtm(ix,j)
               iatsp(nps)=i
               go to 200
            end if
            nar(ipm)=nar(ipm)+1
            do 240 ix=1,3
  240       xsp(ix,ipm)=xsp(ix,ipm)+dirtm(ix,j)
  250    continue
         sdis=0.0d0
         ips=nps0-1
         if(nps.lt.ips) goto 200
  260    ips=ips+1
  352  if(nar(ips).eq.0)then
       nps=nps-1
       if(nps.lt.ips) goto 200
       do 369 jps=ips,nps
       nar(jps)=nar(jps+1)
       xsp(1,jps)=xsp(1,jps+1)
       xsp(2,jps)=xsp(2,jps+1)
  369  xsp(3,jps)=xsp(3,jps+1)
       goto 352
       endif
         dist=0.0d0
         do 280 ix=1,3
            x=xsp(ix,ips)
            dist=dist+x*x
  280    continue
         sdis=sdis+dist
         dist=1.d0/dsqrt(dist)
         do 290 ix=1,3
  290    cosurf(ix,ips)=xsp(ix,ips)*dist
         if(ips.lt.nps) goto 260
         if (dabs(sdis-sdis0) .gt. 1.d-5) go to 200
         do 310 ips=nps0,nps
            nsetf(ips)=inset
            inset=inset+nar(ips)
            nar(ips)=0
            do 300 ix=1,3
  300       xsp(ix,ips)=xa(ix)+cosurf(ix,ips)*ri
  310    continue
         do 330 j=1,nppa
            if (.not. din(j)) go to 330
            spm=-1.d0
            x1=dirtm(1,j)
            x2=dirtm(2,j)
            x3=dirtm(3,j)
            do 320 ips=nps0,nps
               sp=x1*cosurf(1,ips)+x2*cosurf(2,ips)+x3*cosurf(3,ips)
               if (sp .lt. spm) go to 320
               spm=sp
               ipm=ips
  320       continue
            if (spm .lt. c2ds) go to 330
            nara=nar(ipm)
            nset(nsetf(ipm)+nara)=j
            nar(ipm)=nara+1
  330    continue
  340 continue
      area=area*4.d0*3.14159d0/nppa
c filling aamat
      do 450 ips=1,nps
         i=iatsp(ips)
         ri=srad(i)-rds
         nari=nar(ips)
         nsetfi=nsetf(ips)
         aa=0.0d0
         do 350 k=nsetfi,nsetfi+nari-1
            j1=nset(k)
            aa=aa+fdiag
            x1=dirvec(1,j1)
            x2=dirvec(2,j1)
            x3=dirvec(3,j1)
            do 350 l=nsetfi,k-1
               j2=nset(l)
               aa=aa+2.d0/dsqrt((x1-dirvec(1,j2))**2+
     1             (x2-dirvec(2,j2))**2+(x3-dirvec(3,j2))**2)
  350    continue
         aa=aa/ri/nari**2
         abcmat(ips+(ips-1)*nps)=aa
         do 360 ix=1,3
            xi(ix)=coord(ix,i)
  360    xa(ix)=xsp(ix,ips)
         do 440 jps=ips+1,nps
            narj=nar(jps)
            nsetfj=nsetf(jps)
            j=iatsp(jps)
            dist=0.0d0
            do 370 ix=1,3
               xj(ix)=coord(ix,j)-xi(ix)
  370       dist=dist+(xsp(ix,jps)-xa(ix))**2
            if (dist .lt. disex2) then
               rj=srad(j)-rds
               aij=0.0d0
               do 430 k=nsetfi,nsetfi+nari-1
                  j1=nset(k)
                  do 380 ix=1,3
  380             xx(ix)=dirvec(ix,j1)*ri
                  if (i .ne. j) then
                     x1=xx(1)*tm(1,1,i)+xx(2)*tm(2,1,i)+xx(3)*tm(3,1,i)-
     1xj(1)
                     x2=xx(1)*tm(1,2,i)+xx(2)*tm(2,2,i)+xx(3)*tm(3,2,i)-
     1xj(2)
                     x3=xx(1)*tm(1,3,i)+xx(2)*tm(2,3,i)+xx(3)*tm(3,3,i)-
     1xj(3)
                     do 400 l=nsetfj,nsetfj+narj-1
                        j2=nset(l)
                        do 390 ix=1,3
  390                   xx(ix)=dirvec(ix,j2)*rj
                        y1=xx(1)*tm(1,1,j)+xx(2)*tm(2,1,j)+xx(3)*tm(3,1,
     1j)-x1
                        y2=xx(1)*tm(1,2,j)+xx(2)*tm(2,2,j)+xx(3)*tm(3,2,
     1j)-x2
                        y3=xx(1)*tm(1,3,j)+xx(2)*tm(2,3,j)+xx(3)*tm(3,3,
     1j)-x3
                        aij=aij+1.d0/dsqrt(y1*y1+y2*y2+y3*y3)
  400                continue
                  else
  410                do 420 l=nsetfj,nsetfj+narj-1
                        j2=nset(l)
c                  aa=((dirvec(1,j2)*rj-xx(1))**2+(dirvec(2,j2)*rj
c     &                   -xx(2))**2+(dirvec(3,j2)*rj-xx(3))**2)
cjens                        aij=aij+((dirvec(1,j2)*rj-xx(1))**2+(dirvec(2,j2
cjens     1)*rj                   -xx(2))**2+(dirvec(3,j2)*rj-xx(3))**2)**-.5
cjens     2d0
                      aij=aij + ( (dirvec(1,j2)*rj-xx(1))**2
     +                        +   (dirvec(2,j2)*rj-xx(2))**2
     +                        +   (dirvec(3,j2)*rj-xx(3))**2 )**(-.5d0)

  420                continue
                  end if
  430          continue
               aij=aij/nari/narj
            else
               aij=1.d0/dsqrt(dist)
            end if
            abcmat(ips+(jps-1)*nps)=aij
            abcmat(jps+(ips-1)*nps)=aij
  440    continue
  450 continue
c invert a-matrix
      call dgetrf(nps,nps,abcmat,nps,ipiv,info)
      call dgetri(nps,abcmat,nps,ipiv,xsp, 3*lenabc,info)
c  store inv. a-matrix as lower triangle
      ii=0
      do 460 i=1,nps
         do 460 j=1,i
            ii=ii+1
            abcmat(ii)=abcmat(j+(i-1)*nps)
  460 continue
      nps2=ii
      return
      end
      subroutine copym(h,f,m)
      implicit REAL (a-h,o-z)
c
c  copym copies matrix h into f
c
      dimension f(m,m),h(m,m)
      do 20 i = 1,m
         do 10 j = 1,m
            f(i,j) = h(i,j)
   10    continue
   20 continue
      return
      end
      subroutine cqden()
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      common /solv/ fepsi,rds,disex2,nspa,nps,nps2,nden,
     1              cosurf(3,lenabc), srad(numatm),abcmat(lenab2),
     2              tm(3,3,numatm),qden(maxden),dirtm(3,nppa),
     3              bh(lenabc)
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),
     1                nlast(numatm), norbs, nelecs,nalpha,nbeta,
     2                nclose,nopen,ndumy,fract
      common /densty/ p(mpack)
      common /corec/ core(107)
      iden=0
      do 30 i=1,numat
         ia=nfirst(i)
         idel=nlast(i)-ia
         im=(ia*(ia+1))/2
         iden=iden+1
         qden(iden)=core(nat(i))-p(im)
         do 20 ic=1,idel
            im=im+ia-1
            do 10 id=0,ic
               im=im+1
               iden=iden+1
               qden(iden)=-p(im)
   10       continue
   20    continue
   30 continue
      return
      end
      subroutine cross(a,b,c)
      implicit REAL (a-h,o-z)
      dimension a(3)
      dimension b(3)
      dimension c(3)
      c(1) = a(2) * b(3) - a(3) * b(2)
      c(2) = a(3) * b(1) - a(1) * b(3)
      c(3) = a(1) * b(2) - a(2) * b(1)
      return
      end
      subroutine diegrd (coord,dxyz)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      common /solv/ fepsi,rds,disex2,nspa,nps,nps2,nden,
     1              cosurf(3,lenabc), srad(numatm),abcmat(lenab2),
     2              tm(3,3,numatm),qden(maxden),dirtm(3,nppa),
     3              qs(lenabc)
      common /solvi/ iatsp(lenabc+1),nar(lenabc)
      common /dirvec/ dirvec(3,nppa), nn(3,numatm)
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),
     1                nlast(numatm), norbs, nelecs,nalpha,nbeta,
     2                nclose,nopen,ndumy,fract
     3       /multip/ dd(107),qq(107),am(107),ad(107),aq(107)
      dimension dxyz(3,*),db(0:3,10),xk(3),xl(3),xx(3),coord(3,numatm)
      do 10 i=1,nps
         j=iatsp(i)
         ri=srad(j)-rds
         do 10 ix=1,3
   10 cosurf(ix,i)=cosurf(ix,i)*ri+coord(ix,j)
      do 20 i=1,10
         do 20 ix=1,3
   20 db(ix,i)=0.0d0
      db(0,1)=1.d0
      call cqden()
      fact=-2.0d0*13.6058d0*.5292d0*fepsi*23.061d0
      do 30 i=1,nps
   30 qs(i)=0.0d0
      i0=nps2-nden
      do 70 i=1,nps
         i2=(i*(i-1))/2
         i1=i0+i*nden
         posi=0.0d0
         do 40 j=1,nden
   40    posi=posi+qden(j)*abcmat(j+i1)
         do 50 k=1,i
   50    qs(k)=qs(k)+posi*abcmat(k+i2)
         do 60 k=i+1,nps
   60    qs(k)=qs(k)+posi*abcmat(i+(k*(k-1))/2)
   70 continue
      do 120 k=1,nps
         iak=iatsp(k)
         do 80 ix=1,3
   80    xk(ix)=cosurf(ix,k)
         qsk=qs(k)
         do 110 l=1,k-1
            ial=iatsp(l)
            if(ial .eq. iak) go to 110
            dist2=0.0d0
            do 90 ix=1,3
               xxx=cosurf(ix,l)-xk(ix)
               xl(ix)=xxx
               dist2=dist2+xxx*xxx
   90       continue
cjens            ff=qsk*qs(l)*fact*dist2**-1.5d0
            ff=qsk*qs(l)*fact*dist2**(-1.5d0)
            do 100 ix=1,3
               dxyz(ix,iak)=dxyz(ix,iak)-xl(ix)*ff
               dxyz(ix,ial)=dxyz(ix,ial)+xl(ix)*ff
  100       continue
  110    continue
  120 continue
      do 190 k=1,nps
         iak=iatsp(k)
         do 130 ix=1,3
  130    xk(ix)=cosurf(ix,k)
         qsk=qs(k)
         iden=0
         do 180 i=1,numat
            idel=nlast(i)-nfirst(i)
            if(i .eq. iak) go to 180
            nati=nat(i)
            dist2=0.0d0
            do 140 ix=1,3
               xxx=xk(ix)-coord(ix,i)
               xx(ix)=xxx
               dist2=dist2+xxx*xxx
  140       continue
            ddi=dd(nati)*2.00d0*.529177d0
            qqi2=(.529177d0*qq(nati))**2
cjens            ff0=-qsk*fact*dist2**-1.5d0
            ff0=-qsk*fact*dist2**(-1.5d0)
            if(idel .eq. 0) go to 150
            rm2=1.d0/dist2
            rm4=rm2**2
            db(0,2)=ddi*3*xx(1)*rm2
            db(0,4)=ddi*3*xx(2)*rm2
            db(0,7)=ddi*3*xx(3)*rm2
            db(0,3)=1.d0+qqi2*(15*xx(1)**2*rm2-3.d0)*rm2
            db(0,6)=1.d0+qqi2*(15*xx(2)**2*rm2-3.d0)*rm2
            db(0,10)=1.d0+qqi2*(15*xx(3)**2*rm2-3.d0)*rm2
            db(0,5)=qqi2*30*xx(1)*xx(2)*rm4
            db(0,8)=qqi2*30*xx(1)*xx(3)*rm4
            db(0,9)=qqi2*30*xx(3)*xx(2)*rm4
            db(1,2)=ddi
            db(2,4)=db(1,2)
            db(3,7)=db(1,2)
            db(1,3)=6*qqi2*xx(1)*rm2
            db(2,6)=6*qqi2*xx(2)*rm2
            db(3,10)=6*qqi2*xx(3)*rm2
            db(1,5)=db(2,6)
            db(2,5)=db(1,3)
            db(1,8)=db(3,10)
            db(3,8)=db(1,3)
            db(2,9)=db(3,10)
            db(3,9)=db(2,6)
  150       do 170 j=1,1+idel*idel
               ff=ff0*qden(iden+j)
               do 160 ix=1,3
                  dx=(xx(ix)*db(0,j)-db(ix,j))*ff
                  dxyz(ix,iak)=dxyz(ix,iak)+dx
                  dxyz(ix,i)=dxyz(ix,i)-dx
  160          continue
  170       continue
  180    iden=iden+1+idel**2
  190 continue
      do 200 i=1,nps
         j=iatsp(i)
         rm=srad(j)-rds
         do 200 ix=1,3
  200 cosurf(ix,i)=(cosurf(ix,i)-coord(ix,j))/rm
      return
      end
      subroutine dielen (edie)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      common /solv/ fepsi,rds,disex2,nspa,nps,nps2,nden,
     1              cosurf(3,lenabc), srad(numatm),abcmat(lenab2),
     2              tm(3,3,numatm),qden(maxden),dirtm(3,nppa),
     3              bh(lenabc)
      call cqden()
      edie=0.0d0
      i0=nps2+nden*nps
      do 20 i=1,nden
         qi=qden(i)
         do 10 j=1,i-1
            i0=i0+1
   10    edie=edie+2*qi*abcmat(i0)*qden(j)
         i0=i0+1
         edie=edie+qi*abcmat(i0)*qi
   20 continue
      return
      end
      function dintrp(table)
c
c     --------------------------
c     gaussian 76 (qcpe version)
c     december 1977
c     control data 7600
c     --------------------------
c
c***********************************************************************
c     routine to perform everett interpolation with throw-back to
c     fourth order using table.
c***********************************************************************
c
      implicit REAL (a-h,o-z)
      dimension table(m+6)
c
      common/mtpc/  at,bt,ap,bp,cm1,c0,c1,c2,m
      equivalence(cm2,bp),(c3,bt)
c
      x     =cm2*table(m+1)+cm1*table(m+2)+c0*table(m+3)+c1*table(m+4)+
     1       c2*table(m+5)+c3*table(m+6)
      dintrp=x
c
      return
      end
      subroutine ldima
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      character*6  iao1s,iao2s,iao2p,iao3s,iao3p,
     1             iao4s,iao4p,iao5s,iao5p,iao6s, iao6p,iao7s,iao7p
      integer shella,shelln,shellt,shellc,shladf,aos
      integer shellx
      character*214 keywrd
c     ---------------
c     pisa version
c     june 1980
c     ---------------
      common /keywrd/ keywrd
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),
     1  nlast(numatm),norbs,nelecs,nalpha,nbeta,nclose,nopen
      common /cmpg/ geo(3,numatm)
      common /corec/ core(107)
      common /funcon/ fpc(2,10),ifpc
      common /jobnam/ jobnam
      common /chanel/ ifiles(30)
      common /expont/ zs(107),zp(107),zd(107)
      common c(numatm,3),natoms,icharg,multip,ian(numatm),nae,nbe,ne,
     1nbasis
      common /b/ exx(360),c1(360),c2(360),c3(360),x(90),y(90),z(90),
     1           jan(90),shella(90),shelln(90),shellt(90),shellc(90),
     2           aos(90),nshell,maxtyp
      common /bx/ aon(90)
      common /scale/scale(90)
      common /iaos/iaos(90)
      common /bb/ valv(55,65),npp,ny,ipr
      common /bbnew/vpot(3575)
      common /mopgrd/ xp1(3),yp1(3),zp1(3),ds
      common /connol/ scle,scincr,den,nsurf
      common /mstq/qs(1500),mflag,iterq
c     common /mstsur/nesf,omega,rd,ret,fro,ndiv,dr,icent
c     common/poly/xe(500),ye(500),ze(500),re(500),ssfe(500),
c    * iploch(1500),as(1500),stot,vol,nsf,nc(numatm)
      common /mopfac/ factor
      common /mstxyz/ xv1(3575),yv1(3575),zv1(3575),nts
      common /xyz/ xv(55,65),yv(55,65),zv(55,65)
      common /deort/ shellx(90)
      character*6 aon
      dimension cc(3,numatm)
      dimension ovrlap(4)
      dimension idif(55,65),vwxyz(3,3600)
      dimension shladf(90),c4(90)
      character  jobnam*80
c     dimension scr1(10726)
      equivalence(c4(1),c3(91)),(shladf(1),c3(181))
      equivalence(ovrf,ovrlap(4))
      equivalence(ovrs,ovrlap(1)),(ovrp,ovrlap(2)),(ovrd,ovrlap(3))
      equivalence(ipot,ifiles(18)),(imep,ifiles(15))
      data zero/0.0d0/,one/1.0d0/,two/2.0d0/,three/3.0d0/
      data pt75/0.75d0/,onpt75/1.75d0/,onpt25/1.25d0/,twopt5/2.5d0/
      data thrpt5/3.5d0/,four/4.0d0/,twpt25/2.25d0/,f15/15.0d0/
      data forpt5/4.5d0/,thrsh/0.1d-04/,tenm6/1.0d-06/
      data onept5/1.5d0/
      data rone/1.0d0/
      data iao1s/'    1s'/
      data iao2s/'    2s'/,iao2p/'    2p'/
      data iao3s/'    3s'/,iao3p/'    3p'/
      data iao4s/'    4s'/,iao4p/'    4p'/
      data iao5s/'    5s'/,iao5p/'    5p'/
      data iao6s/'    6s'/,iao6p/'    6p'/
      data iao7s/'    7s'/,iao7p/'    7p'/
      conv=fpc(ifpc,4)*fpc(ifpc,9)
      recpa0=1.d0/fpc(ifpc,3)
      i=index(jobnam,' ')-1
      open(unit=iw,file=jobnam(:i)//'.out',status='unknown')
      rewind iw
c     transform several variables
c
      natoms=numat
      nae=nalpha
      nbe=nbeta
      ne=nelecs
      sum=0.5d00
      do 10 i=1,natoms
   10 sum=sum+core(nat(i))
      i=sum
      icharg=i-nclose-nopen-nalpha-nbeta
c
c     put cartesian coordinates in array c
c
      call gmetry(geo,cc)
      do 20 i=1,numat
         do 20 j=1,3
            c(i,j)=cc(j,i)
            c(i,j)=c(i,j)*recpa0      
   20 continue
c
c     set up a sto-4g basis adapted to mopac-sto's.
c     common /b/ is filled
c
      mm=1
      mmdf=1
      nshell=0
      ngauss=4
      nstart=1
      do 220 i=1,natoms
         ian(i)=nat(i)
c***********************************************************************
c        1s shell (converted in sto-4g, each gto with ng=1
c***********************************************************************
         ia=ian(i)
         if (ia-2) 30,30,40
   30    j1=mm
         exx(j1)=(zs(ia)**2)*13.11790
         c1(j1)=0.019508d0
         c2(j1)=zero
         exx(j1+1)=(zs(ia)**2)*1.97108d0
         c1(j1+1)=0.137622d0
         c2(j1+1)=zero
         exx(j1+2)=(zs(ia)**2)*0.444645d0
         c1(j1+2)=0.479541d0
         c2(j1+2)=zero
         exx(j1+3)=(zs(ia)**2)*0.121676d0
         c1(j1+3)=0.500553d0
         c2(j1+3)=zero
         nshell=nshell+1
         x(nshell)=c(i,1)
         y(nshell)=c(i,2)
         z(nshell)=c(i,3)
         jan(nshell)=core(nat(i))
         shella(nshell)=mm
         shladf(nshell)=0
         shelln(nshell)=ngauss
         shellt(nshell)=0
         shellc(nshell)=2
         shellx(nshell)=i
         scale(nshell)=rone
         aon(nshell)=iao1s
         aos(nshell)=nstart
         iaos(nshell)=nstart
         nstart=nstart+1
         mm=mm+ngauss
         goto 220
c***********************************************************************
c        2s shell (converted in sto-4g, each gto with ng=1
c***********************************************************************
   40    if (ia-10) 50,50,70
   50    j1=mm
         exx(j1)=((2.0d0*zs(ia))**2)*4.659200d0
         c1(j1)=-0.008762d0
         c2(j1)=zero
         exx(j1+1)=((2.0d0*zs(ia))**2)*0.554244d0
         c1(j1+1)=-0.057567d0
         c2(j1+1)=zero
         exx(j1+2)=((2.0d0*zs(ia))**2)*0.0403319d0
         c1(j1+2)=0.568282d0
         c2(j1+2)=zero
         exx(j1+3)=((2.0d0*zs(ia))**2)*0.0155519d0
         c1(j1+3)=0.487628d0
         c2(j1+3)=zero
         nshell=nshell+1
         x(nshell)=c(i,1)
         y(nshell)=c(i,2)
         z(nshell)=c(i,3)
         jan(nshell)=core(nat(i))
         shella(nshell)=mm
         shladf(nshell)=0
         shelln(nshell)=ngauss
         shellt(nshell)=0
         shellc(nshell)=2
         shellx(nshell)=i
         scale(nshell)=rone
         aon(nshell)=iao2s
         aos(nshell)=nstart
         iaos(nshell)=nstart
         nstart=nstart+1
         mm=mm+ngauss
         if (ia-4) 220,220,60
c***********************************************************************
c        2p shell (converted in sto-4g, each gto with ng=2
c***********************************************************************
   60    j1=mm
         exx(j1)=((2.0d0*zp(ia))**2)*0.722447d0
         c1(j1)=zero
         c2(j1)=0.027090d0
         exx(j1+1)=((2.0d0*zp(ia))**2)*0.171826d0
         c1(j1+1)=zero
         c2(j1+1)=0.185828d0
         exx(j1+2)=((2.0d0*zp(ia))**2)*0.0552204d0
         c1(j1+2)=zero
         c2(j1+2)=0.532171d0
         exx(j1+3)=((2.0d0*zp(ia))**2)*0.0200790d0
         c1(j1+3)=zero
         c2(j1+3)=0.410307d0
         nshell=nshell+1
         x(nshell)=c(i,1)
         y(nshell)=c(i,2)
         z(nshell)=c(i,3)
         jan(nshell)=core(nat(i))
         shella(nshell)=mm
         shladf(nshell)=0
         shelln(nshell)=ngauss
         shellt(nshell)=1
         shellc(nshell)=1
         shellx(nshell)=i
         scale(nshell)=rone
         aon(nshell)=iao2p
         aos(nshell)=nstart-1
         iaos(nshell)=nstart
         nstart=nstart+3
         mm=mm+ngauss
         goto 220
c***********************************************************************
c        3s shell (converted in sto-4g, each gto with ng=1
c***********************************************************************
   70    if (ia-18) 80,80,100
   80    j1=mm
         exx(j1)=((3.0d0*zs(ia))**2)*0.217189
         c1(j1)=-0.023073
         c2(j1)=zero
         exx(j1+1)=((3.0d0*zs(ia))**2)*0.0517494
         c1(j1+1)=-0.173782
         c2(j1+1)=zero
         exx(j1+2)=((3.0d0*zs(ia))**2)*0.00808293
         c1(j1+2)=0.816385
         c2(j1+2)=zero
         exx(j1+3)=((3.0d0*zs(ia))**2)*0.00387327
         c1(j1+3)=0.285658
         c2(j1+3)=zero
         nshell=nshell+1
         x(nshell)=c(i,1)
         y(nshell)=c(i,2)
         z(nshell)=c(i,3)
         jan(nshell)=core(nat(i))
         shella(nshell)=mm
         shladf(nshell)=0
         shelln(nshell)=ngauss
         shellt(nshell)=0
         shellc(nshell)=2
         shellx(nshell)=i
         scale(nshell)=rone
         aon(nshell)=iao3s
         aos(nshell)=nstart
         iaos(nshell)=nstart
         nstart=nstart+1
         mm=mm+ngauss
         if (ia-12) 220,220,90
c***********************************************************************
c        3p shell (converted in sto-4g, each gto with ng=2
c***********************************************************************
   90    j1=mm
         exx(j1)=((3.0d0*zp(ia))**2)*0.232988d0
         c1(j1)=zero
         c2(j1)=-0.013778d0
         exx(j1+1)=((3.0d0*zp(ia))**2)*0.0215155d0
         c1(j1+1)=zero
         c2(j1+1)=0.253019d0
         exx(j1+2)=((3.0d0*zp(ia))**2)*0.0102710d0
         c1(j1+2)=zero
         c2(j1+2)=0.545086d0
         exx(j1+3)=((3.0d0*zp(ia))**2)*0.00505386d0
         c1(j1+3)=zero
         c2(j1+3)=0.275099d0
         nshell=nshell+1
         x(nshell)=c(i,1)
         y(nshell)=c(i,2)
         z(nshell)=c(i,3)
         jan(nshell)=core(nat(i))
         shella(nshell)=mm
         shladf(nshell)=0
         shelln(nshell)=ngauss
         shellt(nshell)=1
         shellc(nshell)=1
         shellx(nshell)=i
         scale(nshell)=rone
         aon(nshell)=iao3p
         aos(nshell)=nstart-1
         iaos(nshell)=nstart
         nstart=nstart+3
         mm=mm+ngauss
         goto 220
c***********************************************************************
c        4s shell (converted in sto-4g, each gto with ng=1
c***********************************************************************
  100    if (ia-36) 110,110,130
  110    j1=mm
         exx(j1)=((4.0d0*zs(ia))**2)*0.0164505d0
         c1(j1)=-0.223592d0
         c2(j1)=zero
         exx(j1+1)=((4.0d0*zs(ia))**2)*0.00738627d0
         c1(j1+1)=-0.258521d0
         c2(j1+1)=zero
         exx(j1+2)=((4.0d0*zs(ia))**2)*0.00350378d0
         c1(j1+2)=0.858128d0
         c2(j1+2)=zero
         exx(j1+3)=((4.0d0*zs(ia))**2)*0.00188555d0
         c1(j1+3)=0.471043d0
         c2(j1+3)=zero
         nshell=nshell+1
         x(nshell)=c(i,1)
         y(nshell)=c(i,2)
         z(nshell)=c(i,3)
         jan(nshell)=core(nat(i))
         shella(nshell)=mm
         shladf(nshell)=0
         shelln(nshell)=ngauss
         shellt(nshell)=0
         shellc(nshell)=2
         shellx(nshell)=i
         scale(nshell)=rone
         aon(nshell)=iao4s
         aos(nshell)=nstart
         iaos(nshell)=nstart
         nstart=nstart+1
         mm=mm+ngauss
         if (ia-20) 220,220,120
c***********************************************************************
c        4p shell (converted in sto-4g, each gto with ng=2
c***********************************************************************
  120    j1=mm
         exx(j1)=((4.0d0*zp(ia))**2)*0.0858757d0
         c1(j1)=zero
         c2(j1)=-0.007342d0
         exx(j1+1)=((4.0d0*zp(ia))**2)*0.0259767d0
         c1(j1+1)=zero
         c2(j1+1)=-0.060896d0
         exx(j1+2)=((4.0d0*zp(ia))**2)*0.00480469d0
         c1(j1+2)=zero
         c2(j1+2)=0.622636d0
         exx(j1+3)=((4.0d0*zp(ia))**2)*0.00236631d0
         c1(j1+3)=zero
         c2(j1+3)=0.435991d0
         nshell=nshell+1
         x(nshell)=c(i,1)
         y(nshell)=c(i,2)
         z(nshell)=c(i,3)
         jan(nshell)=core(nat(i))
         shella(nshell)=mm
         shladf(nshell)=0
         shelln(nshell)=ngauss
         shellt(nshell)=1
         shellc(nshell)=1
         shellx(nshell)=i
         scale(nshell)=rone
         aon(nshell)=iao4p
         aos(nshell)=nstart-1
         iaos(nshell)=nstart
         nstart=nstart+3
         mm=mm+ngauss
         goto 220
c***********************************************************************
c        5s shell (converted in sto-4g, each gto with ng=1
c***********************************************************************
  130    if (ia-54) 140,140,160
  140    j1=mm
         exx(j1)=((5.0d0*zs(ia))**2)*0.0336773d0
         c1(j1)=0.011685d0
         c2(j1)=zero
         exx(j1+1)=((5.0d0*zs(ia))**2)*0.00481262d0
         c1(j1+1)=-0.549835d0
         c2(j1+1)=zero
         exx(j1+2)=((5.0d0*zs(ia))**2)*0.00134481d0
         c1(j1+2)=1.225552d0
         c2(j1+2)=zero
         exx(j1+3)=((5.0d0*zs(ia))**2)*0.000722522d0
         c1(j1+3)=0.115940d0
         c2(j1+3)=zero
         nshell=nshell+1
         x(nshell)=c(i,1)
         y(nshell)=c(i,2)
         z(nshell)=c(i,3)
         jan(nshell)=core(nat(i))
         shella(nshell)=mm
         shladf(nshell)=0
         shelln(nshell)=ngauss
         shellt(nshell)=0
         shellc(nshell)=2
         shellx(nshell)=i
         scale(nshell)=rone
         aon(nshell)=iao5s
         aos(nshell)=nstart
         iaos(nshell)=nstart
         nstart=nstart+1
         mm=mm+ngauss
         if (ia-38) 220,220,150
c***********************************************************************
c        5p shell (converted in sto-4g, each gto with ng=2
c***********************************************************************
  150    j1=mm
         exx(j1)=((5.0d0*zp(ia))**2)*0.0138998d0
         c1(j1)=zero
         c2(j1)=-0.027559d0
         exx(j1+1)=((5.0d0*zp(ia))**2)*0.00696561d0
         c1(j1+1)=zero
         c2(j1+1)=-0.131581d0
         exx(j1+2)=((5.0d0*zp(ia))**2)*0.00201055d0
         c1(j1+2)=zero
         c2(j1+2)=0.732336d0
         exx(j1+3)=((5.0d0*zp(ia))**2)*0.00112114d0
         c1(j1+3)=zero
         c2(j1+3)=0.367027d0
         nshell=nshell+1
         x(nshell)=c(i,1)
         y(nshell)=c(i,2)
         z(nshell)=c(i,3)
         jan(nshell)=core(nat(i))
         shella(nshell)=mm
         shladf(nshell)=0
         shelln(nshell)=ngauss
         shellt(nshell)=1
         shellc(nshell)=1
         shellx(nshell)=i
         scale(nshell)=rone
         aon(nshell)=iao5p
         aos(nshell)=nstart-1
         iaos(nshell)=nstart
         nstart=nstart+3
         mm=mm+ngauss
         goto 220
c***********************************************************************
c        6s shell (converted in sto-4g, each gto with ng=1
c***********************************************************************
  160    if (ia-86) 170,170,190
  170    j1=mm
         exx(j1)=((6.0d0*zs(ia))**2)*0.00906589d0
         c1(j1)=0.046421d0
         c2(j1)=zero
         exx(j1+1)=((6.0d0*zs(ia))**2)*0.00207602d0
         c1(j1+1)=-0.890119d0
         c2(j1+1)=zero
         exx(j1+2)=((6.0d0*zs(ia))**2)*0.000818469d0
         c1(j1+2)=1.227342d0
         c2(j1+2)=zero
         exx(j1+3)=((6.0d0*zs(ia))**2)*0.000533131d0
         c1(j1+3)=0.385413d0
         c2(j1+3)=zero
         nshell=nshell+1
         x(nshell)=c(i,1)
         y(nshell)=c(i,2)
         z(nshell)=c(i,3)
         jan(nshell)=core(nat(i))
         shella(nshell)=mm
         shladf(nshell)=0
         shelln(nshell)=ngauss
         shellt(nshell)=0
         shellc(nshell)=2
         shellx(nshell)=i
         scale(nshell)=rone
         aon(nshell)=iao6s
         aos(nshell)=nstart
         iaos(nshell)=nstart
         nstart=nstart+1
         mm=mm+ngauss
         if (ia-56) 220,220,180
c***********************************************************************
c        6p shell (converted in sto-4g, each gto with ng=2
c***********************************************************************
  180    j1=mm
         exx(j1)=((6.0d0*zp(ia))**2)*0.0243358d0
         c1(j1)=zero
         c2(j1)=0.001725d0
         exx(j1+1)=((6.0d0*zp(ia))**2)*0.00328534d0
         c1(j1+1)=zero
         c2(j1+1)=-0.247801d0
         exx(j1+2)=((6.0d0*zp(ia))**2)*0.000968191d0
         c1(j1+2)=zero
         c2(j1+2)=0.932682d0
         exx(j1+3)=((6.0d0*zp(ia))**2)*0.000567636d0
         c1(j1+3)=zero
         c2(j1+3)=0.213929d0
         nshell=nshell+1
         x(nshell)=c(i,1)
         y(nshell)=c(i,2)
         z(nshell)=c(i,3)
         jan(nshell)=core(nat(i))
         shella(nshell)=mm
         shladf(nshell)=0
         shelln(nshell)=ngauss
         shellt(nshell)=1
         shellc(nshell)=1
         shellx(nshell)=i
         scale(nshell)=rone
         aon(nshell)=iao6p
         aos(nshell)=nstart-1
         iaos(nshell)=nstart
         nstart=nstart+3
         mm=mm+ngauss
         goto 220
c***********************************************************************
c        7s shell (converted in sto-4g, each gto with ng=1
c***********************************************************************
  190    if (ia-104) 200,200,220
  200    j1=mm
         exx(j1)=((7.0d0*zs(ia))**2)*0.00324143d0
         c1(j1)=0.144821d0
         c2(j1)=zero
         exx(j1+1)=((7.0d0*zs(ia))**2)*0.00113212d0
         c1(j1+1)=-1.240536d0
         c2(j1+1)=zero
         exx(j1+2)=((7.0d0*zs(ia))**2)*0.000471755d0
         c1(j1+2)=1.631994d0
         c2(j1+2)=zero
         exx(j1+3)=((7.0d0*zs(ia))**2)*0.000301608d0
         c1(j1+3)=0.204852d0
         c2(j1+3)=zero
         nshell=nshell+1
         x(nshell)=c(i,1)
         y(nshell)=c(i,2)
         z(nshell)=c(i,3)
         jan(nshell)=core(nat(i))
         shella(nshell)=mm
         shladf(nshell)=0
         shelln(nshell)=ngauss
         shellt(nshell)=0
         shellc(nshell)=2
         shellx(nshell)=i
         scale(nshell)=rone
         aon(nshell)=iao7s
         aos(nshell)=nstart
         iaos(nshell)=nstart
         nstart=nstart+1
         mm=mm+ngauss
         if (ia-88) 220,220,210
c***********************************************************************
c        7p shell (converted in sto-4g, each gto with ng=2
c***********************************************************************
  210    j1=mm
         exx(j1)=((7.0d0*zp(ia))**2)*0.00635421d0
         c1(j1)=zero
         c2(j1)=0.0011476d0
         exx(j1+1)=((7.0d0*zp(ia))**2)*0.00154903d0
         c1(j1+1)=zero
         c2(j1+1)=-0.404467d0
         exx(j1+2)=((7.0d0*zp(ia))**2)*0.000579597d0
         c1(j1+2)=zero
         c2(j1+2)=1.007520d0
         exx(j1+3)=((7.0d0*zp(ia))**2)*0.000367363d0
         c1(j1+3)=zero
         c2(j1+3)=0.253181d0
         nshell=nshell+1
         x(nshell)=c(i,1)
         y(nshell)=c(i,2)
         z(nshell)=c(i,3)
         jan(nshell)=core(nat(i))
         shella(nshell)=mm
         shladf(nshell)=0
         shelln(nshell)=ngauss
         shellt(nshell)=1
         shellc(nshell)=1
         shellx(nshell)=i
         scale(nshell)=rone
         aon(nshell)=iao6p
         aos(nshell)=nstart-1
         iaos(nshell)=nstart
         nstart=nstart+3
         mm=mm+ngauss
  220 continue
      aos(nshell+1)=nstart
      iaos(nshell+1)=nstart
      nbasis=nstart-1
c
c     sto's have been transformed in gaussian functions
c     write table of gaussian functions
c
      if (mflag.eq.0) call bprint
c
c     now gaussian functions are normalized
c
  230 format(39h significant renormalization required  ,e20.10)
      sqrt2= dsqrt(two)
      pi=four* datan(1.d0)
      toovpi=two/pi
      pito75=pi**pt75
      fcon=(two/pito75)* dsqrt(two/f15)
      twort3=two/ dsqrt(three)
      delfin=zero
  240 do 360 ishell=1,nshell
         igbeg=shella(ishell)
         igend=igbeg+shelln(ishell)-1
         ovrs=zero
         ovrp=zero
         ovrd=zero
         ovrf=zero
         igdf=shladf(ishell)
         do 280 igauss=igbeg,igend
            jgdf=shladf(ishell)
            do 260 jgauss=igbeg,igend
               axb=four*exx(igauss)*exx(jgauss)
               aplusb=exx(igauss)+exx(jgauss)
               ovrs=ovrs+(c1(igauss)*c1(jgauss))*((axb**pt75)/(aplusb**o
     1nept5))
               ovrp=ovrp+(c2(igauss)*c2(jgauss))*((axb**onpt25)/(aplusb*
     1*twopt5))
               if(igdf)260,260,250
  250          ovrd=ovrd+(c3(igdf  )*c3(jgdf  ))*((axb**onpt75)/(aplusb*
     1*thrpt5))
               ovrf=ovrf+(c4(igdf  )*c4(jgdf  ))*((axb**twpt25)/(aplusb*
     1*forpt5))
               jgdf=jgdf+1
  260       continue
            if(igdf)280,280,270
  270       igdf=igdf+1
  280    continue
         do 330 i=1,4
            if(ovrlap(i)-thrsh)290,290,300
  290       ovrlap(i)=zero
            go to 330
  300       del= dabs(1.d0-ovrlap(i))
            if(del-delfin)320,310,310
  310       delfin=del
  320       ovrlap(i)=1.d0/ dsqrt(ovrlap(i))
  330    continue
         igdf=shladf(ishell)
         do 350 igauss=igbeg,igend
            c1(igauss)=c1(igauss)*ovrs
            c2(igauss)=c2(igauss)*ovrp
            if(igdf)350,350,340
  340       c3(igdf)=c3(igdf)*ovrd
            c4(igdf)=c4(igdf)*ovrf
            igdf=igdf+1
  350    continue
  360 continue
  370 if(dabs(delfin)-tenm6)390,390,380
  380 write(ipot,230)delfin
  390 do 410 ishell=1,nshell
         igbeg=shella(ishell)
         igend=igbeg+shelln(ishell)-1
         igdf=shladf(ishell)
         do 410 igauss=igbeg,igend
            c1(igauss)=c1(igauss)*((toovpi*exx(igauss))**pt75)
            c2(igauss)=c2(igauss)*sqrt2*((two*exx(igauss))**onpt25)/pito
     175
            if(igdf)410,410,400
  400       c3(igdf  )=c3(igdf  )*twort3*((two*exx(igauss))**onpt75)/pit
     1o75
            c4(igdf  )=c4(igdf  )*fcon*(two*exx(igauss))**twpt25
  410 continue
c
c     end of renormalization process
c
c     computation of grid points
c
c     first examine the option mst solvation model
c
      if (index(keywrd,'tom').ne.0) then
         if(mflag.eq.0) then
            call pedra
         end if
         ipr=1
         nts2=nts*2
         write(ipot,440) iterq
         write(ipot,460)
         write(ipot,490)
         npp=1
         ny=1
         do 430 k=1,nts2
            xv(1,1)=xv1(k)
            yv(1,1)=yv1(k)
            zv(1,1)=zv1(k)
            valv(1,1)=zero
            call cadima
            vpot(k)=valv(1,1)
            do 420 i=1,numat
               if(nat(i).eq.0) goto 420
               ax=xv(1,1)-c(i,1)
               ay=yv(1,1)-c(i,2)
               az=zv(1,1)-c(i,3)
               r=dsqrt(ax*ax+ay*ay+az*az)
               vpot(k)=vpot(k)+core(nat(i))/r
  420       continue
            vpot(k)=vpot(k)*factor
            write(ipot,480) k,xv(1,1),yv(1,1),zv(1,1),vpot(k)*conv
            ipr=ipr+1
  430    continue
         return
  440    format(//,12hiteration = ,i2,//)
      end if
c
c     else determine points where mep will be computed
c
  450 format(i4,17f4.0)
  460 format(1h1,2x,'potential values in kcal/mole',///)
  470 format(f13.5,3x,f13.5,3x,f13.5,9x,f13.5)
  480 format(i4,f13.5,3x,f13.5,3x,f13.5,9x,f13.5)
  490 format(1h1,' coordinates of the points on the map in a. u.',///)
      npa=nint(reada(keywrd,index(keywrd,'mep=')))
      if (npa.eq.1) goto 580
c
c     mep computed on connolly's surface
c
  500 format(/10x,'vander waal radii scale factor = ',f5.2)
  510 format(/10x,'parameter for surface generation',//10x,
     1            'initial vander waal radii scale factor =',f5.2,
     2       /10x,'scale factor increment value           =',f5.2,
     3       /10x,'density of points per unit area        =',f5.2,
     4       /10x,'number of surfaces to be generated     =',i5,//)
      write(ipot,510) scle,scincr,den,nsurf
      it345=0
      do 520 i = 1,nsurf
         it455=it345
         call surfat(scle,den,it345,vwxyz)
         it455=it345-it455
         write(ipot,*) 'surface ',i,' : ',it455,' points'
         scle = scle + scincr
  520 continue
      write(ipot,*) 'total     : ',it345,' points'
      do 530 i=1,it345
         do 530 j=1,3
            vwxyz(j,i)=vwxyz(j,i)*recpa0      
  530 continue
      itutua=1000000
      do 550 i=55,1,-1
         do 540 j=1,64
            if (i*j.gt.it345) goto 550
            idif(i,j)=iabs(it345-i*j)
            if (idif(i,j).eq.0) then
               npp=i
               ny=j
               goto 560
            else if (idif(i,j).gt.itutua) then
               goto 540
            else
               itutua=idif(i,j)
               npp=i
               ny=j
            end if
  540    continue
  550 continue
  560 continue
      do 570 i=1,npp
         do 570 j=1,ny
            xv(i,j)=vwxyz(1,j+(i-1)*ny)
            yv(i,j)=vwxyz(2,j+(i-1)*ny)
            zv(i,j)=vwxyz(3,j+(i-1)*ny)
c     valv(i,j)=zero
  570 continue
      goto 790
c
c     mep computed in a cubic grid of points
c
c              a................dyd=ds*3/5...................c
c              -                   ny '64'
c              -
c              -
c              -
c              -
c              ds  npp '55'
c              -
c              -
c              -
c              -
c              b
c
  580 dss=ds
  590 app=dsqrt((xp1(1)-xp1(2))**2+(yp1(1)-yp1(2))**2+
     +          (zp1(1)-zp1(2))**2)
      if(app-0.00001d0) 600,600,610
  600 pn=0.0d0
      dx=0.0d0
      dy=0.0d0
      dz=0.0d0
      go to 620
  610 pn=app/ds
      dx=(xp1(2)-xp1(1))/pn
      dy=(yp1(2)-yp1(1))/pn
      dz=(zp1(2)-zp1(1))/pn
  620 add=dsqrt((xp1(1)-xp1(3))**2+(yp1(1)-yp1(3))**2+
     +          (zp1(1)-zp1(3))**2)
      if(add-0.00001d0) 630,630,640
  630 yn=0.0d0
      dx2=0.0d0
      dy2=0.0d0
      dz2=0.0d0
      go to 650
  640 dyd=ds*3.d0/5.d0
      yn=add/dyd
      dx2=(xp1(3)-xp1(1))/yn
      dy2=(yp1(3)-yp1(1))/yn
      dz2=(zp1(3)-zp1(1))/yn
  650 ny=yn+0.9+1.
      if(ny.gt.64) ny=64
      npp=pn+0.9+1.
      if(npp.gt.55) npp=55
      baint=dfloat(npp)*ds-ds
      caint=dfloat(ny)*dyd-dyd
  660 write(ipot,670)
  670 format(1h1,2x,15h     x(a.u.)   ,15h     y(a.u.)   ,
     115h     z(a.u.)   )
      write(ipot,680) xp1(1),yp1(1),zp1(1)
      write(ipot,690) xp1(2),yp1(2),zp1(2)
      write(ipot,700) xp1(3),yp1(3),zp1(3)
      write(ipot,710) dx,dy,dz
      write(ipot,720) dx2,dy2,dz2
      write(ipot,730) npp,ny
      write(ipot,740) app,baint
      write(ipot,750) add,caint
  680 format(4x,10hcoord.of a,5x,3(1x,f13.7,1x))
  690 format(4x,10hcoord.of b,5x,3(1x,f13.7,1x))
  700 format(4x,10hcoord.of c,5x,3(1x,f13.7,1x))
  710 format(4x,10hvert. inc.,5x,3(1x,f13.7,1x))
  720 format(4x,10hhoriz.inc.,5x,3(1x,f13.7,1x))
  730 format(4x,15hmap dimension :,2x,i4,2x,i4)
  740 format(4x,18hlength ab required,f12.7,2x,9heffective,f12.7)
  750 format(4x,18hlength ac required,f12.7,2x,9heffective,f12.7)
      xv(1,1)=xp1(1)
      yv(1,1)=yp1(1)
      zv(1,1)=zp1(1)
c     valv(1,1)=zero
      if (npp.eq.1.and.ny.eq.1) go to 790
      do 780 i=1,npp
         if (i.eq.1) go to 760
         xv(i,1)=xv(i-1,1)+dx
         yv(i,1)=yv(i-1,1)+dy
         zv(i,1)=zv(i-1,1)+dz
  760    continue
         do 770 j=1,ny
            if (j.eq.1) go to 770
            xv(i,j)=xv(i,j-1)+dx2
            yv(i,j)=yv(i,j-1)+dy2
            zv(i,j)=zv(i,j-1)+dz2
  770    continue
c51   valv(i,j)=zero
  780 continue
c
c     points have been determined and the array valv has
c     been set equal to zero
c     now mep will be computed at these points
c     first initialize the array valv
c
  790 continue
      do 800 i=1,npp
         do 800 j=1,ny
  800 valv(i,j)=zero
c
c     compute the electrostatic electron contribution
c
      call cadima
c7005 call cadima
c
c     now the nuclear contribution is added to the array valv
c
      do 820 i=1,numat
         if (nat(i).eq.0) go to 820
         do 810 j1=1,npp
            do 810 j2=1,ny
               ax=xv(j1,j2)-c(i,1)
               ay=yv(j1,j2)-c(i,2)
               az=zv(j1,j2)-c(i,3)
               r=dsqrt(ax*ax+ay*ay+az*az)
               valv(j1,j2)=valv(j1,j2)+core(nat(i))/r
  810    continue
  820 continue
c
c     mep has been computed and stored in array valv
c
c     if (index(keywrd,'tom').ne.0) then
c     write(ipot,614) iterq
c     end if
c14   format(//,12hiteration = ,i2,//)
  830 write(ipot,460)
      write(ipot,490)
c
c     if mst, transform valv in vpot and values are written
c
c     if (index(keywrd,'tom').ne.0) then
c     k=0
c     do 610 i=1,npp
c     do 610 j=1,ny
c     k=k+1
c     vpot(k)=valv(i,j)
c     write(ipot,613) k,xv(i,j),yv(i,j),zv(i,j),valv(i,j)*conv
c10   continue
c     return
c     end if
      do 850 ir=1,npp
         do 840 jr=1,ny
          write(ipot,470) xv(ir,jr),yv(ir,jr),zv(ir,jr),valv(ir,jr)*conv
  840    continue
  850 write(ipot,860)
  860 format(///)
      if(npp.eq.1.and.ny.eq.1) go to 920
c     creates plot output file according to iplot
c8555 if (npa.eq.2) go to 8000
      iplane=1
      if (dabs(dx).gt.0.00001d0.or.dabs(dx2).gt.0.00001d0) then
         iplane=2
         if (dabs(dy).gt.0.00001d0.or.dabs(dy2).gt.0.00001d0) iplane=3
      end if
      write(imep,870) natoms,iplane,npp*ny
  870 format(i4,3x,i1,3x,i5)
      do 880 i=1,natoms
  880 write(imep,890) ian(i),c(i,1),c(i,2),c(i,3)
  890 format(1x,i3,3(1x,f12.7))
      do 900 ir=1,npp
         do 900 jr=1,ny
          write(imep,910) xv(ir,jr),yv(ir,jr),zv(ir,jr),valv(ir,jr)*conv
  900 continue
  910 format(3(1x,f12.7),1x,f13.5)
  920 return
      end
      subroutine pedra
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      common c(numatm,3),natoms,icharg,multip,ian(numatm),nae,nbe,nel,
     1nbasis
c     common antoau,fconv(3),icdum(131)
      common /mstsur/omega,rd,ret,fro,dr,ndiv,nesf,icent
      common/mstxyz/xv(3575),yv(3575),zv(3575),nts
      common/poly/xe(500),ye(500),ze(500),re(500),
     1ssfe(500),
     2iploch(1500),as(1500),stot,vol,nsf,nc(numatm)
      common/mstq/qs(1500),mflag,iterq
      common/clases/iclass(numatm)
      common/mopfin/gvw,gvws,elc1,ec1
      common /funcon/ fpc(2,10),ifpc
      dimension x0(1500),y0(1500),z0(1500),
     1sre(500)
      dimension xv1(1500),yv1(1500),zv1(1500),rv1(1500)
c     dimension x9(1500),y9(1500),z9(1500),x91(1500),y91(1500)
c     dimension z91(1500),qxy(1500),qxy2(1500),pot2(1500)
c     dimension scr1(10726),scr2(4880)
c     equivalence (scr1(1),xv(1)),(scr2(1),xe(1))
      dimension idum(360)
      dimension jm(60)
      dimension asp(60),thec(12),fic(12),thev(24),fiv(24),jvt1(6,60)
      dimension jvt2(3,4),fm(4),cv(122,3),xc(60),yc(60),zc(60),idf(122)
      dimension ije(60),nv(6),cvn3(6,3),idf3(6),cvn4(6,3),idf4(6)
      dimension cvn5(6,3),idf5(6)
      common /chanel/ ifiles(30)
      equivalence (iw,ifiles(6)),(isol,ifiles(17))
      equivalence (idum(1),jvt1(1,1))
c
c     data iout/6/,in/5/
      data two/2.d0/,four/4.d0/
      data one/1.0d0/,md/6/
      data thec/0.3625764052d0,0.7445723125d0,1.028422216 d0,
     1          1.028422216 d0,1.408599564 d0,1.408599564 d0,
     2          1.732993090 d0,1.732993090 d0,2.113170438 d0,
     3          2.113170438 d0,2.397020341 d0,2.779016248 d0/
      data fic/0.0d0         ,0.0d0         ,0.8518232700d0,
     1         0.4048137915d0,1.043782503 d0,0.2128545579d0,
     2         0.4154639728d0,0.8411730887d0,0.2235047392d0,
     3         1.033132322 d0,0.6283185307d0,0.6283185307d0/
      data thev/0.6523581398d0,1.107148718 d0,1.382085796 d0,
     1          1.759506858 d0,2.034443936 d0,2.489234514 d0,
     2                         0.3261790699d0,0.5535743589d0,
     3          0.8559571251d0,0.8559571251d0,1.017221968 d0,
     4          1.229116717 d0,1.229116717 d0,1.433327788 d0,
     5          1.570796327 d0,1.570796327 d0,1.708264866 d0,
     6          1.912475937 d0,1.912475937 d0,2.124370686 d0,
     7          2.285635528 d0,2.285635528 d0,2.588018295 d0,
     8          2.815413584 d0/
      data fiv/               0.6283185307d0,0.0000000000d0,
     1         0.6283185307d0,0.0000000000d0,0.6283185307d0,
     2         0.0000000000d0,0.6283185307d0,0.0000000000d0,
     3         0.2520539002d0,1.004583161 d0,0.6283185307d0,
     4         0.3293628477d0,0.9272742138d0,0.0000000000d0,
     5         0.3141592654d0,0.9424777961d0,0.6283185307d0,
     6         0.2989556830d0,0.9576813784d0,0.0000000000d0,
     7         0.3762646305d0,0.8803724309d0,0.6283188307d0,
     8         0.0000000000d0/
      data fir/1.256637061 d0/
      data idum(  1)/   1/
      data idum(  2)/   6/
      data idum(  3)/   2/
      data idum(  4)/  32/
      data idum(  5)/  36/
      data idum(  6)/  37/
      data idum(  7)/   1/
      data idum(  8)/   2/
      data idum(  9)/   3/
      data idum( 10)/  33/
      data idum( 11)/  32/
      data idum( 12)/  38/
      data idum( 13)/   1/
      data idum( 14)/   3/
      data idum( 15)/   4/
      data idum( 16)/  34/
      data idum( 17)/  33/
      data idum( 18)/  39/
      data idum( 19)/   1/
      data idum( 20)/   4/
      data idum( 21)/   5/
      data idum( 22)/  35/
      data idum( 23)/  34/
      data idum( 24)/  40/
      data idum( 25)/   1/
      data idum( 26)/   5/
      data idum( 27)/   6/
      data idum( 28)/  36/
      data idum( 29)/  35/
      data idum( 30)/  41/
      data idum( 31)/   7/
      data idum( 32)/   2/
      data idum( 33)/   6/
      data idum( 34)/  51/
      data idum( 35)/  42/
      data idum( 36)/  37/
      data idum( 37)/   8/
      data idum( 38)/   3/
      data idum( 39)/   2/
      data idum( 40)/  47/
      data idum( 41)/  43/
      data idum( 42)/  38/
      data idum( 43)/   9/
      data idum( 44)/   4/
      data idum( 45)/   3/
      data idum( 46)/  48/
      data idum( 47)/  44/
      data idum( 48)/  39/
      data idum( 49)/  10/
      data idum( 50)/   5/
      data idum( 51)/   4/
      data idum( 52)/  49/
      data idum( 53)/  45/
      data idum( 54)/  40/
      data idum( 55)/  11/
      data idum( 56)/   6/
      data idum( 57)/   5/
      data idum( 58)/  50/
      data idum( 59)/  46/
      data idum( 60)/  41/
      data idum( 61)/   8/
      data idum( 62)/   2/
      data idum( 63)/  12/
      data idum( 64)/  62/
      data idum( 65)/  47/
      data idum( 66)/  52/
      data idum( 67)/   9/
      data idum( 68)/   3/
      data idum( 69)/  13/
      data idum( 70)/  63/
      data idum( 71)/  48/
      data idum( 72)/  53/
      data idum( 73)/  10/
      data idum( 74)/   4/
      data idum( 75)/  14/
      data idum( 76)/  64/
      data idum( 77)/  49/
      data idum( 78)/  54/
      data idum( 79)/  11/
      data idum( 80)/   5/
      data idum( 81)/  15/
      data idum( 82)/  65/
      data idum( 83)/  50/
      data idum( 84)/  55/
      data idum( 85)/   7/
      data idum( 86)/   6/
      data idum( 87)/  16/
      data idum( 88)/  66/
      data idum( 89)/  51/
      data idum( 90)/  56/
      data idum( 91)/   7/
      data idum( 92)/  12/
      data idum( 93)/   2/
      data idum( 94)/  42/
      data idum( 95)/  57/
      data idum( 96)/  52/
      data idum( 97)/   8/
      data idum( 98)/  13/
      data idum( 99)/   3/
      data idum(100)/  43/
      data idum(101)/  58/
      data idum(102)/  53/
      data idum(103)/   9/
      data idum(104)/  14/
      data idum(105)/   4/
      data idum(106)/  44/
      data idum(107)/  59/
      data idum(108)/  54/
      data idum(109)/  10/
      data idum(110)/  15/
      data idum(111)/   5/
      data idum(112)/  45/
      data idum(113)/  60/
      data idum(114)/  55/
      data idum(115)/  11/
      data idum(116)/  16/
      data idum(117)/   6/
      data idum(118)/  46/
      data idum(119)/  61/
      data idum(120)/  56/
      data idum(121)/   8/
      data idum(122)/  12/
      data idum(123)/  18/
      data idum(124)/  68/
      data idum(125)/  62/
      data idum(126)/  77/
      data idum(127)/   9/
      data idum(128)/  13/
      data idum(129)/  19/
      data idum(130)/  69/
      data idum(131)/  63/
      data idum(132)/  78/
      data idum(133)/  10/
      data idum(134)/  14/
      data idum(135)/  20/
      data idum(136)/  70/
      data idum(137)/  64/
      data idum(138)/  79/
      data idum(139)/  11/
      data idum(140)/  15/
      data idum(141)/  21/
      data idum(142)/  71/
      data idum(143)/  65/
      data idum(144)/  80/
      data idum(145)/   7/
      data idum(146)/  16/
      data idum(147)/  17/
      data idum(148)/  67/
      data idum(149)/  66/
      data idum(150)/  81/
      data idum(151)/   7/
      data idum(152)/  17/
      data idum(153)/  12/
      data idum(154)/  57/
      data idum(155)/  67/
      data idum(156)/  72/
      data idum(157)/   8/
      data idum(158)/  18/
      data idum(159)/  13/
      data idum(160)/  58/
      data idum(161)/  68/
      data idum(162)/  73/
      data idum(163)/   9/
      data idum(164)/  19/
      data idum(165)/  14/
      data idum(166)/  59/
      data idum(167)/  69/
      data idum(168)/  74/
      data idum(169)/  10/
      data idum(170)/  20/
      data idum(171)/  15/
      data idum(172)/  60/
      data idum(173)/  70/
      data idum(174)/  75/
      data idum(175)/  11/
      data idum(176)/  21/
      data idum(177)/  16/
      data idum(178)/  61/
      data idum(179)/  71/
      data idum(180)/  76/
      data idum(181)/  22/
      data idum(182)/  12/
      data idum(183)/  17/
      data idum(184)/  87/
      data idum(185)/  82/
      data idum(186)/  72/
      data idum(187)/  23/
      data idum(188)/  13/
      data idum(189)/  18/
      data idum(190)/  88/
      data idum(191)/  83/
      data idum(192)/  73/
      data idum(193)/  24/
      data idum(194)/  14/
      data idum(195)/  19/
      data idum(196)/  89/
      data idum(197)/  84/
      data idum(198)/  74/
      data idum(199)/  25/
      data idum(200)/  15/
      data idum(201)/  20/
      data idum(202)/  90/
      data idum(203)/  85/
      data idum(204)/  75/
      data idum(205)/  26/
      data idum(206)/  16/
      data idum(207)/  21/
      data idum(208)/  91/
      data idum(209)/  86/
      data idum(210)/  76/
      data idum(211)/  22/
      data idum(212)/  18/
      data idum(213)/  12/
      data idum(214)/  82/
      data idum(215)/  92/
      data idum(216)/  77/
      data idum(217)/  23/
      data idum(218)/  19/
      data idum(219)/  13/
      data idum(220)/  83/
      data idum(221)/  93/
      data idum(222)/  78/
      data idum(223)/  24/
      data idum(224)/  20/
      data idum(225)/  14/
      data idum(226)/  84/
      data idum(227)/  94/
      data idum(228)/  79/
      data idum(229)/  25/
      data idum(230)/  21/
      data idum(231)/  15/
      data idum(232)/  85/
      data idum(233)/  95/
      data idum(234)/  80/
      data idum(235)/  26/
      data idum(236)/  17/
      data idum(237)/  16/
      data idum(238)/  86/
      data idum(239)/  96/
      data idum(240)/  81/
      data idum(241)/  22/
      data idum(242)/  17/
      data idum(243)/  27/
      data idum(244)/ 102/
      data idum(245)/  87/
      data idum(246)/  97/
      data idum(247)/  23/
      data idum(248)/  18/
      data idum(249)/  28/
      data idum(250)/ 103/
      data idum(251)/  88/
      data idum(252)/  98/
      data idum(253)/  24/
      data idum(254)/  19/
      data idum(255)/  29/
      data idum(256)/ 104/
      data idum(257)/  89/
      data idum(258)/  99/
      data idum(259)/  25/
      data idum(260)/  20/
      data idum(261)/  30/
      data idum(262)/ 105/
      data idum(263)/  90/
      data idum(264)/ 100/
      data idum(265)/  26/
      data idum(266)/  21/
      data idum(267)/  31/
      data idum(268)/ 106/
      data idum(269)/  91/
      data idum(270)/ 101/
      data idum(271)/  22/
      data idum(272)/  28/
      data idum(273)/  18/
      data idum(274)/  92/
      data idum(275)/ 107/
      data idum(276)/  98/
      data idum(277)/  23/
      data idum(278)/  29/
      data idum(279)/  19/
      data idum(280)/  93/
      data idum(281)/ 108/
      data idum(282)/  99/
      data idum(283)/  24/
      data idum(284)/  30/
      data idum(285)/  20/
      data idum(286)/  94/
      data idum(287)/ 109/
      data idum(288)/ 100/
      data idum(289)/  25/
      data idum(290)/  31/
      data idum(291)/  21/
      data idum(292)/  95/
      data idum(293)/ 110/
      data idum(294)/ 101/
      data idum(295)/  26/
      data idum(296)/  27/
      data idum(297)/  17/
      data idum(298)/  96/
      data idum(299)/ 111/
      data idum(300)/  97/
      data idum(301)/  22/
      data idum(302)/  27/
      data idum(303)/  28/
      data idum(304)/ 107/
      data idum(305)/ 102/
      data idum(306)/ 112/
      data idum(307)/  23/
      data idum(308)/  28/
      data idum(309)/  29/
      data idum(310)/ 108/
      data idum(311)/ 103/
      data idum(312)/ 113/
      data idum(313)/  24/
      data idum(314)/  29/
      data idum(315)/  30/
      data idum(316)/ 109/
      data idum(317)/ 104/
      data idum(318)/ 114/
      data idum(319)/  25/
      data idum(320)/  30/
      data idum(321)/  31/
      data idum(322)/ 110/
      data idum(323)/ 105/
      data idum(324)/ 115/
      data idum(325)/  26/
      data idum(326)/  31/
      data idum(327)/  27/
      data idum(328)/ 111/
      data idum(329)/ 106/
      data idum(330)/ 116/
      data idum(331)/ 122/
      data idum(332)/  28/
      data idum(333)/  27/
      data idum(334)/ 117/
      data idum(335)/ 118/
      data idum(336)/ 112/
      data idum(337)/ 122/
      data idum(338)/  29/
      data idum(339)/  28/
      data idum(340)/ 118/
      data idum(341)/ 119/
      data idum(342)/ 113/
      data idum(343)/ 122/
      data idum(344)/  30/
      data idum(345)/  29/
      data idum(346)/ 119/
      data idum(347)/ 120/
      data idum(348)/ 114/
      data idum(349)/ 122/
      data idum(350)/  31/
      data idum(351)/  30/
      data idum(352)/ 120/
      data idum(353)/ 121/
      data idum(354)/ 115/
      data idum(355)/ 122/
      data idum(356)/  27/
      data idum(357)/  31/
      data idum(358)/ 121/
      data idum(359)/ 117/
      data idum(360)/ 116/
      data jvt2/   4,   5,   1,
     1             2,   5,   6,
     2             4,   3,   6,
     3             4,   5,   6/
      data fm/0.25,0.0625,0.015625,0.00390625/
      data pi/3.1415927d0/
c
c   0.0174533 = 3.14159.../180
c
      data first/0.0174533d0/
      data un2/0.5d0/
      antoau=1.d0/fpc(ifpc,3)
c
   10 format(i4,6f10.5,i4)
   20 format(5f10.5)
   30 format(4f10.5)
   40 format(i5,4f10.3,f18.3)
   50 format(i4,4f10.5,i4)
   60 format(f10.5,4i4)
c
c        coordinates are transformed
c
      nsf=nesf
      if(icent.eq.1)then
         do 70 i=1,nesf
            xe(i)=c(nc(i),1)/antoau
            ye(i)=c(nc(i),2)/antoau
            ze(i)=c(nc(i),3)/antoau
   70    continue
      end if
c********************************************************************
c    the cavity is built up from the spheres
c********************************************************************
      omega=omega*first
      senom=dsin(omega)
      cosom2=(dcos(omega))**2
c     rtd=rd*0.1547005
      rtdd=ret+rd
      rtdd2=rtdd*rtdd
      net=nesf
      nn=2
      ne=nesf
      nev=nesf
      go to 90
   80 nn=ne+1
      ne=net
   90 do 180 i=nn,ne
         nes=i-1
         do 170 j=1,nes
c     write(isol,8000)nn,ne,nes,i,j
  100       format(' nn ',i4,'   ne',i4,'   nes',i4,'   i',i4,'   j',i4)
  110       format(4f20.10)
            rij2=(xe(i)-xe(j))**2+
     1     (ye(i)-ye(j))**2+
     2     (ze(i)-ze(j))**2
c     write(isol,8100)rij2
            rij=dsqrt(rij2)
c     write(isol,8100)rij
            rjd=re(j)+rd
            test1=re(i)+rjd+rd
            if(rij.ge.test1) go to 170
            reg=dmax1(re(i),re(j))
            rep=dmin1(re(i),re(j))
            reg2=reg*reg
            rep2=rep*rep
            test2=rep*senom+dsqrt(reg2-rep2*cosom2)
            if(rij.le.test2) go to 170
            regd2=(reg+rd)*(reg+rd)
            test3=(regd2+reg2-rtdd2)/reg
            if(rij.ge.test3) go to 170
            do 120 k=1,nev
               if(k.eq.j .or. k.eq.i) go to 120
               rjk2=(xe(j)-xe(k))**2+
     1     (ye(j)-ye(k))**2+
     2     (ze(j)-ze(k))**2
               if(rjk2.ge.rij2) go to 120
               rik2=(xe(i)-xe(k))**2+
     1     (ye(i)-ye(k))**2+
     2     (ze(i)-ze(k))**2
               if(rik2.ge.rij2) go to 120
               rjk=dsqrt(rjk2)
               rik=dsqrt(rik2)
               sp=(rij+rjk+rik)/2.0d0
               hh=4*(sp*(sp-rij)*(sp-rik)*(sp-rjk))/rij2
               reo=re(k)*fro
               if(k.ge.ne)reo=0.0002d0
               reo2=reo*reo
               if(hh.lt.reo2) go to 170
  120       continue
            repd2=(rep+rd)**2
            test8=dsqrt(repd2-rtdd2)+dsqrt(regd2-rtdd2)
            if(rij.le.test8)go to 140
            rend2=regd2+reg2-(reg/rij)*(regd2+rij2-repd2)
            if(rend2.le.rtdd2) go to 170
            ren=dsqrt(rend2)-rd
            fc=reg/(rij-reg)
            test7=reg-re(i)
            kg=i
            kp=j
            if(test7.le.0.000000001d0) go to 130
            kg=j
            kp=i
  130       fc1=fc+1.0d0
            xen=(xe(kg)+fc*xe(kp))/fc1
            yen=(ye(kg)+fc*ye(kp))/fc1
            zen=(ze(kg)+fc*ze(kp))/fc1
            go to 160
  140       r2gn=rij-rep+reg
            rgn=r2gn/2.0d0
            fc=r2gn/(rij+rep-reg)
            fc1=fc+1.0d0
            test7=reg-re(i)
            kg=i
            kp=j
            if(test7.le.0.000000001d0) go to 150
            kg=j
            kp=i
  150       xen=(xe(kg)+fc*xe(kp))/fc1
            yen=(ye(kg)+fc*ye(kp))/fc1
            zen=(ze(kg)+fc*ze(kp))/fc1
            ren=dsqrt(regd2+rgn*(rgn-(regd2+rij2-repd2)/rij))-rd
  160       net=net+1
            xe(net)=xen
            ye(net)=yen
            ze(net)=zen
            re(net)=ren
  170    continue
         nev=net
  180 continue
      if(net.ne.ne) go to 80
      nesf=net
c     write(isol,620)nesf
  190 format(//,'total number of spheres =',i5,/)
c*********************************************************************
c     splitting of the cavity surface in small surface elements
c*********************************************************************
  200 jj=0
      ij=0
      drd=two*dr
      vol=0.0d0
      stot=0.0d0
c*****coordinates of vertex for a sphere of radius unity********
      cv(1,1)=0.0d0
      cv(1,2)=0.0d0
      cv(1,3)=1.d0
      cv(122,1)=0.0d0
      cv(122,2)=0.0d0
      cv(122,3)=-1.d0
      ii=1
      do 220 i=1,24
         th=thev(i)
         fi=fiv(i)
         cth=dcos(th)
         sth=dsin(th)
         do 210 j=1,5
            fi=fi+fir
            if(j.eq.1) fi=fiv(i)
            ii=ii+1
            cv(ii,1)=sth*dcos(fi)
            cv(ii,2)=sth*dsin(fi)
            cv(ii,3)=cth
  210    continue
  220 continue
c*****coordinates of center for a sphere of radius unity *****
      ii=0
      do 240 i=1,12
         th=thec(i)
         fi=fic(i)
         cth=dcos(th)
         sth=dsin(th)
         do 230 j=1,5
            fi=fi+fir
            if(j.eq.1) fi=fic(i)
            ii=ii+1
            xc(ii)=sth*dcos(fi)
            yc(ii)=sth*dsin(fi)
            zc(ii)=cth
  230    continue
  240 continue
c********************************************************************
c     determine the cavity geometry from every sphere               
c********************************************************************
      do 670 i=1,nesf
         ssfe(i)=0.0d0
         rei=re(i)
         sre(i)=four*pi*rei*rei
         reim=rei-dr
         xei=xe(i)
         yei=ye(i)
         zei=ze(i)
         do 250 j=1,60
  250    jm(j)=1
         do 260 j=1,122
  260    idf(j)=1
         iij=0
c******************************************************************
c      are the vertex of sphere i inside or outside?
c      determine spheres intersecting sphere i
c*******************************************************************
         do 280 j=1,nesf
            if(i.eq.j) go to 280
            dij2=(xei-xe(j))*(xei-xe(j))+
     1     (yei-ye(j))*(yei-ye(j))+
     2     (zei-ze(j))*(zei-ze(j))
            sre2=(rei+re(j))*(rei+re(j))
            if(dij2.gt.sre2) go to 280
            iij=iij+1
            ije(iij)=j
            nejci=iij
            do 270 k=1,122
               if(idf(k).eq.0) go to 270
               xk=cv(k,1)*rei
               yk=cv(k,2)*rei
               zk=cv(k,3)*rei
               xk0=xk+xei
               yk0=yk+yei
               zk0=zk+zei
               dvk2=(xk0-xe(j))*(xk0-xe(j))+
     1     (yk0-ye(j))*(yk0-ye(j))+
     2     (zk0-ze(j))*(zk0-ze(j))
               rej2=re(j)*re(j)
               if(dvk2.lt.rej2) idf(k)=0
  270       continue
  280    continue
  290    format(1x,15i4)
  300    continue
         ddceo=xei*xei+yei*yei+zei*zei
         ast1=sre(i)/60.0d0
         ast2=ast1/4.0d0
         ast3=ast2/4.0d0
         ast4=ast3/4.0d0
         ast5=ast4/4.0d0
c*****first division****************************
         do 660 j=1,60
            atj=0.0d0
            asp(j)=0.0d0
            cxcm=0.0d0
            cycm=0.0d0
            czcm=0.0d0
            cmm=0.0d0
            if(ndiv.eq.1) go to 310
            nv1=jvt1(1,j)
            nv2=jvt1(2,j)
            nv3=jvt1(3,j)
            nv4=jvt1(4,j)
            nv5=jvt1(5,j)
            nv6=jvt1(6,j)
            is1=idf(nv1)+idf(nv2)+idf(nv3)+idf(nv4)+idf(nv5)+idf(nv6)
            if(is1.eq.6) go to 310
            if(is1.eq.0) go to 650
            nv(1)=nv1
            nv(2)=nv2
            nv(3)=nv3
            nv(4)=nv4
            nv(5)=nv5
            nv(6)=nv6
            go to 350
  310       cxcm=rei*xc(j)
            cycm=rei*yc(j)
            czcm=rei*zc(j)
            cxcm0= cxcm+xei
            cycm0=cycm+yei
            czcm0=czcm+zei
            if(ndiv.ne.1) go to 330
            do 320 n3=1,nejci
               n4=ije(n3)
               dd=(cxcm0-xe(n4))**2+
     1   (cycm0-ye(n4))**2+
     2   (czcm0-ze(n4))**2
               rrej=re(n4)*re(n4)
               if(dd.lt.rrej) go to 650
  320       continue
  330       atj=ast1
  340       format(' j',i4,'     atj',f10.5)
            dd=cxcm0*cxcm0+cycm0*cycm0+czcm0*czcm0
            vol=vol+ast1*(rei*rei+dd-ddceo)/(6.0d0*rei)
            go to 630
c*****second division**********************
  350       do 620 j2=1,4
               nv21=nv(jvt2(1,j2))
               nv22=nv(jvt2(2,j2))
               nv23=nv(jvt2(3,j2))
               is2=idf(nv21)+idf(nv22)+idf(nv23)
               if(is2.eq.0) go to 620
               xvv1=cv(nv21,1)*rei
               yvv1=cv(nv21,2)*rei
               zvv1=cv(nv21,3)*rei
               xv2=cv(nv22,1)*rei
               yv2=cv(nv22,2)*rei
               zv2=cv(nv22,3)*rei
               xv3=cv(nv23,1)*rei
               yv3=cv(nv23,2)*rei
               zv3=cv(nv23,3)*rei
               iii=0
               if(is2.eq.3) go to 380
               if(ndiv.le.2) go to 390
               cvn3(1,1)=xvv1
               cvn3(1,2)=yvv1
               cvn3(1,3)=zvv1
               cvn3(2,1)=xv2
               cvn3(2,2)=yv2
               cvn3(2,3)=zv2
               cvn3(3,1)=xv3
               cvn3(3,2)=yv3
               cvn3(3,3)=zv3
               idf3(1)=idf(nv21)
               idf3(2)=idf(nv22)
               idf3(3)=idf(nv23)
               do 370 nnn=1,3
                  n2=nnn+3
                  n1=nnn-1
                  if(nnn.eq.1)n1=3
                  xxx=(cvn3(nnn,1)+cvn3(n1,1))/2.0d0
                  yyy=(cvn3(nnn,2)+cvn3(n1,2))/2.0d0
                  zzz=(cvn3(nnn,3)+cvn3(n1,3))/2.0d0
                  rrr=dsqrt(xxx*xxx+yyy*yyy+zzz*zzz)
                  fc=rei/rrr
                  cvn3(n2,1)=xxx*fc
                  cvn3(n2,2)=yyy*fc
                  cvn3(n2,3)=zzz*fc
                  xxm=cvn3(n2,1)+xei
                  yym=cvn3(n2,2)+yei
                  zzm=cvn3(n2,3)+zei
                  idf3(n2)=1
                  do 360 n3=1,nejci
                     n4=ije(n3)
                     dd=(xxm-xe(n4))*(xxm-xe(n4))+
     1   (yym-ye(n4))*(yym-ye(n4))+
     2   (zzm-ze(n4))*(zzm-ze(n4))
                     rrej=re(n4)*re(n4)
                     if(dd.gt.rrej) go to 360
                     idf3(n2)=0
                     go to 370
  360             continue
  370          continue
               go to 420
  380          iii=1
  390          xxx=(xvv1+xv2+xv3)/3.0d0
               yyy=(yvv1+yv2+yv3)/3.0d0
               zzz=(zvv1+zv2+zv3)/3.0d0
               rrr=dsqrt(xxx*xxx+yyy*yyy+zzz*zzz)
               fc=rei/rrr
               xct=xxx*fc
               yct=yyy*fc
               zct=zzz*fc
               xctm=xct+xei
               yctm=yct+yei
               zctm=zct+zei
               if(iii.eq.1) go to 410
               do 400 nnn=1,nejci
                  n4=ije(nnn)
                  dd=(xctm-xe(n4))*(xctm-xe(n4))+
     1   (yctm-ye(n4))*(yctm-ye(n4))+
     2   (zctm-ze(n4))*(zctm-ze(n4))
                  rrej=re(n4)*re(n4)
                  if(dd.lt.rrej) go to 620
  400          continue
  410          dd=xctm*xctm+yctm*yctm+zctm*zctm
               vol=vol+ast2*(rei*rei+dd-ddceo)/(6.d0*rei)
               atj=atj+ast2
               cxcm=cxcm+xct*fm(1)
               cycm=cycm+yct*fm(1)
               czcm=czcm+zct*fm(1)
               cmm=cmm+fm(1)
               go to 620
c*****  third division **********************************
  420          do 610 j3=1,4
                  nv31=jvt2(1,j3)
                  nv32=jvt2(2,j3)
                  nv33=jvt2(3,j3)
                  is3=idf3(nv31)+idf3(nv32)+idf3(nv33)
                  if(is3.eq.0) go to 610
                  iii=0
                  cvn4(1,1)=cvn3(nv31,1)
                  cvn4(1,2)=cvn3(nv31,2)
                  cvn4(1,3)=cvn3(nv31,3)
                  cvn4(2,1)=cvn3(nv32,1)
                  cvn4(2,2)=cvn3(nv32,2)
                  cvn4(2,3)=cvn3(nv32,3)
                  cvn4(3,1)=cvn3(nv33,1)
                  cvn4(3,2)=cvn3(nv33,2)
                  cvn4(3,3)=cvn3(nv33,3)
                  if(is3.eq.3) go to 450
                  if(ndiv.eq.3) go to 460
                  idf4(1)=idf3(nv31)
                  idf4(2)=idf3(nv32)
                  idf4(3)=idf3(nv33)
                  do 440 nnn=1,3
                     n2=nnn+3
                     n1=nnn-1
                     if(nnn.eq.1) n1=3
                     xxx=(cvn4(nnn,1)+cvn4(n1,1))/2.d0
                     yyy=(cvn4(nnn,2)+cvn4(n1,2))/2.d0
                     zzz=(cvn4(nnn,3)+cvn4(n1,3))/2.d0
                     rrr=dsqrt(xxx*xxx+yyy*yyy+zzz*zzz)
                     fc=rei/rrr
                     cvn4(n2,1)=xxx*fc
                     cvn4(n2,2)=yyy*fc
                     cvn4(n2,3)=zzz*fc
                     xxm=cvn4(n2,1)+xei
                     yym=cvn4(n2,2)+yei
                     zzm=cvn4(n2,3)+zei
                     idf4(n2)=1
                     do 430 n3=1,nejci
                        n4=ije(n3)
                        dd=(xxm-xe(n4))*(xxm-xe(n4))+
     1   (yym-ye(n4))*(yym-ye(n4))+
     2   (zzm-ze(n4))*(zzm-ze(n4))
                        rrej=re(n4)*re(n4)
                        if(dd.gt.rrej) go to 430
                        idf4(n2)=0
                        go to 440
  430                continue
  440             continue
                  go to 490
  450             iii=1
  460             xxx=(cvn4(1,1)+cvn4(2,1)+cvn4(3,1))/3.d0
                  yyy=(cvn4(1,2)+cvn4(2,2)+cvn4(3,2))/3.d0
                  zzz=(cvn4(1,3)+cvn4(2,3)+cvn4(3,3))/3.d0
                  rrr=dsqrt(xxx*xxx+yyy*yyy+zzz*zzz)
                  fc=rei/rrr
                  xct=xxx*fc
                  yct=yyy*fc
                  zct=zzz*fc
                  xctm=xct+xei
                  yctm=yct+yei
                  zctm=zct+zei
                  if(iii.eq.1) go to 480
                  do 470 nnn=1,nejci
                     n4=ije(nnn)
                     dd=(xctm-xe(n4))*(xctm-xe(n4))+
     1   (yctm-ye(n4))*(yctm-ye(n4))+
     2   (zctm-ze(n4))*(zctm-ze(n4))
                     rrej=re(n4)*re(n4)
                     if(dd.lt.rrej) go to 610
  470             continue
  480             dd=xctm*xctm+yctm*yctm+zctm*zctm
                  vol=vol+ast3*(rei*rei+dd-ddceo)/(6.d0*rei)
                  atj=atj+ast3
                  cxcm=cxcm+xct*fm(2)
                  cycm=cycm+yct*fm(2)
                  czcm=czcm+zct*fm(2)
                  cmm=cmm+fm(2)
                  go to 610
c*****  fourth division ******************************
  490             do 600 j4=1,4
                     nv41=jvt2(1,j4)
                     nv42=jvt2(2,j4)
                     nv43=jvt2(3,j4)
                     is4=idf4(nv41)+idf4(nv42)+idf4(nv43)
                     if(is4.eq.0) go to 600
                     iii=0
                     cvn5(1,1)=cvn4(nv41,1)
                     cvn5(1,2)=cvn4(nv41,2)
                     cvn5(1,3)=cvn4(nv41,3)
                     cvn5(2,1)=cvn4(nv42,1)
                     cvn5(2,2)=cvn4(nv42,2)
                     cvn5(2,3)=cvn4(nv42,3)
                     cvn5(3,1)=cvn4(nv43,1)
                     cvn5(3,2)=cvn4(nv43,2)
                     cvn5(3,3)=cvn4(nv43,3)
                     if(is4.eq.3)goto 520
                     if(ndiv.eq.4) go to 530
                     idf5(1)=idf4(nv41)
                     idf5(2)=idf4(nv42)
                     idf5(3)=idf4(nv43)
                     do 510 nnn=1,3
                        n2=nnn+3
                        n1=nnn-1
                        if(nnn.eq.1) n1=3
                        xxx=(cvn5(nnn,1)+cvn5(n1,1))/2.d0
                        yyy=(cvn5(nnn,2)+cvn5(n1,2))/2.d0
                        zzz=(cvn5(nnn,3)+cvn5(n1,3))/2.d0
                        rrr=dsqrt(xxx*xxx+yyy*yyy+zzz*zzz)
                        fc=rei/rrr
                        cvn5(n2,1)=xxx*fc
                        cvn5(n2,2)=yyy*fc
                        cvn5(n2,3)=zzz*fc
                        xxm=cvn5(n2,1)+xei
                        yym=cvn5(n2,2)+yei
                        zzm=cvn5(n2,3)+zei
                        idf5(n2)=1
                        do 500 n3=1,nejci
                           n4=ije(n3)
                           dd=(xxm-xe(n4))*(xxm-xe(n4))+
     1   (yym-ye(n4))*(yym-ye(n4))+
     2   (zzm-ze(n4))*(zzm-ze(n4))
                           rrej=re(n4)*re(n4)
                           if(dd.gt.rrej) go to 500
                           idf5(n2)=0
                           go to 510
  500                   continue
  510                continue
                     go to 560
  520                iii=1
  530                xxx=(cvn5(1,1)+cvn5(2,1)+cvn5(3,1))/3.d0
                     yyy=(cvn5(1,2)+cvn5(2,2)+cvn5(3,2))/3.d0
                     zzz=(cvn5(1,3)+cvn5(2,3)+cvn5(3,3))/3.d0
                     rrr=dsqrt(xxx*xxx+yyy*yyy+zzz*zzz)
                     fc=rei/rrr
                     xct=xxx*fc
                     yct=yyy*fc
                     zct=zzz*fc
                     xctm=xct+xei
                     yctm=yct+yei
                     zctm=zct+zei
                     if(iii.eq.1) go to 550
                     do 540 nnn=1,nejci
                        n4=ije(nnn)
                        dd=(xctm-xe(n4))*(xctm-xe(n4))+
     1   (yctm-ye(n4))*(yctm-ye(n4))+
     2   (zctm-ze(n4))*(zctm-ze(n4))
                        rrej=re(n4)*re(n4)
                        if(dd.lt.rrej) go to 600
  540                continue
  550                dd=xctm*xctm+yctm*yctm+zctm*zctm
                     vol=vol+ast4*(rei*rei+dd-ddceo)/(6.d0*rei)
                     atj=atj+ast4
                     cxcm=cxcm+xct*fm(3)
                     cycm=cycm+yct*fm(3)
                     czcm=czcm+zct*fm(3)
                     cmm=cmm+fm(3)
                     go to 600
c*****  fifth division  *************************************
  560                do 590 j5=1,4
                        nv51=jvt2(1,j5)
                        nv52=jvt2(2,j5)
                        nv53=jvt2(3,j5)
                        is5=idf5(nv51)+idf5(nv52)+idf5(nv53)
                        if(is5.eq.0) go to 590
                        xxx=(cvn5(nv51,1)+cvn5(nv52,1)+cvn5(nv53,1))/3.d
     10
                        yyy=(cvn5(nv51,2)+cvn5(nv52,2)+cvn5(nv53,2))/3.d
     10
                        zzz=(cvn5(nv51,3)+cvn5(nv52,3)+cvn5(nv53,3))/3.d
     10
                        rrr=dsqrt(xxx*xxx+yyy*yyy+zzz*zzz)
                        fc=rei/rrr
                        xct=xxx*fc
                        yct=yyy*fc
                        zct=zzz*fc
                        xctm=xct+xei
                        yctm=yct+yei
                        zctm=zct+zei
                        if(is5.eq.3) go to  580
                        do 570 nnn=1,nejci
                           n4=ije(nnn)
                           dd=(xctm-xe(n4))*(xctm-xe(n4))+
     1   (yctm-ye(n4))*(yctm-ye(n4))+
     2   (zctm-ze(n4))*(zctm-ze(n4))
                           rrej=re(n4)*re(n4)
                           if(dd.lt.rrej) go to  590
  570                   continue
  580                   dd=xctm*xctm+yctm*yctm+zctm*zctm
                        vol=vol+ast5*(rei*rei+dd-ddceo)/(6.d0*rei)
                        atj=atj+ast5
                        cxcm=cxcm+xct*fm(4)
                        cycm=cycm+yct*fm(4)
                        czcm=czcm+zct*fm(4)
                        cmm=cmm+fm(4)
  590                continue
  600             continue
  610          continue
  620       continue
            if(cmm.le.0.0001d0) go to 650
            cxcm=cxcm/cmm
            cycm=cycm/cmm
            czcm=czcm/cmm
            rrr=dsqrt(cxcm*cxcm+cycm*cycm+czcm*czcm)
            fc=rei/rrr
            cxcm=cxcm*fc
            cycm=cycm*fc
            czcm=czcm*fc
            cxcm0=cxcm+xei
            cycm0=cycm+yei
            czcm0=czcm+zei
c2224      xxev=cxcm0
c          yyev=cycm0
c          zzev=czcm0
c          call tranfgc(xxev,yyev,zzev,ovv)
c          if(zzev.gt.0.d0.and.imez.eq.1)go to 33
c          if(zzev.le.0.d0.and.imez.eq.2)go to 33
  630       ij=ij+1
c          isolv(ij)=imez
            x0(ij)=cxcm0
            y0(ij)=cycm0
            z0(ij)=czcm0
  640       format('  ij',i4,'    x',f10.5,'    y',f10.5,'    z',f10.5)
            fdr=reim/rei
            xv1ij=cxcm*fdr+xei
            yv1ij=cycm*fdr+yei
            zv1ij=czcm*fdr+zei
            xv1(ij)=xv1ij
            yv1(ij)=yv1ij
            zv1(ij)=zv1ij
            rv1(ij)=rei
            asp(j)=atj
            as(ij)=asp(j)
            ssfe(i)=ssfe(i)+atj
            iploch(ij)=i
c ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            go to 660
  650       jm(j)=0
  660    continue
  670 continue
c*********************************************************************
c     eliminate nearest points
c*********************************************************************
  680 kvak0=0
      test=0.02d0
      test2=test*test
      ijm=ij-1
      do 700 i=1,ijm
         if(as(i).eq.0.d0)go to 700
         xi=x0(i)
         yi=y0(i)
         zi=z0(i)
         ii=i+1
         do 690 j=ii,ij
            if(iploch(i).eq.iploch(j))go to 690
            if(as(j).eq.0.d0)go to 690
            xj=x0(j)
            yj=y0(j)
            zj=z0(j)
            rij=(xi-xj)**2+(yi-yj)**2+(zi-zj)**2
            if(rij.gt.test2)go to 690
            kvak0=kvak0+1
            as(j)=0.0d0
            asm=(as(i)+as(j))
            xj=(xi+x0(j))*un2
            yj=(yi+y0(j))*un2
            zj=(zi+z0(j))*un2
            xij=(xv1(i)+xv1(j))*un2
            yij=(yv1(i)+yv1(j))*un2
            zij=(zv1(i)+zv1(j))*un2
            rij=dsqrt((xj-xij)**2+(yj-yij)**2+(zj-zij)**2)
            tau1=dr/rij
            tau2=-tau1
            xv1(i)=(xij-xj)*tau1+xj
            yv1(i)=(yij-yj)*tau1+yj
            zv1(i)=(zij-zj)*tau1+zj
            x0(i)=xj
            y0(i)=yj
            z0(i)=zj
            as(i)=asm
  690    continue
  700 continue
      iij=ij
      ij=0
      do 710 i=1,iij
         if(as(i).eq.0.d0)go to 710
         ij=ij+1
         x0(ij)=x0(i)
         y0(ij)=y0(i)
         z0(ij)=z0(i)
         as(ij)=as(i)
         rv1(ij)=rv1(i)
         xv1(ij)=xv1(i)
         yv1(ij)=yv1(i)
         zv1(ij)=zv1(i)
         iploch(ij)=iploch(i)
  710 continue
  720 format(2i4,4f10.5)
      iij=ij
      nts=ij
      stot=0.0d0
      do 730 i=1,nesf
  730 ssfe(i)=0.0d0
      do 740 i=1,nts
         k=iploch(i)
  740 ssfe(k)=ssfe(k)+as(i)
      write(iw,750)nesf
  750 format(//,'1    ****** pisa solvent model ******',//,             
     *       ' * characteristics of the cavity *',                      
     * ////,'  total number of spheres',i5,//,' center - radius :',//,  
     *       ' sphere    center  (x,y,z) (ang.)     radius (ang.)',     
     * '  area(ang.*ang.)')                                             
      gvw=0.0d0
      do 760 i=1,nesf
         write(iw,40)i,xe(i),ye(i),ze(i),re(i),ssfe(i)
      if (iclass(i).eq.1) then
         gvw=gvw-0.0876d0*ssfe(i)
      else if (iclass(i).eq.6) then
         gvw=gvw-0.1088d0*ssfe(i)
      else if (iclass(i).eq.7) then
         gvw=gvw-0.0522d0*ssfe(i)
      else if (iclass(i).eq.8) then
         gvw=gvw-0.0514d0*ssfe(i)
      else if (iclass(i).eq.9) then
         gvw=gvw-0.0514d0*ssfe(i)
      else if (iclass(i).eq.16) then
         gvw=gvw-0.0697d0*ssfe(i)
      else if (iclass(i).eq.99) then
         gvw=gvw-0.1737d0*ssfe(i)
      else
         gvw=gvw-0.0767d0*ssfe(i)
      end if
  760 stot=stot+ssfe(i)
      write(iw,770)omega,rd,ret,fro,ndiv
  770 format(///,' polyhedron parameter: omega=',f8.3,' rd=',f8.3,
     1' ret=', f8.3,' fro=',f8.3,' ndiv=',i5,//)
      write(iw,780)nts,stot,vol
  780 format(' total number of elements ',i8,//,
     1' surface  ',f12.5,'(ang.**2)     volume ',f12.5,
     2'(ang.**3)',//)
  790 format(' sphere',i3,'   area',f10.5)
c     patas: computation of van der waals term
c     see f.m.floris, j.tomasi,j.l.pascual ahuir
c         journal of computational chemistry,12(1991)784-791
c
      gvws=-0.03208d0-0.0767d0*stot
      gvwv=-1.26850d0-0.07469d0*vol
      write(iw,800) gvw,gvws,gvwv
  800 format(' van der waals optimized linear relation: ',f12.5,
     1' kcal/mol',
     2/,' van der waals free-energy (surface): ',f12.5,' kcal/mol',
     3/,' van der waals free-energy (volume):  ',f12.5,' kcal/mol',/)
c     patas: end of modification
c     if(iprint.eq.1)then
      write(isol,810)
      write(isol,820)
c     end if
  810 format('1 *** partitioning of the surface    ***')
  820 format(' element  sphere   area       center coordinates(x,y,z)', 
     *'         point normal to the center(x,y,z)')                    
  830 format(2i7,7f10.5)
      omega=omega/first
      do 840 i=1,nts
c     if(iprint.eq.1)then
         write(isol,830)i,iploch(i),as(i),x0(i),y0(i),z0(i),xv1(i),
     1yv1(i),zv1(i)
c     end if
         k=i+nts
         as(i)=as(i)*antoau*antoau
         xv(k)=xv1(i)*antoau
         yv(k)=yv1(i)*antoau
         zv(k)=zv1(i)*antoau
         xv(i)=x0(i)*antoau
         yv(i)=y0(i)*antoau
         zv(i)=z0(i)*antoau
  840 continue
      nsf=nesf
      return
      end
      subroutine surfat(scale,dens,it345,vwxyz)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
c
c this program calculates the molecular surface of a molecule
c given the coordinates of its atoms.  van der waals radii for
c the atoms and the probe radius must also be specified.
c     for further details see coment.for .
c
c
c     this subroutine is lifted from michael connolly's surface
c     program for ucsf graphics system and adapted to g80 by
c             u.chandra singh and p.a.kollman
c
c
c
c
c     common/abc/co(3,10001),rad(10001),water(3,500),
c    *           ,con(3,500),circle(3,100),
c    *           ,sco(3,100),eat(3,100),arc(3,50,2),ias(10001),
c    *           ,iyon(1250),ivic(3750)
c
      common/moprad/rtype(30),vander(30),den,rw,ntype,itype(30),natom
      common/io/in,iout,ipunch
      common /jobnam/ jobnam
      common /funcon/ fpc(2,10),ifpc
      common /chanel/ ifiles(30)
      common c(numatm,3),natoms,icharg,multip,ian(numatm),nae,nbe,ne,
     1nbasis
      character  jobnam*80 
      dimension vwxyz(3,3600)
      dimension co(3,10001),rad(10001),water(3,500),con(3,500)
      dimension circle(3,100),sco(3,100),eat(3,100),arc(3,50,2)
      dimension ias(10001),iyon(1250),ivic(3750)
c
c     ----- neighbor arrays ----
c
c this same dimension for the maximum number of neighbors
c is used to dimension arrays in the logical function collid1
c
      dimension inbr(200),cnbr(3,200),rnbr(200)
      logical snbr(200),mnbr(200)
c
c     ----- arrays for all atoms ----
c
c dimension these arrays 1 more in case input file is too long
c
c     ----- circle and sphere arrays ----
c
c
c todo lo de arriba creo que son chorradas varias de definiciones
c
c
c     dimension water(3,500)
c     dimension con(3,500)
c     dimension circle(3,100)
c iatom, jatom and katom coordinates
c
      dimension ci(3), cj(3), ck(3) ,ieldat(56), temp0(3)
c
c     ----- geometric construction vectors ----
c
      dimension uij(3),pij(3),cck(3)
      dimension base(3),alt(3),base2(3),alt2(3,2),ralt(3,2)
      dimension cw(3,2),wi(3),wj(3),wk(3)
      dimension arc1(3,50),arcr(3),arca(50)
      dimension vector(3)
c
c     ----- rotation matrices ----
c
      dimension g(3,3),h(3,3),ghgt(3,3),pow(3,3)
c
c     ----- reentrant probe record ----
c
      dimension torus(100),n1(100),n2(100),n3(100)
      logical yon(100)
c
c     ----- logical variables ----
c
      logical int,both,pair(2),ayon(50),si,sj,sk,anyon
c
c     ----- orsr for non-symmetry-related probes ----
c
      dimension yonwat(3,1250),yonalt(3,1250)
      dimension vicwat(3,3750),vicalt(3,3750)
      character*4 ieldat,marker, markss, mynam,namatm
c
c     ----- the input data are no longer needed when orsr is begun ----
c
      equivalence (co(1,1),yonwat),(co(1,1251),yonalt)
      equivalence (co(1,2501),vicwat),(co(1,6251),vicalt)
      equivalence(isur,ifiles(3))
c
c     ----- logical functions ----
c
      logical collid1
c
c     ----- data for vander vall radii ----
c
c     data vander/1.20,1.20,1.37,1.45,1.45,1.50,1.50,1.40,1.35,1.30
c    *           ,1.57,1.36,1.24,1.17,1.80,1.75,1.70,13*0/
      data marker/'a   '/,markss/'ss0 '/,mynam/'uc '/
c
      data ieldat/'  bq','  h ','  he','  li','  be','  b ',
     1            '  c ','  n ','  o ','  f ','  ne','  na',
     2            '  mg','  al','  si','  p ','  s ','  cl',
     3            '  ar','  k ','  ca','  sc','  ti','  v ',
     4            '  cr','  mn','  fe','  co','  ni','  cu',
     5            '  zn','  ga','  ge','  as','  se','  br',
     6            '  kr','  rb','  sr','   y','  zr','  nb',
     7            '  mo','  tc','  ru','  rh','  pd','  ag',
     8            '  cd','  in','  sn','  sb','  te','   i',
     9            '   x','  cs'/
c
      bohr=fpc(ifpc,3)
      vander(1)=1.20d0
      vander(2)=1.20d0
      vander(3)=1.37d0
      vander(4)=1.45d0
      vander(5)=1.45d0
      vander(6)=1.50d0
      vander(7)=1.50d0
      vander(8)=1.40d0
      vander(9)=1.35d0
      vander(10)=1.30d0
      vander(11)=1.57d0
      vander(12)=1.36d0
      vander(13)=1.24d0
      vander(14)=1.17d0
      vander(15)=1.80d0
      vander(16)=1.75d0
      vander(17)=1.70d0
      vander(18)=0.00d0
      vander(19)=0.00d0
      vander(20)=0.00d0
      vander(21)=0.00d0
      vander(22)=0.00d0
      vander(23)=0.00d0
      vander(24)=0.00d0
      vander(25)=0.00d0
      vander(26)=0.00d0
      vander(27)=0.00d0
      vander(28)=0.00d0
      vander(29)=0.00d0
      vander(30)=0.00d0
   10 format(a3,i5,1x,a3,3f9.3,1x,a3,f7.3)
c1010 format(i3,9x,a5,6x,3f12.4)
   20 format(a5,6x,3f12.4)
      i=index(jobnam,' ')-1
      open(unit=isur,file=jobnam(:i)//'.sur',status='unknown')
      rewind isur
c
c     ----- branch to the proper generation ----
c
c     ----- only vander vaal type surface is generated ----
c
      rw =0.0d0
      autoan = bohr
      natom =natoms
      den = dens
      do 30 i=1,natom
         ipoint =ian(i)
         rad(i) =vander(ipoint)*scale
         ias(i) =2
         do 30 j=1,3
            dumm = c(i,j)*autoan
            co(j,i) = dumm
   30 continue
   40 continue
c     if (rw .eq. 0.0) go to 200
c
c
c     ----- set up probe sphere and circle ----
c
c     nwater = (4 * 3.14159 * rw ** 2) * den
****  problems here as nwater loop references 
****  nwater and ncirc later
c     if (nwater .lt. 1) nwater = 1
c     if (nwater .gt. 500) nwater = 500
c     call genunt(water,nwater)
c     ncirc = (2 * 3.14159 * rw) * dsqrt(den)
c     if (ncirc .lt. 1) ncirc = 1
c     if (ncirc .gt. 100) ncirc = 100
c     do 190 i = 1, ncirc
c     fi = (2 * 3.14159 * (i-1))/ncirc
c     circle(1,i) = rw * cos(fi)
c     circle(2,i) = rw * sin(fi)
c     circle(3,i) = 0.0
   50 continue
c
c     ----- open before file for writing ----
c
c     open(3,file='before',status='unknown')
c     rewind(3)
c
c     ---- skip to here if no reentrant surface will be calculated ---
c
   60 continue
c
c     ----- open contact file for writing ----
c
c
c     ----- open coordinate file for potential evaluation ----
c
c
c     ----- big loop for each atom ----
c
      do 520 iatom = 1, natom
         if (ias(iatom) .eq. 0) go to 520
c
c     ----- transfer values from large arrays to iatom variables ----
c
         namatm =ieldat(ian(iatom)+1)
         ri = rad(iatom)
         si = ias(iatom) .eq. 2
         do 70 k = 1,3
            ci(k) = co(k,iatom)
   70    continue
c
c     ----- gather the neighboring atoms of iatom ----
c
         nnbr = 0
         do 90 jatom = 1, natom
            if (iatom .eq. jatom .or. ias(jatom) .eq. 0) go to 90
            d2 = dist2m(ci,co(1,jatom))
            if (d2 .ge. (2d0*rw+ri+rad(jatom)) ** 2) go to 90
c
c     ----- we have a new neighbor ----
c     ---- transfer atom coordinates, radius and surface request number
c
            nnbr = nnbr + 1
            if (nnbr .gt. 200) call surf_err(210,nnbr,0.0d0)
            inbr(nnbr) = jatom
            do 80 k = 1,3
               cnbr(k,nnbr) = co(k,jatom)
   80       continue
            rnbr(nnbr) = rad(jatom)
            snbr(nnbr) = ias(jatom) .eq. 2
   90    continue
c
c     ----- no reentrant surface will be calculated if we are
c     calculating the van der waals surface
c     instead of the molecular surface ----
c
         if (rw .eq. 0.0d0) go to 460
c
c     ----- medium loop for each neighbor of iatom ----
c
         do 450 jnbr = 1,nnbr
            jatom = inbr(jnbr)
c
c     ----- each pair of atoms is considered only once ----
c
            if (jatom .le. iatom) go to 450
c
c     ----- tranfer from neighbor array to jatom variables ----
c
            rj = rnbr(jnbr)
            sj = snbr(jnbr)
            do 100 k = 1,3
               cj(k) = cnbr(k,jnbr)
  100       continue
c
c     ----- calculate the circle-circle intersection
c     of the expanded spheres of the two atoms ----
c
            do 110 k = 1,3
               uij(k) = cj(k) - ci(k)
  110       continue
            call vnorm_mop(uij,uij)
            call vperp_mop(uij,pij)
c
c     ----- call circle-circle intersection subroutine ----
c
            call mopcci(ci,cj,ri+rw,rj+rw,pij,base,alt,int)
c
c     ----- skip to bottom of middle loop if no intersection ----
c
            if (.not. int) go to 450
            height = anorm_mop(alt)
c
c      for both saddle-shaped and concave reentrant surface
c     we are working with a plane passing through the circle
c     of intersection of the expanded spheres of iatom and jatom
c     and also with a line perpendicular to this plane
c     passing through the centers of iatom and jatom
c     the point where the line and plane intersect is called base
c     alt is a vector from the base to the center of a probe sphere
c     which would simultaneously touch iatom and jatom
c
c     ----- concave reentrant surface ----
c     ---- gather mutual neighbors of iatom and jatom ---
c
            do 120 knbr = 1, nnbr
               d2 = dist2m(cj,cnbr(1,knbr))
               mnbr(knbr) = d2 .lt. (2*rw+rj+rnbr(knbr))**2
     1.and. knbr .ne. jnbr
  120       continue
c
c     ---- small loop for each mutual neighbor of iatom and jatom ----
c
            do 280 knbr = 1,nnbr
               if (.not. mnbr(knbr)) go to 280
               katom = inbr(knbr)
               if (katom .le. jatom) go to 280
               sk = snbr(knbr)
               if (.not. (si .or. sj .or. sk)) go to 280
c
c     ---- tranfer from neighbor array to katom variables ----
c
               rk = rnbr(knbr)
               do 130 k = 1,3
                  ck(k) = cnbr(k,knbr)
  130          continue
c
c     geometric calculations for placing a probe next to three atoms
c     we are working with a plane passing through the three atoms
c     and also with a line perpendicular to this plane
c     passing through the center of the probe sphere
c     the point where the line and plane intersect is called base2
c     alt2 is a pair of vectors from the base to the center of the
c     probe spheres which would simultaneously touch the three atoms
c
c     ---- projection of vector from base to katom center onto axis ---
c
c
        pbk = uij(1) * (ck(1)-base(1)) + uij(2) * (ck(2)-base(2))
     1 +uij(3) * (ck(3)-base(3))
c
c     ----- radius of circle of intersection of expandeded katom
c     with plane ----
c
               rck = (rk+rw) ** 2 - pbk ** 2
               if (rck .le. 0.0d0) go to 280
               rck = dsqrt(rck)
               do 140 k = 1,3
                  cck(k) = ck(k) - pbk * uij(k)
  140          continue
c
c     ----- call circle-circle intersection subroutine ----
c
               call mopcci(cck,base,rck,height,uij,base2,
     +                     alt2(1,1),int)
               if (.not. int) go to 280
c
c     ----- skip to bottom of inner loop if no intersection ----
c
c     ---- probe placement at ends of altitude vectors ----
c
               do 150 k = 1,3
                  alt2(k,2) = - alt2(k,1)
  150          continue
               do 170 iw = 1,2
                  do 160 k = 1,3
                     cw(k,iw) = base2(k) + alt2(k,iw)
  160             continue
c
c     ----- collision check with mutual neighbors ----
c
                  pair(iw) = .not. collid1(cw(1,iw),rw,cnbr,rnbr,mnbr,
     +            nnbr,3,jnbr,knbr)
  170          continue
c
c     ----- if neither probe position is allowed, skip to bottom
c     of inner loop ----
c
               if (.not. pair(1) .and. .not. pair(2)) go to 280
               both = pair(1) .and. pair(2)
c
c     ----- generate surface points ----
c
               area = (4.0d0 * 3.14159d0 * rw ** 2)/nwater
               do 270 iw = 1,2
                  if (.not. pair(iw)) go to 270
c
c     ----- calculate vectors defining spherical triangle ----
c
                  do 180 k = 1,3
                     wi(k) = ci(k) - cw(k,iw)
                     wj(k) = cj(k) - cw(k,iw)
                     wk(k) = ck(k) - cw(k,iw)
  180             continue
                  sign = det_mop(wi,wj,wk)
                  np = 1
c
c     ----- gather points on probe sphere lying within triangle ----
c
              do 230 i = 1,nwater
               if (sign * det_mop(water(1,i),wj,wk) .lt. 
     +         0.0d0) go to 230
               if (sign * det_mop(wi,water(1,i),wk) .lt. 
     +         0.0d0) go to 230
               if (sign * det_mop(wi,wj,water(1,i)) .lt. 
     +         0.0d0) go to 230
                   if (np .gt. 100) call surf_err(220,np,0.0d0)
c
c     ----- calculated whether point is on yon side of plane ----
c
               yon(np) = alt2(1,iw) * (alt2(1,iw) + water(1,i)) +
     1alt2(2,iw) * (alt2(2,iw) + water(2,i)) +
     2alt2(3,iw) * (alt2(3,iw) + water(3,i)) .lt. 0.0d0
c
c     ----- overlapping reentrant surface removal
c     for symmetry-related probe positions ----
c
                     if (yon(np) .and. both) go to 230
                     do 190 k = 1,3
                        sco(k,np) = cw(k,iw) + water(k,i) * rw
  190                continue
c
c     ----- find the closest atom ----
c
                     di = dist_mop(sco(1,np),ci) - ri
                     dj = dist_mop(sco(1,np),cj) - rj
                     dk = dist_mop(sco(1,np),ck) - rk
                     if (di .le. dj .and. di .le. dk) go to 200
                     if (dj .le. di .and. dj .le. dk) go to 210
                     if (.not. sk) go to 230
                     n1(np) = katom
                     n2(np) = iatom
                     n3(np) = jatom
                     go to 220
  200                continue
                     if (.not. si) go to 230
                     n1(np) = iatom
                     n2(np) = jatom
                     n3(np) = katom
                     go to 220
  210                continue
                     if (.not. sj) go to 230
                     n1(np) = jatom
                     n2(np) = iatom
                     n3(np) = katom
  220                continue
                     np = np + 1
c
c     ----- end of nwater loop ----
c
  230             continue
                  np = np - 1
                  if (np .le. 0) go to 270
c
c     ----- write the shape, number of points, probe position and
c     the vector from the base to the probe center ----
c
                  write(isur,240)3,np,(cw(k,iw),k=1,3),
     +            (alt2(k,iw),k=1,3)
  240             format(2i5,6f9.3)
c
c     ----- write surface points for this probe position ----
c
                  do 260 i = 1,np
                     write(isur,250) n1(i),n2(i),n3(i),
     +               (sco(k,i),k=1,3),area,yon(i)
  250                format(3i5,3f9.3,f7.3,l5)
  260             continue
c
c     ----- end of iw loop ----
c
  270          continue
c
c     ----- end of concave reentrant loop ----
  280       continue
c
c     ----- saddle-shaped reentrant ----
c
            if (.not. (si .or. sj)) go to 450
c
c     ----- calculate number of rotations of probe pair,
c     rotation angle and rotation matrix ----
c
            rij = (ri + rj) / 2
            avh = 0.5d0 * dabs(height-rw) + 
     +            0.5d0 * (height * (rij/(rij+rw)))
            nrot = dsqrt(den) * 3.14159d0 * avh
            if (nrot .lt. 1) nrot = 1
            angle = 3.14159d0/nrot
            call imatx(h)
            h(2,2) = dcos(angle)
            h(3,3) = h(2,2)
            h(3,2) = dsin(angle)
            h(2,3) = - h(3,2)
c
c     ----- calculate matrix to rotate x-axis onto iatom-jatom axis ---
c
            do 290 k = 1,3
               g(k,1) = uij(k)
               g(k,2) = alt(k)/height
  290       continue
            call cross(g(1,1),g(1,2),g(1,3))
c
c     ---- make the probe pair rotation matrix be about the
c     iatom-jatom axis ----
c
            call conj_mop(h,g,ghgt)
c
c     ----- arc generation ----
c
            do 300 k = 1,3
               cw(k,1) = base(k) + alt(k)
               wi(k) = ci(k) - cw(k,1)
               wj(k) = cj(k) - cw(k,1)
  300       continue
c
c     rotate circle onto iatom-jatom-water plane
c     and select points between water-iatom and
c     water-jatom vector to form the arc
c
            narc = 1
            do 330 i = 1,ncirc
               if (narc .gt. 50) call surf_err(440,narc,0.0d0)
               call multv_mop(circle(1,i),g,arc1(1,narc))
               call cross(wi,arc1(1,narc),vector)
               if (dot1(g(1,3),vector) .lt. 0.0d0) go to 330
               call cross(arc1(1,narc),wj,vector)
               if (dot1(g(1,3),vector) .lt. 0.0d0) go to 330
c
c     make arc point vectors originate with base point
c     rather than probe center because they will be
c     rotated around the iatom-jatom axis which passes
c     through the base point
c
               do 310 k = 1,3
                  arc(k,narc,1) = arc1(k,narc) + alt(k)
  310          continue
c
c     ----- invert arc through line of symmetry ----
c
               p = dot1(uij,arc(1,narc,1))
               do 320 k = 1,3
                  arc(k,narc,2) = - arc(k,narc,1) + 2 * p * uij(k)
  320          continue
c
c     check whether the arc point crosses the iatom-jatom axis
c     and calculate the area associated with the point
c
               ra = dot1(alt,arc(1,narc,1))
               ayon(narc) = ra .lt. 0.0d0
               ra =dabs(ra/height)
               arca(narc) = (2*3.14159d0**2*rw*ra)/(ncirc*nrot)
               narc = narc + 1
  330       continue
            narc = narc - 1
c
c     ----- initialize power matrix to identity ----
c
            call imatx(pow)
c
c     ----- rotate the probe pair around the pair of atoms ----
c
            do 440 irot = 1,nrot
               call multv_mop(alt,pow,ralt(1,1))
               do 340 k = 1,3
                  ralt(k,2) = - ralt(k,1)
  340          continue
               do 360 iw = 1,2
                  do 350 k = 1,3
                     cw(k,iw) = base(k) + ralt(k,iw)
  350             continue
c
c     ----- check for collisions with neighboring atoms ----
c
                  pair(iw) = .not. collid1(cw(1,iw),rw,cnbr,rnbr,mnbr,
     +            nnbr,2,jnbr,knbr)
  360          continue
c
c     ---- no surface generation if neither probe position is allowed
c
               if (.not. pair(1) .and. .not. pair(2)) go to 430
               both = pair(1) .and. pair(2)
c
c     ----- surface generation ----
c
               do 420 iw = 1,2
                  if (.not. pair(iw)) go to 420
                  np = 1
c
c     ---- the saddle-shaped reentrant surface points come from the arc
c
                  do 400 i = 1,narc
c
c     ----- overlapping reentrant surface removal
c     for symmetry-related probe positions ----
c
                     if (both .and. ayon(i)) go to 400
                     if (np .gt. 100)
     1                   call surf_err(480,np,0.0d0)
c
c     ---- rotate the arc from the xy plane onto the
c     iatom-jatom-water plane ----
c
                     call multv_mop(arc(1,i,iw),pow,arcr)
c
c     ----- make coordinates relative to origin ----
c
                     do 370 k = 1,3
                        sco(k,np) = base(k) + arcr(k)
  370                continue
c
c     ----- find the closest atom ----
c
                     di = dist_mop(sco(1,np),ci) - ri
                     dj = dist_mop(sco(1,np),cj) - rj
                     if (di .le. dj) go to 380
                     if (.not. sj) go to 400
                     n1(np) = jatom
                     n2(np) = iatom
                     go to 390
  380                continue
                     if (.not. si) go to 400
                     n1(np) = iatom
                     n2(np) = jatom
  390                continue
c
c     ----- we've got a surface point ----
c
                     yon(np) = ayon(i)
                     torus(np) = arca(i)
                     np = np + 1
c
  400             continue
                  np = np - 1
                  if (np .le. 0) go to 420
c
c     ----- write the shape,number of points,probe position and
c     the vector from the base to the probe center ----
c
                  write(isur,240) 2,np,(cw(k,iw),k=1,3),
     +            (ralt(k,iw),k=1,3)
c
c     ----- write surface points for this probe position ----
c
                  do 410 i = 1,np
                     write(isur,250) n1(i),n2(i),0,
     +               (sco(k,i),k=1,3),torus(i),yon(i)
c
  410             continue
c
  420          continue
  430          continue
c
c     ----- calculate new power matrix ----
c
               call mop_cat(pow,ghgt)
c
  440       continue
  450    continue
c
c     ----- skip to here if van der waals surface calculation ----
c
  460    continue
c
c     ---- contact surface ----
c
         if (.not. si) go to 520
         ncon = (4 * 3.14159d0 * ri ** 2) * den
         if (ncon .gt. 500) ncon = 500
c
c     ----- this call may decrease ncon somewhat ----
c
         call genunt(con,ncon)
         area = (4 * 3.14159d0 * ri ** 2) / ncon
c
c     ----- contact probe placement loop ----
c
         do 510 i = 1,ncon
            do 470 k = 1,3
               cw(k,1) = ci(k) + (ri + rw) * con(k,i)
  470       continue
c
c     ---- check for collision with neighboring atoms ----
c
            if (collid1(cw(1,1),rw,cnbr,rnbr,mnbr,nnbr,1,
     +                  jnbr,knbr)) go to 510
  480       format(3i5,i2,3f9.3,4f7.3)
            do 490 kk=1,3
               temp0(kk) =ci(kk)+ri*con(kk,i)
  490       continue
            it345=it345+1
            do 500 k=1,3
               vwxyz(k,it345)=temp0(k)
  500       continue
  510    continue
  520 continue
c
c     ----- if van der waals surface we are finished ----
c
      if (rw .eq. 0.0) return
c     close(3)
c
c     ----- skip to here if doing orsr only ----
c
  530 continue
c
c     ----- overlapping reentrant surface removal
c     for non-symmetry-related probes ----
c
      dw = 2 * rw
      dw2 = dw ** 2
      rw2 = rw ** 2
      nyw = 1
c     open(3,file='before',status='old')
      rewind(3)
c
      do 550 i = 1,10000
         if (nyw .gt. 1250) call surf_err(720,nyw,0.0d0)
         read (3,240,end=560) ishape,np,(yonwat(k,nyw),k=1,3),
     1(yonalt(k,nyw),k=1,3)
c
c     ----- look for yon points on this probe ----
c
         anyon = .false.
         do 540 j = 1,np
            read (3,250) n1(1),n2(1),n3(1),(sco(k,1),k=1,3),area,yon(1)
            if (yon(1)) anyon = .true.
  540    continue
         if (.not. anyon) go to 550
         iyon(nyw) = i
         nyw = nyw + 1
  550 continue
c
c     ----- go here on end of file on before file ----
c
  560 continue
      nyw = nyw - 1
      nvw = 1
      if (nyw .le. 0) go to 610
      rewind(3)
      do 600 i = 1,10000
         if (nvw .gt. 3750) call surf_err(760,nyw,0.0d0)
         read (3,240,end=610) ishape,np,(vicwat(k,nvw),k=1,3),
     1(vicalt(k,nvw),k=1,3)
         do 570 j = 1,np
            read (3,250) n1(1),n2(1),n3(1),(sco(k,1),k=1,3),area,yon(1)
  570    continue
c
c     ----- check if this is a yon water ----
c
         do 580 j = 1,nyw
            if (iyon(j) .eq. i) go to 600
  580    continue
c
c     ----- look for overlap with any water with yon surface points ---
c
         do 590 j = 1,nyw
            x =dabs(yonwat(1,j) - vicwat(1,nvw))
            if (x .ge. dw) go to 590
            y =dabs(yonwat(2,j) - vicwat(2,nvw))
            if (y .ge. dw) go to 590
            z =dabs(yonwat(3,j) - vicwat(3,nvw))
            if (z .ge. dw) go to 590
            d2 = x ** 2 + y ** 2 + z ** 2
            if (d2 .ge. dw2) go to 590
            if (dot1(yonalt(1,j),vicalt(1,nvw)) .ge. 0.0) go to 590
            ivic(nvw) = i
            nvw = nvw + 1
c
c     ----- one overlap makes this water a victim
c     we don't need to check any more ----
c
            go to 600
  590    continue
c
c     ---- skip to here if finished with hunt for overlapping waters ---
c
  600 continue
c
c     ---- skip to here if there are no yon waters and hence no victims
c
  610 continue
      nvw = nvw - 1
c
c     open(40,file='reentra',status='unknown')
      rewind(4)
c
      rewind(3)
      do 740 i = 1,10000
         read (3,240,end=750) ishape,np,(cw(k,1),k=1,3),(alt(k),k=1,3)
c
c     ---- no points can be eaten if this water is neither yon
c     nor a victim ----
c
         neat = 0
c
c     ----- determine if probe is a yon or victim water
c     by searching our lists of yon and victim waters ----
c
         if (nyw .le. 0) go to 690
         ipt = 0
         do 620 j = 1,nyw
            if (iyon(j) .ne. i) go to 620
c
c     ---- we've got a yon water here ----
c
            ipt = 2
            go to 640
  620    continue
         if (nvw .le. 0) go to 690
         do 630 j = 1,nvw
            if (ivic(j) .ne. i) go to 630
c
c     ---- we've got a victim ----
c
            ipt = 1
            go to 640
  630    continue
  640    continue
c
         if (ipt .le. 0) go to 690
c
c     ---- check this victim or yon probe against all yon probes ---
c
         do 660 j = 1,nyw
            if (dist2m(cw(1,1),yonwat(1,j)) .ge. dw2) go to 660
            if (dot1(alt,yonalt(1,j)) .ge. 0.0) go to 660
c
c     ---- this yon water could eat some of the probe's points ----
c
            neat = neat + 1
            if (neat .gt. 100) call surf_err(830,neat,0.0d0)
            do 650 k = 1,3
               eat(k,neat) = yonwat(k,j)
  650       continue
  660    continue
c
c     ----- only yon waters can have their points eaten by victims ---
c
         if (ipt .le. 1) go to 690
c
c     ----- check this yon probe against all victim probes ----
c
         do 680 j = 1,nvw
            if (dist2m(cw(1,1),vicwat(1,j)) .ge. dw2) go to 680
            if (dot1(alt,vicalt(1,j)) .ge. 0.0) go to 680
c
c     ---- this victim water could eat some of the probe's points ---
c
            neat = neat + 1
            if (neat .gt. 100) call surf_err(850,neat,0.0d0)
            do 670 k = 1,3
               eat(k,neat) = vicwat(k,j)
  670       continue
  680    continue
c
c     ---- skip to here if victim or both probe overlap checks omitted
c
  690    continue
c
c     ---- read the surface point belonging to the probe ----
c
         do 730 j = 1,np
            read (3,250) n1(1),n2(1),n3(1),(sco(k,1),k=1,3),area,yon(1)
            if (neat .le. 0) go to 710
c
c     ---- check surface point against all eaters of this probe ----
c
            do 700 k = 1,neat
               if (dist2m(eat(1,k),sco(1,1)) .lt. rw2) go to 730
  700       continue
c
c     ---- skip to here if no overlapping probes could eat this point
c
  710       continue
            do 720 k = 1,3
               vector(k) = (cw(k,1) - sco(k,1))/rw
  720       continue
            write(40,480) n1(1),n2(1),n3(1),ishape,(sco(k,1),k=1,3),area
     1,(vector(k),k=1,3)
c
  730    continue
  740 continue
  750 continue
c
c     close(3)
c     close(4)
      call mopend
      end
      subroutine conj_mop(h,g,ghgt)
      implicit REAL (a-h,o-z)
      dimension g(3,3)
      dimension h(3,3)
      dimension ghgt(3,3)
      dimension gt(3,3)
c
c     ----- initialize ghgt matrix to identity
c     concatenate g h gt ----
c
      call imatx(ghgt)
      call mop_cat(ghgt,g)
      call mop_cat(ghgt,h)
      do 20 k = 1,3
         do 10 l = 1,3
            gt(k,l) = g(l,k)
   10    continue
   20 continue
      call mop_cat(ghgt,gt)
      return
      end
      function dist_mop(a,b)
      implicit REAL (a-h,o-z)
      dimension a(3)
      dimension b(3)
      dist_mop = 
     +     dsqrt((a(1)-b(1))**2 + (a(2)-b(2))**2 + (a(3)-b(3))**2)
      return
      end
      subroutine mop_cat(a,b)
      implicit REAL (a-h,o-z)
      dimension a(3,3)
      dimension b(3,3)
      dimension temp(3,3)
      do 20 i = 1,3
         do 10 j = 1,3
            temp(i,j) = a(i,1)*b(1,j) + a(i,2)*b(2,j) + a(i,3)*b(3,j)
   10    continue
   20 continue
      do 40 i = 1,3
         do 30 j = 1,3
            a(i,j) = temp(i,j)
   30    continue
   40 continue
      return
      end
      subroutine multv_mop(v,a,w)
      implicit REAL (a-h,o-z)
      dimension a(3,3)
      dimension v(3)
      dimension w(3)
      do 10 i = 1, 3
         w(i) = a(i,1)*v(1) + a(i,2)*v(2) + a(i,3)*v(3)
   10 continue
      return
      end
      subroutine mopcci(a,b,ra,rb,perp,base,vect,tri)
      implicit REAL (a-h,o-z)
c
c     ---- circle-circle intersection ----
c
      dimension a(3), b(3)
      dimension perp(3)
      dimension base(3)
      dimension vect(3)
      logical tri
      dimension c(3),cu(3),c1v(3)
      do 10 k = 1,3
         c(k) = b(k) - a(k)
   10 continue
      dab = anorm_mop(c)
c
c     ----- is it a triangle? ----
c
      tri = .true.
      if (ra + rb .le. dab) tri = .false.
      if (ra + dab .le. rb) tri = .false.
      if (dab + rb .le. ra) tri = .false.
      if (.not. tri) return
      call vnorm_mop(c,cu)
      c1 = 0.5d0 * (dab + (ra**2 - rb**2)/dab)
      do 20 k = 1,3
         c1v(k) = c(k) * (c1/dab)
         base(k) = a(k) + c1v(k)
   20 continue
      v = dsqrt(ra**2 - c1**2)
      call cross(c,perp,vect)
      call vnorm_mop(vect,vect)
      do 30 k = 1,3
         vect(k) = vect(k) * v
   30 continue
      return
      end
      subroutine vnorm_mop(a,b)
      implicit REAL (a-h,o-z)
      dimension a(3),b(3)
      v = anorm_mop(a)
      do 10 k = 1,3
         b(k) = a(k) / v
   10 continue
      return
      end
      subroutine vperp_mop(a,b)
      implicit REAL (a-h,o-z)
      dimension a(3)
      dimension b(3)
      dimension p(3)
      small = 10000.0d0
      m = 0
      do 10 k = 1,3
         if (dabs(a(k)) .ge. small) go to 10
         small = dabs(a(k))
         m = k
   10 continue
      do 20 k = 1,3
         b(k) = 0.0d0
         if (k .eq. m) b(k) = 1.0d0
   20 continue
      dt = a(m) / (a(1)**2 + a(2)**2 + a(3)**2)
      do 30 k = 1, 3
         p(k) = dt * a(k)
         b(k) = b(k) - p(k)
   30 continue
      call vnorm_mop(b,b)
      return
      end
      subroutine drepp2(ni,nj,rij,ri,core)
**********************************************************************
* drepp2 calculates the integral for pmep.
* reference g.p.ford and b.wang, j.comput.chem. 14 (1993)1101.
*                            written by bingze wang, 10 october 1991.
**********************************************************************
      implicit REAL (a-h,o-z)                               
      common /multip/ dd(107),qq(107),add(107,3)                        
      common /corec/ tore(107)
      common /cmporb/ natorb(107)                                       
      dimension ri(22),core(4,2),arg(72),sqr(72) 
      data a0/0.529167d0/ ,ev/27.21d0/, ev1/13.605d0/, ev2/6.8025d0/
      data pp/0.5d00/          
      r=rij/a0                                                          
      if (natorb(ni).lt.3) then 
c                                           hydrogen - hydrogen (ss/ss)
         aee = pp/add(ni,1) 
         aee = aee * aee                                                
         ri(1) = ev/dsqrt(r*r+aee)                                      
         core(1,1 )= ri(1)                                     
         core(1,2) = tore(ni)*ri(1)                                     
      else 
c                                                 heavy atom - hydrogen
         aee = pp/add(ni,1) 
         aee = aee * aee                                                
         da=dd(ni)                                                      
         qa=qq(ni) * 2.0d0
         ade = pp/add(ni,2) 
         ade = ade * ade                                                
         aqe = pp/add(ni,3) 
         aqe = aqe * aqe                                                
         rsq = r*r                                                      
         arg(1) = rsq + aee                                             
         xxx = r+da                                                     
         arg(2) = xxx*xxx + ade                                         
         xxx = r-da                                                     
         arg(3) = xxx*xxx + ade                                         
         xxx = r+qa                                                     
         arg(4) = xxx*xxx + aqe                                         
         xxx = r-qa                                                     
         arg(5) = xxx*xxx + aqe                                         
         arg(6) = rsq + aqe                                             
         arg(7) = arg(6) + qa*qa                                        
         do 10 i = 1,7                                                  
            sqr(i) = dsqrt(arg(i))                                     
   10    continue                                                       
         ee = ev/sqr(1)                                                 
         ri(1) = ee                                                     
         ri(2) = ev1/sqr(2) - ev1/sqr(3)                                
         ri(3) = ee + ev2/sqr(4) + ev2/sqr(5) - ev1/sqr(6)              
         ri(4) = ee + ev1/sqr(7) - ev1/sqr(6)                           
         core(1,1) = ri(1)                                     
         core(2,1) = ri(2)                                     
         core(3,1) = ri(3)                                     
         core(4,1) = ri(4)                                     
         core(1,2) = tore(ni)*ri(1)                                     
      endif                    
      return                                                            
      end                                                               
c                                                                       
      subroutine drotat(ni,nj,xi,xj,e1b,enuc,rij)
***********************************************************************
*  subroutine drotat transforms the integrals from local coordinates
*  into molecular coordinates for pmep computations. 
*                                  written by bingze wang, nov. 1991
***********************************************************************
      implicit REAL (a-h,o-z)                               
      common /cmporb/ natorb(107)                                       
      common /corec/ tore(107)
      common /rotdum/ css1,csp1,cpps1,cppp1,css2,csp2,cpps2,cppp2       
      dimension  x(3),y(3),z(3)                                    
      dimension xi(3),xj(3),e1b(10)
      dimension ri(22),ccore(4,2)
      equivalence (ccore(1,1),css1)                                     
c                                                                       
      x(1)=xi(1)-xj(1)                                                  
      x(2)=xi(2)-xj(2)                                                  
      x(3)=xi(3)-xj(3)                                                  
         rijx= rij                                                      
c                                   compute integrals in diatomic frame 
         call drepp2(ni,nj,rij,ri,ccore)
c                                                                       
         gam = ri(1)                                                    
         a=1.d0/rijx                                                    
         x(1) = x(1)*a                                                  
         x(2) = x(2)*a                                                  
         x(3) = x(3)*a                                                  
         if (dabs(x(3)).gt.0.99999d0) then                         
            x(3) = dsign(1.d0,x(3))                             
            y(1) = 0.d0                                                 
            y(2) = 1.d0                                                 
            y(3) = 0.d0                                                 
            z(1) = 1.d0                                                 
            z(2) = 0.d0                                                 
            z(3) = 0.d0                                                 
         else                                                           
            z(3)=dsqrt(1.d0-x(3)*x(3))                                  
            a=1.d0/z(3)                                                 
            y(1)=-a*x(2)*dsign(1.d0,x(1))                       
            y(2)=dabs(a*x(1))                                     
            y(3)=0.0d0                                                   
            z(1)=-a*x(1)*x(3)                                           
            z(2)=-a*x(2)*x(3)                                           
         endif                                                          
         if ( natorb(ni).gt.1) then 
            xx11 = x(1)*x(1)                                            
            xx21 = x(2)*x(1)                                            
            xx22 = x(2)*x(2)                                            
            xx31 = x(3)*x(1)                                            
            xx32 = x(3)*x(2)                                            
            xx33 = x(3)*x(3)                                            
            yy11 = y(1)*y(1)                                            
            yy21 = y(2)*y(1)                                            
            yy22 = y(2)*y(2)                                            
            zz11 = z(1)*z(1)                                            
            zz21 = z(2)*z(1)                                            
            zz22 = z(2)*z(2)                                            
            zz31 = z(3)*z(1)                                            
            zz32 = z(3)*z(2)                                            
            zz33 = z(3)*z(3)                                            
            yyzz11 = yy11+zz11                                          
            yyzz21 = yy21+zz21                                          
            yyzz22 = yy22+zz22                                          
         endif                                                          
c                               rotate the nuclear attraction integrals 
         e1b(1)=-css1                                                   
         if(natorb(ni).eq.4) then                                       
            e1b(2) = -csp1 *x(1)                                        
            e1b(3) = -cpps1*xx11-cppp1*yyzz11                           
            e1b(4) = -csp1 *x(2)                                        
            e1b(5) = -cpps1*xx21-cppp1*yyzz21                           
            e1b(6) = -cpps1*xx22-cppp1*yyzz22                           
            e1b(7) = -csp1 *x(3)                                        
            e1b(8) = -cpps1*xx31-cppp1*zz31                             
            e1b(9) = -cpps1*xx32-cppp1*zz32                             
            e1b(10)= -cpps1*xx33-cppp1*zz33                             
         endif                                                         
         enuc = tore(ni)*gam                                   
      return                                                            
      end                                                               
      subroutine dvfill(nppa,dirvec)
c        fuellen des feldes dirvec
      implicit REAL (a-h,o-z)
      dimension dirvec(3,*)
      integer fset(3,20), kset(2,30)
      data kset/ 1, 2, 1, 3, 1, 4, 1, 5, 1, 6,
     1            12,11,12,10,12, 9,12, 8,12, 7,
     2             2, 3, 3, 4, 4, 5, 5, 6, 6, 2,
     3             7, 8, 8, 9, 9,10,10,11,11, 7,
     4             2,7,7,3,3,8,8,4,4,9,9,5,5,10,10,6,6,11,11,2/
      data fset/ 1, 2, 3, 1, 3, 4, 1, 4, 5, 1, 5, 6, 1, 6, 2,
     1            12,11,10,12,10, 9,12, 9, 8,12, 8, 7,12, 7,11,
     2             2, 3, 7, 3, 4, 8, 4, 5, 9, 5, 6,10, 6, 2,11,
     3             7, 8, 3, 8, 9, 4, 9,10, 5,10,11, 6,11, 7, 2/
      dirvec (1,1) =  -1.d0
      dirvec (2,1) =   0.d0
      dirvec (3,1) =   0.d0
      nd=1
      r=dsqrt(.8d0)
      h=dsqrt(.2d0)
      do 10 i= -1,1,2
         do 10 j= 1,5
            nd=nd+1
            beta=1.d0+ j*1.25663706d0 + (i+1)*0.3141593d0
            dirvec(2,nd)=r*dcos(beta)
            dirvec(3,nd)=r*dsin(beta)
            dirvec(1,nd)=i*h
   10 continue
      dirvec (2,12) =  0.d0
      dirvec (3,12) =  0.d0
      dirvec (1,12) =  1.d0
      nd=12
c  nppa=10*3**k*4**l+2
      m=(nppa-2)/10
      do 20 k=0,10
         if ((m/3)*3 .ne. m) go to 30
   20 m=m/3
   30 do 40 l=0,10
         if ((m/4)*4 .ne. m) go to 50
   40 m=m/4
   50 if (10*3**k*4**l+2 .ne. nppa) stop 'value of nppa not allowed:
     1  it must be 10*3**k*4**l+2'
      kh=k/2
      m=2**l*3**kh
c create on each edge 2**l*3**kh-1 new points
      do 70 i=1,30
         na=kset(1,i)
         nb=kset(2,i)
         do 70 j=1,m-1
            nd=nd+1
            do 60 ix=1,3
   60       dirvec(ix,nd)=dirvec(ix,na)*(m-j)+dirvec(ix,nb)*j
   70 continue
c create points within each triangle
      do 90 i=1,20
         na=fset(1,i)
         nb=fset(2,i)
         nc=fset(3,i)
         do 90 j1=1,m-1
            do 90 j2=1,m-j1-1
               nd=nd+1
               do 80 ix=1,3
   80          dirvec(ix,nd)=dirvec(ix,na)*(m-j1-j2)
     1                     +dirvec(ix,nb)*j1+dirvec(ix,nc)*j2
   90 continue
      if (k .eq. 2*kh) go to 140
c create to additional subgrids
      t=1.0d0/3.0d0
      do 110 i=1,20
         na=fset(1,i)
         nb=fset(2,i)
         nc=fset(3,i)
         do 110 j1=0,m-1
            do 110 j2=0,m-j1-1
               nd=nd+1
               do 100 ix=1,3
  100          dirvec(ix,nd)=dirvec(ix,na)*(m-j1-j2-2*t)
     1                 +dirvec(ix,nb)*(j1+t)+dirvec(ix,nc)*(j2+t)
  110 continue
      t=2.d0/3.0d0
      do 130 i=1,20
         na=fset(1,i)
         nb=fset(2,i)
         nc=fset(3,i)
         do 130 j1=0,m-2
            do 130 j2=0,m-j1-2
               nd=nd+1
               do 120 ix=1,3
  120          dirvec(ix,nd)=dirvec(ix,na)*(m-j1-j2-2*t)
     1                  +dirvec(ix,nb)*(j1+t)+dirvec(ix,nc)*(j2+t)
  130 continue
c normalize all vectors
  140 do 170 i=1,nppa
         dist=0.0d0
         do 150 ix=1,3
  150    dist=dist+dirvec(ix,i)**2
         dist=1.0d0/dsqrt(dist)
         do 160 ix=1,3
  160    dirvec(ix,i)=dirvec(ix,i)*dist
  170 continue
      return
      end
      subroutine epsab(eigsab,eigs,gab,ga,gb,ua,ub,
     1           uab,udms,norbs,nclose,iwflb)
      implicit REAL (a-h,o-z)
      common /omval/ omega
c
c  this subroutine creates the new epsilon matrix and udms matrix
c
      dimension eigs(norbs),eigsab(norbs,norbs),
     1          ga(norbs,norbs),gb(norbs,norbs),
     2          gab(norbs,norbs),uab(norbs,norbs),
     3          ua(norbs,norbs),ub(norbs,norbs),udms(norbs,norbs)
c
c  zero epsilon omega omega matrix initially
c
      call zerom(eigsab,norbs)
c
c  zero uab minus omega,omega matrix initially
c
      call zerom(udms,norbs)
c
      if ((iwflb .eq. 0) .or. (iwflb .eq. 1)) then
         omval = 2.0d00 * omega
      elseif (iwflb .eq. 3) then
         omval = 0.0d00
      elseif (iwflb .eq. 2) then
         omval = omega
      endif
      do 30 i = 1,nclose
         do 20 j = 1,nclose
            s1=0.0d00
            do 10 k = nclose+1, norbs
c
c calculation for epsab
c
               s1 = s1+ ga(i,k)*ub(k,j)+gb(i,k)*ua(k,j)
c
   10       continue
            eigsab(i,j)=gab(i,j)+s1+uab(i,j)*(eigs(i)-
     1                    eigs(j) + omval)/27.2113961d00
   20    continue
   30 continue
c
c calculation for ums
c
      do 60 i=1,norbs
         do 50 j=1,norbs
            s2=0.0d00
            do 40 k= 1,norbs
               s2 = s2 + ua(i,k)*ub(k,j)+ub(i,k)*ua(k,j)
   40       continue
c
            udms(i,j) = s2-uab(i,j)
   50    continue
   60 continue
c
      return
      end
      subroutine efstr(xparam,funct,ihess,ntime,iloop,igthes,mxstep,
     $ireclc,iupd,dmax,ddmax,dmin,tol2,totime,time1,time2,nvar,
     $scf1,lupd,ldump,log,rrscal,donr,gnmin)
      implicit REAL (a-h,o-z)                                       
INCLUDE(common/sizes)                                                           
      dimension xparam(*)                                                       
c                                                                               
      common /istope/ ams(107)                                                  
      common /last  / last                                                      
      common /keywrd/ keywrd                                                    
      common /timex / time0                                                     
      common /gradnt/ grad(maxpar),gnfina                                       
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),          
     1                nlast(numatm), norbs, nelecs,nalpha,nbeta,                
     2                nclose,nopen,ndumy,fract                                  
      common /numcal/ numcal                                                    
      common /scftyp/ emin, limscf
      common /nllcom/ hess(maxpar,maxpar),bmat(maxpar,maxpar),                  
     *pmat(maxhes)                                                              
      common/fmatrx/oldf(maxpar),d(maxpar),vmode(maxpar),
     $u(maxpar,maxpar),dd,rmin,rmax,omin,xlamd,xlamd0,skal,
     $mode,nstep,negreq,iprnt
      common/iofile/mfgr,mfgw
      dimension ipow(9)               
      logical restrt,scf1,ldum,lupd,log,rrscal,donr,gnmin 
c ***** added    by jiro toyoda at 1994-05-25 *****
      logical limscf
c ***************************** at 1994-05-25 *****
      character*241 keywrd,line                                               
      character chdot*1,zero*1,nine*1,ch*1
      data chdot,zero,nine   /'.','0','9'/                     
      data  icalcn,zzero  /0,0.d0/                          
c     get all initialization data                                               
         nvar=iabs(nvar)
         ldump=0
         icalcn=numcal
         lupd=(index(keywrd,' noupd') .eq. 0)                                
         restrt=(index(keywrd,'restart') .ne. 0)
         log    = index(keywrd,'nolog').eq.0
         scf1=(index(keywrd,'1scf') .ne. 0)
         nstep=0
         ihess=0
         last=0
         ntime=0
         iloop=1
         imin=index(keywrd,' ef')
         if(imin.ne.0) then
            mode=0
            igthes=0
            iupd  =2
            negreq=0
            ddmax=0.5d0
         endif
         limscf=.false.
         its=index(keywrd,' ts')
         if(its.ne.0) then
            mode=1
            igthes=1
            iupd  =1
            negreq=1
            rmin=0.0d0
            rmax=4.0d0
            omin=0.8d0
            ddmax=0.3d0
         endif
         rrscal=.false.
         i=index(keywrd,' rscal') 
         if(i.ne.0) rrscal=.true.
         donr=.true.
         i=index(keywrd,' nonr') 
         if(i.ne.0) donr=.false.
         gnmin=.false.
         i=index(keywrd,' gnmin') 
         if(i.ne.0) gnmin=.true.
         iprnt=0
         ip=index(keywrd,' prnt=') 
         if(ip.ne.0) iprnt=reada(keywrd,ip) 
         if(iprnt.gt.5)iprnt=5                                                  
         if(iprnt.lt.0)iprnt=0                                                  
         mxstep=100                                                             
         i=index(keywrd,' cycles=')                                             
         if(i.ne.0) mxstep=reada(keywrd,i)                                      
         if (i.ne.0 .and. mxstep.eq.0 .and. ip.eq.0) iprnt=3
         ireclc=999999
         i=index(keywrd,' recalc=')
         if(i.ne.0) ireclc=reada(keywrd,i)
         i=index(keywrd,' iupd=')
         if(i.ne.0) iupd=reada(keywrd,i)
         i=index(keywrd,' mode=')
         if(i.ne.0) mode=reada(keywrd,i)
         dmin=1.0d-3
         i=index(keywrd,' ddmin=')
         if(i.ne.0) dmin=reada(keywrd,i)
         dmax=0.2d0
         i=index(keywrd,' dmax=')
         if(i.ne.0) dmax=reada(keywrd,i)
         i=index(keywrd,' ddmax=')
         if(i.ne.0) ddmax=reada(keywrd,i)
         tol2=1.d+0
         if(index(keywrd,' prec') .ne. 0) tol2=5.d-2
         i=index(keywrd,' gnorm=')
         if(i.ne.0) tol2=reada(keywrd,i)
         if(index(keywrd,' let').eq.0.and.tol2.lt.0.01d0)then
            write(mfgw,'(/,a)')
     +      '  gnorm has been set too low, reset to 0.01.',
     +      ' specify let as keyword to allow gnorm less than 0.01'
            tol2=0.01d0
         endif
         i=index(keywrd,' hess=')
         if(i.ne.0) igthes=reada(keywrd,i)
         i=index(keywrd,' rmin=')
         if(i.ne.0) rmin=reada(keywrd,i)
         i=index(keywrd,' rmax=')
         if(i.ne.0) rmax=reada(keywrd,i)
         i=index(keywrd,' omin=')
         if(i.ne.0) omin=reada(keywrd,i)
         time1=time0
         time2=time1
c   done with all initializing stuff.
c   check that options requested are resonable
         if(nvar.gt.(3*numat-6) .and. numat.ge.3)write(mfgw,25)
   25    format(/,'*** warning! more variables than degrees of freedom',
     1/)
         if((its.ne.0).and.(iupd.eq.2))then
            write(mfgw,*)' ts search and bfgs update will not work'
_IF(ipsc,tools)
         call pend
_ELSE
         stop
_ENDIF
         endif
         if((its.ne.0).and.(igthes.eq.0))then
            write(mfgw,*)
     +    ' ts search require better than diagonal hessian'
_IF(ipsc,tools)
            call pend
_ELSE
            stop
_ENDIF
         endif
         if((igthes.lt.0).or.(igthes.gt.3))then
            write(mfgw,*)' unrecognized hess option',igthes
_IF(ipsc,tools)
            call pend
_ELSE
            stop
_ENDIF
         endif
         if((omin.lt.0.d0).or.(omin.gt.1.d0))then
            write(mfgw,*)' omin must be between 0 and 1',omin
_IF(ipsc,tools)
            call pend
_ELSE
            stop
_ENDIF
         endif
         if (restrt) then
c
c   restore data. i indicates (hessian restart or optimization
c   restart). if i .gt. 0 then hessian restart and i is last
c   step calculated in the hessian. if i .le. 0 then j (nstep)
c   in an optimization has been done.
c
            ipow(9)=0
            mtmp=mode
            call bkrsav(tt0,hess,funct,grad,xparam,pmat,i,j,bmat,ipow)
            mode=mtmp
            k=tt0/1000000.d0
            time0=time0-tt0+k*1000000.d0
            iloop=i
            if (i .gt. 0) then
               igthes=4
               nstep=j
               write(mfgw,
     +        '(10x,''restarting hessian at point'',i4)')iloop
               if(nstep.ne.0)write(mfgw,
     +        '(10x,''in optimization step'',i4)')nstep
            else
               nstep=j
               write(mfgw,
     +         '(//10x,''restarting optimization at step'',i4)')nstep
               do 26 i=1,nvar
   26          grad(i)=zzero
               call compfg(xparam, .true., funct, .true., grad, .true.)
            endif
         else
c   not a restart, we need to get the gradients
            do 30 i=1,nvar
   30       grad(i)=zzero
            call compfg(xparam, .true., funct, .true., grad, .true.)
         endif
      return
      end
      subroutine surf_err(number,int,float)
      implicit REAL (a-h,o-z)
c
      common/io/in,iout,ipunch
      dimension list(15)
      data list/110,120,130,140,150,160,170,
     1210,320,440,480,720,760,830,850/
c
      do 10 i = 1,15
         if (list(i) .eq. number) go to 30
   10 continue
      write (iout,20)
   20 format('error of unidentifiable type')
      call mopend
   30 continue
c
      go to (40,60,80,100,120,140,160,180,200,220,240,
     1260,280,300,320) i
c
   40 write (iout,50) number,float
   50 format('error',i5,2x,'negative surface point density: ',f10.5)
      call mopend
   60 write (iout,70) number,float
   70 format('error',i5,2x,'negative probe radius:',f10.5)
      call mopend
   80 write (iout,90) number,int
   90 format('error',i5,2x,'too few or too many atom types:',i5)
      call mopend
  100 write (iout,110) number,float,int
  110 format('error',i5,2x,'negative atom radius:',f10.5,' atom',i5)
      call mopend
  120 write (iout,130) number,int
  130 format('error',i5,2x,'too many atoms:',i5)
      call mopend
  140 write (iout,150) number,int
  150 format('error',i5,2x,
     1'invalid surface request number for atom:',i5)
      call mopend
  160 write (iout,170) number,int
  170 format('error',i5,2x,'invalid atom type for atom:',i5)
      call mopend
  180 write (iout,190) number,int
  190 format('error',i5,2x,'too many neighbors:',i5)
      call mopend
  200 write (iout,210) number,int
  210 format('error',i5,2x,'too many points for reentrant probe:',i5)
      call mopend
  220 write (iout,230) number,int
  230 format('error',i5,2x,'too many points for arc:',i5)
      call mopend
  240 write (iout,250) number,int
  250 format('error',i5,2x,'too many points for reentrant probe:',i5)
      call mopend
  260 write (iout,270) number,int
  270 format('error',i5,2x,'too many yon waters:',i5)
      call mopend
  280 write (iout,290) number,int
  290 format('error',i5,2x,'too many victim waters:',i5)
      call mopend
  300 write (iout,310) number,int
  310 format('error',i5,2x,'too many eaters:',i5)
      call mopend
  320 write (iout,330) number,int
  330 format('error',i5,2x,'too many eaters:',i5)
      call mopend
      end
      subroutine ffreq1(f, ptot, pa, pb, ndim)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      dimension f(ndim,ndim), ptot(ndim,ndim),
     1          pa(ndim,ndim), pb(ndim,ndim)
c *********************************************************************
c
c *** compute the remaining contributions to the one-centre elements.
c
c *********************************************************************
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),
     1                nlast(numatm), norbs, nelecs,nalpha,nbeta,
     2                nclose,nopen,ndumy,fract
      common /cmpga/ fn1(107),fn2(107)
      common /molorb/ uspd(maxorb),dumy(maxorb)
      common /twoele/ gss(107),gsp(107),gpp(107),gp2(107),hsp(107)
     1                ,gsd(107),gpd(107),gdd(107)
      common /keywrd/ keywrd
      character*241 keywrd
      logical first
      save first
      data first /.true./
      if(first)then
         first=.false.
      endif
      do 60 ii=1,numat
         ia=nfirst(ii)
         ib=nmidle(ii)
         ic=nlast(ii)
         ni=nat(ii)
         dtpop=0.0d0
         dapop=0.0d0
         ptpop=0.0d0
         papop=0.0d0
         goto (60,30,20,20,20,10,10,10,10,10)ic-ia+2
   10    dtpop=ptot(ic,ic)+ptot(ic-1,ic-1)
     1        +ptot(ic-2,ic-2)+ptot(ic-3,ic-3)
     2        +ptot(ic-4,ic-4)
         dapop=pa(ic,ic)+pa(ic-1,ic-1)
     1        +pa(ic-2,ic-2)+pa(ic-3,ic-3)
     2        +pa(ic-4,ic-4)
   20    ptpop=ptot(ib,ib)+ptot(ib-1,ib-1)
     1        +ptot(ib-2,ib-2)
         papop=pa(ib,ib)+pa(ib-1,ib-1)
     1        +pa(ib-2,ib-2)
   30    dbpop=dtpop-dapop
c
c     f(s,s)
c
         f(ia,ia) = f(ia,ia) + pb(ia,ia)*gss(ni) + ptpop*gsp(ni)
     1                       - papop*hsp(ni) + dtpop*gsd(ni)
         if (ni.lt.3) go to 60
         iplus=ia+1
         do 40 j=iplus,ib
c
c     f(p,p)
c
            f(j,j) = f(j,j) + ptot(ia,ia)*gsp(ni) - pa(ia,ia)*hsp(ni)
     1                   + pb(j,j)*gpp(ni) + (ptpop-ptot(j,j))*gp2(ni)
     2                   - 0.5d0*(papop-pa(j,j))*(gpp(ni)-gp2(ni))
     3                   + dtpop*gpd(ni)
c
c     f(s,p)
c
            f(ia,j) = f(ia,j) + 2.d0*ptot(ia,j)*hsp(ni)
     1                     - pa(ia,j)*(hsp(ni)+gsp(ni))
            f(j,ia) = f(j,ia) + 2.d0*ptot(j,ia)*hsp(ni)
     1                     - pa(j,ia)*(hsp(ni)+gsp(ni))
   40    continue
c
c     f(p,p*)
c
         iminus=ib-1
         do 50 j=iplus,iminus
            icc=j+1
            do 50 l=icc,ib
               f(j,l) = f(j,l) + ptot(j,l)*(gpp(ni)-gp2(ni))
     1                         - 0.5d0*pa(j,l)*(gpp(ni)+gp2(ni))
               f(l,j) = f(l,j) + ptot(l,j)*(gpp(ni)-gp2(ni))
     1                         - 0.5d0*pa(l,j)*(gpp(ni)+gp2(ni))
   50    continue
   60 continue
      return
      end
      subroutine ffreq2(f,ptot,w,numat,nfirst,nlast,norbs)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      dimension f(norbs,norbs), ptot(norbs,norbs),
     1           nfirst(*), nlast(*), w(*)
c*******************************************************************
c
c  tdhf forms two electron two center repulsion part of the fock
c  matrix
c on input ptot = total density matrix
c          p    = alpha or beta density matrix
c          w    = two electron integral matrix
c
c  on output f = partial fock matrix
c
c********************************************************************
      common /keywrd/ keywrd
      character*241 keywrd
   10 kk=0
c
      do 70 ii=2,numat
         iim1 = ii - 1
         ia=nfirst(ii)
         ib=nlast(ii)
         do 60 jj=1,iim1
            ja=nfirst(jj)
            jb=nlast(jj)
            do 50 i=ia,ib
               do 40 j=ia,i
                  fij = 1.0d00
                  if (i.eq.j) fij = 0.5d00
                  do 30 k=ja,jb
                     do 20 l=ja,k
                        fkl = 1.0d00
                        if (k.eq.l) fkl = 0.5d00
                        kk=kk+1
                        a=w(kk)
                        aint=a*fkl*fij
                        f(i,j)=f(i,j)+ aint*(ptot(k,l)+ptot(l,k))
                        f(j,i)=f(j,i)+ aint*(ptot(k,l)+ptot(l,k))
                        f(k,l)=f(k,l)+ aint*(ptot(i,j)+ptot(j,i))
                        f(l,k)=f(l,k)+ aint*(ptot(i,j)+ptot(j,i))
                        aint=aint*0.5d00
                        f(i,l)=f(i,l)-aint*ptot(j,k)
                        f(l,i)=f(l,i)-aint*ptot(k,j)
                        f(k,j)=f(k,j)-aint*ptot(l,i)
                        f(j,k)=f(j,k)-aint*ptot(i,l)
                        f(i,k)=f(i,k)-aint*ptot(j,l)
                        f(k,i)=f(k,i)-aint*ptot(l,j)
                        f(j,l)=f(j,l)-aint*ptot(i,k)
                        f(l,j)=f(l,j)-aint*ptot(k,i)
   20                continue
   30             continue
   40          continue
   50       continue
   60    continue
   70 continue
      return
      end
      subroutine fhpatn(a,b,norbs,itw,sign)
      implicit REAL (a-h,o-z)
c
c this subroutine converts the matrices into its adjoints
c
      dimension a(norbs,norbs),b(norbs,norbs)
      go to (10,40,40,10) itw
   10 continue
      do 30 j=1,norbs
         do 20 i=1,norbs
            a(i,j)=b(i,j)
   20    continue
   30 continue
      go to 70
   40 continue
      do 60 j=1,norbs
         do 50 i=1,norbs
            a(i,j)=sign*b(j,i)
   50    continue
   60 continue
   70 continue
      return
      end
      subroutine fillc(it,igbeg,igsp,igdf,ca)
      implicit REAL (a-h,o-z)
      integer shella,shelln,shellt,shellc,shladf,aos
c
c     --------------------------
c     gaussian 76 (qcpe version)
c     december 1977
c     control data 7600
c     --------------------------
c
c***********************************************************************
c     routine to obtain s, p, d, and f coefficients for /b/.
c***********************************************************************
c
      dimension ca(20)
      common/b/exx(360),c1(360),c2(360),c3(360),x(90),y(90),z(90),
     1         jan(90),shella(90),shelln(90),shellt(90),shellc(90),
     2         aos(90),nshell,maxtyp
      dimension c4(90),shladf(90)
      equivalence(c4(1),c3(91)),(shladf(1),c3(181))
      common/cfact/pt5,r3ov2,root3,root5,root15,r1,r2,r4,z1,z2,z3
c
c     test for f-functions.
      if(it-3)10,40,40
c
c     no f-functions are involved, fill only the first 10 locations
c     in ca.
   10 ca(1)=c1(igsp)
c
c     test for beyond s.
      if(it)50,50,20
c
c     fill p-part.
   20 ca(2)=c2(igsp)
      ca(3)=c2(igsp)
      ca(4)=c2(igsp)
c
c     test for beyond p.
      if(it-1)50,50,30
c
c     fill d-part, and watch out for normalization.
c     inddf provides indexing when added to igdf.
   30 inddf=igdf+(igsp-igbeg)
      ca( 5)=c3(inddf)
      ca( 6)=c3(inddf)
      ca( 7)=c3(inddf)
      temp=c3(inddf)*root3
      ca( 8)=temp
      ca( 9)=temp
      ca(10)=temp
      go to 50
c
c     fill f-part.
c     inddf provides indexing into c4.
   40 inddf=igdf+(igsp-igbeg)
      ca(11)=c4(inddf)
      ca(12)=c4(inddf)
      ca(13)=c4(inddf)
      temp=c4(inddf)*root5
      ca(14)=temp
      ca(15)=temp
      ca(16)=temp
      ca(17)=temp
      ca(18)=temp
      ca(19)=temp
      ca(20)=c4(inddf)*root15
c
   50 return
      end
      subroutine filmat(f,a)
      implicit REAL (a-h,o-z)
      integer aos,shella,shelln,shellt,shellc
      integer ubound,ulpure
c
c     --------------------------
c     gaussian 76 (qcpe version)
c     december 1977
c     control data 7600
c     --------------------------
c
      dimension f(*),a(*)
      common /ipure/ ipurd,ipurf
      common /commax/ lamax,lbmax,lpmax
      common /limit/ imj,istart,jstart,iend,jend,irange,jrange,lentq
      common /new/ inew,jnew
      common /b/ exx(360),c1(360),c2(360),c3(360),x(90),y(90),z(90),
     1         jan(90),shella(90),shelln(90),shellt(90),shellc(90),
     2         aos(90),nshell,maxtyp
      common /mopord/ nordr(20),n6ord(10),n5ord(9),n10ord(10),
     +                n7ord(7), lbound(4,3),ubound(4),ulpure(4)
      common /ia/ lind(151)
c
c
c***********************************************************************
c     this routine fills the lower triangular matrix a (in linear form)
c     this routine receives as input the shell numbers (inew,jnew),
c     shell duplicate test variable (imj), limiting information (via
c     /limit/), and addresses of shells via /b/, and performs matrix
c     building.
c     if necessary, purdf1 is called to transform to pure d or pure f.
c***********************************************************************
c
c
c     note that iend, jend, irange and jrange may be modified by purdf1.
      call purdf1(f)
      sum=0.d0
c
c     commence main processing loop.
c     here, the correct indices are obtained, referred to lower
c     triangular form, and the matrix elements are planted in a.
c     also, shell duplicate elimination is performed here.
c     ordering is achieved through nordr.
c
c     obtain correct bias for j-loop.
   10 indx1=0
c     obtain correct atomic orbital starting values.
      ist=aos(inew)-1
      jst=aos(jnew)-1
c     commence loop.
      do 90 i=istart,iend
         ix=nordr(i)
         if(imj)30,20,30
   20    jend=i
   30    intc=indx1
         do 80 j=jstart,jend
            intc=intc+1
            jx=nordr(j)
c     obtain raw indices.
            ii=ix+ist
            jj=jx+jst
c     obtain full matrix index.
            if(ii-jj)60,40,50
c     equal.
   40       indfm=lind(ii+1)
            go to 70
c     ii greater.
   50       indfm=lind(ii)+jj
            go to 70
c     jj greater.
   60       indfm=lind(jj)+ii
c
c     plant the value.
   70       sum=a(indfm)*f(intc)+sum
   80    continue
   90 indx1=indx1+jrange
c
c
c     restore iend, jend, irange, and jrange.
      iend=ubound(lamax)
      jend=ubound(lbmax)
      irange=iend-istart+1
      jrange=jend-jstart+1
      f(1)=sum
      return
      end
      subroutine flushm(n)
      endfile(n)
      backspace(n)
      return
      end
      subroutine dopen(c,mdim,norbs,ndubl,nsingl,fract)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      dimension c(mdim,*)
      common/drohf/sdm(mpack)
c**********************************************************************
c
c  dopen computes the density matrix of open shell rohf state functions
c  from the eigenvector matrix and the m.o's occupancies
c
c  input:   c      = square eigenvector matrix c
c           norbs  = number of orbitals
c           ndubl  = number of doubly occupied m.o's (=0 if uhf)
c           nsingl = number of singly or fractionally occupied m.o's
c
c  exit:    sdm    = rohf open shell density matrix
c
c**********************************************************************
c
c  set up limits for sums
c    nl1 = beginning of one electron sum
c    nu1 = end of the same
c
      n2=(norbs*(norbs+1))/2
         frac=fract
         nl1=ndubl+1
         nu1=nsingl
      l=0
      do 40 i=1,norbs
         do 30 j=1,i
            l=l+1
            sum1=0.0d0
            do 20 k=nl1,nu1
   20 sum1=sum1+c(i,k)*c(j,k)
   30    sdm(l)=sum1*frac
   40 continue
      return
      end
c
      subroutine genvec(u,n)
c*******************************************************************
c  generate unit vectors over sphere. for connolly surface only
c*******************************************************************
      implicit REAL (a-h,o-z)
      dimension u(3,n)
      pi=4.d0*atan(1.d0)
      nequat = dsqrt(n * pi)
      nvert = nequat/2
      nu = 0
      do 20 i = 1,nvert+1
         fi = (pi * (i-1)) / nvert
         z = dcos(fi)
         xy = dsin(fi)
         nhor = nequat * xy
         if (nhor .lt. 1) nhor = 1
         do 10 j = 1,nhor
            fj = (2.d0 * pi * (j-1)) / nhor
            x = dcos(fj) * xy
            y = dsin(fj) * xy
            if (nu .ge. n) go to 30
            nu = nu + 1
            u(1,nu) = x
            u(2,nu) = y
            u(3,nu) = z
   10    continue
   20 continue
   30 continue
      n = nu
      return
      end
      subroutine get2c(twoc,x,const,a)
c
c     --------------------------
c     gaussian 76 (qcpe version)
c     december 1977
c     control data 7600
c     --------------------------
c
c    *******************************************************************
c
c     this subroutine forms the two center integrals in twoc.  the
c     functions g are formed from x and const using g(1) = const, and
c     the recursion formula0
c
c          g(iv) = twopt2*(x*g(iv-1) - (iv-2)*g(iv-2))
c
c     the two center integrals are then formed using the coefficients
c     in a, which were formed in subroutine geta1.
c
c    *******************************************************************
c
      implicit REAL (a-h,o-z)
      common/intk/zero,xint(12)
      common/commax/lamax,lbmax,lpmax
      common/twop/twopt2,epi
      common/pdim/incp,idim2c,idimaa
c
      dimension twoc(*),a(*)
      dimension g(9)
c
c     calculate the g functions.
c
      lpnew=lpmax+incp
      g(1)=const
      g(2)=twopt2*x*g(1)
      do 10 i=3,9
   10 g(i)=zero
      if(lpnew.le.2) go to 30
      do 20 iv=3,lpnew
c
   20 g(iv)=twopt2*(x*g(iv-1)-xint(iv-2)*g(iv-2))
c
c     now evaluate the two center integrals using g and a.
c
   30 do 50 lp=1,lpnew
         inda=idim2c*(lp-1)
         y=zero
         do 40 iv=1,lp
   40    y=y+a(inda+iv)*g(iv)
   50 twoc(lp)=y
c
      return
      end
      subroutine get3c(valip,twoc,cc)
c
c     --------------------------
c     gaussian 76 (qcpe version)
c     december 1977
c     control data 7600
c     --------------------------
c
c    *******************************************************************
c
c     this subroutine transforms the integrals over functions at
c     center p, which are now stored in twoc, into the integrals
c     over functions centered at a and b.  these are to be stored in
c     valip.  the coefficients cc were formed in subroutine getcc1,
c     and the integrals over functions at p were formed in either
c     get2c or getefg, depending upon which integrals are being
c     transformed.
c
c      the matrix is of dimension valip(4,4) and is filled to
c     (lbmax,lamax), although the indexing is done linearly.
c
c    *******************************************************************
c
      implicit REAL (a-h,o-z)
      common/commax/lamax,lbmax,lpmax
      common/const/zero
      common/pdim/incp,idim2c,idimaa
c
      dimension cc(*),valip(*)
      dimension twoc(*)
c
      do 20 la=1,lamax
         indca=28*(la-1)
         indip=4*(la-1)
         do 20 lb=1,lbmax
            indc=indca+7*(lb-1)
            lwmax=la+lb-1
            y=zero
            do 10 lw=1,lwmax
   10       y=y+cc(indc+lw)*twoc(lw)
   20 valip(indip+lb)=y
      return
      end
      subroutine geta1(a)
c
c     --------------------------
c     gaussian 76 (qcpe version)
c     december 1977
c     control data 7600
c     --------------------------
c
c    *******************************************************************
c
c          this subroutine calculates the coefficients which transform
c     the functions g(iv) into the two center integrals.  this
c     transformation is carried out in subrouinte get2c, which should
c     be consulted for more details of the use of these coefficients.
c
c          the a matrix is of dimension a(idim,idim), although the
c     actual indexing is done linearly.  idim is 7 in link 302 (stvint)
c     and 9 in link 701 (prop1e).  the coefficients are calculated
c     from a(1,1)=1.0, and the recursion formula0
c
c          a(lv,lp+1) = (a(lv,lp-1)*(lp-1) + a(lv-1,lp))/(2*p)
c
c    *******************************************************************
c
      implicit REAL (a-h,o-z)
      dimension a(*)
c
      common/commax/lamax,lbmax,lpmax
      common/pdim/incp,idim,leng
      common/twop/twopt2,epi
      common/const/zero
      common/intk/zero1,xint(12)
c
      lpnew=lpmax+incp
      pp=0.5d0*epi
      a(1)=1.d0
      a(idim+2)=pp
      if(lpnew.le.2) go to 20
      do 10 lp=3,lpnew
         indlp=idim*(lp-1)
         ilpm1=indlp-idim-1
         ilpm2=ilpm1-idim+1
         lpm2=lp-2
         do 10 lv=1,lp
c
   10 a(indlp+lv)=pp*(xint(lpm2)*a(ilpm2+lv)+a(ilpm1+lv))
c
   20 continue
      return
      end
      subroutine getcc1(cc,ap,bp)
c
c     --------------------------
c     gaussian 76 (qcpe version)
c     december 1977
c     control data 7600
c     --------------------------
c
c    *******************************************************************
c
c     this subroutine calculates the coefficients which transform
c     the two center integrals into the three center integrals.  this
c     transformation is carried out in subroutine get3c, which should
c     be consulted for more details of the use of these coefficients.
c
c     the coefficient matrix is three dimensional, although the
c     actual indexing is done linearly.  the coefficients are
c     calculated from cc(1,1,1)=1.0, and the recursion formulae
c
c          cc(lw,lb,la) = ap*cc(lw,lb,la-1) + cc(lw-1,lb,la-1)
c
c          cc(lw,lb,la) = bp*cc(lw,lb-1,la) + cc(lw-1,lb-1,la)
c
c    *******************************************************************
c
      implicit REAL (a-h,o-z)
      common/commax/lamax,lbmax,lpmax
      common/const/zero
      dimension cc(112)
c
      do 50 la=1,lamax
         inda=28*(la-1)
         do 50 lb=1,lbmax
            ind=inda+7*(lb-1)
            lwmax=la+lb-1
            do 50 lw=1,lwmax
               if(la-1)30,30,10
   10          lwm1=ind+lw-29
               if(lwm1.gt.0) go to 20
               cc(ind+lw)=ap*cc(ind+lw-28)
               go to 50
   20          cc(ind+lw)=ap*cc(ind+lw-28)+cc(lwm1)
               go to 50
   30          if(lb.eq.1) go to 50
               lwm1=ind+lw-8
               if(lwm1.gt.0) go to 40
               cc(ind+lw)=bp*cc(ind+lw-7)
               go to 50
   40          cc(ind+lw)=bp*cc(ind+lw-7)+cc(lwm1)
   50 continue
      return
      end
      subroutine grids(co,potpt,nmep)
*********************************************************************
*   this subroutine calculates the williams surface or grids. it is
*   lifted from <esp> by b.h.besler and k.m.merz.
*********************************************************************
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      common /iofile/ mfgr,mfgw
      common /molkst/ natom,ian(numatm),nfirst(numatm),nmidle(numatm),  
     1                nlast(numatm), norbs, nelecs,nalpha,nbeta,        
     2                nclose,nopen,ndumy,fract                          
      dimension vderw(53),dist(100),xmin(3),xmax(3)
      dimension potpt(3,*),co(3,*)
c
      data vderw/53*0.0d0/
      vderw(1)=2.4d0
      vderw(5)=3.0d0
      vderw(6)=2.9d0
      vderw(7)=2.7d0
      vderw(8)=2.6d0
      vderw(9)=2.55d0
      vderw(15)=3.1d0
      vderw(16)=3.05d0
      vderw(17)=3.0d0
      vderw(35)=3.15d0
      vderw(53)=3.35d0
      shell=1.2d0
      grid=0.8d0
      closer=0.0d0
c     check if vderw is defined for all atoms
c
      do 30 i=1,natom
         if (vderw(ian(i)).eq.0.0d0) go to 40
   30 continue
      go to 50
   40 continue
      write(mfgw,*) 'van der waals'' radius not defined for atom',i
      write(mfgw,*) 'in williams surface routine pdgrid!'
      stop
c     now create limits for a box
   50 do 100 ix = 1,3
         xmin(ix)= 100000.0d0
         xmax(ix)=-100000.0d0
         do 90 ia = 1,natom
            if (co(ix,ia)-xmin(ix))60,70,70
   60       xmin(ix)=co(ix,ia)
   70       if (co(ix,ia)-xmax(ix))90,90,80
   80       xmax(ix)=co(ix,ia)
   90    continue
  100 continue
c     add (or subtract) the maximum vderw plus shell
      vdmax=0.0d0
      do 110 i=1,53
         if (vderw(i).gt.vdmax) vdmax=vderw(i)
  110 continue
      do 120 i=1,3
         xmin(i)=xmin(i)-vdmax-shell
  120 xmax(i)=xmax(i)+vdmax+shell
c step grid back from zero to find starting points
      xstart=0.0d0
  130 xstart=xstart-grid
      if (xstart.gt.xmin(1)) go to 130
      ystart=0.0d0
  140 ystart=ystart-grid
      if (ystart.gt.xmin(2)) go to 140
      zstart=0.0d0
  150 zstart=zstart-grid
      if (zstart.gt.xmin(3)) go to 150
      npnt=0
      zgrid=zstart
  160 ygrid=ystart
  170 xgrid=xstart
  180 do 190 l=1,natom
         jz=ian(l)
         dist(l)=dsqrt((co(1,l)-xgrid)**2+(co(2,l)-ygrid)**2+
     1 (co(3,l)-zgrid)**2)
c     reject grid point if any atom is too close
         if(dist(l).lt.(vderw(jz)-closer)) go to 220
  190 continue
c but at least one atom must be close enough
      do 200 l=1,natom
         jz=ian(l)
         if(dist(l).gt.(vderw(jz)+shell)) go to 200
         go to 210
  200 continue
      go to 220
  210 npnt=npnt+1
      nmep=nmep+1
      potpt(1,nmep)=xgrid
      potpt(2,nmep)=ygrid
      potpt(3,nmep)=zgrid
  220 xgrid=xgrid+grid
      if (xgrid.le.xmax(1)) go to 180
      ygrid=ygrid+grid
      if (ygrid.le.xmax(2)) go to 170
      zgrid=zgrid+grid
      if (zgrid.le.xmax(3)) go to 160
      return
      end
      subroutine hmuf(h1,id,coord,nfirst,nlast,nat,norbs,numat)
      implicit REAL (a-h,o-z)
c
c  form the dipole moment matrix for component id
c
      common /multip/ dd(107),qq(107),am(107),ad(107),aq(107)
      dimension h1(norbs,norbs), coord(3,*)
      dimension nfirst(numat),nlast(numat),nat(numat)
c
c  zero h1 matrix
c
      call zerom(h1,norbs)
c
c  form dipole matrix
c
      do 30 i = 1,numat
         ia = nfirst(i)
         ib = nlast(i)
         ni = nat(i)
         do 20 i1 = ia,ib
            do 10 j1 = ia,i1
               h1(i1,j1) = 0.0d00
               io1 = i1 - ia
               jo1 = j1 - ia
               if ((id.eq.1).and.((jo1.eq.0).and.(io1.eq.1))) then
                  h1(i1,j1) = dd(ni)
                  h1(j1,i1) = dd(ni)
               endif
               if ((id.eq.2).and.((jo1.eq.0).and.(io1.eq.2))) then
                  h1(i1,j1) = dd(ni)
                  h1(j1,i1) = dd(ni)
               endif
               if ((id.eq.3).and.((jo1.eq.0).and.(io1.eq.3))) then
                  h1(i1,j1) = dd(ni)
                  h1(j1,i1) = dd(ni)
               endif
   10       continue
            h1(i1,i1) = 0.0d00
c.. added for translation of center from origin
            h1(i1,i1) = h1(i1,i1) + 1.8897262d0*coord(id,i)
   20    continue
   30 continue
c
      return
      end
      subroutine hplusf(f,h,norbs)
      implicit REAL (a-h,o-z)
c
c hplusf adds the 1 and 2-electron parts of the fock matrix
c
      dimension f(norbs,norbs), h(norbs,norbs)
      do 20 i=1,norbs
         do 10 j=1,norbs
            term = f(i,j)/27.2113961d00
            f(i,j)=h(i,j)+term
   10    continue
   20 continue
      return
      end
      subroutine initsv (indeps)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      common /solv/ fepsi,rds,disex2,nspa,nps,nps2,nden,
     1              cosurf(3,lenabc), srad(numatm),abcmat(lenab2),
     2              tm(3,3,numatm),qden(maxden),dirtm(3,nppa),
     3              bh(lenabc)
      common /solvi/ iatsp(lenabc+1),nar(lenabc)
      common /dirvec/ dirvec(3,nppa), nn(3,numatm)
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),
     1                nlast(numatm), norbs, nelecs,nalpha,nbeta,
     2                nclose,nopen,ndumy,fract
      dimension rvdw(53), usevdw(53), dirsm(3,nppa), dirsmh(3,nppa/3)
      common /iofile/ mfgr,iw
c     common /chanel/ ifiles(30)
c     equivalence(iw,ifiles(6))
      equivalence (abcmat(1),dirsm)
      equivalence(dirsmh, abcmat(3*nppa+1))
      character keywrd*241, elemnt(53)*2
      common /keywrd/ keywrd
      data rvdw  /1.08d0, 1.d0, 1.80d0, 999.d0, 999.d0, 1.53d0, 1.48d0,
     1 1.36d0,  1.30d0,  999.d0,  2.30d0,  999.d0,  2.05d0,  2.10d0,
     2 1.75d0,  1.70d0,  1.65d0,  999.d0,  2.80d0,  2.75d0,  999.d0,
     3 999.d0,  999.d0,  999.d0,  999.d0,  999.d0,  999.d0,  999.d0,
     4 999.d0,  999.d0,  999.d0,  999.d0,  999.d0,  999.d0,  1.80d0,
     5 999.d0,  999.d0,  999.d0,  999.d0,  999.d0,  999.d0,  999.d0,
     6 999.d0,  999.d0,  999.d0,  999.d0,  999.d0,  999.d0,  999.d0,
     7 999.d0,  999.d0,  999.d0,  2.05d0 /
      data elemnt/'h ','he',
     1 'li','be','b ','c ','n ','o ','f ','ne',
     2 'na','mg','al','si','p ','s ','cl','ar',
     3 'k ','ca','sc','ti','v ','cr','mn','fe','co','ni','cu',
     4 'zn','ga','ge','as','se','br','kr',
     5 'rb','sr','y ','zr','nb','mo','tc','ru','rh','pd','ag',
     6 'cd','in','sn','sb','te','i '/
      do 10 i=1,53
   10 usevdw(i)=rvdw(i)
      epsi=reada(keywrd,indeps)
      fepsi=(epsi-1.d0)/(epsi+0.5d0)
      nps=0
      nden=3*norbs-2*numat
      maxnps=dsqrt(dfloat(2*lenab2)+0.251d0)-nden-0.5d0
      maxnps=min(maxnps,lenabc)
      write(iw,*) 'maximum number of segments allowed:',maxnps
      if ((nden*(nden+1))/2 .gt. lenab2) then
         write(iw,*) 'parameter lenabc is too small for this system'
         stop 'parameter lenabc is too small for this system'
      endif
      rsolv=1.0d0
      inrsol=index(keywrd,'rsolv=')
      if (inrsol .ne. 0) then
         rsolv=reada(keywrd,inrsol)
      end if
      if (rsolv .lt. 0.) stop ' rsolv must not be negative'
      delsc=rsolv
      indels=index(keywrd,'delsc=')
      if (indels .ne. 0) then
         delsc=reada(keywrd,indels)
      end if
      if (delsc .lt. 0.1d0) write(iw,*) ' delsc too small: set to 0.1'
      if (delsc .gt. rsolv+0.5d0) stop ' delsc unreasonably large'
      rds=max(delsc,0.1d0)
      disex=2.d0
      indise=index(keywrd,'disex=')
      if (indise .ne. 0) then
         disex=reada(keywrd,indise)
      end if
      do 20 i=1,numat
         iat=nat(i)
         if (iat .gt. 53) then
            stop 'missing van der waals radius'
         else
            avdw=usevdw(iat)
            if (avdw .gt. 10.d0) stop 'missing van der waals radius'
         end if
         srad(i)=avdw+rsolv
   20 continue
      nspa=60
      if(index(keywrd,'nspa=').ne.0)
     1 nspa=nint(reada(keywrd,index(keywrd,'nspa')))
      x0=log(nspa*0.1d0-0.199999d0)
      z3=log(3.d0)
      z4=log(4.d0)
      i4=int(x0/z4)
      nps2=0
      do 7 i=0,i4
      x=x0-i*z4
      n=3**int(x/z3)*4**i
   7  if(n.gt.nps2)nps2=n
      nps=nps2/3
      if(mod(nps2,3).ne.0)nps=nps2/4
      nps2=10*nps2+2
      nps=max(12,nps*10+2)
      call dvfill(nps2,dirsm)
      call dvfill(nps,dirsmh)
      nps=-nps
      disex2=(4*(1.5d0+rsolv-rds)*disex)**2/nspa
      call dvfill(nppa,dirvec)
      return
      end
c
c======================================================================
c
      subroutine insymc
      implicit REAL (a-h,o-z)
******************************************************************
*                                                                *
*     subroutine need for green function calculations            *
******************************************************************
INCLUDE(common/sizes)
      common / readme / ird
      common /iofile/ mfgr,nra
      common/cimos /imoci(200)
      common/ciparm/ici1,ici2,iout2
      common/molkst/numat,nat(numatm),nfirst(numatm),nmidle(numatm),
     * nlast(numatm),norbs,nelecs,nalpha,nbeta,nclose,nopen,
     * ndumy,fract
      character line*80
      dimension value(3)
      namb=norbs-nclose
      read(ird,'(a)') line
      call nuchar(line,value,nvalue)
      ici1=value(1)
      ici2=value(2)
      ioutci=value(3)
      if(ici1.eq.0) ici1=20
      if(ici1.gt.nclose) ici1=nclose
      if(ici2.eq.0) ici2=20
      if(ici2.gt.namb) ici2=namb
      write(nra,3185) ici1,ici2,ioutci
      iout2=ioutci
c *** definition of orbitals involved in the green treatment.
      ia=ici1+1
      ib=ici1+ici2
      do 101 i=1,ici1
  101 imoci(i)=nclose+1-i
      do 102 i=ia,ib
  102 imoci(i)=nclose+1+i-ia
      return
 3185 format(///1x,'number of occupied mos',4x,i4,
     1       /1x,'number of unoccupied mos',2x,i4,
     2       /1x,'printing flag',13x,i4)
      end
      subroutine makeuf(u,uold,g,eigs,last,norbs,nnorbs,nclose,
     1                   diff,atol)
      implicit REAL (a-h,o-z)
      logical last
c
c  this subroutine creates the new transformation matrix u
c  and then checks for convergence
c
      dimension u(norbs,norbs),uold(norbs,norbs),
     1          eigs(norbs),g(norbs,norbs)
      common /omval/ omega
c
c  zero matrix initially
c
      call zerom(u,norbs)
c
c  create off-diagonal blocks
c
      do 20 k = nclose+1,norbs
         do 10 l = 1,nclose
            u(l,k) = 27.2113961d0*g(l,k)/(eigs(k)-eigs(l)-omega)
            u(k,l) = 27.2113961d0*g(k,l)/(eigs(l)-eigs(k)-omega)
   10    continue
   20 continue
c
c  check for convergence
c
      diff = 0.0d00
      do 40 i = 1,norbs
         do 30 j = 1,norbs
            udif = dabs(u(i,j)-uold(i,j))
            if (diff.lt.udif) diff = udif
   30    continue
   40 continue
      if (diff.lt.atol) then
         last = .true.
      endif
c
      do 60 i = 1,norbs
         do 50 j = 1,norbs
            uold(i,j) = u(i,j)
   50    continue
   60 continue
c
      return
      end
      subroutine makpol(coord)
      implicit REAL (a-h, o-z)
INCLUDE(common/sizes)
      dimension coord(3,*)
************************************************************************
*
*   makpol takes a primitive unit cell and generates a total of 'mers' 
*   copies.  the resulting geometry is placed in geo.  arrays loc,
*   xparam, na, nb, nc, simbol, txtatm, labels, locpar, idepfn, and
*   locdep are expanded to suit.  array tvec is modified, as are scalars
*   nvar, natoms, and ndep.
*
*   symmetry is forced on, or added on, in order to make the new mers
*   equivalent to the supplied mer.
*   
************************************************************************

      character keywrd*241, txtatm*8
      common /keywrd/ keywrd
      common /iofile/ mfgr,mfgw
      common /geovar/ nvar, loc(2,maxpar), idumy, xparam(maxpar)
      common /cmpg/ geo(3,numatm)
      common /atomtx/ ltxt, txtatm(numatm)
      common /simbol/ simbol(maxpar)
      common /euler / tvec(3,3), id
      common /geokst/ natoms,labels(numatm),
     1na(numatm),nb(numatm),nc(numatm)
      common /geosym/ ndep, locpar(maxpar), idepfn(maxpar),
     1                      locdep(maxpar)
         mers=reada(keywrd,index(keywrd,' mers'))
         do 270 i=1,natoms
  270    if(labels(i).eq.99)labels(i)=100
         call gmetry(geo,coord)
         do 280 i=1,natoms
  280    if(labels(i).eq.100)labels(i)=99
         nan=na(natoms-1)
         nbn=nb(natoms-1)
         ncn=nc(natoms-1)
         do 330 i=2,mers+1
            im1=ioff
            ioff=ioff+natoms-2
c
c   fill the na, nb, and nc addresses for the new atoms
c
            do 310 j=1,natoms-2
            if(j.ne.1.and.i.gt.mers)goto 310
               simbol(ioff+j)=simbol(im1+j)
               if(ioff+j.ne.natoms-1)then
               na(ioff+j)=na(im1+j)+natoms-2
               nb(ioff+j)=nb(im1+j)+natoms-2
               nc(ioff+j)=nc(im1+j)+natoms-2
               endif
               labels(ioff+j)=labels(im1+j)
               txtatm(ioff+j)=txtatm(im1+j)
               do 300 k=1,3
  300          coord(k,ioff+j)=coord(k,im1+j)+tvec(k,1)
  310       continue
            if(i.eq.2)then
c
c  special treatment for the first three atoms of the second mer
c
               na(natoms-1)=nan
               nb(natoms-1)=nbn
               nc(natoms-1)=ncn
               nb(natoms+0)=na(natoms-2)
               nc(natoms+0)=nb(natoms-2)
               nc(natoms+1)=na(natoms-2)
            endif
c#            do 320 j=1,natoms-2
c#  320       write(mfgw,'(3i5,3f12.5,3i4)')i,j,labels(iff+j),
c#     1(coord(k,ioff+j),k=1,3),
c#     2na(ioff+j), nb(ioff+j), nc(ioff+j)
  330    continue
c
c  use atoms of first mer to define the other mers.  for atoms 1, 2, and
c  3, use data from the second mer.
c
         do 360 i=1,natoms-2
            do 350 k=1,3
            if(k.ge.i)then
            koff=natoms-2
            joff=3
            else
            koff=0
            joff=2
            endif
               do 340 j=joff,mers+1
               if(i.ne.1.and.j.gt.mers) goto 340
                  ndep=ndep+1
                  locpar(ndep)=i+koff
                  idepfn(ndep)=k
                  locdep(ndep)=(natoms-2)*(j-1)+i
  340          continue
  350       continue
  360    continue
c
c   cartesian coordinates of the tv
c
         last=(natoms-2)*mers+2
         coord(1,last)=coord(1,ioff+1)
         coord(2,last)=coord(2,ioff+1)
         coord(3,last)=coord(3,ioff+1)
c
c  remove optimization flags of last two atoms supplied by the user
c
         do 331 i=1,6
  331    if(loc(1,nvar).gt.natoms-2)nvar=nvar-1
c
c   put on optimization flages for first three atoms of the second mer
c
         loc(1,nvar+1)=natoms-1
         loc(2,nvar+1)=1
         loc(1,nvar+2)=natoms-1
         loc(2,nvar+2)=2
         loc(1,nvar+3)=natoms-1
         loc(2,nvar+3)=3
         loc(1,nvar+4)=natoms
         loc(2,nvar+4)=2
         loc(1,nvar+5)=natoms
         loc(2,nvar+5)=3
         loc(1,nvar+6)=natoms+1
         loc(2,nvar+6)=3
c
c  re-do specification of the tv
c
         labels(last-1)=99
         labels(last)=107
         txtatm(last-1)=' '
         txtatm(last)=' '
         na(last)=1
         nb(last)=last-1
         nc(last)=last-2
         loc(1,nvar+7)=last
         loc(2,nvar+7)=1
c
c   convert to internal coordinates.  use connectivity created here
c
         degree=1.d0
         na(2)=-2
         call mopxyz(coord,last,na,nb,nc,degree,geo)
c
c  re-size the translation vector
c
         tvec(1,1)=coord(1,last)
         tvec(2,1)=coord(2,last)
         tvec(3,1)=coord(3,last)
c
c the coordinates of the first 3 atoms need to be optimized
c
         xparam(nvar+1)=geo(1,natoms-1)
         xparam(nvar+2)=geo(2,natoms-1)
         xparam(nvar+3)=geo(3,natoms-1)
         xparam(nvar+4)=geo(2,natoms)
         xparam(nvar+5)=geo(3,natoms)
         xparam(nvar+6)=geo(3,natoms+1)
         natoms=last
         xparam(nvar+7)=geo(1,natoms)
         nvar=nvar+7
         write(mfgw,160)(i,(tvec(j,i),j=1,3),i=1,id)
  150    format(/,'       expanded unit cell translation vectors',/
     1/,'              x              y              z')
  160    format('    t',i1,' = ',f11.7,'    ',f11.7,'    ',f11.7)
         write(mfgw,'(/,10x,a)')' expanded polymer unit cell'
         call geout(1)
         return
         end
      subroutine ngamtg(igam,x,gd3,ud3,g1,u1,gs,usmd,eps,us)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
c.....................................................................
c  calculate gamma(thg) in a noniterative fashion
c.....................................................................
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),
     1                nlast(numatm),norbs,nelecs,nalpha,nbeta,nclose,
     2                nopen,ndumy,fract
      common /omval/ omega
c     common /chanel/ ifiles(30)
c     equivalence(iw,ifiles(6))
      common /iofile/ mfgr,iw
      dimension x(maxorb,maxorb),gd3(maxorb,maxorb),ud3(maxorb,maxorb),
     1          g1(maxorb,maxorb),u1(maxorb,maxorb),gs(maxorb,maxorb),
     2          usmd(maxorb,maxorb),eps(maxorb,maxorb),
     3          gamma(9),us(maxorb,maxorb)
      character*1 alab
      dimension alab(3),ida(9),idb(9),idc(9),idd(9),
     1          ipair(3,3)
      save alab, ida, idb, idc, idd, ipair
      data alab /'x','y','z'/
      data ida /1,2,3,1,1,2,2,3,3/
      data idb /1,2,3,1,1,2,2,3,3/
      data idc /1,2,3,2,3,1,3,1,2/
      data idd /1,2,3,2,3,1,3,1,2/
      data ipair /1,2,3,2,4,5,3,5,6/
      one=1.d0
      msq = norbs*norbs
   10 write(iw,20) omega
   20 format (//,
     1   ' gamma (third harmonic generation) at ',f10.5,' ev.'//)
c
c igam=1 (third harmonic generation)
c
      jgarc=22
      juarc=19
      jurec=07
      jgrec=10
      jg2rec=55
      ju2rec=49
      ju2mrc=67
      jeprec=61
c
c loop begins for the calculation of gamma(abcd)
c
      gav = 0.0d+00
      do 100 ie=1,9
c
         ia=ida(ie)
         ib=idb(ie)
         ic=idc(ie)
         id=idd(ie)
         icd=ipair(ic,id)
         ibd=ipair(ib,id)
         ibc=ipair(ib,ic)
c
c  read in the first order u3 omega and g3 omega in the direction a
c
c make gd3 omega matrix from g3 matrix
c
         call daread_mop(x,msq,jgarc+ia)
         call fhpatn(gd3,x,norbs,2,one)
c
c make ud3 omega matrix from u3 omega matrix
c
         call daread_mop(x,msq,juarc+ia)
         call fhpatn(ud3,x,norbs,2,-one)
c
         yy=0.0d00
         imove=1
   30    continue
c
   40    go to (50,60,70), imove
c
   50    j2=ib
         j34=icd
         go to 80
   60    j2=ic
         j34=ibd
         go to 80
   70    j2=id
         j34=ibc
   80    continue
c
c  read in g1,u1,gs,us,ums,eps
c
c  get  ub
         call daread_mop(u1,msq,jurec+j2)
c  get  gb
         call daread_mop(g1,msq,jgrec+j2)
c  get  gcd
         call daread_mop(gs,msq,jg2rec+j34)
c  get  ucd
         call daread_mop(us,msq,ju2rec+j34)
c  get  usmd
         call daread_mop(usmd,msq,ju2mrc+j34)
c  get  epcd
         call daread_mop(eps,msq,jeprec+j34)
c
c
c first kind
c
         yy = yy+trsub(ud3,g1,us,nclose,norbs,norbs)
         yy = yy-trsub(usmd,g1,ud3,nclose,norbs,norbs)
         yy = yy-trsub(ud3,g1,us,norbs,nclose,norbs)
         yy = yy+trsub(usmd,g1,ud3,norbs,nclose,norbs)
c
c second kind
c
         yy = yy+trsub(ud3,gs,u1,nclose,norbs,norbs)
         yy = yy+trsub(u1,gs,ud3,nclose,norbs,norbs)
         yy = yy-trsub(ud3,eps,u1,norbs,nclose,norbs)
         yy = yy-trsub(u1,eps,ud3,norbs,nclose,norbs)
c
c third kind
c
         yy = yy+trsub(u1,gd3,us,nclose,norbs,norbs)
         yy = yy-trsub(usmd,gd3,u1,nclose,norbs,norbs)
         yy = yy-trsub(u1,gd3,us,norbs,nclose,norbs)
         yy = yy+trsub(usmd,gd3,u1,norbs,nclose,norbs)
c
         imove=imove+1
         if (imove .le. 3) go to 30
c
         gamma(ie) = yy
c
c calculate the average gamma value
c
         gav = gav + yy
c
c write gamma(abcd)
c
         write(iw,90)
     +   alab(ia),alab(ib),alab(ic),alab(id),gamma(ie)
   90    format(' gamma(',a1,',',a1,',',a1,',',a1,') = ',1f13.5)
c
  100 continue
      gave = gav/5.0d+00
      write(iw,110) omega,gave
  110 format(//,' average gamma value at ',f10.5,' = ',1f13.5,//)
      return
      end
      subroutine ngefis(igam,x,gd3,ud3,g1,u1,gs,usmd,eps,us)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      common /iofile/ mfgr,mfgw
c.....................................................................
c  calculate gamma(dc-efishg) in a noniterative fashion
c.....................................................................
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),
     1                nlast(numatm),norbs,nelecs,nalpha,nbeta,nclose,
     2                nopen,ndumy,fract
      common /omval/ omega
      common /iodaf/idaf,irecln,irecst,ifilen(145),ioda(145)
      common /chanel/ ifiles(30)
      equivalence(iw,ifiles(6))
      dimension x(maxorb,maxorb),gd3(maxorb,maxorb),ud3(maxorb,maxorb),
     1          g1(maxorb,maxorb),u1(maxorb,maxorb),gs(maxorb,maxorb),
     2          usmd(maxorb,maxorb),eps(maxorb,maxorb),
     3          gamma(15),us(maxorb,maxorb)
      character*1 alab
      dimension alab(3),ida(15),idb(15),idc(15),idd(15),
     1          ip(3,3),ipair(3,3)
      save alab, ida, idb, idc, idd, ip, ipair
      data alab /'x','y','z'/
c
      data ida /1,2,3,1,1,2,2,3,3,1,1,2,2,3,3/
      data idb /1,2,3,2,3,1,3,1,2,1,1,2,2,3,3/
      data idc /1,2,3,1,1,2,2,3,3,2,3,1,3,1,2/
      data idd /1,2,3,2,3,1,3,1,2,2,3,1,3,1,2/
      data ip /1,2,3,2,4,5,3,5,6/
      data ipair /1,4,7,2,5,8,3,6,9/
      one=1.d0
      msq = norbs*norbs
      write(mfgw,10) omega
   10 format (//,
     1   ' gamma (dc-efishg) at ',f10.5,' ev.'//)
c
c get data from alpha  and iterative beta calculations
c
c   required records from polarizability calculations
c   -------------------------------------------------------
c        0    w    2w    3w
c
c       -02- -08-  -14-  -20-  -u- matrix for -x- direction
c       -03- -09-  -15-  -21-  -u- matrix for -y- direction
c       -04- -10-  -16-  -22-  -u- matrix for -z- direction
c       -05- -11-  -17-  -23-  -g- matrix for -x- direction
c       -06- -12-  -18-  -24-  -g- matrix for -y- direction
c       -07- -13-  -19-  -25-  -g- matrix for -z- direction
c   -------------------------------------------------------
c      (0,0)    (w,w)    (0,w)    (w,-w)
c
c      -26-     -50-     -74-     -110-   -u- matrix for -xx- direction
c      -27-     -51-     -75-     -111-   -u- matrix for -xy- direction
c      -28-     -52-     -76-     -112-   -u- matrix for -xz- direction
c                        -77-     -113-   -u- matrix doe -yx- direction
c      -29-     -53-     -78-     -114-   -u- matrix for -yy- direction
c      -30-     -54-     -79-     -115-   -u- matrix for -yz- direction
c                        -80-     -116-   -u- matrix for -zx- direction
c                        -81-     -117-   -u- matrix for -zy- direction
c      -31-     -55-     -82-     -118-   -u- matrix for -zz- direction
c   ------------------------------------------------------------------
c
c      -32-     -56-     -83-     -119-   -g- matrix for -xx- direction
c      -33-     -57-     -84-     -120-   -g- matrix for -xy- direction
c      -34-     -58-     -85-     -121-   -g- matrix for -xz- direction
c                        -86-     -122-   -g- matrix for -yx- direction
c      -35-     -59-     -87-     -123-   -g- matrix for -yy- direction
c      -36-     -60-     -88-     -124-   -g- matrix for -yz- direction
c                        -89-     -125-   -g- matrix for -zx- direction
c                        -90-     -126-   -g- matrix for -zy- direction
c      -37-     -61-     -91-     -127-   -g- matrix for -zz- direction
c   ------------------------------------------------------------------
c
c      -38-     -62-     -92-     -128-   -e- matrix for -xx- direction
c      -39-     -63-     -93-     -129-   -e- matrix for -xy- direction
c      -40-     -64-     -94-     -130-   -e- matrix for -xz- direction
c                        -95-     -131-   -e- matrix for -yx- direction
c      -41-     -65-     -96-     -132-   -e- matrix for -yy- direction
c      -42-     -66-     -97-     -133-   -e- matrix for -yz- direction
c                        -98-     -134-   -e- matrix for -zx- direction
c                        -99-     -135-   -e- matrix for -zy- direction
c      -43-     -67-     -100-    -136-   -e- matrix for -zz- direction
c   ------------------------------------------------------------------
c
c      -44-     -68-     -101-    -137-   -um- matrix for -xx- direction
c      -45-     -69-     -102-    -138-   -um- matrix for -xy- direction
c      -46-     -70-     -103-    -139-   -um- matrix for -xz- direction
c                        -104-    -140-   -um- matrix for -yx- direction
c      -47-     -71-     -105-    -141-   -um- matrix for -yy- direction
c      -48-     -72-     -106-    -142-   -um- matrix for -yz- direction
c                        -107-    -143-   -um- matrix for -zx- direction
c                        -108-    -144-   -um- matrix for -zy- direction
c      -49-     -73-     -109-    -145-   -um- matrix for -zz- direction
c   ------------------------------------------------------------------
c
c calculation of different gamma values in a noniterative method.
c
c igam=2 (dc-electic field induced second harmonic generation)
c
      jgarc=16
      juarc=13
      jurec=01
      jgrec=04
      jg2rec=55
      ju2rec=49
      ju2mrc=67
      jeprec=61
c loop begins for the calculation of gamma(abcd)
c
      gav = 0.0d00
      do 90 ie=1,15
         ia=ida(ie)
         ib=idb(ie)
         ic=idc(ie)
         id=idd(ie)
         icd=ip(ic,id)
         ibd=ipair(ib,id)
         ibc=ipair(ib,ic)
c
c  read in the first order u3 omega and g3 omega in the direction a
c  make gd3 omega matrix from g3 matrix
c
         call daread_mop(x,msq,jgarc+ia)
         call fhpatn(gd3,x,norbs,2,one)
c
c make ud3 omega matrix from u3 omega matrix
c
         call daread_mop(x,msq,juarc+ia)
         call fhpatn(ud3,x,norbs,2,-one)
         yy=0.0d00
         imove=1
   20    continue
c
c dc efishg
c
   30    go to (40,50,60), imove
   40    j2=ib
         j34=icd
         go to 70
   50    j2=ic+6
c                 j34=ibd+24
         j3u=ibd+24
         j3g=ibd+27
         j3e=ibd+30
         j3um=ibd+33
         go to 70
   60    j2=id+6
         j3u=ibc+24
         j3g=ibc+27
         j3e=ibc+30
         j3um=ibc+33
   70    continue
c
c  read in g1,u1,gs,us,ums,eps
c
c  call ub
c
         call daread_mop(u1,msq,jurec+j2)
c  call gb
         call daread_mop(g1,msq,jgrec+j2)
         if (imove .eq. 1) then
c  call gcd
            call daread_mop(gs,msq,jg2rec+j34)
c  call ucd
            call daread_mop(us,msq,ju2rec+j34)
c  call usmd
            call daread_mop(usmd,msq,ju2mrc+j34)
c  call epcd
            call daread_mop(eps,msq,jeprec+j34)
c
         else
c  call gcd
            call daread_mop(gs,msq,jg2rec+j3g)
c  call ucd
            call daread_mop(us,msq,ju2rec+j3u)
c  call usmd
            call daread_mop(usmd,msq,ju2mrc+j3um)
c  call epcd
            call daread_mop(eps,msq,jeprec+j3e)
         endif
c
c first kind
c
         yy = yy+trsub(ud3,g1,us,nclose,norbs,norbs)
         yy = yy-trsub(usmd,g1,ud3,nclose,norbs,norbs)
         yy = yy-trsub(ud3,g1,us,norbs,nclose,norbs)
         yy = yy+trsub(usmd,g1,ud3,norbs,nclose,norbs)
c
c second kind
c
         yy = yy+trsub(ud3,gs,u1,nclose,norbs,norbs)
         yy = yy+trsub(u1,gs,ud3,nclose,norbs,norbs)
         yy = yy-trsub(ud3,eps,u1,norbs,nclose,norbs)
         yy = yy-trsub(u1,eps,ud3,norbs,nclose,norbs)
c
c third kind
c
         yy = yy+trsub(u1,gd3,us,nclose,norbs,norbs)
         yy = yy-trsub(usmd,gd3,u1,nclose,norbs,norbs)
         yy = yy-trsub(u1,gd3,us,norbs,nclose,norbs)
         yy = yy+trsub(usmd,gd3,u1,norbs,nclose,norbs)
c
         imove=imove+1
         if (imove .le. 3) go to 20
c
         gamma(ie) = yy
c calculate the average gamma value
         if (ie .le. 3) then
            gav = gav + 3*yy
         elseif (ie .gt. 9) then
            gav = gav + yy
         else
            gav = gav + 2*yy
         endif
c
c write gamma(abcd)
c
         write(mfgw,80) 
     +   alab(ia),alab(ib),alab(ic),alab(id),gamma(ie)
   80    format(' gamma(',a1,',',a1,',',a1,',',a1,') = ',1pd14.7)
c
   90 continue
      gave = gav/15.0d+00
      write(mfgw,100) omega,gave
  100 format(//,' average gamma value at ',f10.5, ' ev = ',1pd14.7,//)
      return
      end
      subroutine ngidri(igam,x,gd3,ud3,g1,u1,gs,usmd,eps,us)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      common /iofile/ mfgr,mfgw
c.....................................................................
c  calculate gamma(idri) in a noniterative fashion
c.....................................................................
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),
     1                nlast(numatm),norbs,nelecs,nalpha,nbeta,nclose,
     2                nopen,ndumy,fract
      common /omval/ omega
      common /iodaf/idaf,irecln,irecst,ifilen(145),ioda(145)
      common /chanel/ ifiles(30)
      equivalence(iw,ifiles(6))
      dimension x(maxorb,maxorb),gd3(maxorb,maxorb),ud3(maxorb,maxorb),
     1          g1(maxorb,maxorb),u1(maxorb,maxorb),gs(maxorb,maxorb),
     2          usmd(maxorb,maxorb),eps(maxorb,maxorb),
     3          gamma(15),us(maxorb,maxorb)
      dimension alab(3),ida(15),idb(15),idc(15),idd(15),
     1          ip(3,3),ipair(3,3)
      character*1 alab
      save alab, ida, idb, idc, idd, ip, ipair
      data alab /'x','y','z'/
c
      data ida /1,2,3,1,1,2,2,3,3,1,1,2,2,3,3/
      data idb /1,2,3,1,1,2,2,3,3,2,3,1,3,1,2/
      data idc /1,2,3,2,3,1,3,1,2,2,3,1,3,1,2/
      data idd /1,2,3,2,3,1,3,1,2,1,1,2,2,3,3/
      data ip /1,2,3,2,4,5,3,5,6/
      data ipair /1,4,7,2,5,8,3,6,9/
      one=1.0d00
      msq = norbs*norbs
c
      write(mfgw,10) omega
   10 format (//,
     1              ' gamma (idri) at ',f10.5,' ev.'//)
c
c get data from alpha  and iterative beta calculations
c
c
c igam=3 (intensity dependent refractive index or degenerated four
c wave mixing)
c
      jgarc=10
      juarc=07
      jurec=07
      jgrec=10
c loop begins for the calculation of gamma(abcd)
c
      gav = 0.0d+00
      do 80 ie=1,15
         ia=ida(ie)
         ib=idb(ie)
         ic=idc(ie)
         id=idd(ie)
         icd=ipair(ic,id)
         ibd=ipair(ib,id)
         ibc=ip(ib,ic)
c
c  read in the first order u3 omega and g3 omega in the direction a
c
c make gd3 omega matrix from g3 matrix
c
         call daread_mop(x,msq,jgarc+ia)
         call fhpatn(gd3,x,norbs,2,one)
c
c make ud3 omega matrix from u3 omega matrix
c
         call daread_mop(x,msq,juarc+ia)
         call fhpatn(ud3,x,norbs,2,-one)
c
         yy=0.0d00
         imove=1
   20    continue
c
c
c idri
c
         go to (30,40,50), imove
   30    j2= ib
         j34=icd
         jg2rec=118
         ju2rec=109
         ju2mrc=136
         jeprec=127
         go to 60
   40    j2=ic
         j34=ibd
         jg2rec=118
         ju2rec=109
         ju2mrc=136
         jeprec=127
         go to 60
   50    j2=id
         j34=ibc
         jg2rec= 55
         ju2rec= 49
         ju2mrc= 67
         jeprec= 61
   60    continue
c  read in g1,u1,gs,us,ums,eps
c
c  call ub
         if (imove.eq.3) then
            call daread_mop(x,msq,jurec+j2)
            call fhpatn(u1,x,norbs,2,-one)
         else
            call daread_mop(u1,msq,jurec+j2)
         endif
c  call gb
         if (imove.eq.3) then
            call daread_mop(x,msq,jgrec+j2)
            call fhpatn(g1,x,norbs,2,one)
         else
            call daread_mop(g1,msq,jgrec+j2)
         endif
c  call gcd
         call daread_mop(gs,msq,jg2rec+j34)
c  call ucd
         call daread_mop(us,msq,ju2rec+j34)
c  call usmd
         call daread_mop(usmd,msq,ju2mrc+j34)
c  call epcd
         call daread_mop(eps,msq,jeprec+j34)
c
c first kind
c
         yy = yy+trsub(ud3,g1,us,nclose,norbs,norbs)
         yy = yy-trsub(usmd,g1,ud3,nclose,norbs,norbs)
         yy = yy-trsub(ud3,g1,us,norbs,nclose,norbs)
         yy = yy+trsub(usmd,g1,ud3,norbs,nclose,norbs)
c
c second kind
c
         yy = yy+trsub(ud3,gs,u1,nclose,norbs,norbs)
         yy = yy+trsub(u1,gs,ud3,nclose,norbs,norbs)
         yy = yy-trsub(ud3,eps,u1,norbs,nclose,norbs)
         yy = yy-trsub(u1,eps,ud3,norbs,nclose,norbs)
c
c third kind
c
         yy = yy+trsub(u1,gd3,us,nclose,norbs,norbs)
         yy = yy-trsub(usmd,gd3,u1,nclose,norbs,norbs)
         yy = yy-trsub(u1,gd3,us,norbs,nclose,norbs)
         yy = yy+trsub(usmd,gd3,u1,norbs,nclose,norbs)
c
         imove=imove+1
         if (imove .le. 3) go to 20
c
         gamma(ie) = yy
c
c calculate the average gamma value
c
         if (ie .le. 3) then
            gav = gav + 3.0d0*yy
         elseif (ie .gt. 9) then
            gav = gav + yy
         else
            gav = gav + 2.0d0*yy
         endif
c
c write gamma(abcd)
c
         write(mfgw,70) 
     +   alab(ia),alab(ib),alab(ic),alab(id),gamma(ie)
   70    format(' gamma(',a1,',',a1,',',a1,',',a1,') = ',1pd14.7)
c
   80 continue
      gave = gav/15.0d+00
      write(mfgw,90) omega,gave
   90 format(//,'  average gamma value at ',f10.5,' = ',1pd14.7,//)
      return
      end
      subroutine ngoke(igam,x,gd3,ud3,g1,u1,gs,usmd,eps,us)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      common /iofile/ mfgr,mfgw
c.....................................................................
c  calculate gamma(oke) in a noniterative fashion
c.....................................................................
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),
     1                nlast(numatm),norbs,nelecs,nalpha,nbeta,nclose,
     2                nopen,ndumy,fract
      common /omval/ omega
      common /iodaf/idaf,irecln,irecst,ifilen(145),ioda(145)
      common /chanel/ ifiles(30)
      equivalence(iw,ifiles(6))
      dimension x(maxorb,maxorb),gd3(maxorb,maxorb),ud3(maxorb,maxorb),
     1          g1(maxorb,maxorb),u1(maxorb,maxorb),gs(maxorb,maxorb),
     2          usmd(maxorb,maxorb),eps(maxorb,maxorb),
     3          gamma(15),us(maxorb,maxorb)
      character*1 alab
      dimension alab(3),ida(15),idb(15),idc(15),idd(15),
     1          ip(3,3),ipair(3,3)
      save alab, ida, idb, idc, idd, ip, ipair
      data alab /'x','y','z'/
c
      data ida /1,2,3,1,1,2,2,3,3,1,1,2,2,3,3/
      data idb /1,2,3,1,1,2,2,3,3,2,3,1,3,1,2/
      data idc /1,2,3,2,3,1,3,1,2,2,3,1,3,1,2/
      data idd /1,2,3,2,3,1,3,1,2,1,1,2,2,3,3/
      data ip /1,2,3,2,4,5,3,5,6/
      data ipair /1,4,7,2,5,8,3,6,9/
      one=1.0d00
      msq = norbs*norbs
c
      if (igam .eq. 3 ) then
         write(mfgw,10) omega
   10    format (//,
     1              ' gamma (idri) at ',f10.5,' ev.'//)
      else
         write(mfgw,20) omega
   20    format (//,
     1              ' gamma (oke) at ',f10.5,' ev.'//)
      endif
c
c data including yx, zy, zx directions
c get data from alpha  and iterative beta calculations
c
c   required records from polarizability calculations
c
c   -------------------------------------------------------
c        0    w    2w    3w
c
c       -02- -08-  -14-  -20-  -u- matrix for -x- direction
c       -03- -09-  -15-  -21-  -u- matrix for -y- direction
c       -04- -10-  -16-  -22-  -u- matrix for -z- direction
c       -05- -11-  -17-  -23-  -g- matrix for -x- direction
c       -06- -12-  -18-  -24-  -g- matrix for -y- direction
c       -07- -13-  -19-  -25-  -g- matrix for -z- direction
c   -------------------------------------------------------
c      (0,0)    (w,w)    (0,w)    (w,-w)
c
c      -26-     -50-     -74-     -110-   -u- matrix for -xx- direction
c      -27-     -51-     -75-     -111-   -u- matrix for -xy- direction
c      -28-     -52-     -76-     -112-   -u- matrix for -xz- direction
c                        -77-     -113-   -u- matrix doe -yx- direction
c      -29-     -53-     -78-     -114-   -u- matrix for -yy- direction
c      -30-     -54-     -79-     -115-   -u- matrix for -yz- direction
c                        -80-     -116-   -u- matrix for -zx- direction
c                        -81-     -117-   -u- matrix for -zy- direction
c      -31-     -55-     -82-     -118-   -u- matrix for -zz- direction
c   ------------------------------------------------------------------
c
c      -32-     -56-     -83-     -119-   -g- matrix for -xx- direction
c      -33-     -57-     -84-     -120-   -g- matrix for -xy- direction
c      -34-     -58-     -85-     -121-   -g- matrix for -xz- direction
c                        -86-     -122-   -g- matrix for -yx- direction
c      -35-     -59-     -87-     -123-   -g- matrix for -yy- direction
c      -36-     -60-     -88-     -124-   -g- matrix for -yz- direction
c                        -89-     -125-   -g- matrix for -zx- direction
c                        -90-     -126-   -g- matrix for -zy- direction
c      -37-     -61-     -91-     -127-   -g- matrix for -zz- direction
c   ------------------------------------------------------------------
c
c      -38-     -62-     -92-     -128-   -e- matrix for -xx- direction
c      -39-     -63-     -93-     -129-   -e- matrix for -xy- direction
c      -40-     -64-     -94-     -130-   -e- matrix for -xz- direction
c                        -95-     -131-   -e- matrix for -yx- direction
c      -41-     -65-     -96-     -132-   -e- matrix for -yy- direction
c      -42-     -66-     -97-     -133-   -e- matrix for -yz- direction
c                        -98-     -134-   -e- matrix for -zx- direction
c                        -99-     -135-   -e- matrix for -zy- direction
c      -43-     -67-     -100-    -136-   -e- matrix for -zz- direction
c   ------------------------------------------------------------------
c
c      -44-     -68-     -101-    -137-   -um- matrix for -xx- direction
c      -45-     -69-     -102-    -138-   -um- matrix for -xy- direction
c      -46-     -70-     -103-    -139-   -um- matrix for -xz- direction
c                        -104-    -140-   -um- matrix for -yx- direction
c      -47-     -71-     -105-    -141-   -um- matrix for -yy- direction
c      -48-     -72-     -106-    -142-   -um- matrix for -yz- direction
c                        -107-    -143-   -um- matrix for -zx- direction
c                        -108-    -144-   -um- matrix for -zy- direction
c      -49-     -73-     -109-    -145-   -um- matrix for -zz- direction
c   ------------------------------------------------------------------
c
c get data from alpha  and iterative beta calculations
c
c
c igam=4 (optical kerr effect)
c
      jgarc=10
      juarc=07
      jurec=01
      jgrec=04
c loop begins for the calculation of gamma(abcd)
c
      gav = 0.0d+00
      do 90 ie=1,15
         ia=ida(ie)
         ib=idb(ie)
         ic=idc(ie)
         id=idd(ie)
         icd=ipair(ic,id)
         ibd=ipair(ib,id)
         ibc=ip(ib,ic)
c
c  read in the first order u3 omega and g3 omega in the direction a
c
c make gd3 omega matrix from g3 matrix
c
         call daread_mop(x,msq,jgarc+ia)
         call fhpatn(gd3,x,norbs,2,one)
c
c make ud3 omega matrix from u3 omega matrix
c
         call daread_mop(x,msq,juarc+ia)
         call fhpatn(ud3,x,norbs,2,-one)
c
         yy=0.0d00
         imove=1
   30    continue
c
c oke
         go to (40,50,60), imove
   40    j2= ib
         j34=icd
         jg2rec=82
         ju2rec=73
         ju2mrc=100
         jeprec=91
         go to 70
   50    j2=ic
         j34=ibd
         jg2rec=82
         ju2rec=73
         ju2mrc=100
         jeprec=91
         go to 70
   60    j2=id
         j34=ibc
         jg2rec=31
         ju2rec=25
         ju2mrc=43
         jeprec=37
   70    continue
c  read in g1,u1,gs,us,ums,eps
c
c  call ub
         if (imove.eq.3) then
            call daread_mop(u1,msq,juarc+j2)
         else
            call daread_mop(u1,msq,jurec+j2)
         endif
c  call gb
         if (imove.eq.3) then
            call daread_mop(g1,msq,jgarc+j2)
         else
            call daread_mop(g1,msq,jgrec+j2)
         endif
c  call gcd
         call daread_mop(gs,msq,jg2rec+j34)
c  call ucd
         call daread_mop(us,msq,ju2rec+j34)
c  call usmd
         call daread_mop(usmd,msq,ju2mrc+j34)
c  call epcd
         call daread_mop(eps,msq,jeprec+j34)
c
c first kind
c
         yy = yy+trsub(ud3,g1,us,nclose,norbs,norbs)
         yy = yy-trsub(usmd,g1,ud3,nclose,norbs,norbs)
         yy = yy-trsub(ud3,g1,us,norbs,nclose,norbs)
         yy = yy+trsub(usmd,g1,ud3,norbs,nclose,norbs)
c
c second kind
c
         yy = yy+trsub(ud3,gs,u1,nclose,norbs,norbs)
         yy = yy+trsub(u1,gs,ud3,nclose,norbs,norbs)
         yy = yy-trsub(ud3,eps,u1,norbs,nclose,norbs)
         yy = yy-trsub(u1,eps,ud3,norbs,nclose,norbs)
c
c third kind
c
         yy = yy+trsub(u1,gd3,us,nclose,norbs,norbs)
         yy = yy-trsub(usmd,gd3,u1,nclose,norbs,norbs)
         yy = yy-trsub(u1,gd3,us,norbs,nclose,norbs)
         yy = yy+trsub(usmd,gd3,u1,norbs,nclose,norbs)
c
         imove=imove+1
         if (imove .le. 3) go to 30
c
         gamma(ie) = yy
c
c calculate the average gamma value
c
         if (ie .le. 3) then
            gav = gav + 3.0d0*yy
         elseif (ie .gt. 9) then
            gav = gav + yy
         else
            gav = gav + 2.0d0*yy
         endif
c
c write gamma(abcd)
c
         write(mfgw,80) 
     +   alab(ia),alab(ib),alab(ic),alab(id),gamma(ie)
   80    format(' gamma(',a1,',',a1,',',a1,',',a1,') = ',1pd14.7)
c
   90 continue
      gave = gav/15.0d+00
      write(mfgw,100) omega,gave
  100 format(//,'  average gamma value at ',f10.5,' = ',1pd14.7,//)
      return
      end
      subroutine mopend
      logical opend, namd
      dimension ilose(3)
c
c   mopend shuts all files which may have been opened
c        and then stops the job
c
      common /chanel/ ifiles(30)
      data ilose/2,5,7/
c
c  first, delete all unwanted files
c
      do 10 i=1,3
         j=ifiles(ilose(i))
         inquire (unit=j,opened=opend)
   10 if (opend) close(unit=j,status='delete')
c
c  next, deliberately close and keep all remaining open files.
c
      do 20 i=1,30
         inquire (unit=ifiles(i),opened=opend,named=namd)
         if (opend) then
            if(namd)then
               close(unit=ifiles(i),status='keep')
            else
               close(unit=ifiles(i),status='delete')
            endif
         endif
   20 continue
c
c  finally, stop the job
c
      stop
      end
      subroutine mepchg(co,potpt,nmep)
***********************************************************************
*  mepchg calculates the mep charges by fitting the quantum potential 
*  to the coulomb potential. 
*  ref.  b. wang and g.p.ford j.compt.chem. in press.
*        g.p.ford and b. wang j.compt.chem. 14(1993)1101.
*                                       bingze wang on 19 august 1993
***********************************************************************
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      parameter (mxmep=numatm*50+1000, nonzox=10*maxhev+maxlit+50)
      common /densty/ p(mpack),pa(mpack),pb(mpack)
      common /molkst/ natom,ian(numatm),nfirst(numatm),nmidle(numatm),  
     1                nlast(numatm), norbs, nelecs,nalpha,nbeta,        
     2                nclose,nopen,ndumy,fract                          
      common /dipsto/ ux,uy,uz,ch(numatm)
      common /elemts/ elemnt(107)
      common /keywrd/ keywrd
      common /iofile/ mfgr,mfgw
      character keywrd*241, elemnt*2
      dimension al((numatm+4)**2),a(numatm+4,numatm+4),q(numatm),
     1          potpt(3,*),ep(mxmep),co(3,*),b(numatm+4),pp(nonzox),
     1          qsc(numatm),d(numatm,mxmep),d1(numatm,mxmep),qq(numatm)
      logical cequiv(numatm,numatm),idip
c
      data au/627.506d0/,bohr/0.529167d0/,iz/0/,rms/0.0d0/,rrms/0.0d0/, 
     1   dipx/0.0d0/, dipy/0.0d0/, dipz/0.0d0/,idip/.false./
      bohr1=1.0d0/bohr
      au1=1.0d0/au
      cf=5.2917715d0*1.601917d0/3.33564d0
      natom0=natom+1
c
      write(mfgw,11)
11    format(//1x,'atomic charges derived from molecular',
     1  ' electrostatic potential')
      if(index(keywrd,' williams').ne.0) then
          write(mfgw,'(8x,"(williams surfaces)"/)')
      else
          write(mfgw,'(8x,"(connolly surfaces)"/)')
      endif
c
      if(index(keywrd,' charge=') .ne. 0) 
     1      iz=reada(keywrd,index(keywrd,' charge='))
c                                                  dipolar constraints
      if(index(keywrd,'dipole').ne.0) then
        if (iz.eq.0) then
           idip = .true.
           natom0=natom+4
           write(mfgw,'(/12x,''dipole constraints will be used'',/)')
           dx = ux
           dy = uy
           dz = uz
           if(index(keywrd,'dipx=') .ne. 0) 
     1       dx = reada(keywrd,index(keywrd,'dipx='))
           if(index(keywrd,'dipy=') .ne. 0) 
     1       dy = reada(keywrd,index(keywrd,'dipy='))
           if(index(keywrd,'dipz=') .ne. 0)
     1       dz = reada(keywrd,index(keywrd,'dipz='))
        else
           write(mfgw,*)
     +     ' dipole constraints not used for charged molecule'
        endif
      endif
      do 10  k=1,natom
            xk=co(1,k)
            yk=co(2,k)
            zk=co(3,k)
         do 10  i=1,nmep
            xp=potpt(1,i)-xk
            yp=potpt(2,i)-yk
            zp=potpt(3,i)-zk
            dki=dsqrt(xp*xp+yp*yp+zp*zp)
            d(k,i)=dki
            d1(k,i)=bohr/dki
10    continue
c
*******  set up the linear equation a*q=b  *******
c                                       mep at sample points & b matrix
      call packp(p,pp,nonzo)
        do 20 i=1,natom
20      b(i)=0.0d0
      do 100 ip=1,nmep
        call pmepco(pp,d(1,ip),potpt(1,ip),ui,co,nonzo,1)
        ep(ip)=ui*au1
        do 40 i=1,natom
40      b(i)=b(i)+ep(ip)*d1(i,ip)
100   continue
        b(natom+1)=dfloat(iz)
      if(idip) then
        b(natom+2)=dx/cf
        b(natom+3)=dy/cf
        b(natom+4)=dz/cf
      endif
c                                                      the a(j,k) array
      do 120  k=1,natom
        do 118  j=1,k
            ajk=0.0d0
          do 115  ip=1,nmep
            ajk=ajk+d1(k,ip)*d1(j,ip)
  115     continue
            a(k,j)=ajk
            a(j,k)=ajk
  118    continue
            a(natom+1,k)= 1.d0
            a(k,natom+1)= 1.d0
         if(idip) then
            a(natom+2,k)= co(1,k)*bohr1
            a(natom+3,k)= co(2,k)*bohr1
            a(natom+4,k)= co(3,k)*bohr1
            a(k,natom+2)= a(natom+2,k)
            a(k,natom+3)= a(natom+3,k)
            a(k,natom+4)= a(natom+4,k)
         endif
  120 continue
            a(natom+1,natom+1)=0.0d0
         if(idip) then
            a(natom+2,natom+2)=0.0d0
            a(natom+3,natom+3)=0.0d0
            a(natom+4,natom+4)=0.0d0
         endif
c                                                            solve aq=b            
         l=0
         do 130 i=1,natom0 
            do 130 j=1,natom0
               l=l+1
  130    al(l)=a(i,j)
      call osinv(al,natom0,det)
         l=0
         do 150 i=1,natom
             qi=0.0d0
            do 140 j=1,natom0
               l=l+1
               qi=qi+al(l)*b(j)
  140       continue
            q(i)=qi
  150    continue
c                               average charges equivalent by symmetry
        do 70 i=1,natom
           do 70 j=1,natom
             cequiv(i,j)=.false.
             if(dabs(dabs(ch(i))-dabs(ch(j))).lt.1.d-5) 
     +          cequiv(i,j)=.true.
   70   continue
        do 90 i=1,natom
          ieq=0
          qsc(i)=0.0d0
          do 80 j=1,natom
             if(cequiv(i,j)) then
                qsc(i)=qsc(i)+dabs(q(j))
                ieq=ieq+1
             endif
   80     continue
          qq(i)=q(i)/dabs(q(i))*qsc(i)/ieq
   90   continue
        do 95 i=1,natom
95        q(i)=qq(i)
c                              root mean square (rms) and relative rms 
      do 160 i=1,nmep
         epc=0.0d0
         epi=ep(i)
         do 155 j=1,natom
  155    epc=epc+q(j)*d1(j,i)
         epc=epc-epi
         rms=rms+epc*epc
  160 rrms=rrms+epi*epi
      rms=dsqrt(rms/nmep)
      rrms=rms/dsqrt(rrms/nmep)
      rms=rms*au
c     
      write(mfgw,'(3x,''atom no.    type    charge'')')
      do 170 i=1,natom
  170 write(mfgw,'(5x,i2,9x,a2,1x,f10.4)') i,elemnt(ian(i)),q(i)
c
      write(mfgw,'(/2x,a,4x,i6)')  'number of points ',nmep
      write(mfgw,'(2x,a,4x,f9.4)') 'rms deviation ',rms
      write(mfgw,'(2x,a,3x,f9.4)') 'rrms deviation ',rrms
c
      if (iz.ne.0) return
c                                    dipole moment for neutral molecule
         do 50 i=1,natom
            dipx=dipx+co(1,i)*q(i)
            dipy=dipy+co(2,i)*q(i)
            dipz=dipz+co(3,i)*q(i)
   50    continue
            dipx=dipx*bohr1
            dipy=dipy*bohr1
            dipz=dipz*bohr1
            dip =dsqrt(dipx*dipx+dipy*dipy+dipz*dipz)
      write(mfgw,
     +      '(//1x,"dipole moment evaluated from the mep charges")')
      write(mfgw,'(7x,''d(x)     d(y)     d(z)     total'')')
      write(mfgw,'(3x,4f9.4)')dipx*cf,dipy*cf,dipz*cf,dip*cf
c
      return
      end
c
      subroutine mepmap(c1)
**********************************************************************
*  subroutine mepmap calculates the mep minima and generates the 
*  conrour data in a defined plane.
*  ref.  g.p.ford and b. wang j.compt.chem. 14(1993)1101.
*                                    written by bingze wang, dec 1992
**********************************************************************
      implicit REAL (a-h,o-z)                               
INCLUDE(common/sizes)                                                   
      common /iofile/ mfgr,mfgw
      parameter (nonzox=10*maxhev+maxlit+50)
      common /densty/ p(mpack),pa(mpack),pb(mpack)
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),  
     1                nlast(numatm), norbs, nelecs,nalpha,nbeta,        
     2                nclose,nopen,ndumy,fract                          
      common /keywrd/ keywrd                                            
      common /elemts/ elemnt(107)
      character keywrd*241,elemnt*2
      dimension pp(nonzox),w(3),c1(3,*),
     1          r0(3),t(3,3),ria(numatm),mx(numatm),my(numatm),
     1          vmin(numatm),cw(3,numatm),uu(200),rk(3),cmep(3,numatm)
      logical prtmep,minmep
      data t/1.0d0,3*0.0d0,1.0d0,3*0.0d0,1.0d0/
      data step/0.1d0/,need1/0/,natm/0/,r0/3*0.0d0/,iw/7/,cut/999.0d0/
      data icase/0/,z0/0.0d0/,iback/0/
      write(mfgw,15)
15    format(///13x,'molcular electrostatic potential',
     1 //1x,'references  b.wang and g.p.ford j.compt.chem. in press',
     1  /13x,'g.p.ford and b.wang j.compt.chem. 14(1993)1101')
      call meprot(c1,r0,t,xm,ym,icase,step,cmep,z0,iback)
      if (iback.gt.0) return
      prtmep=index(keywrd,' prtmep').ne.0
      minmep=index(keywrd,' minmep').ne.0
      do 20 i=1,numat
        cw(1,i)=cut
        cw(2,i)=cut
        cw(3,i)=cut
 20     vmin(i)=cut
c                             
      call packp(p,pp,nonzo)
c        
         npx=int(xm/step)*2+1
      if (icase.eq.2.or.icase.eq.3) then
         ym=ym+3.0d0
         npy=int(ym/step)+1
      else
         npy=int(ym/step)*2+1
      endif
      if (prtmep) then
        write(iw,25) numat,npx,npy,-xm,-ym,step
25      format(1x,3i5,3f8.2/)
        write(iw,35) npx,npy,npx*npy,z0,-xm,step,-ym,step
        write(7,45)
        write(7,55) (i,nat(i),(cmep(k,i),k=1,2),i=1,numat)
        write (7,*)
      endif
c                                   create the points and calculate mep
         do 30 i=1,3
30        rk(i)=r0(i)
c
         ip=0
          t11=t(1,1)
          t12=t(1,2)
          t13=t(1,3)
          t21=t(2,1)
          t22=t(2,2)
          t23=t(2,3)
          t31=t(3,1)
          t32=t(3,2)
          t33=t(3,3)
         xx0=z0*t31
         yy0=z0*t32
         zz0=z0*t33
         xxw=xx0+r0(1)
         yyw=yy0+r0(2)
         zzw=zz0+r0(3)
         step1=step
888      xx1=xx0+r0(1)
         yy1=yy0+r0(2)
         zz1=zz0+r0(3)
c     
         do 3000 m=1,npx
            stepm=(m-1)*step1
            xx2=xx1+stepm*t11
            yy2=yy1+stepm*t12
            zz2=zz1+stepm*t13
         do 2000 n=1,npy
            uu(n)=cut
            stepn=(n-1)*step1
            w(1)=xx2+stepn*t21
            w(2)=yy2+stepn*t22
            w(3)=zz2+stepn*t23
         if (need1.eq.0) then 
c                                          check if too close to nuclei
               rmin=81.0d0
            do 60 i=1,numat
               rr=(w(1)-c1(1,i))**2+(w(2)-c1(2,i))**2+(w(3)-c1(3,i))**2
               if (rr.lt.0.25d0) goto 2000
               if (nat(i).gt.1.and.rr.lt.0.36d0) goto 2000
               ria(i)=dsqrt(rr)
               if (rmin.gt.rr) then
                  rmin=rr
                  imin=i
               endif
60          continue
            call pmepco(pp,ria,w,ui,c1,nonzo,1)
            uu(n)=ui
            if (ui.lt.vmin(imin)) then
               vmin(imin)=ui
               cw(1,imin)=w(1)
               cw(2,imin)=w(2)
               cw(3,imin)=w(3)
               mx(imin)=m 
               my(imin)=n
            endif
         else
            call pmepco(pp,ria,w,ui,c1,nonzo,0)
            if (ui.lt.vmin(natm)) then
               vmin(natm)=ui
               cw(1,natm)=w(1)
               cw(2,natm)=w(2)
               cw(3,natm)=w(3)
            endif
         endif
            ip=ip+1
2000   continue
       if (need1.eq.0.and.prtmep)  write(iw,99) (uu(ny),ny=1,npy)
3000   continue
c
       if (need1.eq.0)  write(mfgw,401) npx,npy
       if (prtmep.and.need1.eq.0) 
     1  write(mfgw,*) '=> contour file is printed on channel 7'
       if (need1.gt.0) goto 777
c                                               remove the false minima
      minima=0
      do 80 i=1,numat
         if (vmin(i).gt.0.0d0) goto 80
         do 70 m=mx(i)-1,mx(i)+1
            stepm=(m-1)*step 
            xx2=xxw+stepm*t11
            yy2=yyw+stepm*t12
            zz2=zzw+stepm*t13
         do 70 n=my(i)-1,my(i)+1
            stepn=(n-1)*step
            w(1)=xx2+stepn*t21
            w(2)=yy2+stepn*t22
            w(3)=zz2+stepn*t23
            ip=ip+1
          call pmepco(pp,ria,w,ui,c1,nonzo,0)
          if (ui.lt.vmin(i)-0.001d0) then
              vmin(i)=99.0d0
              goto 80 
          endif
70     continue
          minima=minima+1
80     continue
        if (minima.eq.0) then
           write(mfgw,*)' no mep minimum found in this plane'
           return
        endif
        if (.not.minmep) goto 999
              need1=1
              step1=step*0.2d0
              npx=11
              npy=11
777     natm=natm+1
          if (natm.gt.numat) goto 999
          if (vmin(natm).gt.0.0d0) goto 777
              r0(1)=cw(1,natm)-step*(t11+t21)
              r0(2)=cw(2,natm)-step*(t12+t22)
              r0(3)=cw(3,natm)-step*(t13+t23)
              goto 888
999   if (need1.gt.0)  write(mfgw,402) ip
      write(mfgw,403)
      do 600 i=1,numat
         if (vmin(i).lt.0.0d0) 
     1   write(mfgw,405) i,elemnt(nat(i)),vmin(i),
     1      dsqrt((c1(1,i)-cw(1,i))**2+(c1(2,i)-cw(2,i))**2
     1           +(c1(3,i)-cw(3,i))**2),
     1      (cw(j,i),j=1,3)
600   continue
      return
35    format(22x,'instruction', 
     1  /1x,'1) nx*ny = ',i3,'*',i3,' =',i6,' grids;',
     1  /1x,'2) ny values in each of the nx blocks;',
     1  /1x,'3) x,y coordinates (z=',f6.2,' ) of the grids:',
     1  /9x,'x(i)=',f8.2,'+',f6.2,'*(i-1)    i=1,2,...,nx',
     1  /9x,'y(j)=',f8.2,'+',f6.2,'*(j-1)    i=1,2,...,ny')
45    format(1x,'4) the molecular coordinates (x,y)',
     1         ' on the 2d-mep contour map')
55    format(9x,2i4,2f12.5)
99    format(6f11.5)
401   format(/1x,'grids nx*ny=', i3,' *',i3)
402   format(1x,'total number of the points calculated ',i8)
403   format(/1x,'minima in the specified plane',
     1      /5x,'atom       umin      distance',10x,'xyz coordinate',
     1 /15x,'kcal/mol     ang',14x,'in mol coord')
405   format(3x,i3,2x,a2,2x,f9.1,4x,f6.2,4x,3f9.3)
      end
c
      subroutine meprot(c,r0,t,xm,ym,icase,step,c1,z0,iback)
**********************************************************************
* meprot rotates the molecule to choose the plane in which mep is 
* to be computed. 
*                                     by bingze wang  28 oct 1992
**********************************************************************
      implicit REAL (a-h,o-z)                               
INCLUDE(common/sizes)                                                   
      common /iofile/ mfgr,mfgw
      common / readme / ird
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),  
     1                nlast(numatm), norbs, nelecs,nalpha,nbeta,        
     2                nclose,nopen,ndumy,fract                          
      common /keywrd/ keywrd
      character keywrd*241
      dimension  c(3,*),c1(3,*),t(3,3),r0(3),c0(3)
      data c0/3*0.0d0/
c
11    format(/1x,'input card for pmepr: icase,i,j,k,z0 =',4i4,f8.2)
15    format(1x,'icase should be 1,2, or 3 as pmepr is specified',
     1      /1x, 'pmepr was not executed')
16    format(1x,'the three referential atoms are unreasonable, ',
     1      /1x, 'pmepr was not executed')
c
      if (index(keywrd,' pmepr').eq.0) goto 111
        read(ird,*) icase,n1,n2,n3,z0
      write(mfgw,11) icase,n1,n2,n3,z0 
      if (icase.lt.1.or.icase.gt.3) then
                 write(mfgw,15)    
                 iback=1
                 return
      endif
      if (n1.eq.n2.or.n1.eq.n3.or.n2.eq.n3.or.
     1     n1.gt.numat.or.n2.gt.numat.or.n3.gt.numat) then
                 write(mfgw,16)    
                 iback=1
                 return
      endif
      if (icase.eq.1) then
           if (dabs(z0).lt.0.0001d0) then
                 write(mfgw,21) n1,n2,n3
           else
                 write(mfgw,22) z0,n1,n2,n3
           endif
      endif
21    format(1x,'meps are in the plane defined by atoms',
     1      3i4)
22    format(1x,'meps are in the plane',f6.2,
     1       ' above that defined by atoms',3i4)
      if (icase.eq.2) then
           if (dabs(z0).lt.0.0001d0) then
                 write(mfgw,31) n1,n2,n3,n1,n2
           else
                 write(mfgw,32) n1,n2,n3,n1,n2,z0
           endif
      endif
31    format(1x,'meps are in the plane perpendicular to that defined ',
     1      /5x,  'by (',3i3,') and through (',2i3,')')
32    format(1x,'meps are in the plane perpendicular to that defined',
     1 /5x,'by (',3i3,') and parallel to (',2i3,') with distance',f6.2)
      if (icase.eq.3) then
           if (dabs(z0).lt.0.0001d0) then
                 write(mfgw,41) n2,n1,n3
           else
                 write(mfgw,42) n2,n1,n3,z0
           endif
       endif
41    format(1x,'meps are in the plane bisecting the angle (',3i3,')')
42    format(1x,'meps are in the plane bisecting the angle (',3i3,')',
     1      /5x,'but non-zero value z0=',f6.2,' makes no sense',
     1          ' and is ignored')
111   if (icase.le.1) then                             
             do 24 i=1,numat
                  c1(1,i)=c(1,i)
                  c1(2,i)=c(2,i)
24                c1(3,i)=c(3,i)
             goto 999
       endif
c                                            move the origin to atom n1
         do 20 i=1,numat
            c1(1,i)=c(1,i)-c(1,n1)
            c1(2,i)=c(2,i)-c(2,n1)
            c1(3,i)=c(3,i)-c(3,n1)
20       continue
c                                                                       
         x2=c1(1,n2)
         y2=c1(2,n2)
         z2=c1(3,n2)
         rr2=x2*x2+y2*y2+z2*z2                                   
         r2 =dsqrt(rr2)                              
         r21=1.0d0/r2
         x3= c1(1,n3)
         y3= c1(2,n3)
         z3= c1(3,n3)
         rr3= x3*x3+y3*y3+z3*z3                                  
         r3=dsqrt(rr3)                                                 
         r31=1.0d0/r3
         cos1=(rr3+rr2-(x3-x2)**2-(y3-y2)**2-(z3-z2)**2)*(0.5d0*r31*r21)
         if (1.0d0-dabs(cos1).lt.0.01d0) then
              write (mfgw,25) dacos(cos1)             
_IF(ipsc,tools)
              call pend
_ELSE
              stop
_ENDIF
         endif
c 
      if (icase.eq.1.or.icase.eq.2) then                                
c                                            choose x-axis for case 1,2
           t(1,1)=x2*r21                                                
           t(1,2)=y2*r21                                                
           t(1,3)=z2*r21                                                
c                                           y-axis for case 1, z case 2
             p41=r3*cos1*r21
             x34=x3-p41*x2                   
             y34=y3-p41*y2                   
             z34=z3-p41*z2                   
             r341=1.0d0/dsqrt(x34*x34+y34*y34+z34*z34)
                 if (icase.eq.1) then          
           t(2,1)= x34*r341
           t(2,2)= y34*r341                                       
           t(2,3)= z34*r341                                       
                 else                                                   
           t(3,1)=-x34*r341
           t(3,2)=-y34*r341                                       
           t(3,3)=-z34*r341                                       
                 endif                                                  
       endif                                                            
c                                           choose x, z-axes for case 3 
       if (icase.eq.3) then
           if (r3.gt.r2) then              
               x6= r2*r31                                
               y6= x6*y3                                 
               z6= x6*z3                                 
               x6= x6*x3                                 
               x62= x6-x2
               y62= y6-y2
               z62= z6-z2
               r621=1.0d0/dsqrt(x62*x62+y62*y62+z62*z62)   
              t(3,1)=-x62*r621     
              t(3,2)=-y62*r621    
              t(3,3)=-z62*r621   
               x4=(x2+x6)*0.5d0
               y4=(y2+y6)*0.5d0
               z4=(z2+z6)*0.5d0
            else     
               x6= r3*r21
               y6= x6*y2                                 
               z6= x6*z3                                 
               x6= x6*x2                                 
               x63= x6-x3
               y63= y6-y3
               z63= z6-z3
               r631=1.0d0/dsqrt(x63*x63+y63*y63+z63*z63)   
              t(3,1)= x63*r631
              t(3,2)= y63*r631  
              t(3,3)= z63*r631 
               x4=(x3+x6)*0.5d0
               y4=(y3+y6)*0.5d0
               z4=(z3+z6)*0.5d0
           endif                                    
         r41=1.0d0/dsqrt(x4*x4+y4*y4+z4*z4)
         t(1,1)=x4*r41                                                 
         t(1,2)=y4*r41                                                 
         t(1,3)=z4*r41                                                 
       endif                                                            
c                                      z for icase=1, y for icase=2 & 3 
         z5=1.0d0  
           if (dabs(x2).gt.0.1d0) then
               y5=-(x2*z3-x3*z2)/(x2*y3-x3*y2)
               x5=-(y5*y2+z2)/x2
               goto 55
           endif
           if (dabs(x3).gt.0.1d0) then
               y5=-(x3*z2-x2*z3)/(x3*y2-x2*y3)   
               x5=-(y3*y5+z3)/x3                         
               goto 55
           endif
           if (dabs(y3).gt.0.1d0) then
               x5=-(y3*z2-y2*z3)/(x2*y3-x3*y2)
               y5=-(x5*x3+z3)/y3
               goto 55
           endif
           if (dabs(y2).gt.0.1d0) then
               x5=-(y2*z3-y3*z2)/(x3*y2-x2*y3)
               y5=-(x5*x2+z2)/y2
               goto 55
             else
               write(mfgw,35) x2,y2,x3,y3
_IF(ipsc,tools)
               call pend
_ELSE
               stop
_ENDIF
           endif
55       r51=1.0d0/dsqrt(x5*x5+y5*y5+1.0d0)
                    k=3                                                 
                 if (icase.ne.1) k=2                                    
         t(k,1)=x5*r51                                   
         t(k,2)=y5*r51                                   
         t(k,3)=z5*r51                                  
c                            rotate the molecule to new xyz coordinates 
      do 300 k=1,numat                                                  
                xi=t(1,1)*c1(1,k)+t(1,2)*c1(2,k)+t(1,3)*c1(3,k)
                yi=t(2,1)*c1(1,k)+t(2,2)*c1(2,k)+t(2,3)*c1(3,k)
           c1(3,k)=t(3,1)*c1(1,k)+t(3,2)*c1(2,k)+t(3,3)*c1(3,k)
           c1(1,k)=xi
           c1(2,k)=yi
300   continue                                                          
c                                check if it is right-handed xyz system 
      dett=  t(1,1)*t(2,2)*t(3,3) + t(1,2)*t(2,3)*t(3,1)  
     2     + t(1,3)*t(2,1)*t(3,2) - t(1,3)*t(2,2)*t(3,1)
     3     - t(1,2)*t(2,1)*t(3,3) - t(1,1)*t(2,3)*t(3,2)
c                                                   non-weighted center
999      do 131 j=1,2
         cs=1.d6
         cl=-1.d6
               do 130 i=1,numat         
                  if (c1(j,i).lt.cs) then
                     cs=c1(j,i)
                     is=i
                  endif
                  if (c1(j,i).gt.cl) then
                     cl=c1(j,i)
                     il=i
                  endif 
130             continue
            c0(j)=(cs+cl)/2.0d0 
            r0(j)=cl-c0(j)+2.0d0
            if (nat(is).gt.1.or.nat(il).gt.1) r0(j)=r0(j)+0.4d0
131       continue
c                                                move to the new center
         do 40 i=1,numat
            c1(1,i)=c1(1,i)-c0(1)
            c1(2,i)=c1(2,i)-c0(2)
40       continue
            xm=int(r0(1)/step)*step
            ym=int(r0(2)/step)*step
         if (icase.lt.1.or.icase.gt.3) then
            r0(1)=(-xm+c0(1))*t(1,1)+(-ym+c0(2))*t(2,1)
            r0(2)=(-xm+c0(1))*t(1,2)+(-ym+c0(2))*t(2,2)
            r0(3)=(-xm+c0(1))*t(1,3)+(-ym+c0(2))*t(2,3)
         else
            if (icase.eq.1) then
               r0(1)=(-xm+c0(1))*t(1,1)+(-ym+c0(2))*t(2,1)+c(1,n1)
               r0(2)=(-xm+c0(1))*t(1,2)+(-ym+c0(2))*t(2,2)+c(2,n1)
               r0(3)=(-xm+c0(1))*t(1,3)+(-ym+c0(2))*t(2,3)+c(3,n1)
            else
               r0(1)=(-xm+c0(1))*t(1,1)+c0(2)*t(2,1)+c(1,n1)
               r0(2)=(-xm+c0(1))*t(1,2)+c0(2)*t(2,2)+c(2,n1)
               r0(3)=(-xm+c0(1))*t(1,3)+c0(2)*t(2,3)+c(3,n1)
            endif
         endif
      return
25    format(1x,'n2-n1-n3=',f9.3,' degrees, almost linear!')
35    format('x21,y21,x31,y31=',4f8.4,' why they are so small?') 
      end                                                               
c
      subroutine packp(p,pp,mn)                                      
**********************************************************************
*  subroutine packp re-writes the density matrix. 
*  written by bingze wang, 20 october 1991.
**********************************************************************
      implicit REAL (a-h,o-z)                               
INCLUDE(common/sizes)                                                   
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),  
     1                nlast(numatm), norbs, nelecs,nalpha,nbeta,        
     2                nclose,nopen,ndumy,fract                          
      dimension p(*), pp(*)                                             
      mn=0                                                              
      do 100 i=1,numat                                                  
             ia=nfirst(i)                                               
             ib=nlast(i)                                                
           do 80 j=ia,ib                                                
                j1st=j*(j-1)/2                                          
           do 80 k=ia,j                                                 
                mn=mn+1                                                 
                pp(mn)=p(j1st+k)                                        
   80      continue                                                     
  100   continue                                                        
      return                                                            
      end                                                               
       subroutine pmep
************************************************************************
*  this is a driving routine for computations of pmep - parametric
*  molecular electrostatic potential as well as  mep charges.
*
*  ref.  b. wang and g.p.ford j.compt.chem. in press.
*        g.p.ford and b. wang j.compt.chem. 14(1993)1101.
*
*                               written by bingze wang, august 1993
************************************************************************
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      common /iofile/ mfgr,mfgw
      parameter (mxmep=numatm*50+1000)
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),  
     1                nlast(numatm), norbs, nelecs,nalpha,nbeta,        
     2                nclose,nopen,ndumy,fract                          
      common /keywrd/ keywrd
      common /cmpg/ geo(3,numatm)
      character*241 keywrd
      dimension potpt(3,mxmep),coord(3,numatm),alpw(107)
c                                    am1 parameters (for h,c,n,o,f,cl)
      data alpw/2.92d0,4*0.0d0,4.36d0,6.95d0,9.22d0,5.53d0,0.0d0,
     1         6*0.0d0,3.32d0,90*0.0d0/
      data nmep/0/
*                                                 check for saving time
      if(index(keywrd,' am1') .eq. 0) goto 999
      do 10 i=1,numat
         if (alpw(nat(i)).lt.0.1d0) goto 999
10    continue
c
      t1=secmop()
c
      call gmetry(geo,coord)
*                                              ***** calculate mep only 
      if(index(keywrd,' pmep') .ne. 0) then
         call mepmap(coord)
         goto 1000
      endif
*                         ***** choose surface where points are sampled
*
      if (index(keywrd,'williams').ne.0) then
*                                                  the williams surface
             call grids(coord,potpt,nmep)
      else
*                                                  the connolly surface
             call surfa(coord,potpt,nmep)
      endif
c                                           ***** calculate mep charges
      call mepchg(coord,potpt,nmep)
c
1000  t1=secmop()-t1
      write(mfgw,
     + '(/1x,a,f9.2,a)') 'time to calculate mep',t1,' seconds'
      return
999   write(mfgw,*) 
     + ' am1 parameters for h,c,n,f and cl are available.',
     1  '  pmep was not executed'
      return
      end
c
      subroutine pmepco(pp,ria,w,ui,co,nonzo,id)
***********************************************************************
* pmepco is the core subroutine of this program <pmep>. it calculates
* the mep at an arbitralry position w(3). 
* ref.  b. wang and g.p.ford j.compt.chem. in press
*       g.p.ford and b. wang j.compt.chem. 14(1993)1101 
*                                      written by bingze wang feb 1993
***********************************************************************
      implicit REAL (a-h,o-z)                               
INCLUDE(common/sizes)                                                   
      parameter (nonzox=10*maxhev+maxlit+50)
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),  
     1                nlast(numatm), norbs, nelecs,nalpha,nbeta,        
     2                nclose,nopen,ndumy,fract                          
      dimension e1b(10),pp(*),w(3),vp(nonzox),co(3,*),ria(*)
      dimension alpw(107),aw(107)
c                                    am1 parameters (for h,c,n,o,f,cl)
      data alpw/2.92d0,4*0.0d0,4.36d0,6.95d0,9.22d0,5.53d0,0.0d0,
     1         6*0.0d0,3.32d0,90*0.0d0/
      data  aw /0.05d0,4*0.0d0,0.63d0,0.64d0,0.67d0,0.29d0,0.0d0,
     1         6*0.0d0,0.31d0,90*0.0d0/
      data ev/23.061d0/
c
      do 10 j=1,nonzo                                                   
   10 vp(j)=0.0d0                                                       
             mn=0                                                       
             enuclr=0.0d0                                                
      do 200 i=1,numat                                                  
         ia=nfirst(i)                                                   
         ib=nlast(i)                                                    
         ni=nat(i)                                                      
            if (id.eq.1) then
                 rr=ria(i)
            else
                 xx=w(1)-co(1,i)
                 yy=w(2)-co(2,i)
                 zz=w(3)-co(3,i)
                 rr=dsqrt(xx*xx+yy*yy+zz*zz)
            endif
            fnear=1.0d0+dexp(-alpw(ni)*(rr-aw(ni)) )
c                                                                       
            call drotat(ni,1,co(1,i),w,e1b,enuc,rr) 
            enuclr = enuclr + enuc *fnear
            i2=0                                                        
            do 60 i1=ia,ib
            do 60 j1=ia,i1                                           
                  i2=i2+1                                               
                  mn=mn+1                                               
                  vp(mn)=e1b(i2)
   60       continue
  200    continue                                                       
           mn=0                                                         
           ui=0.0d0   
        do 50 i=1,numat                                                 
             ia=nfirst(i)                                               
             ib=nlast(i)                                                
           do 51 j=ia,ib                                                
           do 51 k=ia,j                                                 
                 mn=mn+1                                                
                 if (k.eq.j) then                                       
                     ui=ui+pp(mn)*vp(mn)                             
                 else                                                   
                     ui=ui+2.0d0*pp(mn)*vp(mn)                         
                 endif                                                  
   51      continue                                                     
  50    continue                                                        
        ui=(enuclr+ui)*ev
c                                                       ui  in kcal/mol
      return
      end
      subroutine prjfc(f,xparam,nvar) 
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      common /iofile/ mfgr,mfgw
c                                                                       
c  calculates projected force constant matrix (f).                      
c  this routine came originally from polyrate. it is used by permission
c  of d. truhlar. the current version is lifted from gamess and 
c  adapted by f.jensen, odense, dk             
c  if we are at a stationary point (stpt=.t.), i.e. gnorm .lt. 10,      
c  then the rotational and translational modes are projected out        
c  and their frequencies become identical zero. if not at a stationary  
c  point then the mass-weighted gradient is also projected out and      
c  the corresponding frequency become zero.                             
c ************************************************                      
c   x : mass-weighted coordinate                                        
c   dx: normalized mass-weighted gradient vector                        
c   f : mass-weighted force constant matrix                             
c   rm: inversion of square root of mass                                
c   p, cof: buffer                                                      
c                                                                       
      common /atmass/ atmass(numatm)
      dimension x(maxpar),rm(maxpar),f(maxpar,maxpar),                  
     *          p(maxpar,maxpar),cof(maxpar,maxpar)                     
      dimension tens(3,3,3),rot(3,3),scr(3,3),iscr(6),cmass(3)          
      dimension coord(3,numatm),dx(maxpar),xparam(maxpar)
      parameter (zero=0.0d+00, one=1.0d+00, eps=1.0d-14,                
     *           cut5=1.0d-05, cut8=1.0d-08)                            
c                                                                       
c totally asymmetric cartesian tensor.                                  
      data tens/ 0.0d+00,  0.0d+00,  0.0d+00,                           
     x           0.0d+00,  0.0d+00, -1.0d+00,                           
     x           0.0d+00,  1.0d+00,  0.0d+00,                           
     y           0.0d+00,  0.0d+00,  1.0d+00,                           
     y           0.0d+00,  0.0d+00,  0.0d+00,                           
     y          -1.0d+00,  0.0d+00,  0.0d+00,                           
     z           0.0d+00, -1.0d+00,  0.0d+00,                           
     z           1.0d+00,  0.0d+00,  0.0d+00,                           
     z           0.0d+00,  0.0d+00,  0.0d+00  /                         
c                                                                       
      natm=nvar/3                                                        
      nc1=nvar
      ij=1
      do 2 i=1,natm                                                    
         coord(1,i)=xparam(ij)
         coord(2,i)=xparam(ij+1)
         coord(3,i)=xparam(ij+2)
         ij=ij+3
2     continue                                                          
c     calculate 1/sqrt(mass)                                            
      l=0                                                               
      do 3 i=1,natm                                                     
         tmp=one/dsqrt(atmass(i))                                        
         do 3 j=1,3                                                     
            l=l+1                                                       
3           rm(l)=tmp                                                   
c     prepare gradient                                                  
         do 4 i=1,nc1                                                   
4        dx(i)=zero                                                     
c     find cms and calculated mass weighted coordinates                 
      totm=zero                                                         
      cmass(1)=zero                                                     
      cmass(2)=zero                                                     
      cmass(3)=zero                                                     
      do 6 i=1,natm                                                     
         totm=totm+atmass(i)                                            
         do 6 j=1,3                                                     
            cmass(j)=cmass(j)+atmass(i)*coord(j,i)                      
6     continue                                                          
      do 7 j=1,3                                                        
7     cmass(j)=cmass(j)/totm                                            
      l=0                                                               
      do 8 i=1,natm                                                     
         do 8 j=1,3                                                     
         tmp=dsqrt(atmass(i))                                            
             l=l+1                                                      
             x(l)=tmp*(coord(j,i)-cmass(j))                             
8     continue                                                          
c     write(mfgw,9020)                                                     
c     call prsq(f,nc1,nc1,maxpar,1)                                          
c9020 format(/1x,'enter the subroutine <prjfc>'//                       
c    *        1x,'unprojected force constant matrix (hartree/bohr**2)') 
c     write(mfgw*)' mass-weighted coordinates and corresponding gradient' 
c     do 9 i=1,nc1                                                      
c9       write(mfgw*)x(i),dx(i)                                           
c                                                                       
c 2. compute inertia tensor.                                            
      do 10 i=1,3                                                       
       do 10 j=1,3                                                      
   10   rot(i,j)=zero                                                   
      do 20 i=1,natm                                                    
       l=3*(i-1)+1                                                      
       rot(1,1)=rot(1,1)+x(l+1)**2+x(l+2)**2                            
       rot(1,2)=rot(1,2)-x(l)*x(l+1)                                    
       rot(1,3)=rot(1,3)-x(l)*x(l+2)                                    
       rot(2,2)=rot(2,2)+x(l)**2+x(l+2)**2                              
       rot(2,3)=rot(2,3)-x(l+1)*x(l+2)                                  
   20  rot(3,3)=rot(3,3)+x(l)**2+x(l+1)**2                              
      rot(2,1)=rot(1,2)                                                 
      rot(3,1)=rot(1,3)                                                 
      rot(3,2)=rot(2,3)                                                 
c                                                                       
check the inertia tensor.                                               
      chk=rot(1,1)*rot(2,2)*rot(3,3)                                    
      if(dabs(chk).gt.cut8) go to 21                                     
c     write(mfgw,23)                                                       
c  23 format(/1x,'matrix of inertia moment')                            
c     call prsq(rot,3,3,3,3)                                              
      if(dabs(rot(1,1)).gt.cut8) go to 11                                
c x=0                                                                   
      if(dabs(rot(2,2)).gt.cut8) go to 12                                
c x,y=0                                                                 
      if(dabs(rot(3,3)).gt.cut8) go to 13                                
      write(mfgw,14) rot(1,1),rot(2,2),rot(3,3)                            
   14 format(1x,'every diagonal elements are zero ?',3f20.10)           
      return                                                            
c                                                                       
c* 1. x,y=0 but z.ne.0                                                  
   13 rot(3,3)=one/rot(3,3)                                             
      go to 22                                                          
c y.ne.0                                                                
   12 if(dabs(rot(3,3)).gt.cut8) go to 15                                
c* 2. x,z=0 but y.ne.0                                                  
      rot(2,2)=one/rot(2,2)                                             
      go to 22                                                          
c x.ne.0                                                                
   11 if(dabs(rot(2,2)).gt.cut8) go to 16                                
      if(dabs(rot(3,3)).gt.cut8) go to 17                                
c* 3. y,z=0 but x.ne.0                                                  
      rot(1,1)=one/rot(1,1)                                             
      go to 22                                                          
c* 4. x,y.ne.0 but z=0                                                  
   16 det=rot(1,1)*rot(2,2)-rot(1,2)*rot(2,1)                           
      trp=rot(1,1)                                                      
      rot(1,1)=rot(2,2)/det                                             
      rot(2,2)=trp/det                                                  
      rot(1,2)=-rot(1,2)/det                                            
      rot(2,1)=-rot(2,1)/det                                            
      go to 22                                                          
c* 5. x,z.ne.0 but y=0                                                  
   17 det=rot(1,1)*rot(3,3)-rot(1,3)*rot(3,1)                           
      trp=rot(1,1)                                                      
      rot(1,1)=rot(3,3)/det                                             
      rot(3,3)=trp/det                                                  
      rot(1,3)=-rot(1,3)/det                                            
      rot(3,1)=-rot(3,1)/det                                            
      go to 22                                                          
c* 6. y,z.ne.0 but x=0                                                  
   15 det=rot(3,3)*rot(2,2)-rot(3,2)*rot(2,3)                           
      trp=rot(3,3)                                                      
      rot(3,3)=rot(2,2)/det                                             
      rot(2,2)=trp/det                                                  
      rot(3,2)=-rot(3,2)/det                                            
      rot(2,3)=-rot(2,3)/det                                            
      go to 22                                                          
   21 continue                                                          
c                                                                       
c.debug.                                                                
c      call prsq(tens(1,1,1),3,3,3,3)                                     
c      call prsq(tens(1,1,2),3,3,3,3)                                     
c      call prsq(tens(1,1,3),3,3,3,3)                                     
c      call prsq(rot,3,3,3,3)                                             
c                                                                       
c 4. compute inversion matrix of rot.                                   
c     call mxlneq(rot,3,3,det,jrnk,eps,scr,+0)                          
c     if(jrnk.lt.3) stop 1                                              
      info=0                                                            
      call dgefa(rot,3,3,iscr,info)                                     
      if(info.ne.0) then
_IF(ipsc,tools)
       call pend
_ELSE
       stop
_ENDIF
      endif
      det=zero                                                          
      call dgedi(rot,3,3,iscr,det,scr,1)                                
c                                                                       
   22 continue                                                          
c     write ((mfgw702)                                                     
c 702 format(/1x,'inverse matrix of moment of inertia.')                
c     call prsq(rot,3,3,3,3)                                              
c                                                                       
c 5. total mass ---> totm.                                              
c                                                                       
c 6. compute p matrix                                                   
c    ----------------                                                   
      do 100 ip=1,natm                                                  
       indx=3*(ip-1)                                                    
       do 100 jp=1,ip                                                   
        jndx=3*(jp-1)                                                   
        do 70 ic=1,3                                                    
         jend=3                                                         
         if(jp.eq.ip) jend=ic                                           
         do 70 jc=1,jend                                                
          sum=zero                                                      
          do 50 ia=1,3                                                  
           do 50 ib=1,3                                                 
            if(tens(ia,ib,ic).eq.0) go to 50                            
            do 30 ja=1,3                                                
             do 30 jb=1,3                                               
              if(tens(ja,jb,jc).eq.0) go to 30                          
              sum=sum+tens(ia,ib,ic)*tens(ja,jb,jc)*rot(ia,ja)*         
     &                x(indx+ib)*x(jndx+jb)                             
   30         continue                                                  
   50       continue                                                    
          ii=indx+ic                                                    
          jj=jndx+jc                                                    
          p(ii,jj)=sum+dx(ii)*dx(jj)                                    
          if(ic.eq.jc) p(ii,jj)=p(ii,jj)+one/(rm(ii)*rm(jj)*totm)       
   70     continue                                                      
  100   continue                                                        
c                                                                       
c 7. compute delta(i,j)-p(i,j)                                          
      do 110 i=1,nc1                                                    
       do 110 j=1,i                                                     
        p(i,j)=-p(i,j)                                                  
        if(i.eq.j) p(i,j) = one +p(i,j)                                 
  110   continue                                                        
c                                                                       
c 8. neglect smaller values than 10**-8.                                
      do 120 i=1,nc1                                                    
       do 120 j=1,i                                                     
        if(dabs(p(i,j)).lt.cut8) p(i,j)=zero                             
        p(j,i)=p(i,j)                                                   
  120   continue                                                        
c                                                                       
c.debug.                                                                
c     write((mfgw703)                                                      
c 703 format(/1x,'projection matrix')                                   
c     call prsq(p,nc1,nc1,nc1)                                          
c     call prsq(p,nc1,nc1,maxpar,3)                                       
c                                                                       
c 10. post and premultiply f by p.                                      
c     use cof for scratch.                                              
      do 150 i=1,nc1                                                    
       do 150 j=1,nc1                                                   
        sum=zero                                                        
        do 140 k=1,nc1                                                  
  140    sum=sum+f(i,k)*p(k,j)                                          
  150   cof(i,j)=sum                                                    
c                                                                       
c 11. compute p*f*p.                                                    
      do 200 i=1,nc1                                                    
       do 200 j=1,nc1                                                   
        sum=zero                                                        
        do 190 k=1,nc1                                                  
  190    sum=sum+p(i,k)*cof(k,j)                                        
  200   f(i,j)=sum                                                      
c                                                                       
c     write((mfgw9030)                                                     
c     call prsq(f,nc1,nc1,maxpar,1)                                          
c9030 format(/1x,'leave the subroutine <prjfc>'//                       
c    *        1x,'projected force constant matrix (hartree/bohr**2)')   
      return                                                            
      end                                                               
      subroutine purdf1(x)
      implicit REAL (a-h,o-z)
      integer ubound,ulpure
c
c     --------------------------
c     gaussian 76 (qcpe version)
c     december 1977
c     control data 7600
c     --------------------------
c
      common/type/itype,jtype
      common/ipure/ipurd,ipurf
      common/limit/imj,istart,jstart,iend,jend,irange,jrange,lentq
      common/cfact/pt5,r3ov2,root3,root5,root15,r1,r2,r4,z1,z2,z3
      common/mopord/nordr(20),n6ord(10),n5ord(9),n10ord(10),
     +              n7ord(7),lbound(4,3),ubound(4),ulpure(4)
      common/commax/lamax,lbmax,lpmax
      common/new/inew,jnew
      dimension x(10)
      equivalence(r3,r3ov2)
c
c
c***********************************************************************
c     this routine transforms the input rectangular matrix x from
c     second- or third-order gaussians to pure angular functions.
c     (ie. to pure d- or f-functions.)
c
c     the transformation is done index sequentially, and is
c     o(n**3) operations.
c
c     because the transformation matrices are of unit matrix form
c     and are sparse, the matrix multiplications are explicitely
c     written.
c
c     this routine will alter /limit/ in that iend, jend, irange,
c     and jrange are updated if necessary.
c***********************************************************************
c
c
c
c     test for possible bypass of trnasformation at b.
      if(jtype-2)100,10,40
c
c     test for pure d at b.
   10 if(ipurd)100,20,100
c
c     ******************************************************************
c     d-transform at b.
c     ******************************************************************
c     indx1 is the main index into x.
   20 indx1=5-jstart+1
c     loop over all values of i.
      do 30 i=1,irange
c     form 3*z**2-r**2 part at b.
         dz2=x(indx1+2)-pt5*(x(indx1)+x(indx1+1))
c     form x**2-y**2 at b.
         dx2y2=r3ov2*(x(indx1)-x(indx1+1))
c     fill the integrals into x.
         x(indx1  )=dz2
         x(indx1+1)=x(indx1+4)
         x(indx1+2)=x(indx1+5)
         x(indx1+4)=x(indx1+3)
         x(indx1+3)=dx2y2
   30 indx1=indx1+jrange
c     branch to compression.
      go to 70
c
c
c     test for f-transformation.
   40 if(ipurf)100,50,100
c
c     ******************************************************************
c     f-transform at b.
c     ******************************************************************
c     we have only f. (ie. no s=p stuff).
c     set indx1.
   50 indx1=0
c     loop over all possible i values.
      do 60 i=1,irange
c
         f0 =x(indx1+3)-r2*(x(indx1+6)+x(indx1+9))
         f1p=r4*(z1*x(indx1+7)-x(indx1+1)-z2*x(indx1+4))
         f1m=r4*(z1*x(indx1+8)-x(indx1+2)-z2*x(indx1+5))
         f2p=r3*(x(indx1+6)-x(indx1+9))
         f2m=x(indx1+10)
         f3p=r1*(x(indx1+1)-z3*x(indx1+4))
         f3m=r1*(z3*x(indx1+5)-x(indx1+2))
c
         x(indx1+1)=f0
         x(indx1+2)=f1p
         x(indx1+3)=f1m
         x(indx1+4)=f2p
         x(indx1+5)=f2m
         x(indx1+6)=f3p
         x(indx1+7)=f3m
c
   60 indx1=indx1+jrange
c
c
c     after transformation at b, it is necessary to eliminate
c     the extraneous functions.
c
c     indx2 counts into compressed array.
c     indx1 counts from the un-compressed array.
c
c     set jendp and jrpure.
   70 jendp=ulpure(lbmax)
      jrpure=jendp-jstart+1
c
      indx1=0
      indx2=0
c
c     loop over all i, new j.
      do 90 i=1,irange
         do 80 j=1,jrpure
   80    x(indx2+j)=x(indx1+j)
         indx1=indx1+jrange
   90 indx2=indx2+jrpure
c
c     transformation at b is complete.
c     update necessary /limit/ variables.
      jend=jendp
      jrange=jrpure
c
c
c     test for possible bypass of transformation at a.
  100 if(itype-2)180,110,140
c
c     test for d-transform at a.
  110 if(ipurd)180,120,180
c
c     ******************************************************************
c     execute d-transform at a.
c     ******************************************************************
c     obtain starting index.
  120 indx1=(5-istart)*jrange+1
c     obtain increments.
      incr1=jrange
      incr2=incr1+jrange
      incr3=incr2+jrange
      incr4=incr3+jrange
      incr5=incr4+jrange
c
c     perform d-transform at a.
      do 130 j=1,jrange
         dz2=x(indx1+incr2)-pt5*(x(indx1)+x(indx1+incr1))
         dx2y2=r3ov2*(x(indx1)-x(indx1+incr1))
         x(indx1      )=dz2
         x(indx1+incr1)=x(indx1+incr4)
         x(indx1+incr2)=x(indx1+incr5)
         x(indx1+incr4)=x(indx1+incr3)
         x(indx1+incr3)=dx2y2
  130 indx1=indx1+1
      go to 170
c
c
c     test for required pure f at a.
  140 if(ipurf)180,150,180
c
c     ******************************************************************
c     transform to pure f at a.
c     ******************************************************************
c     obtain starting index.
  150 indx1=1
c     obtain increments.
      incr1=jrange
      incr2=incr1+jrange
      incr3=incr2+jrange
      incr4=incr3+jrange
      incr5=incr4+jrange
      incr6=incr5+jrange
      incr7=incr6+jrange
      incr8=incr7+jrange
      incr9=incr8+jrange
c
c     commence f-transformation loop at a.
      do 160 j=1,jrange
c
         f0 =x(indx1+incr2)-r2*(x(indx1+incr5)+x(indx1+incr8))
         f1p=r4*(z1*x(indx1+incr6)-x(indx1)-z2*x(indx1+incr3))
         f1m=r4*(z1*x(indx1+incr7)-x(indx1+incr1)-z2*x(indx1+incr4))
         f2p=r3*(x(indx1+incr5)-x(indx1+incr8))
         f2m=x(indx1+incr9)
         f3p=r1*(x(indx1)-z3*x(indx1+incr3))
         f3m=r1*(z3*x(indx1+incr4)-x(indx1+incr1))
c
         x(indx1      )=f0
         x(indx1+incr1)=f1p
         x(indx1+incr2)=f1m
         x(indx1+incr3)=f2p
         x(indx1+incr4)=f2m
         x(indx1+incr5)=f3p
         x(indx1+incr6)=f3m
c
  160 indx1=indx1+1
c
c     get corrected i values to /limit/.
  170 iend=ulpure(lamax)
      irange=iend-istart+1
c
  180 return
      end
      subroutine rfield
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      character*4 app
      common c(numatm,3),natoms,icharg,multip,ian(numatm),nae,nbe,ne,
     1nbasis
c     common antoau,fconv(3),icdum(131)
      common /poly/ sx(500),sy(500),sz(500),srd(500),
     1surf(500),
     2isphe(1500),ta(1500),stot,vtot,n,nc(numatm)
      common /mstsol/ eps,dmp,mc,icomp,ifield,icav
      common /mstcav/ tabs,vmol,dmol,tce,sten,dsten,cmf
      common /mstxyz/ xv(3575),yv(3575),zv(3575),nts
      common /mopfin/ gvw,gvws,elc1,ec1
      common /bbnew/ valv(3575)
      dimension pot(1500),pots(1500)
      dimension scr1(10725),scr2(3078)
      common/mstq/qs(1500),mflag,iterq
c     dimension qsfe(15),qs1(1500),qs0(1500)
      dimension qsfe(500),qs1(1500),qs0(1500)
      common /chanel/ ifiles(30)
      common /funcon/ fpc(2,10),ifpc
      equivalence (iw,ifiles(6)),(isol,ifiles(17))
      equivalence(xv(1),scr1(1)),(scr2(1),sx(1))
      data pi/3.14159265d0/
      data zero,pt5,one,two,four/0.0d0, .5d0,1.0d0,2.0d0,4.0d0/
      data tpi,fpi/6.28318531d0,12.56637061d0/
      data cekm/0.0014389d0/
      gc=fpc(ifpc,5)
      avgdr=fpc(ifpc,10)*1.d-24
      const=fpc(ifpc,4)*fpc(ifpc,9)
c      cekm=
   10 format(' * solvent physical parameters * ',//,
     1' permittivity ',f8.3,///)
   20 format(' * dielectric reaction field computed at level',
     1a4,'*')
   30 format(f8.3,i3,f6.3,4i3)
      if(mc.eq.0)then
         app='1a'
         if(icomp.ne.0)app='1b'
      end if
      if(mc.ne.0)then
         app='2a'
         if(icomp.ne.0)app='2b'
      end if
      if(mflag.eq.0)write(isol,10)eps
      write(isol,20)app
      conv=-(eps-1.d0)/eps
      fact=conv/fpi
      qtot1=zero
      elet1=zero
      do 40 i=1,n
   40 qsfe(i)=zero
      n1=nts+1
      dr=dsqrt((xv(1)-xv(n1))**2+
     +         (yv(1)-yv(n1))**2+
     +         (zv(1)-zv(n1))**2)
c-----------------------------------------------------------------------
c                  approximation i:
c-----------------------------------------------------------------------
      do 70 i=1,nts
         if (i.eq.1) write(isol,50)
   50    format(/,
     +   ' sphere element       x         y         z      charge',
     +   'a   area    c.e.')
         k=i+nts
         l=isphe(i)
c7020 format(2f10.5)
         ef=(valv(k)-valv(i))/dr
         qs(i)=ta(i)*fact*ef
         write(isol,60)l,i,xv(i),yv(i),zv(i),qs(i),ta(i),ef
   60    format(2(i5,5x),6f10.7)
         pot(i)=valv(i)
         qsfe(l)=qsfe(l)+qs(i)
         qtot1=qtot1+qs(i)
         elet1=elet1+qs(i)*pot(i)
   70 continue
      elet1=elet1*pt5
c
   80 format(i5,5x,f12.7)
   90 format(//, '    total charge on the cavity surface ',f10.5)
  100 format(/,' solution dielectric interaction/2 ',f10.5
     1       ,'a.u.',f15.5,'kcal/mole')
  110 format(/,'    charge on the surface for every sphere',/,
     1'   sphere     charge ')
c-----------------------------------------------------------------------
      write(isol,20)'1a'
      write(isol,100)elet1,elet1*const 
c     if(iprint.eq.1)then
      write(isol,90)qtot1
      write(isol,110)
      do 120 i=1,n
         write(isol,80)i,qsfe(i)
  120 continue
c     end if
      if(mc.eq.0)then
         if(icomp.eq.0)goto 360
         goto 270
      end if
c-----------------------------------------------------------------------
c            approximation ii:
c-----------------------------------------------------------------------
      m=0
      tlm=1.d0-dmp
      do 130 i=1,nts
  130 qs0(i)=qs(i)
  140 m=m+1
      elet3=zero
      elet2=zero
      do 150 i=1,n
  150 qsfe(i)=zero
      do 160 i=1,nts
  160 qs1(i)=qs(i)
      write(isol,170)m
  170 format(//,' self-polarization cycle      ',i4)
      chrg=zero
c
      do 220 i=1,nts
         if(i.eq.1)write(isol,180)
  180 format(/,' element    charge(no  pol.)  self-pol.     cambering  
     *   another charge   charge1(pol.)    charge2(pol.)')            
         k=i+nts
         xi=xv(i)
         yi=yv(i)
         zi=zv(i)
         xd=xv(k)
         yd=yv(k)
         zd=zv(k)
         qsi=qs1(i)
         ks=isphe(i)
c
         rad=ta(i)/(fpi*srd(ks)**2)
         qself0=-tpi*qsi*fact
         qcumb=qself0*dsqrt(rad)
         qself1=qself0-qcumb
         potslf=tpi*qsi/dsqrt(ta(i)*pi)
         if(i.eq.1)write(isol,210)potslf
c
         potsi=zero
         qsa=zero
         do 190 j=1,nts
            if(j.eq.i)goto 190
            qsj=qs1(j)
            xj=xv(j)
            yj=yv(j)
            zj=zv(j)
            rdj=dsqrt((xd-xj)**2+(yd-yj)**2+(zd-zj)**2)
            rij=dsqrt((xi-xj)**2+(yi-yj)**2+(zi-zj)**2)
            if(rij.lt.0.026d0)goto 190
            efn=qsj*(1.d0/rdj-1.d0/rij)/dr
            qsa=qsa+efn*ta(i)*fact
            potsi=potsi+qsj/rij
  190    continue
c     end of internal cycle over charges   
         qsib=qs0(i)+qself1+qsa
         qs(i)=qsib*dmp+qsi*tlm
         write(isol,200)i,qsi,qself0,qcumb,qsa,qsib,qs(i)
  200    format(i5,6f15.5)
         pots(i)=potsi+potslf
         if(i.eq.1)write(isol,210)potsi,pots(i)
  210    format(3f10.5)
         l=isphe(i)
         qsfe(l)=qsfe(l)+qs(i)
         elet3=elet3+pots(i)*qs(i)
         elet2=elet2+qs(i)*pot(i)
         chrg=chrg+qs(i)
  220 continue
c     end of external cycle over charges   
      write(isol,90)chrg
      elet3=elet3*pt5
      elet2=elet2*pt5
      write(isol,100)elet2,elet2*const 
  230 format(' interaction 1/2(sigma(pol.)*m.e.p.) ',f10.5,      
     *' interaction 1/2(sigma(pol.)*sigma(pol.)) ',f10.5)       
      if(m.eq.1)goto 240
      if(dabs(pchrg-chrg).lt.0.0001d0)goto 250
  240 pchrg=chrg
      if(m.lt.mc)go to 140
  250 qtot=chrg
      write(isol,20)'2a'
      write(isol,100)elet2,elet2*const 
c     if(iprint.eq.1)then
      write(isol,90)chrg
      write(isol,110)
      do 260 i=1,n
         write(isol,80)i,qsfe(i)
  260 continue
c     end if
      if(icomp.eq.0)goto 360
c-----------------------------------------------------------------------
c               approximation iii: charge compensation.
c-----------------------------------------------------------------------
  270 if(mc.eq.0)write(isol,20)'1b'
      if(mc.ne.0)write(isol,20)'2b'
      vchrg=dfloat(icharg)*conv
      qdif=qtot-vchrg
      write(isol,280)vchrg,chrg
  280 format(/,5x,'theoretical virtual charge',f15.6,
     15x,'effective virtual charge',3x,f10.6)
      qneg=zero
      qpos=zero
      do 290 i=1,n
  290 qsfe(i)=zero
      do 300 i=1,nts
  300 if(qs(i).lt.zero)qneg=qneg-qs(i)
      qpos=qtot+qneg
      fc=pt5
      if(qpos.gt.0.00001d0.and.qneg.gt.0.00001d0)then
         fcp=1.d0-fc*qdif/qpos
         fcn=1.d0+fc*qdif/qneg
      end if
      if(qneg.lt.0.00001d0)then
         fcp=1.d0-one*qdif/qpos
         fcn=1.d0
      end if
      if(qpos.lt.0.00001d0)then
         fcn=1.d0+one*qdif/qneg
         fcp=1.d0
      end if
      qtot=zero
      do 310 i=1,nts
         if(qs(i).lt.zero)qs(i)=qs(i)*fcn
         if(qs(i).gt.zero)qs(i)=qs(i)*fcp
  310 qtot=qtot+qs(i)
c-----------------------------------------------------------------------
      elet4=zero
      elet5=zero
  320 do 340 i=1,nts
         l=isphe(i)
         qsfe(l)=qsfe(l)+qs(i)
         req=dsqrt(ta(i)/pi)
         pots(i)=tpi*qs(i)*req/ta(i)
         do 330 j=1,nts
            rij=
     +      dsqrt((xv(i)-xv(j))**2+(yv(i)-yv(j))**2+(zv(i)-zv(j))**2)
            if(rij.lt.0.026d0)goto 330
            pots(i)=pots(i)+qs(j)/rij
  330    continue
         elet5=elet5+pots(i)*qs(i)
         elet4=elet4+pot(i)*qs(i)
  340 continue
      elet4=elet4*pt5
      elet5=elet5*pt5
      write(isol,100)elet4,elet4*const 
      write(isol,110)
      do 350 i=1,n
         write(isol,80)i,qsfe(i)
  350 continue
  360 continue
  370 continue
c-----------------------------------------------------------------------
c    cavitation energy         r.a. pierotti
c                              chem. review, 76,717,(1976).
c-----------------------------------------------------------------------
      if (icav.eq.0)goto 420
      if (mflag.ne.0)goto 420
c     read(in,500)tabs,vmol,dmol,tce
  380 format(6f10.5)
      dcav=dsqrt(stot/pi)
      tabs2=tabs**2
      denum=avgdr/vmol
      yp=denum*pi*dmol**3/6.0d0
      ypm1=1.d0-yp
      rp=dcav/dmol
      ecf=tce*gc*tabs2*yp/(ypm1**3)
      ec=ecf*(ypm1**2+3.d0*ypm1*rp+3.d0*(1.d0+two*yp)*rp*rp)/1000.0d0
      sig=(dcav+dmol)*pt5
      rap=yp/ypm1
      rap2=rap**2
      pk0=-dlog(ypm1)+4.5d0*rap2
      pk1=-(6.d0*rap+18.0d0*rap2)/dmol
      pk2=(12.d0*rap+18*rap2)/dmol**2
      elc=(pk2*sig+pk1)*sig+pk0
      elc=elc*gc*tabs/1000.d0
      write(iw,390)elc,tce,ec,denum,dmol,dcav
      elc1=elc
      ec1=ec
  390 format( //,' pierotti: free energy of cavitation',f9.5,'kcal/mole'
     1,5x,'thermal expansion coef.=',f14.6,/,
     211x,'cavitation en (enthalpy)',f9.5,' kcal/mole',
     35x,'numeral density=',f22.6,/,
     460x,'solvent molecule diameter ',f12.6,/,
     560x,'cavity diameter ',f22.6)
c-----------------------------------------------------------------------
c    energia di cavitazione:  sinanoglu at all
c                             t.c.a. 42,310,(1976)
c-----------------------------------------------------------------------
c     read(in,500)sten,dsten,cmf
      cmfm=(cmf-1.d0)/rp**2+1.d0 
      elc=sten*cmfm*stot*cekm
      ec=elc*(1.d0+dsten-two*tabs*tce/3.d0)
      write(iw,400)elc,cmf,ec,sten,dsten,tabs
  400 format(//,' sinanoglu: cavitation free energy ',f9.5,'kcal/mole'
     1,5x,'microscop. cavity factor ',f14.6,/,
     211x,' cavitation en.(enthalpy) ',f9.5,' kcal/mole',
     35x,'surface tension=',f22.6,/,
     460x,'surface tension derivate ',f12.6,/,
     560x,'absolute temperature ',f22.6,/,
     610x,'**************************************************',/)
c-----------------------------------------------------------------------
c     calculation of reaction field at selected points    
c-----------------------------------------------------------------------
  410 format(/,'sfera  tessera           x         y         z       ',
     1'carica')
c 910 mflag=0
  420 continue
c     if(iprint.eq.2)then
      write(isol,410)
      do 430 i=1,nts
         l=isphe(i)
  430 write(isol,60)l,i,xv(i),yv(i),zv(i),qs(i)
c     end if
c     if(ifield.eq.0)goto 700
c     reaction fiel on points from card.
c     read(in,2030)npts2
c     read(in,500)(xv(i),yv(i),zv(i),i=1,npts2)
c     read(in,500)xe1,ye1,ze1
c     if(xe1.eq.1000.d0)return
c     cex=zero
c     cey=zero
c     cez=zero
c     ptz=zero
c     do 550 i=1,nts
c     xu=xv(i)-xe1
c     yu=yv(i)-ye1
c     zu=zv(i)-ze1
c     r1=dsqrt((xu**2+yu**2+zu**2)**3)
c     r2=dsqrt(xu**2+yu**2+zu**2)
c     cex=cex+qs(i)*xu/r1
c     cey=cey+qs(i)*yu/r1
c     cez=cez+qs(i)*zu/r1
c     ptz=ptz+qs(i)/r2
c 550 continue
c     cei=dsqrt(cex**2+cey**2+cez**2)
c     cdx=cex/cei
c     cdy=cey/cei
c     cdz=cez/cei
c6070 format(///,' site ',3f10.5,/,'   reaction field components '
c    *,3f7.3,' intensity ',f10.5,' direction cosines ',3f7.3)
c6100 format(/,'   reaction potential',f10.7)
c     return
c     reaction field on nuclei        
  440 ptz=zero
      write(isol,460)
      do 480 i=1,natoms
         if(ian(i).eq.0)goto 480
         cex=zero
         cey=zero
         cez=zero
         do 450 j=1,nts
            xu=xv(j)-c(i,1)
            yu=yv(j)-c(i,2)
            zu=zv(j)-c(i,3)
            r1=dsqrt((xu**2+yu**2+zu**2)**3)
            r2=dsqrt(xu**2+yu**2+zu**2)
            cex=cex+qs(j)*xu/r1
            cey=cey+qs(j)*yu/r1
            cez=cez+qs(j)*zu/r1
            ptz=ptz+qs(i)/r2
  450    continue
         cei=dsqrt(cex**2+cey**2+cez**2)
         cdx=cex/cei
         cdy=cey/cei
         cdz=cez/cei
         write(isol,470)i,ian(i),cex,cey,cez,cei
  460 format(//,' reaction electric field on nuclei      ',/,       
     *'center/num.atom.           components (x,y,z) (a.u)     ',  
     *'  modulus (a.u.)')                                         
  470    format(2i5,4f15.6)
  480 continue
c
c     change value of parameter mflag
c
      if(mflag.eq.0) mflag=1
      return
      end
      subroutine rpol1(n,x,tp2,wp2)
c
c     --------------------------
c     gaussian 76 (qcpe version)
c     december 1977
c     control data 7600
c     --------------------------
c
      implicit REAL (a-h,o-z)
      dimension tp2(*),wp2(*)
c
c     given n (order of the rys polynomial) and x (the argument to
c     the f(m,t) routine), this routine uses common/t2w2/ to inter-
c     polate the roots and weights of the rys polynomial.
c
      common/t2w21e/lent(4),lind(4),iadr(4),s(4),ycut(4),t2(1030),w2(103
     10)
      common/herm1e/hroot2(10),hweigh(10)
      common/intcon/f6i,f20i,f100
      common/intk/zero,xint(12)
      equivalence(one,xint(1)),(four,xint(4))
      common/mtpc/  atheta,btheta,aphi,bphi,cm1,c0,c1,c2,m
      equivalence(th2,ph2,bt2,y100)
c**   data f100/100.0e0/
      f100=100.0d0
c     given x, compute y.
      sx=s(n)*x
      y=sx/(1.d0+sx)
c
c     test for possible use of large x formula.
      if(y-ycut(n))10,30,30
c
c     map onto 100.
   10 y100=f100*y
      m=int(y100)
      theta=y100- dfloat(m)
      phi=1.d0-theta
c
c     compute polynomials in theta and phi.
      th2=theta*theta
      atheta=theta*(th2-1.d0)*f6i
      btheta=atheta*(th2-four)*f20i
      ph2=phi*phi
      aphi=phi*(ph2-1.d0)*f6i
      bphi=aphi*(ph2-four)*f20i
c
c     compute interpolation coefficients.
      at2=atheta+atheta
      bt2=btheta+btheta
      bt3=bt2+btheta
      bt4=bt3+btheta
      ap2=aphi+aphi
      bp2=bphi+bphi
      bp3=bp2+bphi
      bp4=bp3+bphi
      cm1=btheta-bp4+aphi
      c0=phi-bt4+(bp3+bp3)+atheta-ap2
      c1=theta+(bt3+bt3)-bp4-at2+aphi
      c2=bphi+atheta-bt4
c
c     all required information is now ready.  perform interpolation.
c     this step creates n roots (squared) and n weights.
      iad=iadr(n)
      do 20 i=1,n
         tp2(i)=dintrp(t2(iad))
         wp2(i)=dintrp(w2(iad))
         wp2(i)= dsqrt(wp2(i))
   20 iad=iad+lent(n)
      return
c
c
c     compute rys roots and weights for large x by a hermite polynomial
c     approximation.
c     hroot2 contains the squares of the zeroes of the first seven
c     even hermite polynomials.
c     hweigh contains the corresponding weights (not squared).
   30 xi=1.d0/x
      xrooti= dsqrt(xi)
      do 40 i=1,n
         iad=lind(n)+i
         tp2(i)=hroot2(iad)*xi
   40 wp2(i)=hweigh(iad)*xrooti
      return
      end
c
      subroutine surfa(co,potpt,nmep)
************************************************************************
*   this subroutine calculated the molecular surface and was lifted
*   from m. connolly's program by u.c.singh and p.a.kollman.
*   in this modified version it generates the sample points on four 
*   layers of van der waal's surfaces.
*                                     by bingze wang on 19 august 1993
************************************************************************
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      common /iofile/ mfgr,mfgw
      parameter (mxmep=numatm*50+1000)
      common /molkst/ natom,ian(numatm),nfirst(numatm),nmidle(numatm),  
     1                nlast(numatm), norbs, nelecs,nalpha,nbeta,        
     2                nclose,nopen,ndumy,fract                          
      common /keywrd/ keywrd
      character*241 keywrd
      dimension vander(100),con(3,1000),ias(mxmep),rad(mxmep),
     1          co(3,*),potpt(3,*)
c
c     neighbor arrays
c
c     this same dimension for the maximum number of neighbors
c     is used to dimension arrays in the logical function collidm
c
      dimension inbr(200),cnbr(3,200),rnbr(200)
      logical snbr(200),mnbr(200)
c
c              arrays for all atoms, iatom, jatom and katom coordinates
      dimension ci(3), ieldat(56), temp0(3)
c                                        geometric construction vectors
      dimension cw(3,2)
c                                                     logical variables
      logical si
c                                                     logical functions
      logical collids
c                                            data for vander vall radii
      character marker*3, markss*3, mynam*3, ieldat*4, namatm*4
      data scale/1.4d0/,dens/1.0d0/,scincr/0.20d0/,layer/4/
      data vander/1.20d0,1.20d0,1.37d0,1.45d0,1.45d0,1.50d0,1.50d0,
     1            1.40d0,1.35d0,1.30d0,1.57d0,1.36d0,1.24d0,1.17d0,
     2            1.80d0,1.75d0,1.70d0,17*0.0d0,2.3d0,65*0.0d0/
      data marker/'a  '/,markss/'ss0'/,mynam/'uc '/
c
      data ieldat/'  bq','  h ','  he','  li','  be','  b ',
     1            '  c ','  n ','  o ','  f ','  ne','  na',
     2            '  mg','  al','  si','  p ','  s ','  cl',
     3            '  ar','  k ','  ca','  sc','  ti','  v ',
     4            '  cr','  mn','  fe','  co','  ni','  cu',
     5            '  zn','  ga','  ge','  as','  se','  br',
     6            '  kr','  rb','  sr','   y','  zr','  nb',
     7            '  mo','  tc','  ru','  rh','  pd','  ag',
     8            '  cd','  in','  sn','  sb','  te','   i',
     9            '   x','  cs'/
c
      pi=4.d0*datan(1.d0)
c                                    insert van der waal radii for zinc
      vander(30)=1.00d0
c
         if(index(keywrd,'scale=') .ne. 0)
     1          scale = reada(keywrd,index(keywrd,'scale='))
         if(index(keywrd,'den=') .ne. 0)
     1          dens = reada(keywrd,index(keywrd,'den='))
         if(index(keywrd,'scincr=') .ne. 0)
     1          scincr = reada(keywrd,index(keywrd,'scincr='))
         if(index(keywrd,'nsurf=') .ne. 0)
     1      layer = reada(keywrd,index(keywrd,'nsurf='))
c
      do 1000 ishel=1,layer
c                         only van der waals' type surface is generated
      rw =0.0d0
      den = dens
      do 30 i=1,natom
         ipoint = ian(i)
         rad(i) = vander(ipoint)*scale
         if (rad(i) .lt. 0.01d0) 
     1      write(mfgw,
     +      '(t2,''van der waals'''' radius for atom '',i3,
     1      '' is zero, supply a value in subroutine surfac)'' )')
         ias(i) = 2
   30 continue
c
c     big loop for each atom
c
      do 110 iatom = 1, natom
         if (ias(iatom) .eq. 0) go to 110
c
c     transfer values from large arrays to iatom variables
c
         namatm =ieldat(ian(iatom)+1)
         ri = rad(iatom)
         si = ias(iatom) .eq. 2
         do 40 k = 1,3
            ci(k) = co(k,iatom)
   40    continue
c                                gather the neighboring atoms of iatom
         nnbr = 0
         do 60 jatom = 1, natom
            if (iatom .eq. jatom .or. ias(jatom) .eq. 0) go to 60
            d2=(ci(1)-co(1,jatom))**2+(ci(2)-co(2,jatom))**2
     1         +(ci(3)-co(3,jatom))**2
            if (d2 .ge. (2*rw+ri+rad(jatom)) ** 2) go to 60
c
c     we have a new neighbor
c     transfer atom coordinates, radius and surface request number
c
           nnbr = nnbr + 1
           if (nnbr .gt. 200)then
              write (mfgw,
     +        '(''error'',2x,''too many neighbors:'',i5)')nnbr
_IF(ipsc,tools)
               call pend
_ELSE
               stop
_ENDIF
           endif
           inbr(nnbr) = jatom
           do 50 k = 1,3
              cnbr(k,nnbr) = co(k,jatom)
   50      continue
           rnbr(nnbr) = rad(jatom)
           snbr(nnbr) = ias(jatom) .eq. 2
   60    continue
c
c     contact surface
c
         if (.not. si) go to 110
         ncon = (4 * pi * ri ** 2) * den
         if (ncon .gt. 1000) ncon = 1000
c
c     this call may decrease ncon somewhat
c
         if ( ncon .eq. 0) then
            write(mfgw,'(t2,''vector length of zero in surfac'')')
_IF(ipsc,tools)
            call pend
_ELSE
            stop
_ENDIF
         endif
         call genvec(con,ncon)
         area = (4 * pi * ri ** 2) / ncon
c
c     contact probe placement loop
c
         do 100 i = 1,ncon
            do 70 k = 1,3
               cw(k,1) = ci(k) + (ri + rw) * con(k,i)
   70       continue
c
c     check for collision with neighboring atoms
c
            if (collids(cw(1,1),rw,cnbr,rnbr,mnbr,nnbr,1,
     1      jnbr,knbr)) go to 100
            do 80 kk=1,3
               temp0(kk) =ci(kk)+ri*con(kk,i)
   80       continue
c
c     store point in potpt and increment nmep
c
            nmep = nmep + 1
            if (nmep .gt. mxmep) goto 1001
            potpt(1,nmep) = temp0(1)
            potpt(2,nmep) = temp0(2)
            potpt(3,nmep) = temp0(3)
  100    continue
  110 continue
            scale = scale + scincr
1000  continue
      return
1001  write(mfgw,90)
_IF(ipsc,tools)
      call pend
_ELSE
      stop
_ENDIF
   90 format(/'error - to many points generated in surfac'/,
     1        '    reduce nsurf, scale, den, or scincr')
      end
      subroutine mopsymh(h, dip, i, n)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      dimension h(*), dip(3,*)
      common /symops/ r( 9,120), nsym, ipo(numatm,120), nent
      common /symopc/ isymt(6)
      character*10 isymt
*****************************************************************
*
c  input:   h()   a packed lower triangular hessian
c           dip(,) a matrix of dipole tensors to be symm
c           r(,)  a matrix of symmetry operations
c           ipo(,) a matrix of atomic mapping according to r
c           i     the atom (row and column) to add to h()
c           n     the symmetry operation to use to generate i
c
c  output:  h()   a packed lower triangular hessian with information
c                   about atom i added
c           dip(,) a matrix of dipole tensors that have been symm
c
*****************************************************************
c
c
c  this routine will add all necessary information to the hessian con
c    atom i.  since the hessian is a packed lower half triangle, the exi
c    information for atom pair (k,l) where k,l < i is fully known, (k >
c    l < i) or (vice versa) is half known, k,l > i is completely unknown
c    therefore, start in unknown region and make it half known.  double
c    known values, and move in the diagonal element at full strength.
c
c
      dimension   temp(9), temp2(9)
      common /fokmat/ ha(mpack*2)
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),
     1                nlast(numatm), norbs, nelecs,nalpha,nbeta,
     2                nclose,nopen,ndumy,fract
      common /coord/ coord(3,numatm)
c
c
c
c  variables used:  (n represents the number of atomic centers)
c     h(3n,3n):  input/output matrix.  it is a packed lower half triangu
c        matrix.  commonly, the hessian.
c     temp(9), temp2(9):   temporary matricies used to hold small parts
c          larger matricies for specific matrix operations.
c
c    for the next two items, the last indicy represents the symmetry
c        operation number.
c     r(14,*):   the first 9 elements of each record are a packed 3 by 3
c          array of a given symmetry operations.  elements 10 - 14 are t
c          users input describing the symmetry operation.
c     ipo(n,*):  a vector that contains the symmetry mapping of atomic c
c
c
      k = ipo(i,n)
c
c  now, to climb up the matrix
      do 10 j = numat, i+1, -1
         l = ipo(j,n)
c
c  now, to actually perform r h r
c
c  do this multiplication in a 3 by 3 block at a time.  store h(i,j) in
c    h( ipo(i,n), ipo(j,n))
c
         if (k .gt. l) then
            iel33 = (3*k*(3*k-1))/2 + 3*l
            temp(9) = 0.5d0 * h(iel33)
            temp(8) = 0.5d0 * h(iel33-1)
            temp(7) = 0.5d0 * h(iel33-2)
            temp(6) = 0.5d0 * h(iel33-k*3+1)
            temp(5) = 0.5d0 * h(iel33-k*3)
            temp(4) = 0.5d0 * h(iel33-k*3-1)
            temp(3) = 0.5d0 * h(iel33-6*k+3)
            temp(2) = 0.5d0 * h(iel33-6*k+2)
            temp(1) = 0.5d0 * h(iel33-6*k+1)
         else
            iel33 = (3*l*(3*l-1))/2 + 3*k
            fact = 1.0d0
            if (l .lt. i) fact = 0.5d0
            temp(9) = fact * h(iel33)
            temp(6) = fact * h(iel33-1)
            temp(3) = fact * h(iel33-2)
            temp(8) = fact * h(iel33-l*3+1)
            temp(5) = fact * h(iel33-l*3)
            temp(2) = fact * h(iel33-l*3-1)
            temp(7) = fact * h(iel33-6*l+3)
            temp(4) = fact * h(iel33-6*l+2)
            temp(1) = fact * h(iel33-6*l+1)
         endif
c
         call mat33(r(1,n), temp, temp2)
c
         iel33 = j*3*(j*3-1)/2 + i*3
         h(iel33)       = temp2(9)
         h(iel33-3*j+1) = temp2(8)
         h(iel33-6*j+3) = temp2(7)
         h(iel33-1)     = temp2(6)
         h(iel33-3*j)   = temp2(5)
         h(iel33-6*j+2) = temp2(4)
         h(iel33-2)     = temp2(3)
         h(iel33-3*j-1) = temp2(2)
         h(iel33-6*j+1) = temp2(1)
   10 continue
c
c  now, to do the diagonal term
c
      iel33 = (3*k*(3*k+1))/2
      temp(9) = 0.5d0 * h(iel33)
      temp(8) = 0.5d0 * h(iel33-1)
      temp(7) = 0.5d0 * h(iel33-2)
      temp(6) = temp(8)
      temp(5) = 0.5d0 * h(iel33-k*3)
      temp(4) = 0.5d0 * h(iel33-k*3-1)
      temp(3) = temp(7)
      temp(2) = temp(4)
      temp(1) = 0.5d0 * h(iel33-6*k+1)
c
      call mat33(r(1,n), temp, temp2)
c
      iel33 = i*3*(i*3+1)/2
      h(iel33)       = temp2(9)
      h(iel33-1)     = temp2(8)
      h(iel33-2)     = temp2(7)
      h(iel33-i*3)   = temp2(5)
      h(iel33-i*3-1) = temp2(4)
      h(iel33-6*i+1) = temp2(1)
c
c   now, to rotate the dipole tensor term
c
      temp(9) = dip(3,k*3  )
      temp(8) = dip(2,k*3  )
      temp(7) = dip(1,k*3  )
      temp(6) = dip(3,k*3-1)
      temp(5) = dip(2,k*3-1)
      temp(4) = dip(1,k*3-1)
      temp(3) = dip(3,k*3-2)
      temp(2) = dip(2,k*3-2)
      temp(1) = dip(1,k*3-2)
c
      call mat33(r(1,n), temp, temp2)
c
      dip(3,i*3  ) = temp2(9)
      dip(2,i*3  ) = temp2(8)
      dip(1,i*3  ) = temp2(7)
      dip(3,i*3-1) = temp2(6)
      dip(2,i*3-1) = temp2(5)
      dip(1,i*3-1) = temp2(4)
      dip(3,i*3-2) = temp2(3)
      dip(2,i*3-2) = temp2(2)
      dip(1,i*3-2) = temp2(1)
c
c
c   now, to double all existing values going across
      istart = (i-1)*3*((i-1)*3+1)/2+1
      do 20 j = istart, iel33
         h(j) = h(j) + h(j)
   20 continue
c  everything is now done for this symmetry element.
c
      return
      end
      subroutine symp
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      common /symops/ r(9,120), nsym, ipo(numatm,120), nent
      common /symopc/ isymt(6)
      common /iofile/ mfgr,mfgw
      character*10 isymt
      character*5 oper
*****************************************************************
*
*   on input   r    = symmetry operations (7 max)
*              ipo  = perm opr for above operations
*              nsym = current number of symmetry operations
*              nent = number of user supplied operations
*
*   on output  r    = symmetry operations (120 max)
*              ipo  = permutation operator for symmetry operations
*              nsym = number of symmetry operations
*
*****************************************************************
c
c  a subroutine that will expand the symmetry operations read in into
c     the complete set.  note: very few operations are required to
c     generate even very large groups of operations.
c
c
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),
     1                nlast(numatm), norbs, nelecs,nalpha,nbeta,
     2                nclose,nopen,ndumy,fract
      common /coord/ coord(3,numatm)
      common /keywrd/ keywrd
      character keywrd*241
c  the next parameters are the max number of symm functions, the 
c     max number of symm functions to read in, and the
c     tolerence used to determine if two functions are identical
      parameter (maxfun=120)
      parameter (tol   =1d-2)
c
c
c  variables used:  (n represents the number of atomic centers)
c
c    for the next two items, the last index represents the symmetry
c        operation number.
c     r(9,*):   the 9 elements of each record are a packed 3 by 3
c          array of a given symmetry operations. 
c    ipo(n,*):  a vector that contains the symmetry mapping of atomic ce
c
c  nsym is always the upper bound of the valid functions.  quit if it 
c     reaches 120.
c  i is the slow index of functions to multiply
c  j is the fast index of functions to multiply
c  always do r(i)*r(j) and take i,j from 2 to nsym
c
      i = 2
      j = 1
c
c  if more information is wanted, print headder.
c
      if (index(keywrd,' rmat') .ne. 0)write(mfgw,100)
 100  format(/,' entering the symmetry generating routine ',
     +/,'    number  symm. oper.   * ',
     +   '   number  symm. oper.   = ',
     +   '   number  symm. oper.')
c  determine if it is time to stop
c
  10  j = j+1
      if (j .gt. nsym) then
        j = 2
        i = i+1
        if (i .gt. nsym) goto 50  
      endif
      if(nsym .eq. maxfun) goto 50  
c
c  now to start the multiplication
c
      r(1,nsym+1)=r(1,i)*r(1,j)+r(2,i)*r(4,j)+r(3,i)*r(7,j)
      r(2,nsym+1)=r(1,i)*r(2,j)+r(2,i)*r(5,j)+r(3,i)*r(8,j)
      r(3,nsym+1)=r(1,i)*r(3,j)+r(2,i)*r(6,j)+r(3,i)*r(9,j)
      r(4,nsym+1)=r(4,i)*r(1,j)+r(5,i)*r(4,j)+r(6,i)*r(7,j)
      r(5,nsym+1)=r(4,i)*r(2,j)+r(5,i)*r(5,j)+r(6,i)*r(8,j)
      r(6,nsym+1)=r(4,i)*r(3,j)+r(5,i)*r(6,j)+r(6,i)*r(9,j)
      r(7,nsym+1)=r(7,i)*r(1,j)+r(8,i)*r(4,j)+r(9,i)*r(7,j)
      r(8,nsym+1)=r(7,i)*r(2,j)+r(8,i)*r(5,j)+r(9,i)*r(8,j)
      r(9,nsym+1)=r(7,i)*r(3,j)+r(8,i)*r(6,j)+r(9,i)*r(9,j)
c
c  is it unique?
c
      do 30 n = 1, nsym
        res = 0.d0
        do 20 m = 1, 9
  20    res = res + dabs(r(m,n) - r(m,nsym+1))
      if (res .lt. tol) goto 10
  30  continue
c
c  yes, it is unique.  now, generate the new ipo(,nsym)
c
      nsym = nsym + 1
      do 40 n = 1, numat
  40  ipo(n,nsym) = ipo(ipo(n,j),i)
c
c     all done adding the new function.  go try to find a new one.
c     but first, see if we need to print this.
c
      if (index(keywrd,' rmat') .ne. 0) 
     +   write(mfgw,110)
     +   i,oper(r(1,i)),j,oper(r(1,j)),nsym,oper(r(1,nsym))
 110  format(8x,i3,6x,a5,4x,'*',8x,i3,6x,a5,4x,'=',8x,i3,6x,a5)
      if (index(keywrd,' rmat') .ne. 0) then
        write(mfgw,120)(
     +  r(k,i),k=1,3),(r(k,j),k=1,3),(r(k,nsym),k=1,3)
        write(mfgw,130)
     +  (r(k,i),k=4,6),(r(k,j),k=4,6),(r(k,nsym),k=4,6)
        write(mfgw,140)
     +  (r(k,i),k=7,9),(r(k,j),k=7,9),(r(k,nsym),k=7,9)
 120    format(' |',3f7.3,' |   |',3f7.3,' |   |',3f7.3,' |')
 130    format(' |',3f7.3,' | * |',3f7.3,' | = |',3f7.3,' |')
 140    format(' |',3f7.3,' |   |',3f7.3,' |   |',3f7.3,' |',/)
      endif
c
      goto 10
c
c
  50  continue
c
c  now, to do final wrapup
c
      write(mfgw,150)nsym
 150  format(/,' there are ',i3,' unique symmetry functions.',/)
c
c  print the ipo matrix if asked for.
c
      if(index(keywrd,' ipo') .ne. 0) then
        write(mfgw,160)
 160  format(/,20x,'the permutation matrix')
        i = 1
        j = min(12,nsym)
  60    write(mfgw,170)(k,k=i,j)
 170  format(/,/,5x,'oper. no. ',12i5)
        write(mfgw,175)(oper(r(1,k)),k=i,j)
 175  format(5x,'symm. oper. ',12a5)
        write(mfgw,180)
 180  format(5x,'atom no.')
        do 70 k = 1, numat
  70    write(mfgw,190)k,(ipo(k,l),l=i,j)
 190  format(i10,5x,12i5)
        if (j .lt. nsym) then
          i = j+1
          j = min(j+12,nsym)
          goto 60
        endif
      endif
      return
      end
      subroutine sympop(h,i,iskip,deldip)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      dimension h(*), deldip(3,*)
      common /symops/ r( 9,120), nsym, ipo(numatm,120), nent
      common /symopc/ isymt(6)
      character*10 isymt
      do 10 j = 1, nsym
         if (ipo(i,j).lt.i) then
            call mopsymh(h, deldip, i, j)
            iskip=3
c  atom ipo(i,j) is suitable for transition dipole calc'n
c
            k=i*3-2
c
c   insert deldip rotation here
c
            goto 20
         endif
   10 continue
      iskip=0
   20 continue
      return
      end
      subroutine symr
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      common /symops/ r(9,120), nsym, ipo(numatm,120), nent
      common /symopc/ isymt(6)
      common /iofile/ mfgr,mfgw
      common / readme / ird
      character*10 isymt
*****************************************************************
*
*   on input   none
*
*   on output  r    = symmetry operations
*              ipo  = permutation operator for symmetry operations
*              nsym = number of symmetry operations
*              nent = number of symmetry operations entered
*
*****************************************************************
c
c  a subroutine that will read in the primative symmetry operations
c     and determine if they are valid for this molecule.  this
c     information is then expanded to the complete set and used for
c     symmatrizing the hessian.
c
c  the correct format for describing a symmetry function is:
c  label  ifncn  axis
c
c  where:
c       label  -  must be included and is the label that will
c                 be used to identify that function
c       ifncn  -  the number of the symmetry function to be used:
c                 0   -  inversion operator
c                 1   -  reflection plane perpendicular to the axis
c                 2-x -  a c(n) axis
c                -3-x -  a s(n) axis
c       axis   -  the axis for the operation.  may be specified as:
c                 x, y, z coordinates -> must use 3 values.  at least one
c                     must be non-integer or two must be identical
c                 an atom list -> the coordinates of the atoms listed will
c                     be summed to generate the axis.
c                 a -b ->  the vector from atom b to atom a will be used as
c                     the axis.
c
c   a maximum of 6 symmetry operations can be inputted.  these should be the
c      unique generating functions from which all the operations of the group
c      can be constructed.  e.g.  only c5 needs to be specified since c5(2) 
c      through c5(4) can be generated from this single function.
c
c   a maximum of 8 unique atoms can be used to specify an axis.
c
c   the e function is by default the first symmetry function.  this function
c      never needs to be explictly included in your list.  it cannot be 
c      entered.
c
c   if you enter a given symmetry function more than once, only the first
c      occurance will be used.  all duplicates will be deleted.
c
      dimension   temp(9), temp2(9),  istart(7)
      integer    itemp(9)
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),
     1                nlast(numatm), norbs, nelecs,nalpha,nbeta,
     2                nclose,nopen,ndumy,fract
      common /coord/ coord(3,numatm)
      common /keywrd/ keywrd
      character keywrd*241
      character*80 line
      logical leadsp, prob, allint
c  the next parameters are the max number of symm functions, the 
c     max number of symm functions to read in, and the
c     tolerence used to determine if two functions are identical
      parameter (maxfun=120)
      parameter (maxent=6)  
      parameter (tol   =1d-3)
c
c
c  variables used:  (n represents the number of atomic centers)
c     temp(9), temp2(9):   temporary matricies used to hold small parts
c          larger matricies for specific matrix operations.
c
c    for the next two items, the last index represents the symmetry
c        operation number.
c     r(9,*):   the 9 elements of each record are a packed 3 by 3
c          array of a given symmetry operations. 
c    ipo(n,*):  a vector that contains the symmetry mapping of atomic ce
c
      prob = .false.
c  get the symmetry functions: (note: the first is alway e)
      r(1,1) = 1.d0
      r(2,1) = 0.d0
      r(3,1) = 0.d0
      r(4,1) = 0.d0
      r(5,1) = 1.d0
      r(6,1) = 0.d0
      r(7,1) = 0.d0
      r(8,1) = 0.d0
      r(9,1) = 1.d0
c
      x = 0.d0
      y = 0.d0
      z = 0.d0
      do 10 i=1,numat
         x = x + coord(1,i)
         y = y + coord(2,i)
         z = z + coord(3,i)
         ipo(i,1) = i
   10 continue
      xa = x/dfloat(numat)
      ya = y/dfloat(numat)
      za = z/dfloat(numat)
      do 20 i=1,numat
         coord(1,i) = -xa + coord(1,i)
         coord(2,i) = -ya + coord(2,i)
         coord(3,i) = -za + coord(3,i)
   20 continue
      write(mfgw,'(/''   symmetry operations used for symmetrizing'',
     1'' the hessian'')')
      write(mfgw,'(/,'' operator  type     axis definition '')')
c
      nent = 1
      nsym = 0
      isymt(1)='e'
   30 nsym = nsym + 1
      read(ird,'(a)',end=120,err=120)line
      leadsp=.true.
      nvalue=0
      allint=.true.
      do 40 i=1,80
         if (leadsp.and.line(i:i).ne.' ') then
            nvalue=nvalue+1
            istart(nvalue)=i
         endif
         leadsp=(line(i:i).eq.' ')
   40 continue
      if (nvalue.eq.0) goto 120
      if (nvalue.eq.1) then
        write(mfgw,200)
 200    format(' not a valid line. only has one entry')
        prob = .true.
        goto 120
      endif
      isymt(1+nent)=line(istart(1):istart(2)-1)
      do 50 i=2,nvalue
        temp(i-1)=reada(line,istart(i))
        itemp(i-1)=nint(temp(i-1))
        if((dabs(itemp(i-1)-temp(i-1)).gt.tol).and.(i.ne.2)) 
     +    allint=.false.
   50 continue
      if (allint) then
        write(mfgw,210)isymt(1+nent),(itemp(i),i=1,nvalue-1)
 210  format(1x,a10,i7,8i7)
      else
        write(mfgw,220)
     +  isymt(1+nent),itemp(1),(temp(i),i=2,nvalue-1)
 220  format(1x,a10,i7,8f7.3)
      endif
      sigma = 1
      if (itemp(1) .le. -3) sigma = -1
      temp(1) = dabs( temp(1))
      itemp(1)= iabs(itemp(1))
      if (dabs(itemp(1)-temp(1)) .ge. tol) then
        write(mfgw,230)
 230    format(' the symmetry function must be integer')
        prob = .true.
        goto 120
      endif
      if (itemp(1) .eq. 0) then
c  with inversion, the axis is unimportant
        r(1,1+nent) = -1.d0
        r(2,1+nent) =  0.d0
        r(3,1+nent) =  0.d0
        r(4,1+nent) =  0.d0
        r(5,1+nent) = -1.d0
        r(6,1+nent) =  0.d0
        r(7,1+nent) =  0.d0
        r(8,1+nent) =  0.d0
        r(9,1+nent) = -1.d0
        goto 70
      endif
c  with anything else, the axis must be determined.  if no axis is defined
c    flag it as a problem
      if (nvalue .eq. 2) then
        prob = .true.
        write(mfgw,240) nsym
 240    format(' no axis information was entered for function',i2)
        goto 120
      endif
      if ((nvalue .eq. 5).and.((temp(2).eq.temp(3))
     +   .or.(temp(2).eq.temp(4)).or.
     +   (temp(3).eq.temp(4)).or.(.not. allint).or.
     +   (iabs(itemp(2)).lt. 1).or.(iabs(itemp(2)).gt.numat) .or.
     +   (iabs(itemp(3)).lt. 1).or.(iabs(itemp(3)).gt.numat) .or.
     +   (iabs(itemp(4)).lt. 1).or.(iabs(itemp(4)).gt.numat))) then
c  it appears to be xyz input
        x = temp(2)
        y = temp(3)
        z = temp(4)
      else
c  appears to be atom number input
        if (.not. allint) then
          prob = .true.
          write(mfgw,250)
 250      format(' you must have all integer input when not',
     +     ' using xyz input')
          goto 120
        endif
        x = 0.d0
        y = 0.d0
        z = 0.d0
        do 60 i = 2, nvalue-1
          if ((iabs(itemp(i)).lt.1).or.(iabs(itemp(i)).gt.numat)) 
     +         then
            write(mfgw,260)itemp(i)
 260        format(' atom number',i3,' is out of range')
            prob=.true.
          endif
          x = x + itemp(i)/abs(itemp(i))*coord(1,abs(itemp(i)))
          y = y + itemp(i)/abs(itemp(i))*coord(2,abs(itemp(i)))
          z = z + itemp(i)/abs(itemp(i))*coord(3,abs(itemp(i)))
  60    continue
      endif
c
c  time to decipher the symmetry function
c
      if (itemp(1) .gt. 10) then
        write(mfgw,270)
 270    format(' a c-10 axis is the highest that can be specified')
        prob = .true.
        goto 120
      endif
      rot=4.d0*dasin(1.d0)/itemp(1)
      if(itemp(1).eq. 1) sigma = -1
c
c  first, construct the matrix defining the rotation axis
      xy=x**2+y**2
      ra=dsqrt(xy+z**2)
      if (ra.lt. tol) then
        prob = .true.
        write(mfgw,280)
  280   format('  your vector axis must have a non-zero length ')
        goto 120
      endif
      xy=dsqrt(xy)
      if (xy.gt.1.d-10) then
        ca=y/xy
        cb=z/ra
        sa=x/xy
        sb=xy/ra
      elseif (z.gt. 0.d0) then
        ca=1.d0
        cb=1.d0
        sa=0.0d0
        sb=0.0d0
      else
        ca=-1.d0
        cb=-1.d0
        sa=0.0d0
        sb=0.0d0
      endif
c  generate the matrix elements by doing the euler transform
      temp( 1)=ca
      temp( 2)=-sa
      temp( 3)=0.0d0
      temp( 4)=sa*cb
      temp( 5)=ca*cb
      temp( 6)=-sb
      temp( 7)=sa*sb
      temp( 8)=ca*sb
      temp( 9)=cb
c
c
      ca = dcos(rot)
      sa = dsin(rot)
c
c  the construct the actual r matrix to be used
c
c
      temp2(1) = ca
      temp2(2) = sa
      temp2(3) = 0.d0
      temp2(4) = -sa
      temp2(5) = ca
      temp2(6) = 0.d0
      temp2(7) = 0.d0
      temp2(8) = 0.d0
      temp2(9) = sigma  
      call mat33(temp, temp2, r(1,1+nent))
c
c  now, verify that this is a unique and valid function
 70   continue
c
      res = 10.d0
      do 90 i = 2, nent
        reso = 0.d0
        do 80 j  = 1, 9
  80      reso= dabs( r(j,i) - r(j,1+nent)) + reso
        res = dmin1(res, reso)
  90  continue
      if (res .lt. tol) then
c  this is not valid function
        write(mfgw,290)
 290    format(' this function is identical to an earlier one')
        goto 120
      endif
c  now, to calculate the ipo of this function
      nent = 1+nent
      n = nent
c  now, to initialize ipo(n) and
c  perform r on each atomic center and determine where it maps to.
      do 110 i = 1, numat
        x=coord(1,i)*r(1,n) + coord(2,i)*r(2,n) + coord(3,i)*r(3,n)
        y=coord(1,i)*r(4,n) + coord(2,i)*r(5,n) + coord(3,i)*r(6,n)
        z=coord(1,i)*r(7,n) + coord(2,i)*r(8,n) + coord(3,i)*r(9,n)
        ipo(i,n) = 0
        do 100 j = 1, numat
          dist=dabs(x-coord(1,j))+dabs(y-coord(2,j))+dabs(z-coord(3,j))
          if (dist .lt. 5.d-2) then
            if (ipo(i,n) .eq. 0) then
              ipo(i,n) = j
            else
              write(mfgw,300)
              prob = .true.
              goto 120
  300         format('  one atom maps onto two different atomic c',
     1'enters')
            endif
          endif
  100   continue
        if (ipo(i,n) .eq. 0)  then
          write(mfgw,310)
  310     format('  one atom maps onto no other atom ')
          prob = .true.
          goto 120
        endif
  110 continue
c
c  if this point is reached, the function is valid
c  check if the r matrix should be printed
c
      if (index(keywrd,' rmat') .ne. 0) then
        write(mfgw,320)(r(i,n),i=1,3)
        write(mfgw,330)n,(r(i,n),i=4,6)
        write(mfgw,340)(r(i,n),i=7,9)
  320   format(/,10x,'| ',3f10.6,' |')
  330   format(i5,' =   | ',3f10.6,' |')
  340   format(10x,'| ',3f10.6,' |',/)
      endif
c
 120  if((nvalue.ne.0).and.(nsym.lt.maxent)) goto 30
c
c  if a problem exists.  stop the program.
c
      if (prob) then
        close (6)
         write(mfgw,321)
 321     format(//'***** problem in symr *****')
_IF(ipsc,tools)
        call pend
_ELSE
        stop
_ENDIF
      endif
c
c  now, all user functions are in with no errors (just elimination of dups)
c
      if(nvalue.ne.0) read(ird,'(a)',end=130)line
 130  continue
      nsym = nent
c
c  next, expand the existing operators to the full set
c
      call symp
c
      return
      end
      subroutine symt(h, deldip)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      dimension h(*), deldip(3,*)
      common /symops/ r( 9,120), nsym, ipo(numatm,120), nent
      common /symopc/ isymt(6)
      character*10 isymt
*****************************************************************
*
*   on input   h    = hessian matrix, packed lower half triangle
*              r    = symmetry operations
*              ipo  = map of atoms moved
*              nsym = number of symmetry operations
*
*   on output  h    = symmetrized hessian matrix
*
*****************************************************************
c  a subroutine that will symmatrize the hamiltonian, or other matrix
c     by successive application of group operations.  the method used
c     is r h r  added to ha then divided by the total number of symmetry
c     operations used.  this in effects averages all the values in a
c     symmetry correct fashion.
c
      dimension   temp(9), temp2(9), deltmp(3,maxpar)
      common /fokmat/ ha(mpack*2)
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),
     1                nlast(numatm), norbs, nelecs,nalpha,nbeta,
     2                nclose,nopen,ndumy,fract
      common /coord/ coord(3,numatm)
c
c
c  variables used:  (n represents the number of atomic centers)
c     h(3n,3n):  input/output matrix.  it is a packed lower half triangu
c        matrix.  commonly, the hessian.
c     ha(3n,3n): an internal matrix used to sum the symatrized hessian
c     nsym:      input, the value of this symmetry operation.
c     temp(9), temp2(9):   temporary matricies used to hold small parts
c          larger matricies for specific matrix operations.
c
c    for the next two items, the last indicy represents the symmetry
c        operation number.
c     ipo(n,*):  a vector that contains the symmetry mapping of atomic c
c
c   skip this routine if nsymm <= 0.  this implies that only e is pre
      if (nsym .lt. 2) return
c
      do 10 i=1,(3*numat*(numat*3+1))/2
   10 ha(i)=0.0d0
c
      do 15 i = 1, numat*3
        deltmp(1,i) = 0.d0
        deltmp(2,i) = 0.d0
   15   deltmp(3,i) = 0.d0
c
      do 40 n = 1, nsym
c
c  now, to actually perform r h r
         do 30 i = 1, numat
            do 20 j = 1, i-1
c
c  do this multiplication in a 3 by 3 block at a time.  store h(i,j) in
c    ha( ipo(i,n), ipo(j,n)) or hs( ipo(i,n), ipo(j,n))
c
               k = ipo(i,n)
               l = ipo(j,n)
               if (k .gt. l) then
                  iel33 = (3*k*(3*k-1))/2 + 3*l
                  temp(9) = h(iel33)
                  temp(8) = h(iel33-1)
                  temp(7) = h(iel33-2)
                  temp(6) = h(iel33-k*3+1)
                  temp(5) = h(iel33-k*3)
                  temp(4) = h(iel33-k*3-1)
                  temp(3) = h(iel33-6*k+3)
                  temp(2) = h(iel33-6*k+2)
                  temp(1) = h(iel33-6*k+1)
               else
                  iel33 = (3*l*(3*l-1))/2 + 3*k
                  temp(9) = h(iel33)
                  temp(6) = h(iel33-1)
                  temp(3) = h(iel33-2)
                  temp(8) = h(iel33-l*3+1)
                  temp(5) = h(iel33-l*3)
                  temp(2) = h(iel33-l*3-1)
                  temp(7) = h(iel33-6*l+3)
                  temp(4) = h(iel33-6*l+2)
                  temp(1) = h(iel33-6*l+1)
               endif
c
               call mat33(r(1,n), temp, temp2)
c
               iel33 = i*3*(i*3-1)/2 + j*3
               ha(iel33)       = temp2(9) + ha(iel33)
               ha(iel33-1)     = temp2(8) + ha(iel33-1)
               ha(iel33-2)     = temp2(7) + ha(iel33-2)
               ha(iel33-i*3+1) = temp2(6) + ha(iel33-i*3+1)
               ha(iel33-i*3)   = temp2(5) + ha(iel33-i*3)
               ha(iel33-i*3-1) = temp2(4) + ha(iel33-i*3-1)
               ha(iel33-6*i+3) = temp2(3) + ha(iel33-6*i+3)
               ha(iel33-6*i+2) = temp2(2) + ha(iel33-6*i+2)
               ha(iel33-6*i+1) = temp2(1) + ha(iel33-6*i+1)
   20       continue
            k = ipo(i,n)
            iel33 = (3*k*(3*k+1))/2
            temp(9) = h(iel33)
            temp(8) = h(iel33-1)
            temp(7) = h(iel33-2)
            temp(6) = temp(8)
            temp(5) = h(iel33-k*3)
            temp(4) = h(iel33-k*3-1)
            temp(3) = temp(7)
            temp(2) = temp(4)
            temp(1) = h(iel33-6*k+1)
c
            call mat33(r(1,n), temp, temp2)
c
            iel33 = i*3*(i*3+1)/2
            ha(iel33)       = temp2(9) + ha(iel33)
            ha(iel33-1)     = temp2(8) + ha(iel33-1)
            ha(iel33-2)     = temp2(7) + ha(iel33-2)
            ha(iel33-i*3)   = temp2(5) + ha(iel33-i*3)
            ha(iel33-i*3-1) = temp2(4) + ha(iel33-i*3-1)
            ha(iel33-6*i+1) = temp2(1) + ha(iel33-6*i+1)
c
c  apply symmetry to dipole term as well
c
            temp(9) = deldip(3,k*3  )
            temp(8) = deldip(2,k*3  )
            temp(7) = deldip(1,k*3  )
            temp(6) = deldip(3,k*3-1)
            temp(5) = deldip(2,k*3-1)
            temp(4) = deldip(1,k*3-1)
            temp(3) = deldip(3,k*3-2)
            temp(2) = deldip(2,k*3-2)
            temp(1) = deldip(1,k*3-2)
c
            call mat33(r(1,n), temp, temp2)
c
            deltmp(3,i*3  ) = temp2(9) + deltmp(3,i*3  )
            deltmp(2,i*3  ) = temp2(8) + deltmp(2,i*3  )
            deltmp(1,i*3  ) = temp2(7) + deltmp(1,i*3  )
            deltmp(3,i*3-1) = temp2(6) + deltmp(3,i*3-1)
            deltmp(2,i*3-1) = temp2(5) + deltmp(2,i*3-1)
            deltmp(1,i*3-1) = temp2(4) + deltmp(1,i*3-1)
            deltmp(3,i*3-2) = temp2(3) + deltmp(3,i*3-2)
            deltmp(2,i*3-2) = temp2(2) + deltmp(2,i*3-2)
            deltmp(1,i*3-2) = temp2(1) + deltmp(1,i*3-2)
c
   30    continue
   40 continue
c
      do 50 i = 1, (numat*3*(numat*3+1))/2
   50 h(i) = ha(i)/nsym
c
      do 60 i = 1, 3*numat
        deldip(1,i) = deltmp(1,i)/nsym
        deldip(2,i) = deltmp(2,i)/nsym
   60   deldip(3,i) = deltmp(3,i)/nsym
c
      return
      end
c
c
c
      subroutine symtrz (coord,c,norb,nmos,flag,flag2)
      implicit REAL (a-h,o-z)
c**************************************************************
c                                                             *
c     determine point group & symmetrize orbitals             *
c                                                             *
c**************************************************************
INCLUDE(common/sizes)
      parameter (mxdim=maxpar+numatm)
c     ---------------------------------------------------------------
      common/molkst/numat,nat(numatm),nfirst(numatm),nmidle(numatm),
     1   nlast(numatm),norbs,nelecs,nalpha,nbeta,nclose,nopen,ndumy,
     2 fract
      common/symres/ trans,rtr,sig,name,namo(mxdim),index(mxdim),ista(2)
      common /syminf/ ibase(2,12),nbase,ivibro(2,12),ivib
      common/vector/cdum(morb2),eigs(maxorb),cbdum(morb2),eigb(maxorb)
      common /s00002/ nunum,nonorb,nadim,ncdim,iqual,ndorbs,ierror
      common/s00004/shift(3),r(3,3),vect(2,mxdim)
      character*4  name, namo, nam, ista
      logical flag,flag2
      dimension rsav(3,3),cotim(3,numatm)
      dimension v1(maxorb),v2(maxorb),v3(maxorb),v4(maxorb)
      dimension coord(3,numatm),c(maxorb,maxorb)
      dimension iopsym(7),image(numatm,7)
      data iopsym /1,1,1,1,1,1,1/
      nunum = numat
      nonorb = norbs
      do k=1,3
      do l=1,numat
      cotim(k,l)=coord(k,l)
      enddo
      enddo
      do i=1,3
      do j=1,3
      rsav(i,j)=r(i,j)
      enddo
      enddo
      nam=name
      call syman1(numat,2,coord,nat,1,maxorb)
      if(flag2) call syman2(norbs,norbs,c,0,1,maxorb)
      do i=1,3
      do j=1,3
      r(i,j)=rsav(i,j)
      enddo
      enddo
      do k=1,3
      do l=1,numat
      coord(k,l)=cotim(k,l)
      enddo
      enddo
      return
      end
c
c=======================================================================
c
      subroutine tf(ua,ga,ub,gb,t,norbs,nclose,iwflb)
      implicit REAL (a-h,o-z)
c
c  this routine creates the new t matrix
c
      dimension ua(norbs,norbs),ub(norbs,norbs),
     1          t(norbs,norbs),ga(norbs,norbs),
     2          gb(norbs,norbs)
c
c  zero matrix initially
c
      call zerom(t,norbs)
c
c calculate t (ij)(w,w)= sum(ga(ik)(w)*ub(kj)(w)+
c gb(ik)(w)*ua(kj)(w)-ua(ik)(w)gb(kj)(w)-ub(ik)(w)ga(kj)(w)
c
      do 30 i = 1,norbs
         do 20 j = 1,norbs
            sum1=0.0d0
            sum2=0.0d0
            do 10 k = 1,norbs
c calculate for (w,w), (0,w) values
c
               sum1 = sum1+ga(i,k)*ub(k,j)+gb(i,k)*ua(k,j)
     1         -ua(i,k)*gb(k,j)-ub(i,k)*ga(k,j)
               sum2 = sum2+ga(j,k)*ub(k,i)+gb(j,k)*ua(k,i)
     1         -ua(j,k)*gb(k,i)-ub(j,k)*ga(k,i)
   10       continue
            t(i,j) = sum1
            t(j,i) = sum2
   20    continue
   30 continue
c
      return
      end
      subroutine syma(e, v)
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      common /iofile/ mfgr,mfgw
      dimension  e(numat*3), v(numat*numat*9)
      common /symops/ r( 9,120), nsym, ipo(numatm,120), nent
      common /symopc/ isymt(6)
      character*10 isymt
*********************************************************************
*
*  on input e    = frequencies in cm(-1)
*           v    = eigenvectors of normal modes, normalized
*           r    = symmetry operations
*           ipo  = map of atoms being moved
*           nsym = number of symmetry operation
*
*********************************************************************
c
c  this routine determines the symmetry function value of each
c    vibrational mode.  it does it by doing <ev r ev>
c
      common /coord/ coord(3,numatm)
      common /keywrd/ keywrd
      dimension  t1(maxpar), t2(maxpar,7)
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),
     1                nlast(numatm), norbs, nelecs,nalpha,nbeta,
     2                nclose,nopen,ndumy,fract
      character keywrd*241
c
      tol=1.d-3
c
      nvar=numat*3
c
c  t1(nvar) and t2(nvar,nsym) are the only additional arrays needed.  th
c    are temporary arrays.
      do 30 k = 0, nvar-1
         do 20 n = 1, nent
            do 10 i = 1, numat
c
               j=ipo(i,n)
               t1(i*3-2)=v(j*3-2+k*nvar)*r(1,n)+
     1              v(j*3-1+k*nvar)*r(4,n)+
     2              v(j*3  +k*nvar)*r(7,n)
               t1(i*3-1)=v(j*3-2+k*nvar)*r(2,n)+
     1              v(j*3-1+k*nvar)*r(5,n)+
     2              v(j*3  +k*nvar)*r(8,n)
               t1(i*3  )=v(j*3-2+k*nvar)*r(3,n)+
     1              v(j*3-1+k*nvar)*r(6,n)+
     2              v(j*3  +k*nvar)*r(9,n)
   10       continue
            t2(k+1,n) = 0.0d0
            do 20 i = 1, nvar
               t2(k+1,n) = t2(k+1,n) + t1(i)*v(i+k*nvar)
   20    continue
   30 continue
      write(mfgw,100)
      write(mfgw,
     +      '(''                    '',7a9)')(isymt(i),i=1,nent)
  100 format('  freq.',/,'  no.   freq.         character table ')
      i=1
      j=i+1
      if (index(keywrd,' nodegen') .ne. 0) tol = -1.d0
      eref = e(1)
  110 if(dabs((e(j)-eref)) .le. tol) then
         do 120 k = 1, nent
  120    t2(i,k) = t2(i,k) + t2(j,k)
         e(i) = (e(i) + e(j))
         j = j+1
      else
         e(i)=e(i)/dfloat(j-i)
         write(mfgw,130)i,e(i),(t2(i,k),k=1,nent)
         i=j
         j=j+1
         eref=e(i)
      endif
      if (j .le. nvar) goto 110
      e(i)=e(i)/dfloat(j-i)
      write(mfgw,130)i,e(i),(t2(i,k),k=1,nent)
  130 format(i4,f9.3,3x,7f9.4)
      end
      subroutine upsurf (coord)
c this routine is called alternatively to consts during geometry
c optimization. it updates the segments on the scas , i.e. their 
c areas and centers, according to a new geometry, but it doesnot create
c a new segmentation. the reason for using upsurf is to smooth the total
c energy with respect to fluctations arisig from a fluctuating segmentation.
c be aware that the use of upsurf brings some 'hysteresis' into the
c hamiltonian. 
c upsurf fills the a-matrix and calls the inversion routine. 
c written by a. klamt, burscheider str. 524, 5090 leverkusen 3, germany 
      implicit REAL (a-h,o-z)
INCLUDE(common/sizes)
      dimension coord(3,*)
      dimension xx(3),xa(3),cobas(3,nppa,numatm)
      dimension xsp(4,maxnss),nset(maxnss,maxnss)
c     added to satisfy the lapack call to dgetri. sjc 1/10/93
      dimension ipiv(maxnss)   
      logical din(nppa)
      common / solvi / nspa,nss,iatsp(maxnss),nar(maxnss),nn(2,numatm)
      common / solvr / dipl,fepsi,rds,disex2,tm(3,3,numatm),
     &                aamat(maxnss,maxnss),admat(maxnss,maxnss), 
     &                ccmat(maxorb,maxorb), bbmat(maxorb,maxnss),
     &                cosurf(3,maxnss), srad(numatm)
      common /dirvec/ dirvec(3,nppa), dirtm(3,nppa)
      common /molkst/ numat,nat(numatm),nfirst(numatm),nmidle(numatm),
     1                nlast(numatm), norbs, nelecs,nalpha,nbeta,
     2                nclose,nopen,ndumy,fract
      common /chanel/ ifiles(30)
      equivalence (iw,ifiles(6))
      equivalence (admat,cobas),(bbmat,xsp)
      fdiag=1.05d0*dsqrt(nppa+0.d0)
      area=0.0d0
      ds=dsqrt(4.0d0/nspa)
      c2ds=dcos(2.0d0*ds)
      nss1=0
      do 1000 i=1,numat
        do 4 ix=1,3
4       xa(ix)=coord(ix,i)
        r=srad(i)
        rm=r-rds
        nss0=nss1+1
        if (iatsp(nss0) .ne. i) go to 1000
        ips=nss0
304     if (ips .gt. nss .or. iatsp(ips) .ne. i) go to 306
        nar(ips)=0
        xsp(1,ips)=0.0d0
        xsp(2,ips)=0.0d0
        xsp(3,ips)=0.0d0
        xsp(4,ips)=admat(ips,ips)
        ips=ips+1
        go to 304
306     nss1=ips-1
c transform cosurf according to tm(inv)
        do 5 j=nss0,nss1
          xx(1)=cosurf(1,j)
          xx(2)=cosurf(2,j)
          xx(3)=cosurf(3,j)
          cosurf(1,j)=xx(1)*tm(1,1,i)+xx(2)*tm(1,2,i)+xx(3)*tm(1,3,i)
          cosurf(2,j)=xx(1)*tm(2,1,i)+xx(2)*tm(2,2,i)+xx(3)*tm(2,3,i)
          cosurf(3,j)=xx(1)*tm(3,1,i)+xx(2)*tm(3,2,i)+xx(3)*tm(3,3,i)
5       continue
c update tm
        nn1=nn(1,i)
        nn2=nn(2,i)
        if (nn1 .eq. 0) then
          tm(1,1,i)=1.d0
          tm(1,2,i)=0.0d0
          tm(1,3,i)=0.0d0
        else
          dist1=0.0d0
          do 6 ix=1,3
6         dist1=dist1+(xa(ix)-coord(ix,nn1))**2
          dist=1.d0/dsqrt(dist1)
          tm(1,1,i)=(coord(1,nn1)-xa(1))*dist
          tm(1,2,i)=(coord(2,nn1)-xa(2))*dist
          tm(1,3,i)=(coord(3,nn1)-xa(3))*dist
        end if
        if (nn2 .eq. 0) then
          tm(2,1,i)=-tm(1,2,i)
          tm(2,2,i)=tm(1,1,i)
          tm(2,3,i)=0.0d0
        else
          dist2=0.0d0
          do 7 ix=1,3
7         dist2=dist2+(xa(ix)-coord(ix,nn2))**2
          dist=1.d0/dsqrt(dist2)
          xx(1)=(coord(1,nn2)-xa(1))*dist
          xx(2)=(coord(2,nn2)-xa(2))*dist
          xx(3)=(coord(3,nn2)-xa(3))*dist
          sp=xx(1)*tm(1,1,i)+xx(2)*tm(1,2,i)+xx(3)*tm(1,3,i)
          sininv=1.d0/dsqrt(1.d0-sp*sp)
          tm(2,1,i)=(xx(1)-sp*tm(1,1,i))*sininv
          tm(2,2,i)=(xx(2)-sp*tm(1,2,i))*sininv
          tm(2,3,i)=(xx(3)-sp*tm(1,3,i))*sininv
        end if
        tm(3,1,i)=tm(1,2,i)*tm(2,3,i)-tm(2,2,i)*tm(1,3,i)
        tm(3,2,i)=tm(1,3,i)*tm(2,1,i)-tm(2,3,i)*tm(1,1,i)
        tm(3,3,i)=tm(1,1,i)*tm(2,2,i)-tm(2,1,i)*tm(1,2,i)
c transform cosurf according to tm
        do 35 j=nss0,nss1
          xx(1)=cosurf(1,j)
          xx(2)=cosurf(2,j)
          xx(3)=cosurf(3,j)
          cosurf(1,j)=xx(1)*tm(1,1,i)+xx(2)*tm(2,1,i)+xx(3)*tm(3,1,i)
          cosurf(2,j)=xx(1)*tm(1,2,i)+xx(2)*tm(2,2,i)+xx(3)*tm(3,2,i)
          cosurf(3,j)=xx(1)*tm(1,3,i)+xx(2)*tm(2,3,i)+xx(3)*tm(3,3,i)
35      continue
        do 45 j=1,nppa
          xx(1)=dirvec(1,j)
          xx(2)=dirvec(2,j)
          xx(3)=dirvec(3,j)
          do 45 ix=1,3
            x=xx(1)*tm(1,ix,i)+xx(2)*tm(2,ix,i)+xx(3)*tm(3,ix,i)
            dirtm(ix,j)=x
            cobas(ix,j,i)=rm*x+xa(ix)
45      continue
        do 2080 j = 1,nppa
          din(j)=.false.
          do 2020 ix=1,3            
            xx(ix) = xa(ix) + dirtm(ix,j)* r
2020      continue        
          do 2040 k = 1, numat
            if (k . eq. i) go to 2040
            dist=0.0d0
            do 2030 ix=1,3
              dist = dist + (xx(ix) - coord(ix,k))**2
2030        continue
            dist=dsqrt(dist)-srad(k)
            if (dist .lt. 0.d0) go to 2080
2040      continue
          din(j)=.true.
2080    continue
        do 350 j=1,nppa
          if (.not. din(j)) go to 350
          spm=-1.d0
          x1=dirtm(1,j)
          x2=dirtm(2,j)
          x3=dirtm(3,j)
          do 340 ips=nss0,nss1
            sp=x1*cosurf(1,ips)+x2*cosurf(2,ips)+x3*cosurf(3,ips)
            if (sp .lt. spm) go to 340
            spm=sp
            ipm=ips
340       continue
          if (spm .lt. c2ds) go to 350
          nara=nar(ipm)+1
          nset(ipm,nara)=j
          nar(ipm)=nara
          do 345 ix=1,3
345       xsp(ix,ipm)=xsp(ix,ipm)+dirtm(ix,j)
350     continue
        do 400 ips=nss0,nss1
          dist=0.0d0
          if (nar(ips) .eq. 0) then
            go to 400
          end if
          do 390 ix=1,3
            x=xsp(ix,ips)
            dist=dist+x*x
390       continue
          dist=1.d0/dsqrt(dist)
          do 391 ix=1,3
391       cosurf(ix,ips)=xsp(ix,ips)*dist
400     continue
        do 490 ips=nss0,nss1  
          do 405 ix=1,3
405       xsp(ix,ips)=xa(ix)+cosurf(ix,ips)*rm
490     continue
1000  continue
c    
c filling aamat
      do 170 ips=1,nss
        i=iatsp(ips)
        ri=srad(i)-rds
        nari=nar(ips)
        aa=0.0d0
        do 140 k=1,nari
          j1=nset(ips,k)
          aa=aa+.5d0*fdiag
          x1=dirvec(1,j1)
          x2=dirvec(2,j1)
          x3=dirvec(3,j1)
          do 140 l=1,k-1
            j2=nset(ips,l)
            aa=aa+1.0d0/dsqrt((x1-dirvec(1,j2))**2+
     &          (x2-dirvec(2,j2))**2+(x3-dirvec(3,j2))**2)
140     continue
        aa=2*aa/ri 
        if (nari .eq. 0) then
          aamat(ips,ips)=xsp(4,ips)
        else
          aamat(ips,ips)=aa
        endif
        do 141 ix=1,3
141     xa(ix)=xsp(ix,ips)
        do 169 jps=1,ips-1
          narj=nar(jps)
          dist=0.0d0
          do 143 ix=1,3
143       dist=dist+(xsp(ix,jps)-xa(ix))**2
          if (dist .lt. disex2) then
            j=iatsp(jps)
            aij=0.0d0
            do 149 k=1,nari
              j1=nset(ips,k)
              x1=cobas(1,j1,i)
              x2=cobas(2,j1,i)
              x3=cobas(3,j1,i)
              do 149 l=1,narj
                j2=nset(jps,l)
                aij=aij+1.d0/dsqrt((cobas(1,j2,j)-x1)**2+
     &          (cobas(2,j2,j)-x2)**2+(cobas(3,j2,j)-x3)**2)
149         continue
          else
            aij=nari*narj/dsqrt(dist)
          end if
          aamat(ips,jps)=aij
          aamat(jps,ips)=aij
169     continue
170   continue
      do 175 i=1,nss
        do 175 j=1,nss
175   admat(i,j)=aamat(i,j)
c invert aamax
c     call ma22bd(aamat,maxnss,nss,bbmat,error)
c     call invaa(aamat,maxnss,nss)
      call dgetrf(nss,nss,aamat,maxnss,ipiv,info)
      if (info .ne. 0) then
         write (iw,*) 'upsurf: factorization failed. info=',info
_IF(ipsc,tools)
         call pend
_ELSE
         stop
_ENDIF
      endif
      call dgetri(nss,aamat,maxnss,ipiv,bbmat,maxorb*maxnss,info)
      if (info .ne. 0) then
         write (iw,*) 'upsurf: inversion failed. info=',info
_IF(ipsc,tools)
         call pend
_ELSE
         stop
_ENDIF
      endif
      return
      end
